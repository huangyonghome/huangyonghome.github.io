<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jesse&#39;s home</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jesse.top/"/>
  <updated>2020-04-28T13:02:44.400Z</updated>
  <id>https://jesse.top/</id>
  
  <author>
    <name>Jesse</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://jesse.top/2020/06/30/Rsync%E5%90%8C%E6%AD%A5%E6%9C%AC%E5%9C%B0%E5%92%8C%E8%BF%9C%E7%A8%8B%E4%B8%BB%E6%9C%BA%E6%9C%89%E5%B7%AE%E5%BC%82%E7%9A%84%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84/"/>
    <id>https://jesse.top/2020/06/30/Rsync同步本地和远程主机有差异的目录结构/</id>
    <published>2020-06-30T12:30:18.466Z</published>
    <updated>2020-04-28T13:02:44.400Z</updated>
    
    <content type="html"><![CDATA[<h3 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h3><p>将BETA服务器的代码和配置文件数据迁移到IDC环境，IDC的BETA服务器已经存在一份数据，不能将本机所有的数据全部同步过去。一来耗时，占用带宽。二来会覆盖IDC BETA上正在使用的数据</p><p>所以，</p><p>1.需要判断如果对方（IDC BETA）如果不存在某个文件或者目录，则同步过去。</p><p>2.不能将目录上所有数据传递过去，因为代码目录包含很多不需要的旧版本releases的发布记录，全部同步过去耗费带宽和时间。</p><h3 id="脚本内容"><a href="#脚本内容" class="headerlink" title="脚本内容"></a>脚本内容</h3><p>我直接在命令行操作的，没有写shell脚本。但是命令差不多</p><p>1.本地/data/apps/下的代码目录，如果对方服务器并不存在，则同步结构过去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /data/apps</span><br><span class="line"></span><br><span class="line">for dir in $(ls);do if ! `ssh work@172.16.20.1 &quot;ls -d /data/apps/$dir&quot; &gt; /dev/null 2&gt;&amp;1`;then rsync -avz $dir  --include &apos;*/&apos; --exclude &apos;*&apos; work@172.16.20.1:/data/logs/;fi;done</span><br></pre></td></tr></table></figure><p>以下是2个知识点:</p><figure class="highlight plain"><figcaption><span>work@iP COMMAND```可以在本地远程执行shell命令</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">以下命令只同步目录结构(包括所有子目录),但是不同步文件</span><br><span class="line"></span><br><span class="line">```rsync -avz LOCAL_PATH --include &apos;*/&apos; --exclude &apos;*&apos; work@IP:REMOTE_PATH</span><br></pre></td></tr></table></figure><p>那么同样,同步nginx配置文件.这个时候因为是同步文件,所以使用scp命令.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/nginx/conf.d/</span><br><span class="line"></span><br><span class="line">for dir in $(ls);do if ! `ssh work@172.16.20.1 &quot;ls  /data/conf/nginx/conf.d/$dir&quot; &gt; /dev/null 2&gt;&amp;1`;then scp $dir work@172.16.20.1:/data/conf/nginx/conf.d/;fi;done</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;需求&quot;&gt;&lt;a href=&quot;#需求&quot; class=&quot;headerlink&quot; title=&quot;需求&quot;&gt;&lt;/a&gt;需求&lt;/h3&gt;&lt;p&gt;将BETA服务器的代码和配置文件数据迁移到IDC环境，IDC的BETA服务器已经存在一份数据，不能将本机所有的数据全部同步过去。一来耗时，占
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>acme.sh自动申请SSL证书脚本</title>
    <link href="https://jesse.top/2020/06/30/Linux-Basic/shell&amp;shell%E8%84%9A%E6%9C%AC/acme.sh%E8%87%AA%E5%8A%A8%E7%94%B3%E8%AF%B7SSL%E8%AF%81%E4%B9%A6%E8%84%9A%E6%9C%AC/"/>
    <id>https://jesse.top/2020/06/30/Linux-Basic/shell&amp;shell脚本/acme.sh自动申请SSL证书脚本/</id>
    <published>2020-06-29T16:44:48.000Z</published>
    <updated>2020-06-30T13:01:53.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="acme-sh自动申请SSL证书脚本"><a href="#acme-sh自动申请SSL证书脚本" class="headerlink" title="acme.sh自动申请SSL证书脚本"></a>acme.sh自动申请SSL证书脚本</h2><p>acme.sh是GitHub上的一个项目.有关这个工具的介绍可以参考github,或者查看Linux-证书目录下的相关笔记</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#description: 使用acme.sh工具通过自动DNS验证方式申请SSL证书.</span><br><span class="line">#date: 20190620</span><br><span class="line"></span><br><span class="line">#判断是否有指定域名,以及域名</span><br><span class="line">if [ $# != 2 ];then</span><br><span class="line">   echo &quot;usage: $0 domain_name ssl_install_dir&quot;</span><br><span class="line">   exit 1</span><br><span class="line">fi</span><br><span class="line">#接收要申请SSL证书的域名参数</span><br><span class="line">ssl_domain=$1</span><br><span class="line">#接收证书安装目标路径的参数</span><br><span class="line">ssl_install_dir=$2</span><br><span class="line"></span><br><span class="line">#判断申请的是否是通配符证书</span><br><span class="line">if `echo $ssl_domain | grep &quot;^\*&quot; &gt; /dev/null 2&gt;&amp;1`;then</span><br><span class="line"></span><br><span class="line">    #如果是通配符证书,那么替换到域名前面的&quot;*.&quot;</span><br><span class="line">    ssl_name=$(echo $ssl_domain | sed &apos;s@\*\.@@&apos;)</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">    ssl_name=$ssl_domain</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#检查证书安装目录,判断该域名是否已经申请过证书.如果已经申请过,则直接退出</span><br><span class="line"></span><br><span class="line">#新建ssl_dir证书路径变量</span><br><span class="line">ssl_dir=$&#123;ssl_install_dir&#125;/$&#123;ssl_name&#125;</span><br><span class="line"></span><br><span class="line">if [ -d $ssl_dir ];then</span><br><span class="line"></span><br><span class="line">    echo &quot;$ssl_domain certificate has already installed&quot; &amp;&amp; exit 0</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#导入环境变量</span><br><span class="line">export DP_Id=DNS服务器的AccessKeyID</span><br><span class="line">export DP_Key=DNS服务器的Secret</span><br><span class="line"></span><br><span class="line">#申请证书</span><br><span class="line">cd /home/work/.acme.sh/</span><br><span class="line"></span><br><span class="line"># 判断申请的是通配符证书,还是单域名证书</span><br><span class="line">if [ $ssl_domain == $ssl_name ];then</span><br><span class="line"></span><br><span class="line">./acme.sh --issue --dns dns_dp  -d $ssl_name</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line">./acme.sh --issue --dns dns_dp  -d $ssl_name -d $ssl_domain</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#判断证书申请是否成功</span><br><span class="line">if [ $? != 0 ];then</span><br><span class="line">     echo &quot;$ssl_domain certificate applied failed&quot; &amp;&amp; exit 1</span><br><span class="line">else</span><br><span class="line">    echo &quot;$ssl_domain certificate applied successfully&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#新建证书目标路径</span><br><span class="line">mkdir -p $ssl_dir</span><br><span class="line"></span><br><span class="line">#安装证书</span><br><span class="line">./acme.sh  --installcert  -d  $ssl_name  \</span><br><span class="line">       --key-file $&#123;ssl_dir&#125;/$&#123;ssl_name&#125;.key  \</span><br><span class="line">       --fullchain-file $&#123;ssl_dir&#125;/fullchain.cer     \</span><br><span class="line">       --reloadcmd  &quot;supervisorctl -c /etc/supervisord/supervisord.conf restart nginx&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;acme-sh自动申请SSL证书脚本&quot;&gt;&lt;a href=&quot;#acme-sh自动申请SSL证书脚本&quot; class=&quot;headerlink&quot; title=&quot;acme.sh自动申请SSL证书脚本&quot;&gt;&lt;/a&gt;acme.sh自动申请SSL证书脚本&lt;/h2&gt;&lt;p&gt;acme.s
      
    
    </summary>
    
      <category term="Linux-Basic" scheme="https://jesse.top/categories/Linux-Basic/"/>
    
      <category term="shell&amp;shell脚本" scheme="https://jesse.top/categories/Linux-Basic/shell-shell%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="scripts" scheme="https://jesse.top/tags/scripts/"/>
    
  </entry>
  
  <entry>
    <title>kvm自动创建虚拟机,自定义IP地址</title>
    <link href="https://jesse.top/2020/06/30/Linux-Basic/shell&amp;shell%E8%84%9A%E6%9C%AC/kvm%E9%80%9A%E8%BF%87%E6%A8%A1%E6%9D%BF%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA,%E9%85%8D%E7%BD%AEIP%E7%BD%91%E7%BB%9C/"/>
    <id>https://jesse.top/2020/06/30/Linux-Basic/shell&amp;shell脚本/kvm通过模板自动创建虚拟机,配置IP网络/</id>
    <published>2020-06-29T16:44:48.000Z</published>
    <updated>2020-06-30T13:00:33.613Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">通过KVM模板自动化创建虚拟机（需要电脑中存在模板）.以及创建完虚拟机后,自动修改IP地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash">该脚本需要以root身份执行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"> #</span><span class="bash">镜像和模板源文件</span></span><br><span class="line">src_img_path=/opt/vmx/linux/hadoop.dev.base.img</span><br><span class="line">src_xml_path=/etc/libvirt/qemu/hadoop.dev.base.xml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">镜像和模板源文件父目录</span></span><br><span class="line">prefix_img_path=/opt/vmx/linux</span><br><span class="line">prefix_xml_path=/etc/libvirt/qemu</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">获取新虚拟机名称</span></span><br><span class="line">get_newname()&#123;</span><br><span class="line">while true</span><br><span class="line">        do</span><br><span class="line">                read -p "请输入新虚拟机名称(主机名)：" newname</span><br><span class="line">                if [ $newname ];then</span><br><span class="line">                    if `virsh list --all | grep "\b$&#123;newname&#125;\b"`;then</span><br><span class="line">                        echo "该虚拟机已经存在.请检查系统当前虚拟机"</span><br><span class="line">                    else</span><br><span class="line"></span><br><span class="line">                        #设置新虚拟机镜像和模板路径</span><br><span class="line">                        new_img_path=$&#123;prefix_img_path&#125;/$&#123;newname&#125;.qcow2</span><br><span class="line">                        new_xml_path=$&#123;prefix_xml_path&#125;/$&#123;newname&#125;.xml</span><br><span class="line">                        break</span><br><span class="line">                    fi</span><br><span class="line">                else</span><br><span class="line">                        echo "************"</span><br><span class="line">                        echo "请输入虚拟机主机名！"</span><br><span class="line">                        echo "************"</span><br><span class="line">                fi</span><br><span class="line">        done</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">设置新虚拟机内存</span></span><br><span class="line">get_newmemary()&#123;</span><br><span class="line">while true</span><br><span class="line">        do</span><br><span class="line">                current_free_mem=`free -g|awk '/^Mem/&#123;print $4&#125;'`</span><br><span class="line">                mem_total=`free -g|awk '/^Mem/&#123;print $2&#125;'`</span><br><span class="line">                echo "目前本机内存总大小：$&#123;mem_total&#125;g"</span><br><span class="line">                echo "当前空闲内存大小为：$&#123;current_free_mem&#125;g"</span><br><span class="line">                read -p "请输入新虚拟机内存大小(单位G)：" newmemary</span><br><span class="line">                if [ $newmemary ];then</span><br><span class="line">                        if [[ $newmemary &lt; $mem_total ]];then</span><br><span class="line">                                break</span><br><span class="line">                        else</span><br><span class="line">                                echo "**********************************"</span><br><span class="line">                                echo "输入的数值必须小于当前内存总大小！"</span><br><span class="line">                                echo "**********************************"</span><br><span class="line">                        fi</span><br><span class="line">                else</span><br><span class="line">                        echo "********************"</span><br><span class="line">                        echo "请输入新虚拟机内存！"</span><br><span class="line">                        echo "********************"</span><br><span class="line">                fi</span><br><span class="line">        done</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">设置新虚拟机CPU</span></span><br><span class="line">get_newcpu()&#123;</span><br><span class="line">while true</span><br><span class="line">        do</span><br><span class="line">                core=`cat /proc/cpuinfo| grep "processor"| wc -l`</span><br><span class="line">                echo "可用core个数：$&#123;core&#125;"</span><br><span class="line">                read -p "请输入新虚拟机处理器核数：" newcpu</span><br><span class="line">                if [ $newcpu ];then</span><br><span class="line">                        if [ $newcpu -le $core ];then</span><br><span class="line">                                break</span><br><span class="line">                        else</span><br><span class="line">                                echo "******************************"</span><br><span class="line">                                echo "不能超过可用个数或者输入错误！"</span><br><span class="line">                                echo "******************************"</span><br><span class="line">                        fi</span><br><span class="line">                else</span><br><span class="line">                        echo "**************"</span><br><span class="line">                        echo "输入不能为空！"</span><br><span class="line">                        echo "**************"</span><br><span class="line">                fi</span><br><span class="line">        done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">设置IP</span></span><br><span class="line">get_ip()&#123;</span><br><span class="line"></span><br><span class="line">    while true</span><br><span class="line">        do </span><br><span class="line">            read -p "请输入新虚拟机的IP地址(格式:172.16.10.[2-240]):" ip</span><br><span class="line">            if `echo $ip| grep -E "172.16.10.[0-9]&#123;1,3&#125;$" &gt; /dev/null 2&gt;&amp;1`;then</span><br><span class="line">                ipaddr=$(echo $ip | awk -F "." '&#123;print $4&#125;')</span><br><span class="line">                #valid_check=$(echo $ip | awk -F "." '2&lt;$4 &amp;&amp; $4&lt;241 &#123;print "yes"&#125;')</span><br><span class="line">                #if [ "$valid_check" == "yes" ];then</span><br><span class="line">                if [ $ipaddr -gt 2 -a $ipaddr -lt 241 ];then</span><br><span class="line">                    if ! `ping -W 3 -c 1 $ip &gt; /dev/null 2&gt;&amp;1`;then</span><br><span class="line">                       break</span><br><span class="line">                    </span><br><span class="line">                    else</span><br><span class="line">                       echo "当前IP已经被占用,请重新输入"</span><br><span class="line">                    </span><br><span class="line">                    fi</span><br><span class="line">                </span><br><span class="line">                else</span><br><span class="line">                    echo "IP地址必须要在2-240之间"</span><br><span class="line"></span><br><span class="line">                fi</span><br><span class="line">            </span><br><span class="line">            else</span><br><span class="line">                echo "IP地址格式不对,请重新输入"</span><br><span class="line">            </span><br><span class="line">            fi</span><br><span class="line">    done</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">复制模板、xml</span></span><br><span class="line">copy_model_xml()&#123;</span><br><span class="line">cp $src_img_path $new_img_path</span><br><span class="line">        cp $src_xml_path $new_xml_path</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">修改xml文件</span></span><br><span class="line">modification_xml()&#123;</span><br><span class="line">    uuid=`uuidgen`</span><br><span class="line">sed -ri "s/(&lt;name&gt;).*(&lt;\/name&gt;)/\1$&#123;newname&#125;\2/" $new_xml_path  </span><br><span class="line">        sed -ri "s/(&lt;uuid&gt;).*(&lt;\/uuid&gt;)/\1$&#123;uuid&#125;\2/" $new_xml_path </span><br><span class="line">        mem_kb=$(($&#123;newmemary&#125;*1024*1024)) </span><br><span class="line"> </span><br><span class="line">        sed -ri "s/(&lt;memory.*&gt;).*(&lt;\/memory&gt;)/\1$&#123;mem_kb&#125;\2/" $new_xml_path </span><br><span class="line">        sed -ri "s/(&lt;currentMemory.*&gt;).*(&lt;\/currentMemory&gt;)/\1$&#123;mem_kb&#125;\2/" $new_xml_path</span><br><span class="line">        sed -ri "s/(&lt;vcpu.*&gt;).*(&lt;\/vcpu&gt;)/\1$&#123;newcpu&#125;\2/" $new_xml_path</span><br><span class="line">        sed -ri "s@(&lt;source file=').*('\/&gt;)@\1$&#123;new_img_path&#125;\2@" $new_xml_path  #定义新虚拟机的xml文件路径</span><br><span class="line"></span><br><span class="line">        sed -i "s@port='5930'@port='"59$&#123;ipaddr&#125;"'@" $new_xml_path #配置VNC端口号.格式59+ip地址最后一位</span><br><span class="line">        mac_addr=`openssl rand -hex 3 | sed -r 's/..\B/&amp;:/g'` #生成一个随机的MAC地址</span><br><span class="line"> </span><br><span class="line">        sed -ri "s/(&lt;mac address='..:..:..:).*('\/&gt;)/\1$&#123;mac_addr&#125;\2/" $new_xml_path #配置MAC地址</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">define</span></span><br><span class="line">define_vm()&#123;</span><br><span class="line">virsh define $new_xml_path #从xml文件中生成新虚拟机</span><br><span class="line">echo "**********"</span><br><span class="line">echo "$&#123;newname&#125;建完成！"</span><br><span class="line">echo "**********"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">network_setting()&#123;</span><br><span class="line"></span><br><span class="line">    #该脚本使用guestmount工具，Centos7中安装libguestfs-tools-c可以获得guestmount工具</span><br><span class="line">    #脚本在不登陆虚拟机的情况下，修改虚拟机的IP地址信息</span><br><span class="line"></span><br><span class="line">    mountpath="/tmp/$&#123;newname&#125;"</span><br><span class="line">    [ ! -d $mountpath ] &amp;&amp; mkdir $mountpath</span><br><span class="line"></span><br><span class="line">    guestmount  -d $&#123;newname&#125; -i $mountpath</span><br><span class="line"></span><br><span class="line">    #修改IP地址: 注意这里要通过这种方式才能修改IP..不能使用sed命令直接修改原文件,否则虚拟机启动后无法识别ifcfg-eth0文件</span><br><span class="line">    cat &gt; $&#123;mountpath&#125;/etc/sysconfig/network-scripts/ifcfg-eth0 &lt;&lt; EOF</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=eth0</span><br><span class="line">DEVICE=eth0</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPADDR=$ip</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=172.16.10.254</span><br><span class="line">DNS1=114.114.114.114</span><br><span class="line">EOF</span><br><span class="line">    #sed -i "/IPADDR/s@.*@IPADDR=$&#123;ip&#125;@" $&#123;mountpath&#125;/etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line">    #修改主机名</span><br><span class="line">    echo "$&#123;newname&#125;" &gt; $&#123;mountpath&#125;/etc/hostname</span><br><span class="line"></span><br><span class="line">    echo "虚拟主机IP地址和主机名配置完成"</span><br><span class="line"></span><br><span class="line">    #卸载临时挂载目录</span><br><span class="line">    umount /tmp/$&#123;newname&#125;</span><br><span class="line">    </span><br><span class="line">    #删除临时挂载目录</span><br><span class="line">    rm -rf /tmp/$&#123;newname&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">------------运行分界线------------------------------------</span></span><br><span class="line"></span><br><span class="line">get_newname</span><br><span class="line">get_newmemary</span><br><span class="line">get_newcpu</span><br><span class="line">get_ip</span><br><span class="line">copy_model_xml</span><br><span class="line">modification_xml</span><br><span class="line">define_vm</span><br><span class="line">network_setting</span><br></pre></td></tr></table></figure><p>参考 <a href="https://blog.csdn.net/qq_41814635/article/details/82256970" target="_blank" rel="noopener">https://blog.csdn.net/qq_41814635/article/details/82256970</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="Linux-Basic" scheme="https://jesse.top/categories/Linux-Basic/"/>
    
      <category term="shell&amp;shell脚本" scheme="https://jesse.top/categories/Linux-Basic/shell-shell%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="scripts" scheme="https://jesse.top/tags/scripts/"/>
    
  </entry>
  
  <entry>
    <title>mysql数据库使用xtrabackup全量,增量备份</title>
    <link href="https://jesse.top/2020/06/30/Linux-Basic/shell&amp;shell%E8%84%9A%E6%9C%AC/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8xtrabackup%E5%85%A8%E9%87%8F,%E5%A2%9E%E9%87%8F%E5%A4%87%E4%BB%BD/"/>
    <id>https://jesse.top/2020/06/30/Linux-Basic/shell&amp;shell脚本/mysql数据库使用xtrabackup全量,增量备份/</id>
    <published>2020-06-29T16:44:48.000Z</published>
    <updated>2020-06-30T12:59:00.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mysql数据库使用xtrabackup全量-增量备份"><a href="#mysql数据库使用xtrabackup全量-增量备份" class="headerlink" title="mysql数据库使用xtrabackup全量,增量备份"></a>mysql数据库使用xtrabackup全量,增量备份</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">##############################################################</span><br><span class="line"># File Name: backup.sh</span><br><span class="line"># Version: V1.0</span><br><span class="line"># Author: huangyong</span><br><span class="line"># Created Time : 2018-3-1 18:42:00</span><br><span class="line"># Description: 数据库全量,增量备份脚本</span><br><span class="line"></span><br><span class="line">#备份策略:每周一进行全备,其他日期备份当周的增量备份.每次全备前删除2周前的备份</span><br><span class="line">#可扩展功能:打包备份文件.备份文件传输到远程服务器</span><br><span class="line"></span><br><span class="line">#date:2018-04-15</span><br><span class="line">#update:由于数据库/data磁盘已快满.所以备份只保留一周.</span><br><span class="line"></span><br><span class="line">#date:2018-04-23</span><br><span class="line">#update:增加如果备份失败则发邮件通知功能</span><br><span class="line">#       增加自动删除备份日志功能</span><br><span class="line"></span><br><span class="line">#data:2018-04-24</span><br><span class="line">#update:1.增加xtrabackup自带的的备份压缩功能,且压缩线程数4.</span><br><span class="line">#       2.全备完成后,打包整个全备的备份文件(暂时先不打包)</span><br><span class="line">#       3.全备完成后,同步备份文件到BETA服务器</span><br><span class="line">#       4.保留2份备份文件,也就是保留2周</span><br><span class="line">#       5.将脚本的执行用户从root改到work.</span><br><span class="line"></span><br><span class="line">#date:2018-05-03</span><br><span class="line">#update:修改N_变量的抓取inc增量备份目录的命令.之前用的是sort命令,经常会抓取到错误的inc增量备份目录</span><br><span class="line">#        脚本执行用户改成root,因为work用户没有权限访问mysql的数据文件目录</span><br><span class="line">##############################################################</span><br><span class="line"></span><br><span class="line">#获取脚本所存放目录</span><br><span class="line">cd `dirname $0`</span><br><span class="line">bash_path=`pwd`</span><br><span class="line">#脚本名</span><br><span class="line">me=$(basename $0)</span><br><span class="line"></span><br><span class="line">#设置要备份的innodb数据库，用空格格开，空为备份所有库</span><br><span class="line">databases=&apos;&apos;</span><br><span class="line"></span><br><span class="line">#定义变量</span><br><span class="line">DATE=$(date +%W) #全年的第几周,一个星期为一个备份周期.备份根目录，其子目录：base为全量，inc1、inc2...为增量</span><br><span class="line">TWO_WEEKS_AGO=$(echo $&#123;DATE&#125;-2|bc) #前两周前的备份</span><br><span class="line">FULL_DATE=$(date +%F) #存储日志日期</span><br><span class="line">DAY_DATE=$(date +%w) #判断一周的第几天</span><br><span class="line">#MYSQL=&quot;mysql&quot;  # mysql命令绝对路径或在PATH中</span><br><span class="line">MYSQL_DATA_DIR=&quot;/data/mysql/data&quot;  # 数据库目录</span><br><span class="line">BACKUP_USER=&quot;tongji&quot;  # 备份用户</span><br><span class="line">PASSWD=$(cat /data/xtrabackup/password)  # 备份密码保存文件</span><br><span class="line">BACK_FILE_DIR=&quot;/data/backups/$&#123;DATE&#125;&quot;  # 备份频率目录，此目录变化频率为备份一周期</span><br><span class="line">LOG_P_DIR=&quot;/data/backup_logs&quot; #备份日志根目录</span><br><span class="line">LOG_DIR=&quot;/data/backup_logs/$&#123;FULL_DATE&#125;&quot;  # 备份过程日志目录</span><br><span class="line">#LOG_ERR=&quot;$&#123;LOG_DIR&#125;/mysql_backup_fail.log&quot; #备份错误日志文件</span><br><span class="line">LOG_FILE=&quot;$&#123;LOG_DIR&#125;/mysql_backup.log&quot;  #备份过程日志文件</span><br><span class="line">email_user=&quot;huangyong@doweidu.com&quot;</span><br><span class="line">ssh_server=&quot;10.25.2.85&quot;  # 远程备份服务器IP</span><br><span class="line">ssh_server_dir=&quot;/data/tongjidb-mysqlbackup&quot;  # 远程备份服务器目录</span><br><span class="line">ssh_port=&quot;5822&quot;  # ssh端口</span><br><span class="line">ssh_parameters=&quot;-o StrictHostKeyChecking=no -o ConnectTimeout=60&quot;</span><br><span class="line">ssh_user=&quot;work&quot;</span><br><span class="line">ssh_command=&quot;ssh $&#123;ssh_parameters&#125; -p $&#123;ssh_port&#125;&quot;</span><br><span class="line">#scp_command=&quot;scp $&#123;ssh_parameters&#125; -P $&#123;ssh_port&#125;&quot;</span><br><span class="line"></span><br><span class="line">#定义保存日志函数</span><br><span class="line">function save_log () &#123;</span><br><span class="line">        </span><br><span class="line">echo -e &quot;#################[`date +%F\ %T`]$* ####################&quot; &gt;&gt; $LOG_FILE</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#定义发送邮件函数</span><br><span class="line">function send_mail () &#123;</span><br><span class="line">        echo $1 | mail -s $1  $email_user</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#创建目录</span><br><span class="line">[ ! -d &quot;$&#123;BACK_FILE_DIR&#125;&quot; ] &amp;&amp; mkdir -p $&#123;BACK_FILE_DIR&#125;</span><br><span class="line">[ ! -d &quot;$&#123;LOG_DIR&#125;&quot; ] &amp;&amp; mkdir -p $&#123;LOG_DIR&#125;</span><br><span class="line"></span><br><span class="line">function full_backup () &#123;</span><br><span class="line"># 全量备份函数</span><br><span class="line">[ ! -z &quot;$databases&quot; ] &amp;&amp; option=&quot;--databases=$&#123;databases&#125;&quot; || option=&quot;&quot; </span><br><span class="line"></span><br><span class="line">##############################MYSQL全库备份#########################</span><br><span class="line">/usr/bin/xtrabackup  --user=$BACKUP_USER --password=$PASSWD --compress --compress-threads=4 --backup --target-dir=$&#123;BACK_FILE_DIR&#125;/base --datadir=$&#123;MYSQL_DATA_DIR&#125; $option &gt; $LOG_FILE 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">        if [ $? -eq 0 ];then</span><br><span class="line">             save_log &quot;mysql full_backup succeed&quot;</span><br><span class="line">             chown -R mysql:mysql $&#123;BACK_FILE_DIR&#125;/base</span><br><span class="line">        </span><br><span class="line">        else</span><br><span class="line">             save_log &quot;mysql full_backup failed&quot;</span><br><span class="line">             #send_mail &quot;mysql full_backup failed&quot;</span><br><span class="line">             exit 1   </span><br><span class="line">        </span><br><span class="line">        fi                </span><br><span class="line">###################################################################</span><br><span class="line"></span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function incremental_backup () &#123;</span><br><span class="line">    [ ! -z &quot;$databases&quot; ] &amp;&amp; option=&quot;--databases=$&#123;databases&#125;&quot; || option=&quot;&quot;</span><br><span class="line"></span><br><span class="line">    cd  $BACK_FILE_DIR</span><br><span class="line">    # 判断是否存在第一次增量备份目录inc1</span><br><span class="line">    # 存在则获取最后一次增量备份目录incN，然后基于最后一次增量备份，做增量备份</span><br><span class="line">    # 不存在则基于全量备份目录base做增量备份</span><br><span class="line">    if [ -d &quot;inc1&quot; ];then</span><br><span class="line">        N_=$(ls -l | awk -F &apos;inc&apos; &apos;/^d+.+inc[0-9]+$/&#123;a[NR]=$NF;len=asort(a,sa)&#125;END&#123;print sa[len]&#125;&apos;)</span><br><span class="line">        N=$(echo $N_+1|bc)</span><br><span class="line">        #增量备份 </span><br><span class="line">        /usr/bin/xtrabackup --user=$BACKUP_USER --password=$PASSWD --backup --compress --target-dir=$BACK_FILE_DIR/inc$N \</span><br><span class="line">        --incremental-basedir=$BACK_FILE_DIR/inc$N_ --datadir=$MYSQL_DATA_DIR $option &gt; $LOG_FILE 2&gt;&amp;1</span><br><span class="line">    else</span><br><span class="line">        N=&quot;1&quot;</span><br><span class="line">        #增量备份 </span><br><span class="line">        [ ! -d $BACK_FILE_DIR/base ] &amp;&amp; save_log &quot;incremental backup failed,no full_backup&quot; &amp;&amp; exit 1</span><br><span class="line">        /usr/bin/xtrabackup --user=$BACKUP_USER --password=$PASSWD --backup --compress --target-dir=$BACK_FILE_DIR/inc$N \</span><br><span class="line">        --incremental-basedir=$BACK_FILE_DIR/base --datadir=$MYSQL_DATA_DIR $option &gt; $LOG_FILE 2&gt;&amp;1</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if [ $? -eq 0 ];then</span><br><span class="line">             save_log &quot;mysql inc$&#123;N&#125;-backup successed&quot;</span><br><span class="line">             chown -R mysql:mysql $&#123;BACK_FILE_DIR&#125;/inc$N</span><br><span class="line">        </span><br><span class="line">        else</span><br><span class="line">             save_log &quot;mysql inc$&#123;N&#125;-backup failed&quot; </span><br><span class="line">            #send_mail &quot;mysql inc$&#123;N&#125;-backup failed&quot;</span><br><span class="line">             exit 1   </span><br><span class="line">                        </span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function rsync_backup_files () &#123;</span><br><span class="line">#传输到远程服务器备份, 需要配置免密ssh认证</span><br><span class="line">        </span><br><span class="line">        #使用rsync将本地的/data/backups目录同步到BETA服务器.同时删除BETA服务器上2周前的备份目录</span><br><span class="line">rsync -az --delete /data/backups -e &quot;$&#123;ssh_command&#125;&quot; $ssh_user@$&#123;ssh_server&#125;:$ssh_server_dir</span><br><span class="line">[ $? -eq 0 ] &amp;&amp; save_log &quot;full-backuped rsync successed&quot; || \</span><br><span class="line">&#123; save_log &quot;backup rsync failed&quot; ; send_mail &quot;mysql backup rsync failed&quot; ; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#每周1进行全备.其他日期对本周一的全备做增量备份</span><br><span class="line">if [ $DAY_DATE -eq 1 ];then</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">   #删除2周前的备份文件</span><br><span class="line">   if [ 1 -le $TWO_WEEKS_AGO -a $TWO_WEEKS_AGO -lt 10 ];then #如果本周和2周前的数相减小于10,并且大于等于1,则相差的结果前加个0.比如07</span><br><span class="line">        FILE_NAME=$(dirname $BACK_FILE_DIR)/0$TWO_WEEKS_AGO</span><br><span class="line">        [ -d $FILE_NAME ] &amp;&amp; rm -rf $FILE_NAME</span><br><span class="line"></span><br><span class="line">   elif [ $TWO_WEEKS_AGO -ge 10 ];then  #如果两数相减等于两位数,直接删除文件</span><br><span class="line">           FILE_NAME=$(dirname $BACK_FILE_DIR)/$TWO_WEEKS_AGO</span><br><span class="line">           [ -d $FILE_NAME ] &amp;&amp; rm -rf $FILE_NAME</span><br><span class="line"></span><br><span class="line">   fi</span><br><span class="line"></span><br><span class="line">   full_backup #调用全备</span><br><span class="line">  </span><br><span class="line">else</span><br><span class="line">     incremental_backup #调用增备</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#删除7天前日志文件</span><br><span class="line">find $LOG_P_DIR -type d -mtime +7 -exec rm -rf &#123;&#125; \;</span><br><span class="line"></span><br><span class="line">rsync_backup_files</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;mysql数据库使用xtrabackup全量-增量备份&quot;&gt;&lt;a href=&quot;#mysql数据库使用xtrabackup全量-增量备份&quot; class=&quot;headerlink&quot; title=&quot;mysql数据库使用xtrabackup全量,增量备份&quot;&gt;&lt;/a&gt;mysql
      
    
    </summary>
    
      <category term="Linux-Basic" scheme="https://jesse.top/categories/Linux-Basic/"/>
    
      <category term="shell&amp;shell脚本" scheme="https://jesse.top/categories/Linux-Basic/shell-shell%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="scripts" scheme="https://jesse.top/tags/scripts/"/>
    
  </entry>
  
  <entry>
    <title>分析统计Nginx日志的响应时间</title>
    <link href="https://jesse.top/2020/06/30/Linux-Basic/shell&amp;shell%E8%84%9A%E6%9C%AC/%E5%88%86%E6%9E%90Nginx%E6%97%A5%E5%BF%97%E7%9A%84%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4/"/>
    <id>https://jesse.top/2020/06/30/Linux-Basic/shell&amp;shell脚本/分析Nginx日志的响应时间/</id>
    <published>2020-06-29T16:44:48.000Z</published>
    <updated>2020-06-30T13:03:22.173Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分析统计Nginx日志的响应时间"><a href="#分析统计Nginx日志的响应时间" class="headerlink" title="分析统计Nginx日志的响应时间"></a>分析统计Nginx日志的响应时间</h2><p>Nginx日志格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                &apos;&quot;$http_user_agent&quot; $http_x_forwarded_for &quot;$request_time&quot;&apos;;</span><br></pre></td></tr></table></figure><p>实际日志如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[work@iqg-yyq2 ~]$ head  /data/logs/nginx/iqg_api_v5.access.log</span><br><span class="line">100.97.74.45 - - [11/Mar/2019:03:46:01 +0800] &quot;HEAD / HTTP/1.0&quot; 200 0 &quot;-&quot; &quot;-&quot; - &quot;0.001&quot;</span><br><span class="line">100.117.85.154 - - [11/Mar/2019:03:46:01 +0800] &quot;HEAD / HTTP/1.0&quot; 200 0 &quot;-&quot; &quot;-&quot; - &quot;0.001&quot;</span><br><span class="line">100.97.74.22 - - [11/Mar/2019:03:46:02 +0800] &quot;HEAD / HTTP/1.0&quot; 200 0 &quot;-&quot; &quot;-&quot; - &quot;0.002&quot;</span><br><span class="line">100.117.85.96 - - [11/Mar/2019:03:46:02 +0800] &quot;HEAD / HTTP/1.0&quot; 200 0 &quot;-&quot; &quot;-&quot; - &quot;0.001&quot;</span><br><span class="line">100.117.85.133 - - [11/Mar/2019:03:46:02 +0800] &quot;HEAD / HTTP/1.0&quot; 200 0 &quot;-&quot; &quot;-&quot; - &quot;0.001&quot;</span><br><span class="line">100.117.85.172 - - [11/Mar/2019:03:46:02 +0800] &quot;HEAD / HTTP/1.0&quot; 200 0 &quot;-&quot; &quot;-&quot; - &quot;0.002&quot;</span><br><span class="line">100.97.74.0 - - [11/Mar/2019:03:46:02 +0800] &quot;HEAD / HTTP/1.0&quot; 200 0 &quot;-&quot; &quot;-&quot; - &quot;0.001&quot;</span><br><span class="line">100.97.73.184 - - [11/Mar/2019:03:46:02 +0800] &quot;HEAD / HTTP/1.0&quot; 200 0 &quot;-&quot; &quot;-&quot; - &quot;0.001&quot;</span><br><span class="line">100.117.85.85 - - [11/Mar/2019:03:46:02 +0800] &quot;HEAD / HTTP/1.0&quot; 200 0 &quot;-&quot; &quot;-&quot; - &quot;0.001&quot;</span><br><span class="line">100.97.74.62 - - [11/Mar/2019:03:46:02 +0800] &quot;HEAD / HTTP/1.0&quot; 200 0 &quot;-&quot; &quot;-&quot; - &quot;0.001&quot;</span><br></pre></td></tr></table></figure><p>最后一行为响应时间.但是是个字符串,还不能直接用awk来统计</p><p>下面这个脚本用来统计响应时间:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">[ $# -ne 2 ] &amp;&amp; echo &quot;Usage: ./loganalysis.sh two parameters: logfile path  and cost time&quot; &amp;&amp; exit 0</span><br><span class="line"></span><br><span class="line">[ ! -f &quot;$1&quot; ] &amp;&amp; echo &quot;the file doesn&apos;t exsit,please check again&quot; &amp;&amp; exit 0</span><br><span class="line">logfile=$(basename $1)</span><br><span class="line"></span><br><span class="line">[ &quot;$2&quot; -lt 0 ] &amp;&amp; echo &quot; the second parameter is not a digit&quot; &amp;&amp; exit 0</span><br><span class="line">cost_time=$2</span><br><span class="line"></span><br><span class="line">cat $1 | awk &apos;&#123;print $NF&#125;&apos;  | awk -F &quot;\&quot;&quot; &apos;&#123;print $2&#125;&apos;  &gt;  time.txt</span><br><span class="line">echo &quot;split request_time over!!!&quot;</span><br><span class="line"></span><br><span class="line">paste  -d &quot; &quot; $1 time.txt &gt; new.log</span><br><span class="line">echo &quot;build new logfile over!!!&quot;</span><br><span class="line"></span><br><span class="line">awk &apos;($NF&gt;&apos;$cost_time&apos;)&#123;print $0&#125;&apos; new.log &gt; slow-$&#123;logfile&#125;</span><br><span class="line">echo &quot;please see slowtime in slow-$&#123;logfile&#125;&quot;</span><br><span class="line"></span><br><span class="line">rm -f time.txt</span><br><span class="line">rm -f new.log</span><br><span class="line"></span><br><span class="line"># analyze the access frequence of API</span><br><span class="line"></span><br><span class="line">echo &quot;#############the access frequence of API ##################&quot;</span><br><span class="line">awk &apos;&#123;++S[$4]&#125; END &#123; for (i in S) print &quot;URL:&quot;i &quot;\t&quot; &quot;access times:&quot;S[i]&#125;&apos; slow-$&#123;logfile&#125;</span><br></pre></td></tr></table></figure><p>下面是统计iqg_api_v5.access.log这个日志响应时间超过1秒的记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[work@iqg-yyq2 ~]$ ./loganalysis.sh /data/logs/nginx/iqg_api_v5.access.log 1</span><br><span class="line">split request_time over!!!</span><br><span class="line">build new logfile over!!!</span><br><span class="line">please see slowtime in slowtime.txt!!!</span><br><span class="line">[work@iqg-yyq2 ~]$</span><br></pre></td></tr></table></figure><p>查看最终结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">work@iqg-yyq2 ~]$ head slowtime.txt</span><br><span class="line">100.117.85.64 [11/Mar/2019:14:14:15 &quot;HEAD / 1.223</span><br><span class="line">100.97.74.41 [11/Mar/2019:14:14:16 &quot;HEAD / 1.984</span><br><span class="line">100.97.74.104 [11/Mar/2019:14:14:16 &quot;HEAD / 1.880</span><br><span class="line">100.97.74.5 [11/Mar/2019:14:14:16 &quot;HEAD / 1.758</span><br><span class="line">100.117.85.100 [11/Mar/2019:14:14:16 &quot;HEAD / 1.757</span><br><span class="line">100.97.73.213 [11/Mar/2019:14:14:16 &quot;HEAD / 1.767</span><br><span class="line">100.117.85.160 [11/Mar/2019:14:14:16 &quot;HEAD / 1.662</span><br><span class="line">100.97.74.118 [11/Mar/2019:14:14:16 &quot;HEAD / 1.566</span><br><span class="line">100.97.73.141 [11/Mar/2019:14:14:16 &quot;HEAD / 1.215</span><br><span class="line">100.117.56.238 [11/Mar/2019:14:14:16 &quot;HEAD / 1.132</span><br><span class="line">[work@iqg-yyq2 ~]$</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分析统计Nginx日志的响应时间&quot;&gt;&lt;a href=&quot;#分析统计Nginx日志的响应时间&quot; class=&quot;headerlink&quot; title=&quot;分析统计Nginx日志的响应时间&quot;&gt;&lt;/a&gt;分析统计Nginx日志的响应时间&lt;/h2&gt;&lt;p&gt;Nginx日志格式如下:&lt;/
      
    
    </summary>
    
      <category term="Linux-Basic" scheme="https://jesse.top/categories/Linux-Basic/"/>
    
      <category term="shell&amp;shell脚本" scheme="https://jesse.top/categories/Linux-Basic/shell-shell%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="scripts" scheme="https://jesse.top/tags/scripts/"/>
    
  </entry>
  
  <entry>
    <title>将服务器日志归档到阿里云OSS的脚本</title>
    <link href="https://jesse.top/2020/06/30/Linux-Basic/shell&amp;shell%E8%84%9A%E6%9C%AC/%E5%B0%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%A5%E5%BF%97%E5%BD%92%E6%A1%A3%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91OSS%E7%9A%84%E8%84%9A%E6%9C%AC/"/>
    <id>https://jesse.top/2020/06/30/Linux-Basic/shell&amp;shell脚本/将服务器日志归档到阿里云OSS的脚本/</id>
    <published>2020-06-29T16:44:48.000Z</published>
    <updated>2020-06-30T13:02:31.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="将服务器日志归档到阿里云OSS的脚本"><a href="#将服务器日志归档到阿里云OSS的脚本" class="headerlink" title="将服务器日志归档到阿里云OSS的脚本"></a>将服务器日志归档到阿里云OSS的脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#Descripion: upload trade center logs file to Aliyun OSS</span><br><span class="line">#Author: HuangYong</span><br><span class="line">#date: 2019-04-29 </span><br><span class="line"></span><br><span class="line">buket=mg-tradecenter-log-archived #OSS Buket name</span><br><span class="line">year=$(date +%Y) #年份</span><br><span class="line">year_dir=log-archived-$&#123;year&#125; #OSS年份目录</span><br><span class="line">month=$(date +%m) #月份</span><br><span class="line">ossutil64_dir=/home/work</span><br><span class="line"></span><br><span class="line">yesterday_logtime=$(date +%Y%m%d --date=&quot;-1 day&quot;) #upload yeasterday logfile</span><br><span class="line">log_dir=/data/logs/apps/trade-center/trade-center # tradecenter log file parent dir</span><br><span class="line">log_prefix=&quot;trade-center.log&quot; #logfile prefix</span><br><span class="line">hostname=api1 #tradecenter server</span><br><span class="line"></span><br><span class="line">#判断是否安装ossutil64工具</span><br><span class="line">[ ! -f &quot;/home/work/ossutil64&quot; ] &amp;&amp; echo &quot;请安装ossutil64软件&quot; &amp;&amp; exit 1</span><br><span class="line"></span><br><span class="line">#判断年份目录是否存在,不存在则创建</span><br><span class="line">if ! `$&#123;ossutil64_dir&#125;/ossutil64 ls oss://$&#123;buket&#125;/$&#123;year_dir&#125;/ &gt; /dev/null 2&gt;&amp;1`;then</span><br><span class="line">   $&#123;ossutil64_dir&#125;/ossutil64 mkdir oss://$&#123;buket&#125;/$&#123;year_dir&#125;/</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#判断月份目录是否存在,不存在则创建</span><br><span class="line">if ! `$&#123;ossutil64_dir&#125;/ossutil64 ls oss://$&#123;buket&#125;/$&#123;year_dir&#125;/$&#123;month&#125; &gt; /dev/null 2&gt;&amp;1`;then</span><br><span class="line">   $&#123;ossutil64_dir&#125;/ossutil64 mkdir oss://$&#123;buket&#125;/$&#123;year_dir&#125;/$&#123;month&#125;/</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 打包昨天的日志文件</span><br><span class="line"></span><br><span class="line">cd $log_dir</span><br><span class="line"></span><br><span class="line">for log_type in &quot;debug&quot; &quot;error&quot; &quot;netrcd-admin&quot; &quot;netrcd-callback&quot; &quot;netrcd-gateway&quot; &quot;netrcd-notify&quot; &quot;script&quot;;do</span><br><span class="line"></span><br><span class="line">    log_name=&quot;$&#123;log_prefix&#125;.$&#123;log_type&#125;.$yesterday_logtime&quot;</span><br><span class="line">    if [ -f $log_name ];then</span><br><span class="line">        tar -zc -f $&#123;hostname&#125;.$&#123;log_name&#125;.tar.gz  $log_name</span><br><span class="line">    fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 上传文件到OSS</span><br><span class="line"></span><br><span class="line">$&#123;ossutil64_dir&#125;/ossutil64 cp $log_dir --include=&quot;$&#123;hostname&#125;*.tar.gz&quot; -r -f oss://$&#123;buket&#125;/$&#123;year_dir&#125;/$&#123;month&#125;/</span><br><span class="line"></span><br><span class="line">#上传完成后,删除打包的日志</span><br><span class="line">[ $? == 0 ] &amp;&amp; rm -f $log_dir/$&#123;hostname&#125;*</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;将服务器日志归档到阿里云OSS的脚本&quot;&gt;&lt;a href=&quot;#将服务器日志归档到阿里云OSS的脚本&quot; class=&quot;headerlink&quot; title=&quot;将服务器日志归档到阿里云OSS的脚本&quot;&gt;&lt;/a&gt;将服务器日志归档到阿里云OSS的脚本&lt;/h2&gt;&lt;figure c
      
    
    </summary>
    
      <category term="Linux-Basic" scheme="https://jesse.top/categories/Linux-Basic/"/>
    
      <category term="shell&amp;shell脚本" scheme="https://jesse.top/categories/Linux-Basic/shell-shell%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="scripts" scheme="https://jesse.top/tags/scripts/"/>
    
  </entry>
  
  <entry>
    <title>docker学习笔记---理解swarm集群</title>
    <link href="https://jesse.top/2020/06/29/docker/docker%E5%AE%98%E7%BD%91%E5%AD%A6%E4%B9%A0-5.%E5%AD%A6%E4%B9%A0swarm%E9%9B%86%E7%BE%A4/"/>
    <id>https://jesse.top/2020/06/29/docker/docker官网学习-5.学习swarm集群/</id>
    <published>2020-06-29T03:59:58.000Z</published>
    <updated>2020-06-29T13:11:55.850Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解swarm集群"><a href="#理解swarm集群" class="headerlink" title="理解swarm集群"></a>理解swarm集群</h3><p>一个swarm是一组运行docker服务器的的集群,docker服务器可以是物理机也可以是虚拟机.</p><p>swarm manager可以使用多种策略来运行容器.比如”emptiest node”—部署容器到压力最小的服务器上,或者”global”—确保每台服务器都只允许一个容器实例.你可以在Compose文件中指示swarm manager去选择何种策略</p><p>swarm managers是swarm进群中唯一可以执行命令,或者授权其他服务器以”workers”身份加入swarm集群的服务器.</p><hr><h4 id="初始化swarm-加入节点"><a href="#初始化swarm-加入节点" class="headerlink" title="初始化swarm,加入节点"></a>初始化swarm,加入节点</h4><p>试验环境:</p><p>1.10.0.0.50 —swarm manager<br>2.10.0.0.12 —worker 节点</p><ul><li>初始化swarm,并且指定通告的IP</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$docker swarm init --advertise-addr 10.0.0.50</span><br><span class="line">Swarm initialized: current node (zlvl9l94blu3rfcaaptdvo9u1) is now a manager.</span><br><span class="line"></span><br><span class="line">To add a worker to this swarm, run the following command:</span><br><span class="line"></span><br><span class="line">    docker swarm join --token SWMTKN-1-2i5fyjf2niw81tudcvpw33yuni277vz45lt6tyi5bvcnhvuwea-bj091dpe6e69ph9kt3lmsthgp 10.0.0.50:2377</span><br><span class="line"></span><br><span class="line">To add a manager to this swarm, run &apos;docker swarm join-token manager&apos; and follow the instructions.</span><br></pre></td></tr></table></figure><p>根据上面提示,在第二台服务器上以worker身份加入swarm集群</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@php ~]$docker swarm join --token SWMTKN-1-2i5fyjf2niw81tudcvpw33yuni277vz45lt6tyi5bvcnhvuwea-bj091dpe6e69ph9kt3lmsthgp 10.0.0.50:2377</span><br><span class="line">This node joined a swarm as a worker.</span><br><span class="line">[root@php ~]$</span><br></pre></td></tr></table></figure><p>执行docker node ls命令可以管理和查看swarm集群的所有节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$docker node ls</span><br><span class="line">ID                            HOSTNAME                STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION</span><br><span class="line">zlvl9l94blu3rfcaaptdvo9u1 *   localhost.localdomain   Ready               Active              Leader              18.09.2</span><br><span class="line">ud5ztqzvvfwg3d3hwmts5y9ct     php                     Ready               Active                                  18.09.3</span><br><span class="line">[root@localhost ~]$</span><br></pre></td></tr></table></figure><p>执行docker swarm leave命令将某个节点退出swarm集群</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@php ~]$docker swarm leave</span><br><span class="line">Node left the swarm.</span><br><span class="line">[root@php ~]$</span><br><span class="line"></span><br><span class="line">此时这个节点在swarm集群中状态为down</span><br><span class="line"></span><br><span class="line">[root@localhost ~]$docker node ls</span><br><span class="line">ID                            HOSTNAME                STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION</span><br><span class="line">zlvl9l94blu3rfcaaptdvo9u1 *   localhost.localdomain   Ready               Active              Leader              18.09.2</span><br><span class="line">ud5ztqzvvfwg3d3hwmts5y9ct     php                     Down                Active                                  18.09.3</span><br><span class="line">[root@localhost ~]$</span><br></pre></td></tr></table></figure><hr><h4 id="在swarm集群部署app"><a href="#在swarm集群部署app" class="headerlink" title="在swarm集群部署app"></a>在swarm集群部署app</h4><p>现在可以把上一小节的docker compose部署在swarm集群上了.执行命令和上一小节一样.但是需要注意的是只能在swarm manager节点服务器上执行命令.</p><p>在第一台服务器上执行如下命令:(确保docker compose文件和镜像文件在这台服务器上)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@localhost ~]$cd /data/compose</span><br><span class="line">[root@localhost compose]$ls</span><br><span class="line">docker-compose.yml</span><br><span class="line">[root@localhost compose]$docker stack deploy -c docker-compose.yml getstartedlab</span><br><span class="line">Creating network getstartedlab_webnet</span><br><span class="line">Creating service getstartedlab_web</span><br><span class="line">[root@localhost compose]$</span><br></pre></td></tr></table></figure><p>APP已经成功部署到swarm集群上,现在可以使用上一小节中的同样的命令来管理app集群,只不过这次services和容器已经部署到两台服务器上:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost compose]$docker stack ps getstartedlab</span><br><span class="line">ID                  NAME                      IMAGE                  NODE                    DESIRED STATE       CURRENT STATE              ERROR                              PORTS</span><br><span class="line">4borwslue8k5        getstartedlab_web.1       friendlyhello:latest   localhost.localdomain   Running             Preparing 6 seconds ago</span><br><span class="line">ixmkldh16otx        getstartedlab_web.2       friendlyhello:latest   php                     Ready               Preparing 22 seconds ago</span><br><span class="line">i2yhimkst4iq         \_ getstartedlab_web.2   friendlyhello:latest   php                     Shutdown            Rejected 23 seconds ago    &quot;No such image: friendlyhello:…&quot;</span><br><span class="line">gytqpcwnzvrm        getstartedlab_web.3       friendlyhello:latest   localhost.localdomain   Running             Preparing 6 seconds ago</span><br><span class="line">j94tblo4qjwa        getstartedlab_web.4       friendlyhello:latest   php                     Ready               Preparing 22 seconds ago</span><br><span class="line">b7r9xkf4glh6         \_ getstartedlab_web.4   friendlyhello:latest   php                     Shutdown            Rejected 22 seconds ago    &quot;No such image: friendlyhello:…&quot;</span><br><span class="line">i8sv4c293ata        getstartedlab_web.5       friendlyhello:latest   localhost.localdomain   Running             Preparing 6 seconds ago</span><br></pre></td></tr></table></figure><blockquote><p>需要在另外一台服务器上pull同样的镜像,否则容器无法启动</p></blockquote><ul><li><p>在第二台服务器上下载我阿里云私有仓库的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">docker login --username=jessehuang408 registry.cn-hangzhou.aliyuncs.com</span><br><span class="line">Password:</span><br><span class="line"></span><br><span class="line">[root@php ~]$docker pull registry.cn-hangzhou.aliyuncs.com/jesse_images/jesse_images:frendlyhello-v1.0</span><br><span class="line">frendlyhello-v1.0: Pulling from jesse_images/jesse_images</span><br><span class="line">f7e2b70d04ae: Pull complete</span><br><span class="line">1e9214730e83: Pull complete</span><br><span class="line">5bd4ec081f7b: Pull complete</span><br><span class="line">be26b369a1e7: Pull complete</span><br><span class="line">236be9d80905: Pull complete</span><br><span class="line">1bf8a3675b0b: Pull complete</span><br><span class="line">5752f9477f0c: Pull complete</span><br><span class="line">Digest: sha256:8e8b57ef6e22c8c04c1c80cfab9f336928cffabacaa4ae4e74ec57e54bcffdb2</span><br><span class="line">Status: Downloaded newer image for registry.cn-hangzhou.aliyuncs.com/jesse_images/jesse_images:frendlyhello-v1.0</span><br><span class="line"></span><br><span class="line">[root@php ~]$docker images</span><br><span class="line">REPOSITORY                                                    TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/jesse_images/jesse_images   frendlyhello-v1.0   f091d1bb803c        2 days ago          131MB</span><br><span class="line">[root@php ~]$*</span><br></pre></td></tr></table></figure></li><li><p>将镜像修改成和第一台服务器一样:frendlyhello:latest</p></li></ul><p>命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag 镜像ID REPOSITORY:TAG</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@php ~]$docker tag f091d1bb803c frendlyhello:latest</span><br><span class="line">[root@php ~]$docker images</span><br><span class="line">REPOSITORY                                                    TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">frendlyhello                                                  latest              f091d1bb803c        2 days ago          131MB</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/jesse_images/jesse_images   frendlyhello-v1.0   f091d1bb803c        2 days ago          131MB</span><br><span class="line">[root@php ~]$</span><br></pre></td></tr></table></figure><ul><li>将第一台服务器的docker-compose文件拷贝到同样的目录下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@php ~]$mkdir /data/compose</span><br><span class="line">[root@php ~]$scp root@10.0.0.50:/data/compose/docker-compose.yml /data/compose/</span><br></pre></td></tr></table></figure><ul><li>回到第一台服务器上删除刚才创建的getstartedlab</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost compose]$docker stack rm getstartedlab</span><br><span class="line">Removing service getstartedlab_web</span><br><span class="line">Removing network getstartedlab_webnet</span><br><span class="line"></span><br><span class="line">[root@localhost compose]$docker stack ps getstartedlab</span><br><span class="line">nothing found in stack: getstartedlab</span><br></pre></td></tr></table></figure><ul><li>重新部署docker compose</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost compose]$docker stack deploy -c docker-compose.yml getstartedlab</span><br><span class="line">Creating network getstartedlab_webnet</span><br><span class="line">Creating service getstartedlab_web</span><br><span class="line">[root@localhost compose]$</span><br></pre></td></tr></table></figure><ul><li>成功部署</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost compose]$docker stack ps getstartedlab</span><br><span class="line">ID                  NAME                  IMAGE                  NODE                    DESIRED STATE       CURRENT STATE              ERROR               PORTS</span><br><span class="line">uqsj8mim0sac        getstartedlab_web.1   friendlyhello:latest   localhost.localdomain   Running             Preparing 3 seconds ago</span><br><span class="line">shjiwlnj12sp        getstartedlab_web.2   friendlyhello:latest   php                     Running             Preparing 24 seconds ago</span><br><span class="line">8sqllvgid8jp        getstartedlab_web.3   friendlyhello:latest   php                     Running             Preparing 24 seconds ago</span><br><span class="line">v7fsecgcg504        getstartedlab_web.4   friendlyhello:latest   php                     Running             Preparing 24 seconds ago</span><br><span class="line">np8utmyvk5px        getstartedlab_web.5   friendlyhello:latest   localhost.localdomain   Running             Preparing 3 seconds ago</span><br><span class="line">[root@localhost compose]$</span><br></pre></td></tr></table></figure><p>在第二台的worker节点上执行命令会提示失败:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@php compose]$docker stack ps getstartedlab</span><br><span class="line">Error response from daemon: This node is not a swarm manager. Worker nodes can&apos;t be used to view or modify cluster state. Please run this command on a manager node or promote the current node to a manager.</span><br><span class="line">[root@php compose]$</span><br></pre></td></tr></table></figure><p>现在,在两台服务器上都能访问刚才部署的app</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> huangyong@huangyong-Macbook-Pro  ~  curl http://10.0.0.12:4000</span><br><span class="line">&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; 926f433b3896&lt;br/&gt;&lt;b&gt;Visits:&lt;/b&gt; &lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;% </span><br><span class="line"></span><br><span class="line">huangyong@huangyong-Macbook-Pro  ~  curl http://10.0.0.50:4000</span><br><span class="line">&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; 1535f17586ea&lt;br/&gt;&lt;b&gt;Visits:&lt;/b&gt; &lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;%                                                            huangyong@huangyong-Macbook-Pro  ~ </span><br></pre></td></tr></table></figure><h4 id="扩展app"><a href="#扩展app" class="headerlink" title="扩展app"></a>扩展app</h4><p>扩展app还是直接编辑docker-compose.yml文件.然后重新docker stack deploy部署即可.</p><p>如果是需要将其他虚拟机或者物理服务器加入进swarm集群,就像第二台服务器一样使用docker swarm join命令加入即可,</p><h4 id="停止swarm"><a href="#停止swarm" class="headerlink" title="停止swarm"></a>停止swarm</h4><p>命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack rm getstartedlab</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 初始化一个swarm集群</span><br><span class="line"></span><br><span class="line">docker swarm init --advertise-addr IP</span><br><span class="line"></span><br><span class="line">#加入到swarm集群</span><br><span class="line">docker swarm join --token &lt;token&gt; &lt;swarm manager IP&gt;:&lt;port&gt;</span><br><span class="line"></span><br><span class="line">#部署app</span><br><span class="line">docker stack deploy -c docker-compose.yml &lt;services name&gt;</span><br><span class="line">&gt; note:在所有docker服务器节点上都需要有docker-compose.yml文件和相关镜像</span><br><span class="line"></span><br><span class="line"># 查看services </span><br><span class="line">docker stack ps &lt;services name&gt;</span><br><span class="line">docker services ls</span><br><span class="line">docker stack ls</span><br><span class="line"></span><br><span class="line"># 从swarm集群中删除 services</span><br><span class="line"></span><br><span class="line">docker stack rm &lt;service name&gt;</span><br><span class="line"></span><br><span class="line"># 删除swarm集群节点</span><br><span class="line"></span><br><span class="line">docker swarm leave #worker节点</span><br><span class="line">docker swarm leave --force #manager节点</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;理解swarm集群&quot;&gt;&lt;a href=&quot;#理解swarm集群&quot; class=&quot;headerlink&quot; title=&quot;理解swarm集群&quot;&gt;&lt;/a&gt;理解swarm集群&lt;/h3&gt;&lt;p&gt;一个swarm是一组运行docker服务器的的集群,docker服务器可以是物理机也可以是虚拟机.&lt;/p&gt;
&lt;p&gt;swarm manager可以使用多种策略来运行容器.比如”emptiest node”—部署容器到压力最小的服务器上,或者”global”—确保每台服务器都只允许一个容器实例.你可以在Compose文件中指示swarm manager去选择何种策略&lt;/p&gt;
&lt;p&gt;swarm managers是swarm进群中唯一可以执行命令,或者授权其他服务器以”workers”身份加入swarm集群的服务器.&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;初始化swarm-加入节点&quot;&gt;&lt;a href=&quot;#初始化swarm-加入节点&quot; class=&quot;headerlink&quot; title=&quot;初始化swarm,加入节点&quot;&gt;&lt;/a&gt;初始化swarm,加入节点&lt;/h4&gt;&lt;p&gt;试验环境:&lt;/p&gt;
&lt;p&gt;1.10.0.0.50 —swarm manager&lt;br&gt;2.10.0.0.12 —worker 节点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化swarm,并且指定通告的IP&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="docker" scheme="https://jesse.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://jesse.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker学习笔记---docker网络之overlay</title>
    <link href="https://jesse.top/2020/06/29/docker/docker%E5%AE%98%E7%BD%91%E5%AD%A6%E4%B9%A0--docker%E7%BD%91%E7%BB%9C%E4%B9%8Boverlay/"/>
    <id>https://jesse.top/2020/06/29/docker/docker官网学习--docker网络之overlay/</id>
    <published>2020-06-29T03:59:58.000Z</published>
    <updated>2020-06-30T12:32:51.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker官网学习-7-docker网络之overlay"><a href="#docker官网学习-7-docker网络之overlay" class="headerlink" title="docker官网学习-7.docker网络之overlay"></a>docker官网学习-7.docker网络之overlay</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>overlay网卡在多个docker宿主机之间创建一个分布式的网络,允许多个容器安全通信.</p><p>当初始化一个swarm集群,或者加入docker宿主机到一个swarm集群中.Docker会在该宿主机上创建2个网络:</p><ul><li>ingress: 负责swarm集群的控制以及数据流量</li><li>docker_gwbridge:一个Bridge网络,负责连接swarm集群中的每个docker节点</li></ul><p>overlay网络的创建方式和bridge一样.也是<code>docker network create</code>命令</p><hr><h3 id="创建overlay网络"><a href="#创建overlay网络" class="headerlink" title="创建overlay网络"></a>创建overlay网络</h3><a id="more"></a><p><strong>创建overlay网络的前提条件</strong></p><p>1.防火墙开通以下端口</p><ul><li>TCP 2377——集群管理节点通信</li><li>TCP,UPD 7946—节点间通信</li><li>UDP 4789—overlay网络流量</li></ul><p>2.初始化docker宿主机为swarm集群的manager角色.命令为<code>docker swarm init</code>.或者使用<code>docker swarm join</code>命令加入到一个现有的swarm集群.</p><p>这两种方式都会创建默认的ingress overlay网络.</p><blockquote><p>即使你不打算使用swarm服务,但是也要这样做.然后才能创建自定义的overlay网络</p></blockquote><p><strong>创建overlay网络命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#创建个overlay网络.名字为my-overlay</span><br><span class="line">docker network create -d overlay my-overlay</span><br></pre></td></tr></table></figure><p>如果swarm服务或者独立容器需要和其他docker宿主机上的独立容器通信.需要加上<code>—attachable</code>参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#创建个overlay网络,名字为my-overlay.并且和其他docker宿主机的standalone容器通信.</span><br><span class="line">docker network create -d overlay --attachable my-overlay</span><br></pre></td></tr></table></figure><blockquote><p>可以自定义地址段,掩码,网关等信息.具体方法见docker network create –help</p></blockquote><hr><h3 id="自定义默认Ingress网络"><a href="#自定义默认Ingress网络" class="headerlink" title="自定义默认Ingress网络"></a>自定义默认Ingress网络</h3><p>大部分用户不需要配置ingress网络.但是docker17.05以上版本可以自定义ingress网络.如果默认的Ingress网络iP地址段和已经存在的网络有冲突,则自定义的配置可很有用.</p><p>配置Ingress网络需要先删除ingress,然后重新创建.所以最好是在创建容器服务之前先定义好ingress.如果已经有暴露出端口的服务.则需要先删除服务.</p><p><strong>自定义默认ingress网络步骤如下:</strong></p><p>1.查看当前ingress网络.<code>docker network inspect ingress</code>.删除所有连接到ingress的容器的服务.</p><p>2.移除现有的ingress网络.<code>docker network rm ingress</code></p><p>3.使用<code>--ingress</code>参数重新创建一个overlay网络.定义自定义参数.例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker network create \</span><br><span class="line"> --driver overlay \</span><br><span class="line"> --ingress \</span><br><span class="line"> --subnet=10.11.0.0/16 \</span><br><span class="line"> --gateway=10.11.0.2 \</span><br><span class="line"> --opt com.docker.network.driver.mtu=1200 \</span><br><span class="line"> my-ingress</span><br></pre></td></tr></table></figure><blockquote><p>可以用自定义名称(my-ingress)来定义ingress网络.但是只允许存在一个自定义Ingress.</p></blockquote><p>4.重启步骤1中的服务</p><hr><h3 id="自定义默认docker-gwbridge-接口"><a href="#自定义默认docker-gwbridge-接口" class="headerlink" title="自定义默认docker_gwbridge 接口"></a>自定义默认docker_gwbridge 接口</h3><p>docker_gwbridge是连接overlay网络和docker宿主机物理网卡之间的虚拟网桥.当初始化一个swarm集群,或者将docker宿主机加入到一个swarm集群时,docker会自动创建docker_gwbridge.但是docker_gwbridge不是一个docker服务,而是存在于docker宿主机的内核当中.</p><p>所以需要在加入到swarm集群前先配置好docker_gwbridge.</p><p><strong>自定义默认docker_gwbridge网络步骤如下:</strong></p><p>1.停止docker</p><p>2.删除当前<code>docker_gwbridge</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip link set docker_gwbridge down</span><br><span class="line"></span><br><span class="line">$ sudo ip link del dev docker_gwbridge</span><br></pre></td></tr></table></figure><p>3.开启docker.不要加入或者初始化swarm</p><p>4.手动创建<code>docker_gwbridge</code>.下面这个例子定义了网络iP地址范围</p><blockquote><p>关于docker_gwbridge的更多参数请参考<a href="https://docs.docker.com/engine/reference/commandline/network_create/#bridge-driver-options" target="_blank" rel="noopener">Bridg dirver options</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create \</span><br><span class="line">--subnet 10.11.0.0/16 \</span><br><span class="line">--opt com.docker.network.bridge.name=docker_gwbridge \</span><br><span class="line">--opt com.docker.network.bridge.enable_icc=false \</span><br><span class="line">--opt com.docker.network.bridge.enable_ip_masquerade=true \</span><br><span class="line">docker_gwbridge</span><br></pre></td></tr></table></figure><p>5.初始化或者加入到swarm集群</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;docker官网学习-7-docker网络之overlay&quot;&gt;&lt;a href=&quot;#docker官网学习-7-docker网络之overlay&quot; class=&quot;headerlink&quot; title=&quot;docker官网学习-7.docker网络之overlay&quot;&gt;&lt;/a&gt;docker官网学习-7.docker网络之overlay&lt;/h2&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;overlay网卡在多个docker宿主机之间创建一个分布式的网络,允许多个容器安全通信.&lt;/p&gt;
&lt;p&gt;当初始化一个swarm集群,或者加入docker宿主机到一个swarm集群中.Docker会在该宿主机上创建2个网络:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ingress: 负责swarm集群的控制以及数据流量&lt;/li&gt;
&lt;li&gt;docker_gwbridge:一个Bridge网络,负责连接swarm集群中的每个docker节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;overlay网络的创建方式和bridge一样.也是&lt;code&gt;docker network create&lt;/code&gt;命令&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;创建overlay网络&quot;&gt;&lt;a href=&quot;#创建overlay网络&quot; class=&quot;headerlink&quot; title=&quot;创建overlay网络&quot;&gt;&lt;/a&gt;创建overlay网络&lt;/h3&gt;
    
    </summary>
    
      <category term="docker" scheme="https://jesse.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://jesse.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>使用goreplay收集线上真实http流量</title>
    <link href="https://jesse.top/2020/06/29/Linux-Web/%E4%BD%BF%E7%94%A8goreplay%E6%94%B6%E9%9B%86%E7%BA%BF%E4%B8%8A%E7%9C%9F%E5%AE%9Ehttp%E6%B5%81%E9%87%8F/"/>
    <id>https://jesse.top/2020/06/29/Linux-Web/使用goreplay收集线上真实http流量/</id>
    <published>2020-06-29T03:59:58.000Z</published>
    <updated>2020-06-29T13:45:33.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用goreplay收集线上真实http流量"><a href="#使用goreplay收集线上真实http流量" class="headerlink" title="使用goreplay收集线上真实http流量"></a>使用goreplay收集线上真实http流量</h2><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>在很多场景中,我们需要将线上服务器的真实Http请求复制转发到某台服务器中(或者测试环境中),并且前提是不影响线上生产业务进行.</p><p>例如:</p><ol><li>通常可能会通过ab等压测工具来对单一http接口进行压测。但如果是需要http服务整体压测，使用ab来压测工作量大且不方便，通过线上流量复制引流，通过将真实请求流量放大N倍来进行压测，能对服务有一个较为全面的检验.</li><li>将线上流量引入到测试环境中,测试某个中间件或者数据库的压力</li><li>上线前在预发布环境，使用线上真实的请求，检查是否准备发布的版本，是否具备发布标准</li><li>用线上的流量转发到预发，检查相同流量下一些指标的反馈情况，检查核心数据是否有改善、优化.</li></ol><a id="more"></a><hr><h3 id="goreplay介绍"><a href="#goreplay介绍" class="headerlink" title="goreplay介绍"></a>goreplay介绍</h3><p>goreplay项目请参考github:<a href="https://github.com/buger/goreplay" target="_blank" rel="noopener">goreplay介绍</a></p><p>goreplay是一款开源网络监控工具,可以在不影响业务的情况下,记录服务器真实流量,将该流量用来做镜像,压力测试,监控和分析等用途.</p><p>简单来说就是goreplay抓取线上真实的流量，并将捕捉到的流量转发到测试服务器上(或者保存到本地文件中)</p><p>goreplay大致工作流程如下:</p><p><img src="https://img2.jesse.top/20200629110035.png" alt=""></p><hr><h3 id="goreplay常见使用方式"><a href="#goreplay常见使用方式" class="headerlink" title="goreplay常见使用方式"></a>goreplay常见使用方式</h3><p>goreplay使用文档参考:<a href="https://github.com/buger/goreplay/wiki" target="_blank" rel="noopener">goreplay文档</a></p><p>常用的一些命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-input-raw 抓取指定端口的流量 gor --input-raw :8080</span><br><span class="line">-output-stdout 打印到控制台</span><br><span class="line">-output-file 将请求写到文件中 gor --input-raw :80 --output-file ./requests.gor</span><br><span class="line">-input-file 从文件中读取请求，与上一条命令呼应 gor --input-file ./requests.gor</span><br><span class="line">-exit-after 5s 持续时间</span><br><span class="line">-http-allow-url url白名单，其他请求将会被丢弃</span><br><span class="line">-http-allow-method 根据请求方式过滤</span><br><span class="line">-http-disallow-url 遇上一个url相反，黑名单，其他的请求会被捕获到</span><br></pre></td></tr></table></figure><blockquote><p>更多命令可以使用 ./gor –help查看</p></blockquote><hr><h3 id="goreplay安装"><a href="#goreplay安装" class="headerlink" title="goreplay安装"></a>goreplay安装</h3><p>在github上下载Linux的二进制文件: <a href="https://github.com/buger/goreplay/releases" target="_blank" rel="noopener">goreplay安装</a></p><blockquote><p>注意.虽然在github上提供了rpm安装包,但是实际安装发现无法安装:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@dwd-tongji-3 ~]# rpm -ivh gor-1.0.0-1.x86_64.rpm</span><br><span class="line">Preparing...                          ################################# [100%]</span><br><span class="line">package goreplay-1.0.0-1.x86_64 is intended for a different operating system</span><br></pre></td></tr></table></figure><p>下载github上的二进制文件,解压后是一个gor的二进制可执行文件.复制到PATH变量路径下即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@dwd-tongji-3 ~]# wget https://github.com/buger/goreplay/releases/download/v1.0.0/gor_1.0.0_x64.tar.gz</span><br><span class="line">[root@dwd-tongji-3 ~]# ls</span><br><span class="line"> gor_1.0.0_x64.tar.gz</span><br><span class="line">[root@dwd-tongji-3 ~]# tar -xf gor_1.0.0_x64.tar.gz</span><br><span class="line">[root@dwd-tongji-3 ~]# ls</span><br><span class="line">gor </span><br><span class="line">[root@dwd-tongji-3 ~]# ll gor</span><br><span class="line">-rwxr-xr-x 1 501 games 17779040 Mar 30  2019 gor</span><br><span class="line">[root@dwd-tongji-3 ~]# cp gor /usr/local/bin/</span><br></pre></td></tr></table></figure><hr><h3 id="goreplay简单实践"><a href="#goreplay简单实践" class="headerlink" title="goreplay简单实践"></a>goreplay简单实践</h3><h4 id="1-将本地http的流量保存到本地文件中"><a href="#1-将本地http的流量保存到本地文件中" class="headerlink" title="1.将本地http的流量保存到本地文件中."></a>1.将本地http的流量保存到本地文件中.</h4><p>为了简便起见,以下命令都在root用户下执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## 1.开启一个screen窗口</span><br><span class="line">[root@dwd-tongji-3 ~]# screen -S GOR</span><br><span class="line">## 2.将80流量保存到本地的文件</span><br><span class="line">[root@dwd-tongji-3 ~]# gor --input-raw :80 --output-file /data/requests.gor</span><br><span class="line">Version: 1.0.0</span><br></pre></td></tr></table></figure><p>默认情况下goreplay会以块文件存储,将流量保存为多个块文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@dwd-tongji-3 ~]# ls /data/requests_* | more</span><br><span class="line">/data/requests_0.gor</span><br><span class="line">/data/requests_100.gor</span><br><span class="line">/data/requests_101.gor</span><br><span class="line">/data/requests_102.gor</span><br><span class="line">/data/requests_103.gor</span><br><span class="line">/data/requests_104.gor</span><br><span class="line">/data/requests_105.gor</span><br><span class="line">/data/requests_106.gor</span><br><span class="line">/data/requests_107.gor</span><br><span class="line">/data/requests_108.gor</span><br><span class="line">/data/requests_109.gor</span><br><span class="line">/data/requests_10.gor</span><br></pre></td></tr></table></figure><p>使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>[root@dwd-tongji-3 ~]#./gor –input-raw :80 –output-file /data/gor.gor –output-file-append</p><p>[root@dwd-tongji-3 ~]# ll /data -h<br>total 1.4M<br>-rw-r—– 1 root root 1.4M Jun 29 15:13 gor.gor<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 2.将http的请求打印到终端</span><br></pre></td></tr></table></figure></p><p>[root@dwd-tongji-3 ~]#gor –input-raw :8000 –output-stdout<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 3.将http的请求转发到测试环境</span><br></pre></td></tr></table></figure></p><p>gor –input-raw :80 –output-http=”<a href="http://beta:80&quot;" target="_blank" rel="noopener">http://beta:80&quot;</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在测试服务器上的nginx查看日志,.发现流量已经进来了</span><br></pre></td></tr></table></figure></p><p>10.111.51.243 - - [29/Jun/2020:14:56:55 +0800] “POST /piwik.php HTTP/1.1” 200 5 “<a href="https://2021001151691008.hybrid.alipay-eco.com/2021001151691008/0.2.2006111453.18/index.html#pages/index/index?appid=2021001151691008&amp;taskId=415&quot;" target="_blank" rel="noopener">https://2021001151691008.hybrid.alipay-eco.com/2021001151691008/0.2.2006111453.18/index.html#pages/index/index?appid=2021001151691008&amp;taskId=415&quot;</a> “Mozilla/5.0 (iPhone; CPU iPhone OS 13_3_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/17D50 Ariver/1.0.12 AliApp(AP/10.1.95.7030) Nebula WK RVKType(0) AlipayDefined(nt:4G,ws:375|667|2.0) AlipayClient/10.1.95.7030 Language/zh-Hans Region/CN NebulaX/1.0.0” “112.96.179.238”<br>10.111.51.243 - - [29/Jun/2020:14:56:55 +0800] “POST /piwik.php HTTP/1.1” 200 5 “<a href="https://servicewechat.com/wxa090d3923fde0d4b/132/page-frame.html&quot;" target="_blank" rel="noopener">https://servicewechat.com/wxa090d3923fde0d4b/132/page-frame.html&quot;</a> “Mozilla/5.0 (iPhone; CPU iPhone OS 13_5_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148 MicroMessenger/7.0.13(0x17000d29) NetType/4G Language/zh_CN” “14.106.171.11”<br>10.111.51.243 - - [29/Jun/2020:14:56:55 +0800] “POST /piwik_new.php?actionname=zt-template HTTP/1.1” 400 249 “-“ “-“ “118.31.36.251”<br>10.111.51.243 - - [29/Jun/2020:14:56:55 +0800] “POST /piwik_new.php?actionname=zt-template HTTP/1.1” 400 249 “-“ “-“ “118.31.36.251”<br>10.111.51.243 - - [29/Jun/2020:14:56:55 +0800] “POST /piwik_new.php?actionname=zt-template HTTP/1.1” 400 249 “-“ “-“ “118.31.36.251”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">####  也可以将流量输出到多个终端</span><br><span class="line"></span><br><span class="line">* 输出到多个http服务器</span><br></pre></td></tr></table></figure></p><p>gor –input-tcp :28020 –output-http “<a href="http://staging.com&quot;" target="_blank" rel="noopener">http://staging.com&quot;</a>  –output-http “<a href="http://dev.com&quot;" target="_blank" rel="noopener">http://dev.com&quot;</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 输出到文件或者Http服务器</span><br></pre></td></tr></table></figure></p><p>gor –input-raw :80 –output-file requests.log –output-http “<a href="http://staging.com&quot;" target="_blank" rel="noopener">http://staging.com&quot;</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">####  4.将流量从文件重放到http服务器</span><br><span class="line"></span><br><span class="line">1.首先将请求流量保存到本地文件</span><br></pre></td></tr></table></figure></p><p>sudo ./gor –input-raw :8000 –output-file=requests.gor<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2.再开一个窗口,运行gor,将请求流量从文件中重放</span><br></pre></td></tr></table></figure></p><p>./gor –input-file requests.gor –output-http=”<a href="http://localhost:8001&quot;" target="_blank" rel="noopener">http://localhost:8001&quot;</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 压力测试</span><br><span class="line"></span><br><span class="line">goreplay支持将捕获到的生产实际请求流量减少或者放大重播以用于测试环境的压力测试.压力测试一般针对Input流量减少或者放大.例如下面的例子</span><br></pre></td></tr></table></figure></p><h1 id="Replay-from-file-on-2x-speed"><a href="#Replay-from-file-on-2x-speed" class="headerlink" title="Replay from file on 2x speed"></a>Replay from file on 2x speed</h1><p>#将请求流量以2倍的速度放大重播<br>gor –input-file “requests.gor|200%” –output-http “staging.com”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当然也也支持10%,20%等缩小请求流量</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 限速</span><br><span class="line"></span><br><span class="line">如果受限于测试环境的服务器资源压力,只想重播一部分流量到测试环境中,而不需要所有的实际生产流量,那么就可以用限速功能.有两种策略可以实现限流</span><br><span class="line"></span><br><span class="line">1.随机丢弃请求流量</span><br><span class="line"></span><br><span class="line">2.基于Header或者URL丢弃一定的流量(百分比)</span><br><span class="line"></span><br><span class="line">#####  随机丢弃请求流量</span><br><span class="line"></span><br><span class="line">input和output两端都支持限速,有两种限速算法:**百分比**或者**绝对值**</span><br><span class="line"></span><br><span class="line">* 百分比: input端支持缩小或者放大请求流量,基于指定的策略随机丢弃请求流量</span><br><span class="line">* 绝对值: 如果单位时间(秒)内达到临界值,则丢弃剩余请求流量,下一秒临界值还原</span><br><span class="line"></span><br><span class="line">**用法**:</span><br><span class="line"></span><br><span class="line">在output终端使用&quot;|&quot;运算符指定限速阈值,例如:</span><br><span class="line"></span><br><span class="line">* 使用绝对值限速</span><br></pre></td></tr></table></figure></p><h1 id="staging-server-will-not-get-more-than-ten-requests-per-second"><a href="#staging-server-will-not-get-more-than-ten-requests-per-second" class="headerlink" title="staging.server will not get more than ten requests per second"></a>staging.server will not get more than ten requests per second</h1><p>#staging服务每秒只接收10个请求<br>gor –input-tcp :28020 –output-http “<a href="http://staging.com|10&quot;" target="_blank" rel="noopener">http://staging.com|10&quot;</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 使用百分比限速</span><br></pre></td></tr></table></figure></p><h1 id="replay-server-will-not-get-more-than-10-of-requests"><a href="#replay-server-will-not-get-more-than-10-of-requests" class="headerlink" title="replay server will not get more than 10% of requests"></a>replay server will not get more than 10% of requests</h1><h1 id="useful-for-high-load-environments"><a href="#useful-for-high-load-environments" class="headerlink" title="useful for high-load environments"></a>useful for high-load environments</h1><p>gor –input-raw :80 –output-tcp “replay.local:28020|10%”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 基于Header或者URL参数限速</span><br><span class="line"></span><br><span class="line">如果header或者URL参数中有唯一值,例如(API key),则可以转发指定百分比的流量到后端,例如:</span><br></pre></td></tr></table></figure></p><h1 id="Limit-based-on-header-value"><a href="#Limit-based-on-header-value" class="headerlink" title="Limit based on header value"></a>Limit based on header value</h1><p>gor –input-raw :80 –output-tcp “replay.local:28020|10%” –http-header-limiter “X-API-KEY: 10%”</p><h1 id="Limit-based-on-URL-param-value"><a href="#Limit-based-on-URL-param-value" class="headerlink" title="Limit based on URL param value"></a>Limit based on URL param value</h1><p>gor –input-raw :80 –output-tcp “replay.local:28020|10%” –http-param-limiter “api_key: 10%”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">###  过滤</span><br><span class="line"></span><br><span class="line">如果只想捕获指定的URL路径请求,或者http头部,或者Http方法,则可以使用过滤功能</span><br><span class="line"></span><br><span class="line">下面是几个例子</span><br><span class="line"></span><br><span class="line">* 只捕获某个URL</span><br></pre></td></tr></table></figure></p><h1 id="only-forward-requests-being-sent-to-the-api-endpoint"><a href="#only-forward-requests-being-sent-to-the-api-endpoint" class="headerlink" title="only forward requests being sent to the /api endpoint"></a>only forward requests being sent to the /api endpoint</h1><p>gor –input-raw :8080 –output-http staging.com –http-allow-url /api<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 拒绝某个URL</span><br></pre></td></tr></table></figure></p><h1 id="only-forward-requests-NOT-being-sent-to-the-api…-endpoint"><a href="#only-forward-requests-NOT-being-sent-to-the-api…-endpoint" class="headerlink" title="only forward requests NOT being sent to the /api… endpoint"></a>only forward requests NOT being sent to the /api… endpoint</h1><p>gor –input-raw :8080 –output-http staging.com –http-disallow-url /api<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 基于正则表达式过滤头部</span><br></pre></td></tr></table></figure></p><h1 id="only-forward-requests-with-an-api-version-of-1-0x"><a href="#only-forward-requests-with-an-api-version-of-1-0x" class="headerlink" title="only forward requests with an api version of 1.0x"></a>only forward requests with an api version of 1.0x</h1><p>gor –input-raw :8080 –output-http staging.com –http-allow-header api-version:^1.0\d</p><h1 id="only-forward-requests-NOT-containing-User-Agent-header-value-“Replayed-by-Gor”"><a href="#only-forward-requests-NOT-containing-User-Agent-header-value-“Replayed-by-Gor”" class="headerlink" title="only forward requests NOT containing User-Agent header value “Replayed by Gor”"></a>only forward requests NOT containing User-Agent header value “Replayed by Gor”</h1><p>gor –input-raw :8080 –output-http staging.com –http-disallow-header “User-Agent: Replayed by Gor”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 过滤HTTP请求方法</span><br></pre></td></tr></table></figure></p><p>gor –input-raw :80 –output-http “<a href="http://staging.server&quot;" target="_blank" rel="noopener">http://staging.server&quot;</a> \<br>    –http-allow-method GET \<br>    –http-allow-method OPTIONS<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用goreplay收集线上真实http流量&quot;&gt;&lt;a href=&quot;#使用goreplay收集线上真实http流量&quot; class=&quot;headerlink&quot; title=&quot;使用goreplay收集线上真实http流量&quot;&gt;&lt;/a&gt;使用goreplay收集线上真实http流量&lt;/h2&gt;&lt;h3 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h3&gt;&lt;p&gt;在很多场景中,我们需要将线上服务器的真实Http请求复制转发到某台服务器中(或者测试环境中),并且前提是不影响线上生产业务进行.&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通常可能会通过ab等压测工具来对单一http接口进行压测。但如果是需要http服务整体压测，使用ab来压测工作量大且不方便，通过线上流量复制引流，通过将真实请求流量放大N倍来进行压测，能对服务有一个较为全面的检验.&lt;/li&gt;
&lt;li&gt;将线上流量引入到测试环境中,测试某个中间件或者数据库的压力&lt;/li&gt;
&lt;li&gt;上线前在预发布环境，使用线上真实的请求，检查是否准备发布的版本，是否具备发布标准&lt;/li&gt;
&lt;li&gt;用线上的流量转发到预发，检查相同流量下一些指标的反馈情况，检查核心数据是否有改善、优化.&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Linux-Web" scheme="https://jesse.top/categories/Linux-Web/"/>
    
    
      <category term="goreplay" scheme="https://jesse.top/tags/goreplay/"/>
    
  </entry>
  
  <entry>
    <title>docker学习笔记---docker使用阿里云私有仓库</title>
    <link href="https://jesse.top/2020/06/29/docker/docker%E5%AE%98%E7%BD%91%E5%AD%A6%E4%B9%A0%E2%80%943.%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E5%92%8C%E4%BB%93%E5%BA%93/"/>
    <id>https://jesse.top/2020/06/29/docker/docker官网学习—3.使用阿里云国内镜像和仓库/</id>
    <published>2020-06-29T03:59:58.000Z</published>
    <updated>2020-06-29T13:11:08.185Z</updated>
    
    <content type="html"><![CDATA[<h3 id="docker使用阿里云私有仓库"><a href="#docker使用阿里云私有仓库" class="headerlink" title="docker使用阿里云私有仓库"></a>docker使用阿里云私有仓库</h3><p>注册阿里云镜像服务:</p><p>以下是我的阿里云镜像仓库链接:<br><a href="https://cr.console.aliyun.com/cn-hangzhou/repositories" target="_blank" rel="noopener">https://cr.console.aliyun.com/cn-hangzhou/repositories</a></p><p>一.使用阿里云镜像加速器<br><a href="https://cr.console.aliyun.com/cn-hangzhou/mirrors" target="_blank" rel="noopener">https://cr.console.aliyun.com/cn-hangzhou/mirrors</a></p><p>镜像加速地址:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://0w5ygvsg.mirror.aliyuncs.com</span><br></pre></td></tr></table></figure><p>如果是Centos系统,可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&apos;EOF&apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://0w5ygvsg.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><hr><a id="more"></a><h4 id="使用阿里云的镜像仓库"><a href="#使用阿里云的镜像仓库" class="headerlink" title="使用阿里云的镜像仓库"></a>使用阿里云的镜像仓库</h4><p>首先在阿里云镜像服务控制台创建镜像仓库和命令空间:</p><p><a href="https://cr.console.aliyun.com/cn-hangzhou/repositories" target="_blank" rel="noopener">https://cr.console.aliyun.com/cn-hangzhou/repositories</a></p><p>我的镜像仓库和命名空间都是:jesse_images<br>这是我的镜像仓库地址:registry.cn-hangzhou.aliyuncs.com/jesse_images/jesse_images</p><p>下面演示,如何推送本地镜像到阿里云仓库</p><p>1.在本地docker服务器登陆阿里云镜像仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker_python]$docker login --username=jessehuang408 registry.cn-hangzhou.aliyuncs.com</span><br></pre></td></tr></table></figure><p>2.将本地镜像推送到仓库执行以下两条命令</p><ul><li>为本地镜像打个标签</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/jesse_images/jesse_images:[镜像版本号]</span><br></pre></td></tr></table></figure><ul><li>将镜像推送到仓库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push registry.cn-hangzhou.aliyuncs.com/jesse_images/jesse_images:[镜像版本号]</span><br></pre></td></tr></table></figure><p>下面演示将friendlyhello这个镜像推送到阿里云远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@localhost docker_python]$docker images</span><br><span class="line">REPOSITORY                                                    TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">friendlyhello                                                 latest              f091d1bb803c        43 minutes ago      131MB</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker tag f091d1bb803c registry.cn-hangzhou.aliyuncs.com/jesse_images/jesse_images:v2.0</span><br><span class="line"></span><br><span class="line">docker push registry.cn-hangzhou.aliyuncs.com/jesse_images/jesse_images:v2.0</span><br></pre></td></tr></table></figure><p>在本机可以看到镜像:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@localhost docker_python]$docker images</span><br><span class="line">REPOSITORY                                                    TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">friendlyhello                                                 latest              f091d1bb803c        43 minutes ago      131MB</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/jesse_images/jesse_images   v2.0                f091d1bb803c        43 minutes ago      131MB</span><br></pre></td></tr></table></figure><p>登陆阿里云的镜像服务控制台,在镜像仓库的管理界面可以看到上传上去的镜像</p><p>如果是从阿里云镜像仓库拉取镜像,执行以下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull registry.cn-hangzhou.aliyuncs.com/jesse_images/jesse_images:[镜像版本号]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;docker使用阿里云私有仓库&quot;&gt;&lt;a href=&quot;#docker使用阿里云私有仓库&quot; class=&quot;headerlink&quot; title=&quot;docker使用阿里云私有仓库&quot;&gt;&lt;/a&gt;docker使用阿里云私有仓库&lt;/h3&gt;&lt;p&gt;注册阿里云镜像服务:&lt;/p&gt;
&lt;p&gt;以下是我的阿里云镜像仓库链接:&lt;br&gt;&lt;a href=&quot;https://cr.console.aliyun.com/cn-hangzhou/repositories&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cr.console.aliyun.com/cn-hangzhou/repositories&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一.使用阿里云镜像加速器&lt;br&gt;&lt;a href=&quot;https://cr.console.aliyun.com/cn-hangzhou/mirrors&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cr.console.aliyun.com/cn-hangzhou/mirrors&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;镜像加速地址:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;https://0w5ygvsg.mirror.aliyuncs.com&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果是Centos系统,可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo mkdir -p /etc/docker&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo tee /etc/docker/daemon.json &amp;lt;&amp;lt;-&amp;apos;EOF&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;quot;registry-mirrors&amp;quot;: [&amp;quot;https://0w5ygvsg.mirror.aliyuncs.com&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;EOF&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo systemctl daemon-reload&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo systemctl restart docker&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="docker" scheme="https://jesse.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://jesse.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker学习笔记---docker网络之host,Container,None网络</title>
    <link href="https://jesse.top/2020/06/29/docker/docker%E5%AE%98%E7%BD%91%E5%AD%A6%E4%B9%A0-7.docker%E7%BD%91%E7%BB%9C%E4%B9%8Bhost,Container,None%E7%BD%91%E7%BB%9C/"/>
    <id>https://jesse.top/2020/06/29/docker/docker官网学习-7.docker网络之host,Container,None网络/</id>
    <published>2020-06-29T03:59:58.000Z</published>
    <updated>2020-06-29T13:14:06.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker官网学习-7-docker网络之host-Container-None网络"><a href="#docker官网学习-7-docker网络之host-Container-None网络" class="headerlink" title="docker官网学习-7.docker网络之host,Container,None网络"></a>docker官网学习-7.docker网络之host,Container,None网络</h2><h3 id="host网络介绍"><a href="#host网络介绍" class="headerlink" title="host网络介绍"></a>host网络介绍</h3><p>如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p><hr><h3 id="创建host网络"><a href="#创建host网络" class="headerlink" title="创建host网络"></a>创建host网络</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -tid --net=host --name busybox busybox1</span><br><span class="line"></span><br><span class="line">#host网络下的容器没有虚拟网卡,而是和宿主机共享网络</span><br><span class="line">[root@localhost ~]$docker exec  -it busybox1 ifconfig</span><br><span class="line">docker0   Link encap:Ethernet  HWaddr 02:42:89:26:D1:C9</span><br><span class="line">          inet addr:192.168.1.5  Bcast:192.168.1.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:1072032 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:1997027 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:61915874 (59.0 MiB)  TX bytes:1934238839 (1.8 GiB)</span><br></pre></td></tr></table></figure><blockquote><p>注:host网络只能工作在Linux主机上.</p><p>如果容器没有暴露任何端口,那host网络没有任何效果</p></blockquote><a id="more"></a><p>host网络示意图</p><p><img src="http://cdn.img2.a-site.cn/pic.php?url=aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXovUVAwQVk3dGRKblV4eFJNWjRRcDl0b21GaFFRMDNYVUVObjRZOVg0Q2tRRVZMV2dFZGt4MWljeThKY3VERXFhTGFZZUhiaDB1TWJZeVVtTjhQQ1l0bDl3LzA/d3hfZm10PXBuZw==" alt=""></p><hr><h3 id="Container网络介绍"><a href="#Container网络介绍" class="headerlink" title="Container网络介绍"></a>Container网络介绍</h3><p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p><p>Container网络示意图</p><p><img src="http://cdn.img2.a-site.cn/pic.php?url=aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXovUVAwQVk3dGRKblV4eFJNWjRRcDl0b21GaFFRMDNYVUVtaWM5elRoU1d1UmdSc2xVT2oyeHpmeUljZXdpY2E3VkpibE03Nnc5N01PZFRLVEl2TkdpYTBPd2cvMD93eF9mbXQ9cG5n" alt=""></p><hr><h3 id="None网络"><a href="#None网络" class="headerlink" title="None网络"></a>None网络</h3><p>使用none模式，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。</p><p>Node模式示意图:</p><p><img src="http://cdn.img2.a-site.cn/pic.php?url=aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXovUVAwQVk3dGRKblV4eFJNWjRRcDl0b21GaFFRMDNYVUVMeFREaWNxUVFYQ0dObVlUNFlRdVdQYkxBRk1TVmhvRFlrcUtENFVLczVXbWtqbTM1THNpY1FZUS8wP3d4X2ZtdD1wbmc=" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;docker官网学习-7-docker网络之host-Container-None网络&quot;&gt;&lt;a href=&quot;#docker官网学习-7-docker网络之host-Container-None网络&quot; class=&quot;headerlink&quot; title=&quot;docker官网学习-7.docker网络之host,Container,None网络&quot;&gt;&lt;/a&gt;docker官网学习-7.docker网络之host,Container,None网络&lt;/h2&gt;&lt;h3 id=&quot;host网络介绍&quot;&gt;&lt;a href=&quot;#host网络介绍&quot; class=&quot;headerlink&quot; title=&quot;host网络介绍&quot;&gt;&lt;/a&gt;host网络介绍&lt;/h3&gt;&lt;p&gt;如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;创建host网络&quot;&gt;&lt;a href=&quot;#创建host网络&quot; class=&quot;headerlink&quot; title=&quot;创建host网络&quot;&gt;&lt;/a&gt;创建host网络&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker run -tid --net=host --name busybox busybox1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#host网络下的容器没有虚拟网卡,而是和宿主机共享网络&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[root@localhost ~]$docker exec  -it busybox1 ifconfig&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker0   Link encap:Ethernet  HWaddr 02:42:89:26:D1:C9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          inet addr:192.168.1.5  Bcast:192.168.1.255  Mask:255.255.255.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          RX packets:1072032 errors:0 dropped:0 overruns:0 frame:0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          TX packets:1997027 errors:0 dropped:0 overruns:0 carrier:0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          collisions:0 txqueuelen:0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          RX bytes:61915874 (59.0 MiB)  TX bytes:1934238839 (1.8 GiB)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;注:host网络只能工作在Linux主机上.&lt;/p&gt;
&lt;p&gt;如果容器没有暴露任何端口,那host网络没有任何效果&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="docker" scheme="https://jesse.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://jesse.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker学习笔记---学习Docker Stack</title>
    <link href="https://jesse.top/2020/06/29/docker/docker%E5%AE%98%E7%BD%91%E5%AD%A6%E4%B9%A0-6.%E5%AD%A6%E4%B9%A0stack/"/>
    <id>https://jesse.top/2020/06/29/docker/docker官网学习-6.学习stack/</id>
    <published>2020-06-29T03:59:58.000Z</published>
    <updated>2020-06-29T13:12:58.803Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习Docker-Stack"><a href="#学习Docker-Stack" class="headerlink" title="学习Docker Stack"></a>学习Docker Stack</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>一个stack是一组共享依赖包的多个相关的services,并且可以编排和扩展.其实从第4小节开始,在利用compose文件部署app时,就已经开始一直使用stack.但是还只是运行在一个单一服务器的单一service.<br>现在,你可以学习在多个服务器上,运行多个相关的services.</p><hr><ul><li>使用下面的docker-compose.yml文件替换第4小节中的docker-compose.yml</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    # replace username/repo:tag with your name and image details</span><br><span class="line">    image: ianch/friendlyhello:v1</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 5</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &quot;0.1&quot;</span><br><span class="line">          memory: 50M</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;4000:80&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">  Visualizer:</span><br><span class="line">    image: dockersamples/visualizer:stable</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br></pre></td></tr></table></figure><a id="more"></a><p>docker-compose文件稍微做了点改动.添加一个Visualizer服务,placement指令确保这个Visualizer服务仅仅运行在swarm manager节点.</p><hr><h4 id="部署compose文件"><a href="#部署compose文件" class="headerlink" title="部署compose文件"></a>部署compose文件</h4><ul><li>初始化swarm</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init</span><br></pre></td></tr></table></figure><ul><li>第二台服务器加入swarm集群</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@php compose]$docker swarm join --token SWMTKN-1-5qr6e90o52h5licxatuvmft65kji5qf1roujebf16auoe5xgam-3d0fuzr8818r6330n88dm1fcu 10.0.0.50:2377</span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure><ul><li>部署app</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost compose]$docker stack deploy -c docker-compose.yml getstartedlab</span><br><span class="line">Creating network getstartedlab_webnet</span><br><span class="line">Creating service getstartedlab_web</span><br><span class="line">Creating service getstartedlab_Visualizer</span><br><span class="line">[root@localhost compose]$</span><br></pre></td></tr></table></figure><blockquote><p>添加了2个服务.web和Visualizer</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost compose]$docker stack ps getstartedlab</span><br><span class="line">ID                  NAME                         IMAGE                             NODE                    DESIRED STATE       CURRENT STATE                ERROR               PORTS</span><br><span class="line">ds77cn4hgd9w        getstartedlab_web.1          friendlyhello:latest              php                     Running             Running about a minute ago</span><br><span class="line">agzj3veqno63        getstartedlab_Visualizer.1   dockersamples/visualizer:stable   localhost.localdomain   Running             Running about a minute ago</span><br><span class="line">3hq0if79g3gk        getstartedlab_web.2          friendlyhello:latest              php                     Running             Running about a minute ago</span><br><span class="line">iuxh7qjfpikw        getstartedlab_web.3          friendlyhello:latest              localhost.localdomain   Running             Running 53 seconds ago</span><br><span class="line">ba9hcq5zmlbd        getstartedlab_web.4          friendlyhello:latest              php                     Running             Running about a minute ago</span><br><span class="line">o600yqmqets7        getstartedlab_web.5          friendlyhello:latest              localhost.localdomain   Running             Running 55 seconds ago</span><br><span class="line">[root@localhost compose]$</span><br></pre></td></tr></table></figure><p>访问任意一台服务器的8080端口,可以看到Visualizer服务正在运行</p><p><img src="https://docs.docker.com/get-started/images/get-started-visualizer1.png" alt=""></p><blockquote><p>这是我借用的官网的图片.</p></blockquote><p>可以看到,visualizer运行在swarm manager节点上,5个web服务运行在swarm集群上.visualizer是一个不需要任何依赖,而可以运行在任何app的独立服务.现在尝试一下创建一个具有依赖项的服务:提供访问计数器的Redis服务</p><hr><h3 id="编辑docker-compose文件"><a href="#编辑docker-compose文件" class="headerlink" title="编辑docker-compose文件"></a>编辑docker-compose文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    # replace username/repo:tag with your name and image details</span><br><span class="line">    image: ianch/friendlyhello:v1</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 5</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &quot;0.1&quot;</span><br><span class="line">          memory: 50M</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;4000:80&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">  Visualizer:</span><br><span class="line">    image: dockersamples/visualizer:stable</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6379:6379&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/home/docker/data:/data&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line">    command: redis-server --appendonly yes</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br></pre></td></tr></table></figure><p> 这里我们添加了一个redis服务.在Docker HUB上有redis官方镜像,并且已经暴露了6379端口.所以这里只需要指定redis镜像即可..同样redis也只运行在manager节点服务器.</p><p> 这里为了持久化数据,在启动redis容器的时候指定了appendonly参数,并且挂载了本机的/home/docker/data目录映射到容器的/data.(redis容器默认保存数据路径)</p><ul><li>在manager节点创建/home/docker/data目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost compose]$mkdir -pv /home/docker/data</span><br><span class="line">mkdir: 已创建目录 &quot;/home/docker&quot;</span><br><span class="line">mkdir: 已创建目录 &quot;/home/docker/data&quot;</span><br></pre></td></tr></table></figure><ul><li>部署compose</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost compose]$docker stack deploy -c docker-compose.yml getstartedlab</span><br><span class="line">Updating service getstartedlab_web (id: mtgafxttekwfh0tkhkaespa1v)</span><br><span class="line">image friendlyhello:latest could not be accessed on a registry to record</span><br><span class="line">its digest. Each node will access friendlyhello:latest independently,</span><br><span class="line">possibly leading to different nodes running different</span><br><span class="line">versions of the image.</span><br><span class="line"></span><br><span class="line">Updating service getstartedlab_Visualizer (id: zmim1kj44afsr9xay8ppxker6)</span><br><span class="line">Creating service getstartedlab_redis</span><br></pre></td></tr></table></figure><p>可以看到3个services都启动起来了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost compose]$docker service ls</span><br><span class="line">ID                  NAME                       MODE                REPLICAS            IMAGE                             PORTS</span><br><span class="line">zmim1kj44afs        getstartedlab_Visualizer   replicated          1/1                 dockersamples/visualizer:stable   *:8080-&gt;8080/tcp</span><br><span class="line">elomaiu5go9p        getstartedlab_redis        replicated          1/1                 redis:latest                      *:6379-&gt;6379/tcp</span><br><span class="line">mtgafxttekwf        getstartedlab_web          replicated          5/5                 friendlyhello:latest              *:4000-&gt;80/tcp</span><br></pre></td></tr></table></figure><p>在浏览器访问服务器的4000端口可以看到有一个访问计数器在增加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> huangyong@huangyong-Macbook-Pro  ~  curl http://10.0.0.50:4000</span><br><span class="line">&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; eed56ca4164b&lt;br/&gt;&lt;b&gt;Visits:&lt;/b&gt; 5%                                                                                                           huangyong@huangyong-Macbook-Pro  ~  curl http://10.0.0.50:4000</span><br><span class="line">&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; 777d2cab6468&lt;br/&gt;&lt;b&gt;Visits:&lt;/b&gt; 6%                                                                                                           huangyong@huangyong-Macbook-Pro  ~  curl http://10.0.0.50:4000</span><br><span class="line">&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; 213e6a729c6a&lt;br/&gt;&lt;b&gt;Visits:&lt;/b&gt; 7%                                                                                                           huangyong@huangyong-Macbook-Pro  ~  curl http://10.0.0.50:4000</span><br><span class="line">&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; 85ccc6b1cb18&lt;br/&gt;&lt;b&gt;Visits:&lt;/b&gt; 8%                                                                                                           huangyong@huangyong-Macbook-Pro  ~ </span><br></pre></td></tr></table></figure><p>访问另外一台服务器也可以看到同样结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> huangyong@huangyong-Macbook-Pro  ~  curl http://10.0.0.12:4000</span><br><span class="line">&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; e77e36db18be&lt;br/&gt;&lt;b&gt;Visits:&lt;/b&gt; 10%                                                                                                          huangyong@huangyong-Macbook-Pro  ~  curl http://10.0.0.50:4000</span><br><span class="line">&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; eed56ca4164b&lt;br/&gt;&lt;b&gt;Visits:&lt;/b&gt; 11%                                                                                                          huangyong@huangyong-Macbook-Pro  ~  curl http://10.0.0.12:4000</span><br><span class="line">&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; eed56ca4164b&lt;br/&gt;&lt;b&gt;Visits:&lt;/b&gt; 12%</span><br></pre></td></tr></table></figure><p>访问visulizer容器的8080端口,可以看到redis服务运行</p><p><img src="https://docs.docker.com/get-started/images/visualizer-with-redis.png" alt=""></p><hr><h3 id="管理命令"><a href="#管理命令" class="headerlink" title="管理命令"></a>管理命令</h3><p>使用docker node ls 列出swarm集群的所有节点<br>使用docker service ls 列出所有服务<br>docker service ps &lt;service_name&gt; 列出某个服务的所有tasks</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$docker node ls</span><br><span class="line">ID                            HOSTNAME                STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION</span><br><span class="line">056r5hr2xb6jjzmbw64m3btd2 *   localhost.localdomain   Ready               Active              Leader              18.09.2</span><br><span class="line">r58bkpsxgi4mjaxrn8octuxw1     php                     Ready               Active                                  18.09.3</span><br><span class="line">[root@localhost ~]$docker service ls</span><br><span class="line">ID                  NAME                       MODE                REPLICAS            IMAGE                             PORTS</span><br><span class="line">zmim1kj44afs        getstartedlab_Visualizer   replicated          1/1                 dockersamples/visualizer:stable   *:8080-&gt;8080/tcp</span><br><span class="line">elomaiu5go9p        getstartedlab_redis        replicated          1/1                 redis:latest                      *:6379-&gt;6379/tcp</span><br><span class="line">mtgafxttekwf        getstartedlab_web          replicated          5/5                 friendlyhello:latest              *:4000-&gt;80/tcp</span><br><span class="line"></span><br><span class="line">[root@localhost ~]$docker service ps getstartedlab_web</span><br><span class="line">ID                  NAME                  IMAGE                  NODE                    DESIRED STATE       CURRENT STATE          ERROR               PORTS</span><br><span class="line">ds77cn4hgd9w        getstartedlab_web.1   friendlyhello:latest   php                     Running             Running 14 hours ago</span><br><span class="line">3hq0if79g3gk        getstartedlab_web.2   friendlyhello:latest   php                     Running             Running 14 hours ago</span><br><span class="line">iuxh7qjfpikw        getstartedlab_web.3   friendlyhello:latest   localhost.localdomain   Running             Running 14 hours ago</span><br><span class="line">ba9hcq5zmlbd        getstartedlab_web.4   friendlyhello:latest   php                     Running             Running 14 hours ago</span><br><span class="line">o600yqmqets7        getstartedlab_web.5   friendlyhello:latest   localhost.localdomain   Running             Running 14 hours ago</span><br><span class="line">[root@localhost ~]$</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;学习Docker-Stack&quot;&gt;&lt;a href=&quot;#学习Docker-Stack&quot; class=&quot;headerlink&quot; title=&quot;学习Docker Stack&quot;&gt;&lt;/a&gt;学习Docker Stack&lt;/h2&gt;&lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;&lt;p&gt;一个stack是一组共享依赖包的多个相关的services,并且可以编排和扩展.其实从第4小节开始,在利用compose文件部署app时,就已经开始一直使用stack.但是还只是运行在一个单一服务器的单一service.&lt;br&gt;现在,你可以学习在多个服务器上,运行多个相关的services.&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;使用下面的docker-compose.yml文件替换第4小节中的docker-compose.yml&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;version: &amp;quot;3&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;services:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  web:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    # replace username/repo:tag with your name and image details&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    image: ianch/friendlyhello:v1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    deploy:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      replicas: 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      resources:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        limits:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          cpus: &amp;quot;0.1&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          memory: 50M&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      restart_policy:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        condition: on-failure&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ports:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      - &amp;quot;4000:80&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    networks:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      - webnet&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Visualizer:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    image: dockersamples/visualizer:stable&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ports:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      - &amp;quot;8080:8080&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    volumes:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      - &amp;quot;/var/run/docker.sock:/var/run/docker.sock&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    deploy:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      placement:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        constraints: [node.role == manager]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    networks:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      - webnet&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;networks:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  webnet:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="docker" scheme="https://jesse.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://jesse.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker学习笔记---Docker存储驱动篇</title>
    <link href="https://jesse.top/2020/06/29/docker/docker%E7%AC%94%E8%AE%B0%E2%80%94%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8%E7%AF%87/"/>
    <id>https://jesse.top/2020/06/29/docker/docker笔记—存储驱动篇/</id>
    <published>2020-06-29T03:59:58.000Z</published>
    <updated>2020-06-29T13:42:46.456Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker笔记——存储驱动篇"><a href="#docker笔记——存储驱动篇" class="headerlink" title="docker笔记——存储驱动篇"></a>docker笔记——存储驱动篇</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>通过前一篇的镜像笔记,我们知道docker的镜像是只读的,而且通过同一个镜像启动的docker容器,他们共享同一份底层镜像文件.</p><p>这里主要说一说.这些分层的多个只读Image镜像是如何在磁盘中存储的.</p><hr><h3 id="docker存储驱动"><a href="#docker存储驱动" class="headerlink" title="docker存储驱动"></a>docker存储驱动</h3><p>docker提供了多种存储驱动来实现不同的方式存储镜像，下面是常用的几种存储驱动：</p><ul><li>AUFS</li><li>OverlayFS</li><li>Devicemapper</li><li>Btrfs</li><li>ZFS</li></ul><p>下面说一说AUFS、OberlayFS及Devicemapper，更多的存储驱动说明可参考：<a href="http://dockone.io/article/1513" target="_blank" rel="noopener">http://dockone.io/article/1513</a></p><a id="more"></a><h4 id="AUFS"><a href="#AUFS" class="headerlink" title="AUFS"></a>AUFS</h4><p>AUFS（AnotherUnionFS）是一种Union FS，是文件级的存储驱动。AUFS是一个能透明覆盖一个或多个现有文件系统的层状文件系统，把多层合并成文件系统的单层表示。简单来说就是支持将不同目录挂载到同一个虚拟文件系统下的文件系统。这种文件系统可以一层一层地叠加修改文件。无论底下有多少层都是只读的，只有最上层的文件系统是可写的。当需要修改一个文件时，AUFS创建该文件的一个副本，使用CoW(写时复制)将文件从只读层复制到可写层进行修改，结果也保存在可写层。</p><p>通常来说最上层是可读写层,下层是只读层.当需要读取一个文件A时,会从最顶层的读写层开始向下寻找.本层没有则根据层关系到下一层开始找.直到找到第一个文件A</p><p>当需要写入一个文件A时,如果这个文件不存在,则在读写层新建一个.否则会像上面的步骤一样从顶层开始寻找,找到A文件后,复制到读写层进行修改</p><p>当需要删除一个文件A时,如果这个文件仅仅存在读写层,则直接删除.否则就需要先在读写层删除,然后再在读写层创建一个whiteout文件来标志这个文件不存在,而不是真正删除底层文件.</p><p>当新建一个文件A.如果这个文件在读写层存在对应的whiteout文件,则先将whiteout文件删除再新建.否则直接读写层新建</p><p>在Docker中，底下的只读层就是image，可写层就是Container。结构如下图所示：</p><p><img src="https://img1.jesse.top/docker-aufs.jpg" alt=""></p><p>如果你正在使用aufs作为存储驱动,那么在Docker的工作目录(/var/lib/docker)和image下发现aufs目录:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">root@docker:~# tree /var/lib/docker -d -L 1</span><br><span class="line">/var/lib/docker</span><br><span class="line">├── aufs</span><br><span class="line">├── containers</span><br><span class="line">├── image</span><br><span class="line">├── network</span><br><span class="line">├── plugins</span><br><span class="line">├── swarm</span><br><span class="line">├── tmp</span><br><span class="line">├── trust</span><br><span class="line">└── volumes</span><br><span class="line"></span><br><span class="line">root@docker:~# tree /var/lib/docker/image -d -L 1</span><br><span class="line">/var/lib/docker/image</span><br><span class="line">└── aufs</span><br><span class="line"></span><br><span class="line">root@docker:~# tree /var/lib/docker/aufs/ -d -L 1</span><br><span class="line">/var/lib/docker/aufs/</span><br><span class="line">├── diff</span><br><span class="line">├── layers</span><br><span class="line">└── mnt</span><br></pre></td></tr></table></figure><p>在docker工作目录的aufs目录下有3个目录.其中mnt为aufs的挂载目录,diff为实际数据,包括只读层和读写层.layers为每层依赖有关的层描述文件</p><hr><h3 id="Device-mapper"><a href="#Device-mapper" class="headerlink" title="Device mapper"></a>Device mapper</h3><p>Device mapper是Linux内核2.6.9后支持的，提供的一种从逻辑设备到物理设备的映射框架机制，在该机制下，用户可以很方便的根据自己的需要制定实现存储资源的管理策略。前面讲的AUFS和OverlayFS都是文件级存储，而Device mapper是块级存储，所有的操作都是直接对块进行操作，而不是文件。</p><p>Device mapper驱动会先在块设备上创建一个资源池，然后在资源池上创建一个带有文件系统的基本设备，所有镜像都是这个基本设备的快照，而容器则是镜像的快照。所以在容器里看到文件系统是资源池上基本设备的文件系统的快照，并不有为容器分配空间。当要写入一个新文件时，在容器的镜像内为其分配新的块并写入数据，这个叫用时分配。</p><p>当要修改已有文件时，再使用CoW为容器快照分配块空间，将要修改的数据复制到在容器快照中新的块里再进行修改。Device mapper 驱动默认会创建一个100G的文件包含镜像和容器。每一个容器被限制在10G大小的卷内，可以自己配置调整。结构如下图所示：</p><p><img src="https://img1.jesse.top/docker-devicemapper.jpg" alt=""></p><p>在Centos 7发行版上最新版的docker中,默认的存储驱动就是device mapper.但是提示已经被弃用了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$docker info</span><br><span class="line">Containers: 3</span><br><span class="line"> Running: 3</span><br><span class="line"> Paused: 0</span><br><span class="line"> Stopped: 0</span><br><span class="line">Images: 138</span><br><span class="line">Server Version: 18.09.2</span><br><span class="line">Storage Driver: devicemapper #这一行</span><br><span class="line">......略......</span><br><span class="line">WARNING: the devicemapper storage-driver is deprecated, and will be removed in a future release. #最后这一行提示devicemapper已经被弃用</span><br></pre></td></tr></table></figure><p>和aufs一样,在docker的工作目录下也能看到device mapper目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ll /var/lib/docker/devicemapper/</span><br><span class="line">总用量 32</span><br><span class="line">drwx------ 2 root root    32 2月  23 16:25 devicemapper</span><br><span class="line">drwx------ 2 root root 24576 5月  16 10:30 metadata</span><br><span class="line">drwxr-xr-x 5 root root  4096 5月  16 10:30 mnt</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;docker笔记——存储驱动篇&quot;&gt;&lt;a href=&quot;#docker笔记——存储驱动篇&quot; class=&quot;headerlink&quot; title=&quot;docker笔记——存储驱动篇&quot;&gt;&lt;/a&gt;docker笔记——存储驱动篇&lt;/h2&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;通过前一篇的镜像笔记,我们知道docker的镜像是只读的,而且通过同一个镜像启动的docker容器,他们共享同一份底层镜像文件.&lt;/p&gt;
&lt;p&gt;这里主要说一说.这些分层的多个只读Image镜像是如何在磁盘中存储的.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;docker存储驱动&quot;&gt;&lt;a href=&quot;#docker存储驱动&quot; class=&quot;headerlink&quot; title=&quot;docker存储驱动&quot;&gt;&lt;/a&gt;docker存储驱动&lt;/h3&gt;&lt;p&gt;docker提供了多种存储驱动来实现不同的方式存储镜像，下面是常用的几种存储驱动：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AUFS&lt;/li&gt;
&lt;li&gt;OverlayFS&lt;/li&gt;
&lt;li&gt;Devicemapper&lt;/li&gt;
&lt;li&gt;Btrfs&lt;/li&gt;
&lt;li&gt;ZFS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面说一说AUFS、OberlayFS及Devicemapper，更多的存储驱动说明可参考：&lt;a href=&quot;http://dockone.io/article/1513&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://dockone.io/article/1513&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="https://jesse.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://jesse.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker学习笔记---docker容器篇</title>
    <link href="https://jesse.top/2020/06/29/docker/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%AE%B9%E5%99%A8%E7%AF%87/"/>
    <id>https://jesse.top/2020/06/29/docker/docker学习笔记—容器篇/</id>
    <published>2020-06-29T03:59:58.000Z</published>
    <updated>2020-06-29T14:28:34.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker学习笔记—-docker容器篇"><a href="#docker学习笔记—-docker容器篇" class="headerlink" title="docker学习笔记— docker容器篇"></a>docker学习笔记— docker容器篇</h2><p><strong>一.创建并启动容器</strong></p><ul><li><strong>创建容器</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create -it 镜像名:tag</span><br></pre></td></tr></table></figure><ul><li><strong>查看所有容器</strong>(包括运行中,已退出,错误容器)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><ul><li>查看所有容器的ID</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -qa</span><br></pre></td></tr></table></figure><ul><li><strong>启动容器</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start container_id</span><br></pre></td></tr></table></figure><ul><li><strong>使用指定的镜像直接创建并启动容器</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -it 镜像名:标签 COMMAND</span><br><span class="line"></span><br><span class="line">jesse@jesse-virtual-machine:~$ docker run -it ubuntu:16.04 /bin/bash</span><br><span class="line">root@66a29f973548:/#   ----------此时已经进入到容器的bash环境</span><br></pre></td></tr></table></figure><a id="more"></a><p>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p><p>1.检查本地是否存在指定的镜像，不存在就从公有仓库下载</p><p>2.利用镜像创建并启动一个容器</p><p>3.分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</p><p>4.从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</p><p>5.从地址池配置一个 ip 地址给容器</p><p>6.执行用户指定的应用程序</p><p>7.执行完毕后容器被终止</p><ul><li><strong>以守护状态运行:</strong></li></ul><p>以守护态运行（加参数-d):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d registry.intra.weibo.com/yushuang3/centos:v1 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br></pre></td></tr></table></figure><ul><li><strong>容器终止:</strong></li></ul><p><strong>获取容器输出的信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs container_id</span><br></pre></td></tr></table></figure><p><strong>停止容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop container_Id</span><br></pre></td></tr></table></figure><blockquote><p>终止一个容器  加入-t=10 表示等待10秒(不加-t选项则默认就是10秒)再次发送SIGKILL信号终止容器</p></blockquote><p><strong>重启容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart container_id</span><br></pre></td></tr></table></figure><p><strong>容器状态:</strong></p><ul><li><strong>status表示容器的状态..</strong></li></ul><ul><li><strong>exited 表示容器已经退出</strong></li><li><strong>up 表示容器正在运行</strong></li></ul><p>docker run启动容器时还可以指定其他的配置参数:</p><ul><li>-h HOSTNAME 或者 –hostname=HOSTNAME.设置容器的主机名</li><li>–dns=IP_ADDRESS:设置容器的DNS.写在容器的/etc/resolv.conf文件中.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]$docker run -itd --name busybox1 -h dwd-busybox --dns=8.8.8.8 busybox</span><br><span class="line">c25dac9c641705e00f02aefe302987f39f853a1feb8c0d3f32dc1675747edd84</span><br><span class="line"></span><br><span class="line">[root@localhost test]$docker exec -it busybox1 hostname</span><br><span class="line">dwd-busybox</span><br><span class="line"></span><br><span class="line">[root@localhost test]$docker exec -it busybox1 cat /etc/resolv.conf</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure><p>但是需要注意的是.这些修改不会被 docker commit保存,也就是不会保存在镜像中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#将busybox1容器保存为busybox1:test镜像</span><br><span class="line">[root@localhost test]$docker commit -m &apos;test&apos; -a &apos;jesse&apos; busybox1 busybox1:test</span><br><span class="line">sha256:3c8faee532f177cf8bb8736db89694c2c3ff5be1a30a15d604e450130909d123</span><br><span class="line"></span><br><span class="line">#用这个镜像,启动一个新的busybox1-test的容器</span><br><span class="line">[root@localhost test]$docker run --name busybox1-test -itd busybox1:test</span><br><span class="line">9326b615e9e3af64336683f7f82e048929de560d4ad0a5caf2485bbc4a62e18c</span><br><span class="line"></span><br><span class="line">#可以看到hostname和dns信息没有被保留</span><br><span class="line">[root@localhost test]$docker exec -it busybox1-test hostname</span><br><span class="line">9326b615e9e3</span><br><span class="line"></span><br><span class="line">[root@localhost test]$docker exec -it busybox1-test cat /etc/resolv.conf</span><br><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 114.114.115.115</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;docker学习笔记—-docker容器篇&quot;&gt;&lt;a href=&quot;#docker学习笔记—-docker容器篇&quot; class=&quot;headerlink&quot; title=&quot;docker学习笔记— docker容器篇&quot;&gt;&lt;/a&gt;docker学习笔记— docker容器篇&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;一.创建并启动容器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建容器&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker create -it 镜像名:tag&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;查看所有容器&lt;/strong&gt;(包括运行中,已退出,错误容器)&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker ps -a&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;查看所有容器的ID&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker ps -qa&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;启动容器&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker start container_id&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用指定的镜像直接创建并启动容器&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker run -it 镜像名:标签 COMMAND&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;jesse@jesse-virtual-machine:~$ docker run -it ubuntu:16.04 /bin/bash&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;root@66a29f973548:/#   ----------此时已经进入到容器的bash环境&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="docker" scheme="https://jesse.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://jesse.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker学习笔记---Dockerfile</title>
    <link href="https://jesse.top/2020/06/29/docker/docker%E5%AE%98%E7%BD%91%E5%AD%A6%E4%B9%A0%E2%80%942.dockerfile/"/>
    <id>https://jesse.top/2020/06/29/docker/docker官网学习—2.dockerfile/</id>
    <published>2020-06-29T03:59:58.000Z</published>
    <updated>2020-06-30T12:32:51.210Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>Dockerfile可以用来编译一个docker镜像.Dockerfile是一个包含一系列指令的文本文档,使用<code>docker build</code>命令,用户可以依据dockerfile和上下文编译一个镜像.</p><p>使用dockerfile需要注意一些事项</p><p><strong>1.上下文</strong></p><p>docker build编译镜像时,会将当前目录下的Dockerfile和所有文件打包添加发送到docker daemon服务端.所以一般情况下创建一个空目录编辑dockerfile文件.然后将需要copy和add的文件放进和dockerfile同一目录下.</p><p>dockerfile中的<code>copy</code>以及<code>add</code>命令,添加文件到docker镜像中时.不要使用绝对路径.例如/home/work/a.txt..docker deamon只能识别到当前上下文环境,无法识别到其他目录.但是可以使用当前上下文的相对路径.</p><p><strong>2.分层</strong></p><p>dockerfile编译镜像时,每条指令都是一个镜像层.除了From指令外,每一行指令都是基于上一行生成的临时镜像运行一个容器.执行一条指令就类似于docker commit命令生成一个新的镜像.所以两条指令之间互不关联.</p><a id="more"></a><p>例如,下列的dockerfile并不能在/data/目录下创建files文件.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">RUN mkdir /data</span><br><span class="line">RUN cd /data</span><br><span class="line">RUN touch files</span><br></pre></td></tr></table></figure><p>下列的dockerfile甚至不会创建/data/file文件,也不会修改/data/目录权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">RUN useradd foo</span><br><span class="line">VOLUME /data</span><br><span class="line">RUN touch /data/file</span><br><span class="line">RUN chown -R foo:foo /data</span><br></pre></td></tr></table></figure></p><p>想要实现这个需求,可以这样写:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">RUN useradd foo</span><br><span class="line">RUN mkdir /data &amp;&amp; touch /data/file</span><br><span class="line">RUN chown -R foo:foo /data</span><br><span class="line">VOLUME /data</span><br></pre></td></tr></table></figure><hr><p><strong>3.精简</strong></p><p>由于dockerfile在构建镜像时,dockerfile文本中每一行语句会产生每一层镜像.</p><p>例如下面这个dockerfile:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">From ubuntu</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get -y install vim git wget net-tools</span><br><span class="line">RUN useradd foo</span><br><span class="line">RUN mkdir /data</span><br><span class="line">RUN touch /data/file</span><br><span class="line">RUN chown -R foo:foo /data</span><br></pre></td></tr></table></figure><p>在编译时,每一个RUN语句都会构建一层镜像.(实际上所有指令都是这样,不仅仅是RUN)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]$docker build -t test:v1 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/7 : From ubuntu</span><br><span class="line"> ---&gt; 94e814e2efa8</span><br><span class="line">Step 2/7 : RUN apt-get update</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 5520126e7fcc</span><br><span class="line">Step 3/7 : RUN apt-get -y install vim git wget net-tools</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; cb24e170539c</span><br><span class="line">Step 4/7 : RUN useradd foo</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; ca31aeba0309</span><br><span class="line">Step 5/7 : RUN mkdir /data</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; d5c6e0f32f6b</span><br><span class="line">Step 6/7 : RUN touch /data/file</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 9c4b06e9b25d</span><br><span class="line">Step 7/7 : RUN chown -R foo:foo /data</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 75ecea0b0795</span><br><span class="line">Successfully built 75ecea0b0795</span><br><span class="line">Successfully tagged test:v1</span><br></pre></td></tr></table></figure><p>这种写法会导致镜像层非常多,镜像文件也会相对较大.所以一般推荐更精简的语法,每一条功能相同的语句,尽量写在一行.上面的dockerfile可以优化成:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">From ubuntu</span><br><span class="line">RUN apt-get update \</span><br><span class="line">    &amp;&amp; apt-get -y install \</span><br><span class="line">       vim \</span><br><span class="line">       git \</span><br><span class="line">       wget \</span><br><span class="line">       net-tools</span><br><span class="line"></span><br><span class="line">RUN useradd foo</span><br><span class="line">RUN mkdir /data &amp;&amp;  touch /data/file &amp;&amp;  chown -R foo:foo /data</span><br></pre></td></tr></table></figure><p>这次编译只需构建4层镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]$docker build -t test:v1 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/4 : From ubuntu</span><br><span class="line"> ---&gt; 94e814e2efa8</span><br><span class="line">Step 2/4 : RUN apt-get update     &amp;&amp; apt-get -y install        vim        git        wget        net-tools</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 7aa2bc9041e0</span><br><span class="line">Step 3/4 : RUN useradd foo</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 5a13764414e6</span><br><span class="line">Step 4/4 : RUN mkdir /data &amp;&amp;  touch /data/file &amp;&amp;  chown -R foo:foo /data</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; bd61817d7526</span><br><span class="line">Successfully built bd61817d7526</span><br><span class="line">Successfully tagged test:v1</span><br></pre></td></tr></table></figure><p>4.使用<code>no-install-recommends</code></p><p>如果是使用APT包管理器,则应该在执行apt-get install 命令时加上<code>no-install-recommends`</code>参数.这样ATP就仅安装核心依赖.而不安装其他推荐和建议的包,这会显著减少不必要包的下载数量</p><hr><h3 id="Dockerfile指令介绍"><a href="#Dockerfile指令介绍" class="headerlink" title="Dockerfile指令介绍"></a>Dockerfile指令介绍</h3><p>介绍完Dockerfile的概念和特点后,接下来了解一下Dockerfile语法中的具体指令的介绍和用法</p><p>下面是一个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Use an official Python runtime as a parent image</span><br><span class="line">FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line"># Set the working directory to /app</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># Copy the current directory contents into the container at /app</span><br><span class="line">COPY . /app</span><br><span class="line"></span><br><span class="line"># Install any needed packages specified in requirements.txt</span><br><span class="line">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class="line"></span><br><span class="line"># Make port 80 available to the world outside this container</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"># Define environment variable</span><br><span class="line">ENV NAME World</span><br><span class="line"></span><br><span class="line"># Run app.py when the container launches</span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure><hr><ul><li>FROM </li></ul><p>格式: <code>FROM image</code> 或者 <code>FROM image:tag</code></p><p>表示从一个基础镜像构建.Dockerfile必须以FROM语句作为第一条非注释语句.</p><ul><li><p>WORKDIR: 表示工作目录,后续的相对路径也是基于这个目录</p></li><li><p>COPY</p></li></ul><p>格式: <code>copy src dest</code></p><p>复制宿主机上的文件到镜像中.src是当前上下文中的文件或者目录.dest是容器中的目标文件或者目录.src指定的源可以有多个.此外 src还支持通配符.例如: <code>COPY hom* /mydir/</code> 表示添加所有当前目录下的hom开头的文件到目录/mydir/下</p><p><dest>可以是文件或者目录.但是必须是镜像中的绝对路径,或者是WORKDIR的相对路径.若<dest>以反斜杠/结尾,则指向的是目录,否则指向文件.当 src 有多个源时, dest必须是目录.如果 dest 目录不存在,则会自动被创建</dest></dest></p><ul><li>ADD</li></ul><p>格式: <code>ADD src dest</code></p><p> ADD和COPY命令有相同功能,都支持复制本地文件到镜像里.但ADD能从互联网的URL下载文件到镜像..src还可以是一个本地的压缩归档文件.ADD会自动将tar,gz等压缩包上传到镜像后进行解压.</p><p> 但是如果src是一个URL的归档格式文件,则不会自动解压.</p><ul><li>RUN</li></ul><p>RUN命令有两种格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN &lt;command&gt; (shell格式)  </span><br><span class="line">RUN [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec格式)</span><br></pre></td></tr></table></figure><p>RUN指令的两种格式表示命令在容器中的两种运行方式.当使用shell格式时,命令通过<code>/bin/sh -c</code>运行.当使用exec格式时.命令直接运行,不调用shell程序.exec格式中的参数会被当成JSON数组被Docker解析.所以必须使用双引号,不能使用单引号. </p><p>另外由于exec格式不会在shell中运行.所以无法识别ENV环境变量.例如当执行<code>CMD [&quot;echo&quot;,&quot;$HOME&quot;]</code>时,$HOME不会被变量替换.如果希望运行shell程序.可以写成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;sh&quot;,&quot;-c&quot;,&quot;echo&quot;,&quot;$HOME&quot;]</span><br></pre></td></tr></table></figure><ul><li>EXPOSE: 镜像需要暴露出来的端口. </li></ul><blockquote><p>要注意的是,这里只是说明镜像需要暴露哪些端口,在镜像构建完毕,启动容器时,仍然需要-p参数来映射端口,否则端口不会自动映射</p></blockquote><ul><li><p>ENV</p><p>格式: <code>ENV &lt;key&gt; &lt;value&gt;</code> 或者 <code>ENV &lt;key&gt;=&lt;value&gt;</code></p><p>ENV指令用来声明环境变量,并且可以被(ADD,COPY,WORKDIR等)指令调用.调用ENV环境变量的格式和shell一样:<code>\$variable_name</code>或者 <code>\${variable_name}</code></p></li><li><p>CMD </p></li></ul><p>CMD命令有3种格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD &lt;command&gt; (shell格式)  </span><br><span class="line">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec格式)  </span><br><span class="line">CMD [&quot;param1&quot;,&quot;param2&quot;] (为ENTRYPOINT命令提供参数)</span><br></pre></td></tr></table></figure><p>CMD提供容器启动后执行的命令.或者是为ENTRYPOINT传递一些参数.一个dockerfile文件只允许存在一条CMD指令.如果存在多条CMD指令,以最后一条为准.但是如果用户在 docker run 时指定了命令,则会覆盖CMD中的指令</p><ul><li>ENTRYPOINT</li></ul><p>ENTRYPOINT有两种格式.和上文CMD一样分为shell格式和exec格式.</p><p>ENTRYPOINT和CMD类似,指定容器启动时执行的命令.和CMD一样一个Dockerfile文件中可以有多个ENTRYPOINT命令.但只有最后一条生效.但是又有一些区别.当使用shell格式时,ENTRYPOINT会忽略任何CMD指令和 <code>docker run</code>启动容器时手动输入的指令.并且会运行在 /bin/sh -c环境中,成为它的子进程.进程在容器中PID不是1,也不能接收UNIX信号.(也就是在执行 <code>docker stop &lt;container&gt;</code>时,进程接收不到SIGTERM指令)</p><p>当使用exec格式时, docker run 手动指定的命令,将作为参数覆盖CMD指定的参数传递到ENTRYPOINT.(也就是说 docker run启动容器时指定的不再是具体命令,而是命令的参数).</p><hr><p>创建上面dockerfile中所需要的app.py和requirements.txt文件,并且将他们和Dockerfile文件放在同一目录下:</p><p>requirements.txt:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker_python]$cat requirements.txt</span><br><span class="line">Flask</span><br><span class="line">Redis</span><br></pre></td></tr></table></figure><p>app.py:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">root@localhost docker_python]$cat app.py</span><br><span class="line">from flask import Flask</span><br><span class="line">from redis import Redis, RedisError</span><br><span class="line">import os</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line"># Connect to Redis</span><br><span class="line">redis = Redis(host=&quot;redis&quot;, db=0, socket_connect_timeout=2, socket_timeout=2)</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">def hello():</span><br><span class="line">    try:</span><br><span class="line">        visits = redis.incr(&quot;counter&quot;)</span><br><span class="line">    except RedisError:</span><br><span class="line">        visits = &quot;&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;&quot;</span><br><span class="line"></span><br><span class="line">    html = &quot;&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Visits:&lt;/b&gt; &#123;visits&#125;&quot;</span><br><span class="line">    return html.format(name=os.getenv(&quot;NAME&quot;, &quot;world&quot;), hostname=socket.gethostname(), visits=visits)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run(host=&apos;0.0.0.0&apos;, port=80)</span><br><span class="line">[root@localhost docker_python]$</span><br></pre></td></tr></table></figure><hr><h4 id="开始构建镜像"><a href="#开始构建镜像" class="headerlink" title="开始构建镜像"></a>开始构建镜像</h4><p>首先确保Dockerfile里所需的文件,以及Dockerfile都在同一目录下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker_python]$ls</span><br><span class="line">app.py  Dockerfile  requirements.txt</span><br></pre></td></tr></table></figure><p>运行以下命令来构建一个镜像.使用–tag参数(或者-t),可以为镜像打个标签:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --tag=friendlyhello .</span><br></pre></td></tr></table></figure><p>构建过程略..在构建过程中,注意以下现象:</p><p>1.构建镜像层:</p><p>部分指令会创建一个新的镜像层,而有些指令则不会.关于如何区分命令是否会新建镜像层,一个基本的原则是:</p><p>如果指令的作用是像镜像中添加新的文件或者程序,那么就会新建镜像层.(例如:RUN,COPY,ADD,FROM等)</p><p>如果只是告诉docker如何构建或者运行应用程序,增加或者修改容器的元数据,那么不会构建新的镜像层.(例如:WORKDIR,EXPOSE,ENV,ENTERPOINT等)</p><p>2.构建步骤:</p><p>基本等过程大致为:</p><p>运行临时容器—-&gt;在该容器中运行Dockerfile指令—-&gt;将运行结果保存为一个新等镜像层——&gt; 删除临时容器</p><p>构建完成后,通过以下命令可以看到构建的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker_python]$docker images</span><br><span class="line">REPOSITORY                 TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line">friendlyhello              latest              f091d1bb803c        About a minute ago   131MB</span><br></pre></td></tr></table></figure><blockquote><p>或者也可以是输入以下命令 docker image ls</p></blockquote><blockquote><p>可能会疑惑,为什么tag标签是latest..镜像的完整标签格式应该是:friendlyhello:lastest.<br>如果需要在构建镜像时指定版本.可以使用: –tag=friendlyhello:v0.0.1</p></blockquote><hr><h4 id="使用构建的镜像启动一个容器"><a href="#使用构建的镜像启动一个容器" class="headerlink" title="使用构建的镜像启动一个容器"></a>使用构建的镜像启动一个容器</h4><p>输入以下命令,利用刚才的镜像启动一个容器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4000:80 friendlyhello</span><br></pre></td></tr></table></figure><p>执行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker_python]$docker run -p 4000:80 friendlyhello</span><br><span class="line"> * Serving Flask app &quot;app&quot; (lazy loading)</span><br><span class="line"> * Environment: production</span><br><span class="line">   WARNING: Do not use the development server in a production environment.</span><br><span class="line">   Use a production WSGI server instead.</span><br><span class="line"> * Debug mode: off</span><br><span class="line"> * Running on http://0.0.0.0:80/ (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure><ul><li>docker run 表示启动一个容器</li><li>-p 宿主机端口:容器端口  表示将宿主机的端口映射给容器.如果是-P 80 表示随机映射一个宿主机的端口给容器</li></ul><p>此时可以在其他电脑上访问这个容器的80端口,下面是在我的PC上访问宿主机的4000端口,也就是刚才启动的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> ✘ huangyong@huangyong-Macbook-Pro  ~  curl http://10.0.0.50:4000</span><br><span class="line">&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; f9b1b804404f&lt;br/&gt;&lt;b&gt;Visits:&lt;/b&gt; &lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;%</span><br></pre></td></tr></table></figure><p>容器默认是在前台执行,加上-d参数可以时容器运行在后台:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 4000:80 friendlyhello</span><br></pre></td></tr></table></figure><p>docker ps命令可以显示正在运行中的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker_python]$docker ps</span><br><span class="line">CONTAINER ID        IMAGE                      COMMAND             CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">fcf7d29ac627        friendlyhello              &quot;python app.py&quot;     5 seconds ago       Up 1 second         0.0.0.0:4000-&gt;80/tcp     stoic_colden</span><br></pre></td></tr></table></figure><blockquote><p>docker container ls命令也有同样的效果</p></blockquote><hr><p>这一节(包括第3小节)涉及到的基础命令如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker build -t friendlyhello .  # Create image using this directory&apos;s Dockerfile</span><br><span class="line">docker run -p 4000:80 friendlyhello  # Run &quot;friendlyname&quot; mapping port 4000 to 80</span><br><span class="line">docker run -d -p 4000:80 friendlyhello         # Same thing, but in detached mode</span><br><span class="line">docker container ls                                # List all running containers</span><br><span class="line">docker container ls -a             # List all containers, even those not running</span><br><span class="line">docker container stop &lt;hash&gt;           # Gracefully stop the specified container</span><br><span class="line">docker container kill &lt;hash&gt;         # Force shutdown of the specified container</span><br><span class="line">docker container rm &lt;hash&gt;        # Remove specified container from this machine</span><br><span class="line">docker container rm $(docker container ls -a -q)         # Remove all containers</span><br><span class="line">docker image ls -a                             # List all images on this machine</span><br><span class="line">docker image rm &lt;image id&gt;            # Remove specified image from this machine</span><br><span class="line">docker image rm $(docker image ls -a -q)   # Remove all images from this machine</span><br><span class="line">docker login             # Log in this CLI session using your Docker credentials</span><br><span class="line">docker tag &lt;image&gt; username/repository:tag  # Tag &lt;image&gt; for upload to registry</span><br><span class="line">docker push username/repository:tag            # Upload tagged image to registry</span><br><span class="line">docker run username/repository:tag                   # Run image from a registry</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Dockerfile&quot;&gt;&lt;a href=&quot;#Dockerfile&quot; class=&quot;headerlink&quot; title=&quot;Dockerfile&quot;&gt;&lt;/a&gt;Dockerfile&lt;/h3&gt;&lt;p&gt;Dockerfile可以用来编译一个docker镜像.Dockerfile是一个包含一系列指令的文本文档,使用&lt;code&gt;docker build&lt;/code&gt;命令,用户可以依据dockerfile和上下文编译一个镜像.&lt;/p&gt;
&lt;p&gt;使用dockerfile需要注意一些事项&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.上下文&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;docker build编译镜像时,会将当前目录下的Dockerfile和所有文件打包添加发送到docker daemon服务端.所以一般情况下创建一个空目录编辑dockerfile文件.然后将需要copy和add的文件放进和dockerfile同一目录下.&lt;/p&gt;
&lt;p&gt;dockerfile中的&lt;code&gt;copy&lt;/code&gt;以及&lt;code&gt;add&lt;/code&gt;命令,添加文件到docker镜像中时.不要使用绝对路径.例如/home/work/a.txt..docker deamon只能识别到当前上下文环境,无法识别到其他目录.但是可以使用当前上下文的相对路径.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.分层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;dockerfile编译镜像时,每条指令都是一个镜像层.除了From指令外,每一行指令都是基于上一行生成的临时镜像运行一个容器.执行一条指令就类似于docker commit命令生成一个新的镜像.所以两条指令之间互不关联.&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="https://jesse.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://jesse.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker学习笔记---Docker镜像篇</title>
    <link href="https://jesse.top/2020/06/29/docker/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E9%95%9C%E5%83%8F%E7%AF%87/"/>
    <id>https://jesse.top/2020/06/29/docker/docker学习笔记——镜像篇/</id>
    <published>2020-06-29T03:59:58.000Z</published>
    <updated>2020-06-30T12:32:51.209Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker笔记——镜像篇"><a href="#docker笔记——镜像篇" class="headerlink" title="docker笔记——镜像篇"></a>docker笔记——镜像篇</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>docker镜像是一个只读的Docker容器模板.含有启动docker容器所需的文件系统结构以及内容.因此是启动一个容器的基础.docker镜像的文件内容以及一些运行docker容器的配置文件组成了docker容器的静态文件运行环境—rootfs.</p><p>可以这么理解,docker镜像是docker容器的静态视角.docker容器是docker镜像的运行状态</p><hr><p><strong>1.rootfs</strong></p><p>rootfs是docker容器的根目录.如:/dev,/proc,/bin,/etc …….传统的Linux容器操作系统内核启动时,首先挂载一个只读(read-only)的rootfs.当系统检测到完整性后,再将其切换到读写(read-write)模式.而在docker架构中.也沿用了Linux内核的启动方法.在docker为容器挂载rootfs时,将rootfs设置为只读模式,挂载完毕后,在已有的只读rootfs上再挂载一个读写层.</p><p>读写层位于docker容器文件系统的最顶层.下面可能挂载了多个只读层.</p><a id="more"></a><p><strong>2.docker镜像的特点</strong></p><ul><li><strong>分层</strong></li></ul><p>每个镜像都由一系列的”镜像层”组成.当需要修改容器镜像内的某个文件时,只对最上方的读写层进行修改,不覆盖下面的只读层文件系统.例如删除一个只读文件系统中的文件时,只会在读写层标记这个文件”已经被删除”,但是这个文件在只读层中仍然存在.只不过不被用户感知.</p><ul><li><strong>写时复制(copy-on-write)</strong></li></ul><p>每个容器在启动的时候并不需要单独复制一份镜像文件,而是将所有镜像层以只读的方式挂载到一个挂载点,在多个容器之间共享.在未更改镜像文件内容时,所有容器共享一份数据,只有在docker容器运行过程中修改过文件时,才会把变化的文件内容写到读写层.并隐藏只读层中的老版本文件.</p><p>写时复制机制减少了镜像对磁盘空间的占用和容器的启动时间</p><ul><li><strong>联合挂载</strong></li></ul><p>联合挂载技术可以在一个挂载点同时挂载多个文件系统.实现这种联合挂载技术的文件系统被称为联合文件系统(union filesystem).从内核的角度来看,docker容器的文件系统分为只读rootfs层和读写层.但是在用户的视角看来,整个文件系统都是rootfs底层.</p><p>下面这个图可以理解,镜像是由一堆的只读层堆叠起来的统一视角:</p><p><img src="![Docker镜像](https://img1.jesse.top/docker-image1.gif" alt=""></p><p>下面这个图理解了docker镜像和docker容器的区别</p><p><img src="https://img1.jesse.top/docker-container1.png" alt=""></p><hr><h3 id="docker镜像的相关概念"><a href="#docker镜像的相关概念" class="headerlink" title="docker镜像的相关概念"></a>docker镜像的相关概念</h3><p>1.<strong>registry</strong></p><p>registry用来保存docker镜像.可以将registry简单的想象成类似于git仓库之类的实体.当<figure class="highlight docker"><figcaption><span>run```命令启动一个容器时,如果宿主机上并不存在该镜像,那么docker将从registry中下载镜像并保存到宿主机</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以使用docker官方的公共registry服务(docker hub),可以可以使用阿里云私有的registry,甚至还可以自己搭建私有的registry</span><br><span class="line"></span><br><span class="line">**<span class="number">2</span>.repository**</span><br><span class="line"></span><br><span class="line">repository是由具有某个功能的docker镜像的所有迭代版本构成的镜像组.repository通常表示镜像所具有的功能,例如ansible/ubunbu14.<span class="number">4</span>-ansible.而顶层仓库则只包含repository名.例如,Ubuntu</span><br><span class="line"></span><br><span class="line">repository是一个镜像集合,包含了多个不同版本的镜像.使用标签进行版本区分,例如ubuntu:<span class="number">14.04</span>,ubuntu12.<span class="number">04</span>.他们均属于ubuntu这个repository</span><br><span class="line"></span><br><span class="line">**总而言之,registry是repository的集合,repository是镜像的集合**</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="comment">### docker镜像相关的命令</span></span><br><span class="line"></span><br><span class="line">* **拉取镜像**</span><br><span class="line"></span><br><span class="line">`docker pull [OPTIONS] NAME[:TAG|@DIGEST]`</span><br><span class="line"></span><br><span class="line">如果只指定了镜像名,则默认从docker hub官方拉取该镜像的最新latest版本</span><br></pre></td></tr></table></figure></p><p>[root@localhost ~]$docker pull nginx<br>Using default tag: latest<br>latest: Pulling from library/nginx<br>743f2d6c1f65: Pull complete<br>6bfc4ec4420a: Pull complete<br>688a776db95f: Pull complete<br>Digest: sha256:23b4dcdf0d34d4a129755fc6f52e1c6e23bb34ea011b315d87e193033bcd1b68<br>Status: Downloaded newer image for nginx:latest<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果指定了tag,则拉取指定的版本镜像</span><br></pre></td></tr></table></figure></p><p>[root@localhost ~]$docker pull nginx:1.15<br>1.15: Pulling from library/nginx<br>Digest: sha256:23b4dcdf0d34d4a129755fc6f52e1c6e23bb34ea011b315d87e193033bcd1b68<br>Status: Downloaded newer image for nginx:1.15<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">拉取我阿里云的私人registry下的镜像</span><br></pre></td></tr></table></figure></p><p>#registry.cn-hangzhou.aliyuncs.com/jesse_images为仓库地址</p><p>#php7.1.9为镜像版本<br>[root@localhost ~]$docker pull registry.cn-hangzhou.aliyuncs.com/jesse_images/jesse_images:php7.1.9</p><p>php7.1.9: Pulling from jesse_images/jesse_images<br>Digest: sha256:ed9b7326b539f47a81697e51ed8ec698bec49fb62959990c1277d068fc55ff94<br>Status: Downloaded newer image for registry.cn-hangzhou.aliyuncs.com/jesse_images/jesse_images:php7.1.9<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">* **删除镜像**</span><br><span class="line"></span><br><span class="line">命令格式:</span><br><span class="line"></span><br><span class="line">`docker rmi [OPTIONS] IMAGE [IMAGE…]`</span><br><span class="line"></span><br><span class="line">可以是docker rmi 镜像ID 或者 docker rmi 镜像名:tag</span><br></pre></td></tr></table></figure></p><p>docker images #查看当前宿主机上的镜像<br>[root@localhost ~]$docker images<br>REPOSITORY                                                    TAG                    IMAGE ID            CREATED             SIZE<br>busybox                                                       latest                 64f5d945efcc        6 days ago          1.2MB<br>nginx                                                         1.15                   53f3fd8007f7        7 days ago          109MB<br>nginx                                                         latest                 53f3fd8007f7        7 days ago          109MB<br>php-swoole                                                    7.1                    aa71c42a22ca        9 days ago          588MB</p><p><none>                                                        <none>                 01f5d7914e61        9 days ago          585MB</none></none></p><p>#删除镜像ID为01f5d7914e61的镜像</p><p>[root@localhost ~]$docker rmi 01f5d7914e61<br>Deleted: sha256:01f5d7914e615b0e2f7cc36a494c876dfc0c678963898374d9ef512d7a762aac<br>Deleted: sha256:b4dd4a057d2561647ff7bf6b299a143c99f66831c129618f49bca5e6ac82f99e<br>Deleted: sha256:c37c880338efd3d340bfa71b35b7653b6cec8eb4f5dfcfab8c7ad0045fef3ce6<br>Deleted: sha256:fb7d015f8921c1244134730b6c21f0bda6c7156ccd421d9e0069d5a1074b48dd<br>Deleted: sha256:ab74760ab0af7680fa9338100c92306392ffeb384b8976045a11dab9a4ebbc57<br>Deleted: sha256:8544a2552375c861955db9034e9c3c5a3e83530b84de9b9bb6d4a7d0d5e5b8ac<br>Deleted: sha256:4eebc2d39a0733b28992a064fc71852297927a3994b01a9d1123d71b042ab729</p><p>#删除nginx.tag为1.15的镜像<br>[root@localhost ~]$docker rmi nginx:1.15<br>Untagged: nginx:1.15<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">* **查看镜像**</span><br><span class="line"></span><br><span class="line">`docker history 镜像名`可以看到镜像的构建分层</span><br></pre></td></tr></table></figure></p><p>[root@localhost ~]$docker history nginx<br>IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT<br>53f3fd8007f7        7 days ago          /bin/sh -c #(nop)  CMD [“nginx” “-g” “daemon…   0B</p><p><missing>           7 days ago          /bin/sh -c #(nop)  STOPSIGNAL SIGTERM           0B</missing></p><p><missing>           7 days ago          /bin/sh -c #(nop)  EXPOSE 80                    0B</missing></p><p><missing>           7 days ago          /bin/sh -c ln -sf /dev/stdout /var/log/nginx…   0B</missing></p><p><missing>           7 days ago          /bin/sh -c set -x  &amp;&amp; apt-get update  &amp;&amp; apt…   54.1MB</missing></p><p><missing>           7 days ago          /bin/sh -c #(nop)  ENV NJS_VERSION=1.15.12.0…   0B</missing></p><p><missing>           7 days ago          /bin/sh -c #(nop)  ENV NGINX_VERSION=1.15.12…   0B</missing></p><p><missing>           7 days ago          /bin/sh -c #(nop)  LABEL maintainer=NGINX Do…   0B</missing></p><p><missing>           8 days ago          /bin/sh -c #(nop)  CMD [“bash”]                 0B</missing></p><p><missing>           8 days ago          /bin/sh -c #(nop) ADD file:fcb9328ea4c115670…   55.3MB<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`docker inspect 镜像名` 可以看到镜像的具体信息</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">* **创建镜像**</span><br><span class="line"></span><br><span class="line">`docker commit`命令可以基于现有的容器创建出一个镜像</span><br></pre></td></tr></table></figure></missing></p><p>#用法格式:<br>docker commit -m ‘镜像说明信息’   -a  作者  容器ID 镜像名:版本</p><p>[root@localhost ~]$docker commit -h</p><p>Usage:    docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</p><p>Create a new image from a container’s changes</p><p>Options:<br>  -a, –author string    Author (e.g., “John Hannibal Smith <a href="mailto:&#104;&#97;&#x6e;&#x6e;&#105;&#x62;&#97;&#108;&#x40;&#x61;&#x2d;&#x74;&#101;&#x61;&#x6d;&#46;&#99;&#x6f;&#x6d;" target="_blank" rel="noopener">&#104;&#97;&#x6e;&#x6e;&#105;&#x62;&#97;&#108;&#x40;&#x61;&#x2d;&#x74;&#101;&#x61;&#x6d;&#46;&#99;&#x6f;&#x6d;</a>“)<br>  -c, –change list      Apply Dockerfile instruction to the created image<br>  -m, –message string   Commit message<br>  -p, –pause            Pause container during commit (default true)</p><p>  #例如.将正在运行中的Nginx容器提交为一个新的nginx:test镜像<br>[root@localhost ~]$docker commit -m ‘test’ -a ‘jesse’ nginx nginx:test<br>sha256:028f5e2b21a66a1bf5f70727f20cac04e8918f57d5584cc2aeb09f18791d9680<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">* 导入导出镜像</span><br><span class="line"></span><br><span class="line">命令: </span><br><span class="line"></span><br><span class="line">`docker save -o 保存文件名 镜像名:tag`  ————将某个镜像保存为一个文件</span><br><span class="line"></span><br><span class="line">`docker load &lt; 文件名` or `docker load —input 文件名`——将某个文件导入到本地镜像</span><br><span class="line"></span><br><span class="line">例如</span><br></pre></td></tr></table></figure></p><p>#将nginx:test这个镜像保存为Nginx_test.tar文件<br>[root@localhost ~]$docker save -o nginx_test.tar nginx:test<br>[root@localhost ~]$ll nginx_test.tar<br>-rw——- 1 root root 113036800 5月  16 10:29 nginx_test.tar</p><p>#删除ningx:test这个镜像.然后再从该文件恢复<br>[root@localhost ~]$docker load &lt; nginx_test.tar<br>67392954caf5: Loading layer [==================================================&gt;]  8.192kB/8.192kB<br>Loaded image: nginx:test</p><p>#镜像已经被导入<br>[root@localhost ~]$docker images | grep nginx<br>nginx                                                         test                   028f5e2b21a6        4 minutes ago       109MB<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;docker笔记——镜像篇&quot;&gt;&lt;a href=&quot;#docker笔记——镜像篇&quot; class=&quot;headerlink&quot; title=&quot;docker笔记——镜像篇&quot;&gt;&lt;/a&gt;docker笔记——镜像篇&lt;/h2&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;docker镜像是一个只读的Docker容器模板.含有启动docker容器所需的文件系统结构以及内容.因此是启动一个容器的基础.docker镜像的文件内容以及一些运行docker容器的配置文件组成了docker容器的静态文件运行环境—rootfs.&lt;/p&gt;
&lt;p&gt;可以这么理解,docker镜像是docker容器的静态视角.docker容器是docker镜像的运行状态&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;1.rootfs&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;rootfs是docker容器的根目录.如:/dev,/proc,/bin,/etc …….传统的Linux容器操作系统内核启动时,首先挂载一个只读(read-only)的rootfs.当系统检测到完整性后,再将其切换到读写(read-write)模式.而在docker架构中.也沿用了Linux内核的启动方法.在docker为容器挂载rootfs时,将rootfs设置为只读模式,挂载完毕后,在已有的只读rootfs上再挂载一个读写层.&lt;/p&gt;
&lt;p&gt;读写层位于docker容器文件系统的最顶层.下面可能挂载了多个只读层.&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="https://jesse.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://jesse.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker学习笔记---docker网络之bridge</title>
    <link href="https://jesse.top/2020/06/29/docker/docker%E5%AE%98%E7%BD%91%E5%AD%A6%E4%B9%A0-7.docker%E7%BD%91%E7%BB%9C%E4%B9%8Bbridge/"/>
    <id>https://jesse.top/2020/06/29/docker/docker官网学习-7.docker网络之bridge/</id>
    <published>2020-06-29T03:59:58.000Z</published>
    <updated>2020-06-30T12:32:51.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker官网学习–docker网络之bridge"><a href="#docker官网学习–docker网络之bridge" class="headerlink" title="docker官网学习–docker网络之bridge"></a>docker官网学习–docker网络之bridge</h2><p>本节介绍docker基础网络概念.以便能认识和利用各种不同的网络类型功能.</p><p>docker的网络支持插件化,驱动化定制.有一些网络驱动已经默认集成到docker中.docker网络主要有以下类型</p><ul><li>bridge</li><li>host</li><li>overlay</li><li>macvlan</li><li>none</li><li>其他网络插件</li></ul><hr><a id="more"></a><h4 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h4><p>​    bridge是docker默认的网络驱动.如果在<code>docker run</code>启动一个容器时没有指定任何网络驱动.那么默认就是bridge桥接网络.桥接网络通常适用于应用进程部署在多个独立的容器中,并且容器之间需要互相通信的场景中.</p><p>   在docker环境中.bridge使用软件桥接允许容器之间通过同一个bridge互联.隔离没有连到这个bridge网络的其他容器网络.docker网络自动创建iptables规则阻止其他网络的容器访问.</p><p>当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。</p><p>从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。在主机上创建一对虚拟网卡veth pair设备，Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0（容器的网卡），另一端放在主机中，以vethxxx这样类似的名字命名，并将这个网络设备加入到docker0网桥中。可以通过brctl show命令查看。</p><p>在Linux中.可以使用brctl命令查看和管理网桥(需要先安装bridge-utils软件包).例如查看本机上的网桥及其端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[work@docker conf.d]$sudo brctl show</span><br><span class="line">bridge namebridge idSTP enabledinterfaces</span><br><span class="line">br-17ace6d9d81a8000.024236cdd4d7noveth82ed0e5</span><br><span class="line">br-d9897c225d258000.024237d1c9f6noveth6981090</span><br><span class="line">veth8e29dbf</span><br><span class="line">vethd511728</span><br><span class="line">docker08000.0242322e2e42noveth0a0e27d</span><br><span class="line">veth0c50104</span><br><span class="line">veth3fe7f4d</span><br></pre></td></tr></table></figure><p>docker 0网桥下关联了很多vethxxxxx规范命名的interfaces.每一个vethxxxx接口对应一个docker容器.在docker容器中一般是eth0的网卡</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[work@docker conf.d]$docker exec -it nginx ifconfig</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.8  netmask 255.255.0.0  broadcast 0.0.0.0</span><br><span class="line">        inet6 fe80::42:acff:fe11:8  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 02:42:ac:11:00:08  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 1428365  bytes 189142687 (180.3 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 1403620  bytes 287806317 (274.4 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p>bridge网桥就是这样通信的,docker服务端通过vethxxxx端口和容器的eth0虚拟网卡进行通信.docker容器将宿主机的docker 0虚拟网卡的IP作为它的网关:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@docker conf.d]$docker exec -it nginx route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         172.17.0.1      0.0.0.0         UG    0      0        0 eth0</span><br></pre></td></tr></table></figure><p>bridge模式是docker的默认网络模式，不写–net参数，就是bridge模式。使用docker run -p时，docker实际是在iptables做了DNAT规则，实现端口转发功能。可以使用iptables -t nat -vnL查看。</p><p>bridge网络模式如下所示:</p><p><img src="http://cdn.img2.a-site.cn/pic.php?url=aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXovUVAwQVk3dGRKblV4eFJNWjRRcDl0b21GaFFRMDNYVUViTWFab1lmbU9pYk56NDZwc0FMcDk0bHR1MllTNVZHMmZtNGUxTTNwM0tOUmVQN04xZVh2OHlBLzA/d3hfZm10PXBuZw==" alt=""></p><p>​    bridge网桥是docker的默认网络驱动.如果用户在创建容器时自定义了Bridge网络.那么自定义Bridge要优于docker默认的Bridge</p><p> <strong>用户定义的bridge和默认bridge的区别</strong></p><ul><li><p>用户定义的bridge在多个容器之间提供更好的隔离性和协调性.</p><p>连到同一个自定义的bridge的容器之间的所有端口互通.而无需通过-p参数暴露到宿主机.这让容器之间的通信更简单,而且提供更好的安全性.例如:</p><p>连到同一个自定义的bridge网络的Nginx容器和mysql容器.及时mysql容器没有暴露任何端口.nginx也可以访问mysql容器的3306端口.</p><p>而默认的Bridge网络,则需要将mysql容器通过<code>-p</code>参数暴露3306端口给宿主机.</p></li><li><p>自定义bridge网络提供容器的主机名DNS解析</p></li></ul><p>​        默认的bridge网络下的容器间不能通过主机名互相访问,只能通过IP地址.(除非使用—link参数,但是这个参数已经废弃).而用户自定义的bridge网络则可以直接访问对方的主机名.</p><ul><li>自定义bridge网络配置更方便</li></ul><p>​        配置一个默认bridge网络,会影响到全局所有容器.而且需要重启docker服务.使用<code>docker network create</code>可以创建一个自定义bridge网络.,而且可以分别配置</p><hr><h4 id="创建和管理自定义bridge网络"><a href="#创建和管理自定义bridge网络" class="headerlink" title="创建和管理自定义bridge网络"></a>创建和管理自定义bridge网络</h4><p>创建命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#创建自定义网络名称为my-net</span><br><span class="line">docker network create my-net</span><br><span class="line"></span><br><span class="line">#还可以指定网络号,子网掩码等信息</span><br><span class="line">[root@localhost ~]$docker network create --help</span><br><span class="line"></span><br><span class="line">Usage:docker network create [OPTIONS] NETWORK</span><br><span class="line"></span><br><span class="line">Create a network</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --attachable           Enable manual container attachment</span><br><span class="line">      --aux-address map      Auxiliary IPv4 or IPv6 addresses used by Network driver (default map)</span><br><span class="line">      --config-from string   The network from which copying the configuration</span><br><span class="line">      --config-only          Create a configuration only network</span><br><span class="line">  -d, --driver string        Driver to manage the Network (default &quot;bridge&quot;)</span><br><span class="line">      --gateway strings      IPv4 or IPv6 Gateway for the master subnet</span><br><span class="line">      --ingress              Create swarm routing-mesh network</span><br><span class="line">      --internal             Restrict external access to the network</span><br><span class="line">      --ip-range strings     Allocate container ip from a sub-range</span><br><span class="line">      --ipam-driver string   IP Address Management Driver (default &quot;default&quot;)</span><br><span class="line">      --ipam-opt map         Set IPAM driver specific options (default map)</span><br><span class="line">      --ipv6                 Enable IPv6 networking</span><br><span class="line">      --label list           Set metadata on a network</span><br><span class="line">  -o, --opt map              Set driver specific options (default map)</span><br><span class="line">      --scope string         Control the network&apos;s scope</span><br><span class="line">      --subnet strings       Subnet in CIDR format that represents a network segment</span><br></pre></td></tr></table></figure><p>删除自定义网络:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#如果有容器正在使用该网络,需要先断开容器</span><br><span class="line">docker network rm my-net</span><br></pre></td></tr></table></figure><hr><h4 id="管理自定义网络下的容器"><a href="#管理自定义网络下的容器" class="headerlink" title="管理自定义网络下的容器"></a>管理自定义网络下的容器</h4><p>创建一个自定义网络下的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#在创建容器的时候指定自定义网络名</span><br><span class="line"></span><br><span class="line">docker create --name my-nginx \</span><br><span class="line">  --network my-net \</span><br><span class="line">  --publish 8080:80 \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p>将一个正在运行的容器关联(移除)自定义网络</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#关联容器和自定义网络命令格式:</span><br><span class="line">docker network connect</span><br><span class="line"></span><br><span class="line">#例如,将一个正在运行的mysql容器关联到my-net网络下</span><br><span class="line">docker network connect my-net mysql</span><br><span class="line"></span><br><span class="line">#相反从自定义网络下移除一个容器命令:</span><br><span class="line">docker network disconnect</span><br><span class="line"></span><br><span class="line">#例如,将一个正在运行的mysql容器从my-net网络下移除</span><br><span class="line">docker network disconnect my-net mysql</span><br></pre></td></tr></table></figure><hr><h3 id="实验"><a href="#实验" class="headerlink" title="实验:"></a>实验:</h3><ul><li><strong>默认的bridge网络,容器之间无法互相访问对方的主机名.只能通过iP地址通信</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$docker run -itd --rm --name=busybox busybox</span><br><span class="line">b3c8be3b3b716579caf11d3852f6c6e04a41b4dc020d9478be1b1f3a4d76cf1f</span><br><span class="line"></span><br><span class="line">[root@localhost ~]$docker run -itd --rm --name=busybox1 busybox</span><br><span class="line">a54d962f6a692d96f0bc2fbca37e1b47e59e6b61541f42b8d6872a5008a46b87</span><br><span class="line"></span><br><span class="line">[root@localhost ~]$docker exec busybox ping busybox1</span><br><span class="line">ping: bad address &apos;busybox1&apos;</span><br><span class="line">[root@localhost ~]$</span><br><span class="line"></span><br><span class="line">#通过IP地址可以通信</span><br><span class="line"></span><br><span class="line">[root@localhost ~]$docker exec busybox ping 172.17.0.8</span><br><span class="line">PING 172.17.0.8 (172.17.0.8): 56 data bytes</span><br><span class="line">64 bytes from 172.17.0.8: seq=0 ttl=64 time=0.136 ms</span><br><span class="line">64 bytes from 172.17.0.8: seq=1 ttl=64 time=0.079 ms</span><br><span class="line">64 bytes from 172.17.0.8: seq=2 ttl=64 time=0.131 ms</span><br></pre></td></tr></table></figure><ul><li><strong>自定义的Bridge网络,可以在容器之间互相访问主机名</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#创建一个自定义网络</span><br><span class="line">[root@localhost ~]$docker network create jesse</span><br><span class="line">e10a936177681cbfc321f67f961f2a717079ef1790c50e82381296fa77bd7d5f</span><br><span class="line"></span><br><span class="line">[root@localhost ~]$docker network ls | grep jesse</span><br><span class="line">e10a93617768        jesse                  bridge              local</span><br><span class="line"></span><br><span class="line">#创建容器,使用network参数指定网络</span><br><span class="line">[root@localhost ~]$docker run --name busybox1 -itd --network jesse --rm busybox</span><br><span class="line">aedf164ea1769741ae6480583abdc838022f49506761d4054daabdb7fffcd852</span><br><span class="line"></span><br><span class="line">[root@localhost ~]$docker run --name busybox2 -itd --network jesse --rm busybox</span><br><span class="line">523bdd54fa12423e25a8ac84f9faef1679ee6031f2d5d2a87c0cacd64f8650ad</span><br><span class="line"></span><br><span class="line">[root@localhost ~]$docker exec busybox1 ping busybox2</span><br><span class="line">PING busybox2 (172.20.0.3): 56 data bytes</span><br><span class="line">64 bytes from 172.20.0.3: seq=0 ttl=64 time=0.116 ms</span><br><span class="line">64 bytes from 172.20.0.3: seq=1 ttl=64 time=0.078 ms</span><br></pre></td></tr></table></figure><ul><li>连接到不同的bridge网络下的容器互相之间网络隔离</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">docker network create bridge</span><br><span class="line">docker network create kong-net</span><br><span class="line"></span><br><span class="line">[work@docker conf.d]$docker run --name busybox1 --network bridge -itd busybox</span><br><span class="line">f95a229aa7eb5d7022bef4441a075b0ad37ecc50e2a02015f09790d23b28dc33</span><br><span class="line"></span><br><span class="line">[work@docker conf.d]$docker run --name busybox2 --network kong-net -itd busybox</span><br><span class="line">a9236a25199cc43a899285462afa851a52cdaf871776a93829897676fc7dd82c</span><br><span class="line"></span><br><span class="line">#busybox1和busybox2不在同一个IP网段</span><br><span class="line">#busybox1的IP</span><br><span class="line">[work@docker conf.d]$docker inspect busybox1 </span><br><span class="line">172.17.0.11</span><br><span class="line"></span><br><span class="line">#busybox2的IP</span><br><span class="line">[work@docker conf.d]$docker exec -it busybox2 ifconfig eth0</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:AC:12:00:05</span><br><span class="line">          inet addr:172.18.0.5  Bcast:0.0.0.0  Mask:255.255.0.0</span><br><span class="line">          </span><br><span class="line">#主机名无法访问</span><br><span class="line">[work@docker conf.d]$docker exec -it busybox1 ping busybox2</span><br><span class="line">ping: bad address &apos;busybox2&apos;</span><br><span class="line"></span><br><span class="line">#busybox1容器也无法ping busybox2容器的IP</span><br><span class="line">[work@docker conf.d]$docker exec -it busybox1 ping 172.18.0.5</span><br><span class="line">PING 172.18.0.5 (172.18.0.5): 56 data bytes</span><br><span class="line">^C</span><br><span class="line">--- 172.18.0.5 ping statistics ---</span><br><span class="line">32 packets transmitted, 0 packets received, 100% packet loss</span><br></pre></td></tr></table></figure><blockquote><p>由于博客不能识别go模板语法,所以省去了go模板,直接用docker inspect busybox1命令来代替.实际场景中该命令无法直接获取容器IP</p></blockquote><h4 id="将容器从自定义bridge网络中移除"><a href="#将容器从自定义bridge网络中移除" class="headerlink" title="将容器从自定义bridge网络中移除"></a>将容器从自定义bridge网络中移除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#将jesse从jesse网络移除</span><br><span class="line">[root@localhost ~]$docker network disconnect jesse busybox1</span><br><span class="line"></span><br><span class="line">#此时jesse网络下只有busybox2容器</span><br><span class="line">[root@localhost ~]$docker network inspect jesse</span><br><span class="line"></span><br><span class="line">#此时busybox1容器的网卡被移除了</span><br><span class="line">[root@localhost ~]$docker inspect busybox1 </span><br><span class="line">&lt;no value&gt;</span><br><span class="line"></span><br><span class="line">root@localhost ~]$docker exec -it busybox1 ifconfig</span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:11 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:11 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:618 (618.0 B)  TX bytes:618 (618.0 B)</span><br></pre></td></tr></table></figure><h4 id="将一个正在运行的容器加入到自定义bridge网络"><a href="#将一个正在运行的容器加入到自定义bridge网络" class="headerlink" title="将一个正在运行的容器加入到自定义bridge网络"></a>将一个正在运行的容器加入到自定义bridge网络</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#将jesse加回到jesse网络</span><br><span class="line">[root@localhost ~]$docker network connect jesse busybox1</span><br><span class="line"></span><br><span class="line">#获得新的IP地址</span><br><span class="line">[root@localhost ~]$docker inspect busybox1 </span><br><span class="line">172.20.0.2</span><br></pre></td></tr></table></figure><hr><h4 id="宿主机转发容器端口"><a href="#宿主机转发容器端口" class="headerlink" title="宿主机转发容器端口"></a>宿主机转发容器端口</h4><p>默认情况下,bridge网络不会转发外部的请求到容器.开启转发需要更改2个设置:</p><p>1.修改内容,开启转发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.conf.all.forwarding=1</span><br><span class="line"></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>2.更改iptables的转发的默认规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -P FORWARD ACCEPT</span><br></pre></td></tr></table></figure><h4 id="更改默认Bridge网络配置"><a href="#更改默认Bridge网络配置" class="headerlink" title="更改默认Bridge网络配置"></a>更改默认Bridge网络配置</h4><p>docker0网桥是在docker daemon启动时自动创建的.IP默认为172.17.0.1/16.所有连到docker 0网桥的docker容器都会在这个IP范围内选取一个未占用的IP使用.并连接到docker 0网桥上</p><p>docker提供了一些参数帮助用户自定义docker0网桥的设置</p><ul><li>—bip=CIDR: 设置Docker0的IP地址和子网范围.使用CIDR格式.例如192.168.0.1/24.需要注意的是这个参数仅仅是配置docker0的,对其他自定义的网桥无效.</li><li>—fixed-cidr=CIDR:限制docker容器获取iP的范围.默认情况下docker容器获取的IP范围为整个docker0网桥的IP地址段,也就是—bip指定的地址范围.此参数可以将docker容器缩小到某个子网范围.</li><li>—mtu=BYTES: 指定docker0的最大传输单元(MTU)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#更改daemon.json配置文件.下面这个例子修改了docker0网络的网段地址</span><br><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;],</span><br><span class="line">  &quot;bip&quot;: &quot;192.168.1.5/24&quot;,</span><br><span class="line">  &quot;mtu&quot;: 1500,</span><br><span class="line">  &quot;dns&quot;: [&quot;114.114.114.114&quot;,&quot;114.114.115.115&quot;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#重启docker服务</span><br><span class="line">[root@localhost ~]$systemctl restart docker</span><br><span class="line"></span><br><span class="line">[root@localhost ~]$ifconfig | grep -A 5 docker0</span><br><span class="line">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.1.5  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">        ether 02:42:89:26:d1:c9  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 1072032  bytes 61915874 (59.0 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 1997027  bytes 1934238839 (1.8 GiB)</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;docker官网学习–docker网络之bridge&quot;&gt;&lt;a href=&quot;#docker官网学习–docker网络之bridge&quot; class=&quot;headerlink&quot; title=&quot;docker官网学习–docker网络之bridge&quot;&gt;&lt;/a&gt;docker官网学习–docker网络之bridge&lt;/h2&gt;&lt;p&gt;本节介绍docker基础网络概念.以便能认识和利用各种不同的网络类型功能.&lt;/p&gt;
&lt;p&gt;docker的网络支持插件化,驱动化定制.有一些网络驱动已经默认集成到docker中.docker网络主要有以下类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bridge&lt;/li&gt;
&lt;li&gt;host&lt;/li&gt;
&lt;li&gt;overlay&lt;/li&gt;
&lt;li&gt;macvlan&lt;/li&gt;
&lt;li&gt;none&lt;/li&gt;
&lt;li&gt;其他网络插件&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="docker" scheme="https://jesse.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://jesse.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker学习笔记---docker-compose</title>
    <link href="https://jesse.top/2020/06/29/docker/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94docker-compose/"/>
    <id>https://jesse.top/2020/06/29/docker/docker学习笔记—docker-compose/</id>
    <published>2020-06-29T03:59:58.000Z</published>
    <updated>2020-06-30T12:32:51.209Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker学习笔记——docker-compose"><a href="#docker学习笔记——docker-compose" class="headerlink" title="docker学习笔记——docker-compose"></a>docker学习笔记——docker-compose</h2><p>docker compose 定义并且运行多个docker容器.使用YAML风格文件定义一个compose文件.利用compose文件创建和启动所有服务.</p><p>使用docker compose基本只需要3个步骤</p><ul><li>在Dockerfile文件定义app环境</li><li>在docker-compose.yml文件中定义组成app的各个服务</li><li>run docker-compose up 和compose 启动和运行app</li></ul><p>下面文档均可以在docker-compose官方找到详细资料:<a href="https://docs.docker.com/compose/" target="_blank" rel="noopener">docker-compose</a></p><h3 id="docker-compose安装"><a href="#docker-compose安装" class="headerlink" title="docker-compose安装"></a>docker-compose安装</h3><a id="more"></a><p>docker-compose的安装非常简单.下面是Linux上的安装方法.其他平台请自行参考官网</p><p>1.下载最近的1.24版本的二进制文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.24.0/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>2.给予执行权限.加入环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line">sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</span><br></pre></td></tr></table></figure><p>3.安装完成.查看是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose --version</span><br><span class="line">docker-compose version 1.24.0, build 1110ad01</span><br></pre></td></tr></table></figure><hr><h2 id="compose例子"><a href="#compose例子" class="headerlink" title="compose例子"></a>compose例子</h2><p>在官网上,或者去github上下载一个例子.这里我参考<docker 深入浅出="">这本书的例子</docker></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/counter-app</span><br><span class="line">cd /data/counter-app</span><br><span class="line">git clone https://github.com/nigelpoulton/counter-app.git</span><br></pre></td></tr></table></figure><h3 id="docker-compose文件"><a href="#docker-compose文件" class="headerlink" title="docker-compose文件"></a>docker-compose文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost counter-app]$cat docker-compose.yml</span><br><span class="line"></span><br><span class="line">version: &quot; 3.5&quot;</span><br><span class="line">services:</span><br><span class="line">   web-fe:</span><br><span class="line">      build:</span><br><span class="line">         command: python app.py</span><br><span class="line">         ports:</span><br><span class="line">            - target: 5000</span><br><span class="line">              published: 5000</span><br><span class="line">         </span><br><span class="line">         networks:</span><br><span class="line">            - counter-net</span><br><span class="line">         </span><br><span class="line">         volumes:</span><br><span class="line">            - type: volume</span><br><span class="line">              source: counter-vol</span><br><span class="line">              target: /code</span><br><span class="line">    </span><br><span class="line">   redis:</span><br><span class="line">      image: &quot;redis:alpine&quot;</span><br><span class="line">      networks:</span><br><span class="line">         counter-net</span><br><span class="line">   </span><br><span class="line">networks:</span><br><span class="line">        counter-net:</span><br><span class="line">   </span><br><span class="line">volumes:</span><br><span class="line">       counter-vol:</span><br></pre></td></tr></table></figure><p><strong>compose文件结构</strong></p><p>包含4个一级key: version.services.network.volumes</p><ul><li>version: 必须指定,定义了compose文件格式版本.这里是3.5最新版</li><li>services: 用于定义不同的应用服务.这个例子中定义了2个服务.一个是web-fe的web前端.一个是redis的内存数据库.docker compose会将每个服务部署在各自的容器中</li><li>networks用于创建新的网络.默认情况下会创建bridge网络</li><li>volume用于创建新的卷</li></ul><p>上面的docker compose文件定义了2个服务.在web-fe的服务定义中.包含如下指令:</p><ul><li>build:  指定docker基于当前目录下的Dockerfile文件构建一个新镜像</li><li>command: 指定在容器中执行app.py脚本作为主程序 (这个指令可以忽略,因为dockerfile镜像中已经配置了CMD指令)</li><li>ports: 将容器(target)的5000端口映射到宿主机(published)5000端口</li><li>networks: docker将此容器连接到指定的网络上</li><li>volumes: 指定docker将宿主机counter-vol卷(source)挂载到容器内的/code(target)上.counter-vol卷是已经存在的,或者是在文件下方的volumes一级key中定义的</li></ul><p>redis服务比较简单,就不再赘述..</p><hr><h2 id="部署docker-compose"><a href="#部署docker-compose" class="headerlink" title="部署docker-compose"></a>部署docker-compose</h2><p>简要介绍counter-app目录内的几个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost counter-app]$ll</span><br><span class="line">总用量 20</span><br><span class="line">-rw-r--r-- 1 root root 599 6月  18 17:34 app.py    #应用程序代码</span><br><span class="line">-rw-r--r-- 1 root root 475 6月  17 18:46 docker-compose.ymal  #compose文件,定义了如何部署容器</span><br><span class="line">-rw-r--r-- 1 root root 109 6月  18 17:34 Dockerfile  #构建web-fe服务镜像的dockerfile</span><br><span class="line">-rw-r--r-- 1 root root 128 6月  18 17:34 README.md   </span><br><span class="line">-rw-r--r-- 1 root root  11 6月  18 17:34 requirements.txt #列出app.py代码文件中python的依赖包</span><br></pre></td></tr></table></figure><h4 id="启动docker-compose"><a href="#启动docker-compose" class="headerlink" title="启动docker-compose"></a>启动docker-compose</h4><p>在当前目录下执行下列路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d #后台启动</span><br></pre></td></tr></table></figure><p>默认情况下<code>docker-compose</code>命令会寻找当前目录下名为docker-compose.yml或者docker-compose.yaml的Compose文件.如果Compose文件是其他文件名.则需要-f参数来指定具体文件名:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f compose_file up -d</span><br></pre></td></tr></table></figure><p>如果找不到文件则会报错:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ERROR:</span><br><span class="line">        Can&apos;t find a suitable configuration file in this directory or any</span><br><span class="line">        parent. Are you in the right directory?</span><br><span class="line"></span><br><span class="line">        Supported filenames: docker-compose.yml, docker-compose.yaml</span><br></pre></td></tr></table></figure><p>部署过程中创建或者拉取了3个镜像: counterapp_web-fe,python,redis</p><p>部署完成后,启动了如下2个容器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost counter-app]$docker ps</span><br><span class="line">CONTAINER ID        IMAGE                             COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">474301996ccc        redis:alpine                      &quot;docker-entrypoint.s…&quot;   21 hours ago        Up 21 hours         6379/tcp                 counter-app_redis_1</span><br><span class="line">c7a1e28b5e28        counter-app_web-fe                &quot;python app.py&quot;          21 hours ago        Up 21 hours         0.0.0.0:5000-&gt;5000/tcp   counter-app_web-fe_1</span><br></pre></td></tr></table></figure><p>每个容器都以项目名为前缀(所在目录名称).此外,还用一个数字为后缀用于表示容器序列(因为docker-compose允许扩容和缩减服务器数量)</p><p>同时,docker-compose还创建了counter-app_counter-net网络:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost counter-app]$docker network ls</span><br><span class="line">NETWORK ID          NAME                      DRIVER              SCOPE</span><br><span class="line">6d40a81d76e7        bridge                    bridge              local</span><br><span class="line">ef71284e9acc        counter-app_counter-net   bridge              local</span><br></pre></td></tr></table></figure><p>应用部署成功后,可以查看容器的运行效果.每次访问,计数器就+1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost counter-app]$curl http://localhost:5000</span><br><span class="line">What&apos;s up Docker Deep Divers! You&apos;ve visited me 1 times.</span><br><span class="line">[root@localhost counter-app]$curl http://localhost:5000</span><br><span class="line">What&apos;s up Docker Deep Divers! You&apos;ve visited me 2 times.</span><br><span class="line">[root@localhost counter-app]$curl http://localhost:5000</span><br><span class="line">What&apos;s up Docker Deep Divers! You&apos;ve visited me 3 times.</span><br></pre></td></tr></table></figure><hr><h2 id="docker-Compose管理"><a href="#docker-Compose管理" class="headerlink" title="docker Compose管理"></a>docker Compose管理</h2><p>上面讲到如何部署一个compose应用..接下来讲解一下compose的管理命令.需要注意的是所有的docker-compose命令都需要在相关目录下执行.不然仍然会提示找不到docker-compose.yml(yaml)文件</p><p>如果是停止应用.只需将up换成down即可.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost counter-app]$docker-compose down</span><br><span class="line">Stopping counter-app_redis_1  ... done</span><br><span class="line">Stopping counter-app_web-fe_1 ... done</span><br><span class="line">Removing counter-app_redis_1  ... done</span><br><span class="line">Removing counter-app_web-fe_1 ... done</span><br><span class="line">Removing network counter-app_counter-net</span><br></pre></td></tr></table></figure><p>停止compose经历了如下的过程:</p><ul><li>停止所有容器</li><li>移除容器</li><li>移除docker网络</li></ul><p>此时,无论是执行<code>docker ps</code>还是<code>docker ps -a</code>都看不到容器</p><h4 id="查看compose各个服务容器的运行的进程"><a href="#查看compose各个服务容器的运行的进程" class="headerlink" title="查看compose各个服务容器的运行的进程"></a>查看compose各个服务容器的运行的进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost counter-app]$docker-compose top</span><br><span class="line">counter-app_redis_1</span><br><span class="line">UID    PID    PPID    C   STIME   TTY     TIME         CMD</span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">100   32558   32542   0   13:21   ?     00:00:00   redis-server</span><br><span class="line"></span><br><span class="line">counter-app_web-fe_1</span><br><span class="line">UID     PID    PPID    C   STIME   TTY     TIME                    CMD</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">root   32582   32564   6   13:21   ?     00:00:00   python app.py</span><br><span class="line">root   32703   32582   4   13:21   ?     00:00:00   /usr/local/bin/python /code/app.py</span><br><span class="line">[root@localhost counter-app]$</span><br></pre></td></tr></table></figure><blockquote><p>PID是docker宿主机的进程ID</p></blockquote><h4 id="停止应用容器-但是并不删除资源"><a href="#停止应用容器-但是并不删除资源" class="headerlink" title="停止应用容器.但是并不删除资源"></a>停止应用容器.但是并不删除资源</h4><p>执行完<code>docker-compose stop</code>命令后,容器还存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost counter-app]$docker-compose stop</span><br><span class="line">Stopping counter-app_web-fe_1 ... done</span><br><span class="line">Stopping counter-app_redis_1  ... done</span><br><span class="line"></span><br><span class="line">[root@localhost counter-app]$docker-compose ps</span><br><span class="line">        Name                      Command               State    Ports</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">counter-app_redis_1    docker-entrypoint.sh redis ...   Exit 0</span><br><span class="line">counter-app_web-fe_1   python app.py                    Exit 0</span><br><span class="line">[root@localhost counter-app]$</span><br></pre></td></tr></table></figure><h4 id="删除-重启已停止的compose应用容器"><a href="#删除-重启已停止的compose应用容器" class="headerlink" title="删除,重启已停止的compose应用容器"></a>删除,重启已停止的compose应用容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose rm #删除.删除应用相关的容器,但是不会删除卷和镜像和网络.</span><br><span class="line">docker-compose restart #重启</span><br></pre></td></tr></table></figure><p>#### </p><h4 id="拉取服务镜像"><a href="#拉取服务镜像" class="headerlink" title="拉取服务镜像"></a>拉取服务镜像</h4><p><code>docker-compose pull server_name</code>这个命令会先拉取服务镜像到本地.例如在本文的docker compose例子中有2个服务:web-fe和redis.如果执行下列命令,会仅仅拉取redis镜像到本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose pull redis</span><br></pre></td></tr></table></figure><h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><p>日常docker管理容器的命令都可以使用<code>docker-compose</code>替代.例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker-compose logs service_name #查看服务容器日志</span><br><span class="line">docker-compose exec service_name #开启终端登陆容器</span><br><span class="line">docker-compose kill -s SIGINT    #杀死docker-compose服务容器</span><br><span class="line">docker-compose ps                #列出容器</span><br></pre></td></tr></table></figure><hr><h3 id="docker-compose配置文件指令解析"><a href="#docker-compose配置文件指令解析" class="headerlink" title="docker-compose配置文件指令解析"></a>docker-compose配置文件指令解析</h3><p>以下配置文件以版本3.x为例.官网参考:<a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">https://docs.docker.com/compose/compose-file/</a></p><p>下面是个包含完整指令的样例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6379&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - frontend</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 2</span><br><span class="line">      update_config:</span><br><span class="line">        parallelism: 2</span><br><span class="line">        delay: 10s</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres:9.4</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/postgresql/data</span><br><span class="line">    networks:</span><br><span class="line">      - backend</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line"></span><br><span class="line">  vote:</span><br><span class="line">    image: dockersamples/examplevotingapp_vote:before</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;5000:80&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - frontend</span><br><span class="line">    depends_on:</span><br><span class="line">      - redis</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 2</span><br><span class="line">      update_config:</span><br><span class="line">        parallelism: 2</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line"></span><br><span class="line">  result:</span><br><span class="line">    image: dockersamples/examplevotingapp_result:before</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;5001:80&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - backend</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 1</span><br><span class="line">      update_config:</span><br><span class="line">        parallelism: 2</span><br><span class="line">        delay: 10s</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line"></span><br><span class="line">  worker:</span><br><span class="line">    image: dockersamples/examplevotingapp_worker</span><br><span class="line">    networks:</span><br><span class="line">      - frontend</span><br><span class="line">      - backend</span><br><span class="line">    deploy:</span><br><span class="line">      mode: replicated</span><br><span class="line">      replicas: 1</span><br><span class="line">      labels: [APP=VOTING]</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">        delay: 10s</span><br><span class="line">        max_attempts: 3</span><br><span class="line">        window: 120s</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line"></span><br><span class="line">  visualizer:</span><br><span class="line">    image: dockersamples/visualizer:stable</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    stop_grace_period: 1m30s</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  frontend:</span><br><span class="line">  backend:</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br></pre></td></tr></table></figure><h2 id="Service块级别的配置文件指令"><a href="#Service块级别的配置文件指令" class="headerlink" title="Service块级别的配置文件指令"></a>Service块级别的配置文件指令</h2><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>build可以指定一个目录或者在build下还可以指定context上下文环境和docker-file文件名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    build: ./dir</span><br><span class="line">    </span><br><span class="line">或者</span><br><span class="line">webapp:</span><br><span class="line">    build:</span><br><span class="line">      context: ./dir</span><br><span class="line">      dockerfile: Dockerfile-alternate #如果指定dockerfile,则必须要指定一个build路径,也就是context</span><br><span class="line">      args:</span><br><span class="line">        buildno: 1</span><br></pre></td></tr></table></figure><p>如果同时指定了Image关键字,那么会构建一个指定的镜像名:tag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">build: ./dir</span><br><span class="line">image: webapp:tag  #构建webapp:tag的镜像名</span><br></pre></td></tr></table></figure><blockquote><p>build选项在swarm中部署stack时是无效的,因为docker stack命令只接受已经build好的镜像</p></blockquote><h4 id="CONTEXT"><a href="#CONTEXT" class="headerlink" title="CONTEXT"></a>CONTEXT</h4><p>定义上下文目录.如果是一个相对目录,那么是相对Compose file文件的目录.</p><h4 id="ARGS"><a href="#ARGS" class="headerlink" title="ARGS"></a>ARGS</h4><p>在build过程中可以允许使用ARGS变量传递给dockerfile.具体用法参考官网</p><h4 id="COMMAND"><a href="#COMMAND" class="headerlink" title="COMMAND"></a>COMMAND</h4><p>重写dockerfile或者镜像中的默认命令.和dockerfile一样可以是shell方式也可以是exec方式执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">command: bundle exec thin -p 3000</span><br><span class="line">command: [&quot;bundle&quot;, &quot;exec&quot;, &quot;thin&quot;, &quot;-p&quot;, &quot;3000&quot;]</span><br></pre></td></tr></table></figure><h4 id="configs"><a href="#configs" class="headerlink" title="configs"></a>configs</h4><p>授予每个service的配置文件访问.具体用法参考官网</p><h4 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h4><p>指定一个容器名,而不是使用默认名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name: my-web-container</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是由于容器名必须唯一,所以当扩展多个容器副本时,指定一个具体的容器名会报错,所以这个指令在swarm模式下部署stack时会被忽略</p></blockquote><h4 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h4><p>用于在多个services之间指定依赖性.service dependencies会导致以下行为</p><ul><li><code>docker-compose up</code> 启动时会参考depndency顺序.在下面这个例子中.db和redis服务会先于web服务启动</li><li><code>docker-compose up SERVICE</code>会自动启动该SERVICE的依赖服务.在下面例子中<code>docker-compose up web</code>命令会自动创建和启动db和redis</li><li><code>docker-compose stop</code>会参考依赖顺序而停止服务.在下面例子中,web服务会先于db和redis服务停止</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - redis</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure><blockquote><p>使用depens_on需要注意以下几点:</p><p>1.denpds_on只会在web依赖的服务启动后就启动web服务,而不是等待db和redis服务启动并且处于ready状态才启动web.这有可能会带来一些问题,比如mysql启动较慢,数据库还没准备好等.如果你需要确定后端的db,redis数据库启动成功,并且可以连接时才启动web服务,可以参考<a href="https://docs.docker.com/compose/startup-order/" target="_blank" rel="noopener">https://docs.docker.com/compose/startup-order/</a></p><p>2.version3版本不再支持depends_on下的condition指令</p><p>3.version3版本的depends_on选项在swarm模式下部署stack时会被忽略</p></blockquote><p>depends_on选项的控制启动顺序参考:</p><p>编写一个shell脚本循环判断后端的数据库是否ready.如果ready则执行CMD命令.然后在command指令中指定脚本的后端db数据库服务名,以及CMD命令参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"># wait-for-postgres.sh</span><br><span class="line">#循环测试db服务($1参数)的状态.一旦可以连接了,执行cmd命令(python app.py)</span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line">host=&quot;$1&quot;</span><br><span class="line">shift</span><br><span class="line">cmd=&quot;$@&quot;</span><br><span class="line"></span><br><span class="line">until PGPASSWORD=$POSTGRES_PASSWORD psql -h &quot;$host&quot; -U &quot;postgres&quot; -c &apos;\q&apos;; do</span><br><span class="line">  &gt;&amp;2 echo &quot;Postgres is unavailable - sleeping&quot;</span><br><span class="line">  sleep 1</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">&gt;&amp;2 echo &quot;Postgres is up - executing command&quot;</span><br><span class="line">exec $cmd</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command: [&quot;./wait-for-postgres.sh&quot;, &quot;db&quot;, &quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure><h4 id="deploy指令"><a href="#deploy指令" class="headerlink" title="deploy指令"></a>deploy指令</h4><p>该指令用于配置服务相关的配置和部署方式.这个指令只在version3版本支持,而且只在swarm模式下才生效.单机<code>docker-compose up</code>方式执行会被忽略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 6</span><br><span class="line">      update_config:</span><br><span class="line">        parallelism: 2</span><br><span class="line">        delay: 10s</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br></pre></td></tr></table></figure><p>下面是有关deploy的几个子指令介绍</p><ul><li>ENDPOINT_MODE</li></ul><blockquote><p>version 3.3 only</p></blockquote><p><code>endpoint_mode: VIP</code>  Docker为service分配一个虚拟IP.作为用户的前端入口.docker路由用户请求到所有可用的worker节点..这也是默认模式</p><p><code>endpoint_mode: dnsrr</code> DNS轮询服务,Docker发起一个service name的DNS查询,并且返回一个包含多个IP地址的列表.客户端通过轮询方式链接其中一个IP地址.</p><ul><li>LABLES</li></ul><p>为service指定一个标签.只对service生效,无法为service的具体某个容器生效</p><ul><li>MODE</li></ul><p>mode定义了在swarm节点上的副本部署模式,有global和replicated两种模式,默认是replicated</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  worker:</span><br><span class="line">    image: dockersamples/examplevotingapp_worker</span><br><span class="line">    deploy:</span><br><span class="line">      mode: global</span><br></pre></td></tr></table></figure><p>关于两种模式的区别参考:<a href="https://docs.docker.com/engine/swarm/how-swarm-mode-works/services/#replicated-and-global-services" target="_blank" rel="noopener">https://docs.docker.com/engine/swarm/how-swarm-mode-works/services/#replicated-and-global-services</a></p><ul><li>REPLACEMENT</li></ul><p>定义了constrants(约束条件)和preferences.的参数.</p><p>下面是constrants指令的用法:</p><p>constrants指令可以限制某个task在哪些swarm节点上运行.多个constrants指令是逻辑AND的关系来匹配满足条件的nodes.constrants可以匹配swarm节点或者Docker引擎标签:</p><table><thead><tr><th style="text-align:left">node attribute</th><th style="text-align:left">matches</th><th style="text-align:left">example</th></tr></thead><tbody><tr><td style="text-align:left"><code>node.id</code></td><td style="text-align:left">Node ID</td><td style="text-align:left"><code>node.id==2ivku8v2gvtg4</code></td></tr><tr><td style="text-align:left"><code>node.hostname</code></td><td style="text-align:left">Node hostname</td><td style="text-align:left"><code>node.hostname!=node-2</code></td></tr><tr><td style="text-align:left"><code>node.role</code></td><td style="text-align:left">Node role</td><td style="text-align:left"><code>node.role==manager</code></td></tr><tr><td style="text-align:left"><code>node.labels</code></td><td style="text-align:left">user defined node labels</td><td style="text-align:left"><code>node.labels.security==high</code></td></tr><tr><td style="text-align:left"><code>engine.labels</code></td><td style="text-align:left">Docker Engine’s labels</td><td style="text-align:left"><code>engine.labels.operatingsystem==ubuntu 14.04</code></td></tr></tbody></table><p>例如下面这个例子中限制redis service的task运行在lable标签等于queue的swarm节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker service create \</span><br><span class="line">  --name redis_2 \</span><br><span class="line">  --constraint &apos;node.labels.type == queue&apos; \</span><br><span class="line">  redis:3.0.6</span><br></pre></td></tr></table></figure><p>回到刚才REPLACEMENT的例子,下面的例子中表示db service只运行在swarm manager节点,而且docker node节点的操作系统是Ubuntu 14.04</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints:</span><br><span class="line">          - node.role == manager</span><br><span class="line">          - engine.labels.operatingsystem == ubuntu 14.04</span><br><span class="line">        preferences:</span><br><span class="line">          - spread: node.labels.zone</span><br></pre></td></tr></table></figure><ul><li>REPLICAS</li></ul><p>如果service 是replicated模式(默认模式),定义容器的启动数量.在下面的例子中启动6个worker容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  worker:</span><br><span class="line">    image: dockersamples/examplevotingapp_worker</span><br><span class="line">    networks:</span><br><span class="line">      - frontend</span><br><span class="line">      - backend</span><br><span class="line">    deploy:</span><br><span class="line">      mode: replicated</span><br><span class="line">      replicas: 6</span><br></pre></td></tr></table></figure><ul><li>RESOURCES</li></ul><p>配置容器限定的使用资源</p><p>在下面这个例子中.redis service被限制只允许使用不超过50M内存,以及0.5的CPU处理器时间(单个CPU内核的50%).并且有20M内存和0.25的CPU处理器时间预留(也就是永远为redis service保留)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    deploy:</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &apos;0.50&apos;</span><br><span class="line">          memory: 50M</span><br><span class="line">        reservations:</span><br><span class="line">          cpus: &apos;0.25&apos;</span><br><span class="line">          memory: 20M</span><br></pre></td></tr></table></figure><p><strong>Out Of Memory Exceptions[OOME]</strong></p><p>如果service 或者容器使用了超过限制的资源.容器或者docker引擎就会出现OOME错误.docker进程可能会被内核OOM killer给kill掉.关于如何规避这种问题,请参考<a href="https://docs.docker.com/config/containers/resource_constraints/" target="_blank" rel="noopener">understand the risks of running out of memory</a></p><ul><li>RESTART_POLICY</li></ul><p>配置当容器停止时如何重新启动容器的策略.有以下几种子指令</p><p>1.<code>condition</code> 重启容器的约束条件.有: <code>none</code>,<code>on-failure</code>,和<code>any</code>(default:any)</p><p>2.<code>delay</code>: 尝试重启容器的时间间隔.默认是0</p><p>3.<code>max_attempts</code>:如果容器重启失败,重启最大尝试次数,默认是一直尝试</p><p>4.<code>window</code>:重启后等待多久认定重启成功.默认是immediately</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    deploy:</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">        delay: 5s</span><br><span class="line">        max_attempts: 3</span><br><span class="line">        window: 120s</span><br></pre></td></tr></table></figure><h4 id="ROLLBACK-CONFIG"><a href="#ROLLBACK-CONFIG" class="headerlink" title="ROLLBACK_CONFIG"></a>ROLLBACK_CONFIG</h4><p>更新失败的回滚指令.</p><h4 id="UPDATE-CONFIG"><a href="#UPDATE-CONFIG" class="headerlink" title="UPDATE_CONFIG"></a>UPDATE_CONFIG</h4><p>配置service如何进行滚动更新.</p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>自定义DNS地址,可以是单个值或者一个列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dns: 8.8.8.8</span><br><span class="line"></span><br><span class="line">dns:</span><br><span class="line">  - 8.8.8.8</span><br><span class="line">  - 9.9.9.9</span><br></pre></td></tr></table></figure><h4 id="entrypoint"><a href="#entrypoint" class="headerlink" title="entrypoint"></a>entrypoint</h4><p>重写dockerfile或者镜像中的entrypoint指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">entrypoint: /code/entrypoint.sh</span><br><span class="line"></span><br><span class="line">#也可以是一个列表格式:</span><br><span class="line"></span><br><span class="line">entrypoint:</span><br><span class="line">    - php</span><br><span class="line">    - -d</span><br><span class="line">    - zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so</span><br><span class="line">    - -d</span><br><span class="line">    - memory_limit=-1</span><br><span class="line">    - vendor/bin/phpunit</span><br></pre></td></tr></table></figure><h4 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h4><p>添加环境变量文件,可以是单个值,也可以是个列表.该文件最好是在当前docker-compose文件目录或者子目录下.</p><p>如果是指定多个变量文件,而且有重复的变量且赋值不同,那么以最后一个变量文件的变量为准</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">  some-service:</span><br><span class="line">    env_file:</span><br><span class="line">      - a.env</span><br><span class="line">      - b.env</span><br></pre></td></tr></table></figure><h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h4><p>添加环境变量.可以使用列表格式,或者字典格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">  RACK_ENV: development</span><br><span class="line">  SHOW: &apos;true&apos;</span><br><span class="line">  SESSION_SECRET:</span><br><span class="line"></span><br><span class="line">environment:</span><br><span class="line">  - RACK_ENV=development</span><br><span class="line">  - SHOW=true</span><br><span class="line">  - SESSION_SECRET</span><br></pre></td></tr></table></figure><h4 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a>extra_hosts</h4><p>添加hostname和IP地址的绑定映射到hosts文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extra_hosts:</span><br><span class="line"> - &quot;somehost:162.242.195.82&quot;</span><br><span class="line"> - &quot;otherhost:50.31.209.229&quot;</span><br><span class="line"> </span><br><span class="line"> #会在容器内的/etc/hosts文件生成如何内容</span><br><span class="line">162.242.195.82  somehost</span><br><span class="line">50.31.209.229   otherhost</span><br></pre></td></tr></table></figure><h4 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a>healthcheck</h4><p>检查service的各个容器是否处于”healthy”状态.例如下面的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">healthcheck:</span><br><span class="line">  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;]</span><br><span class="line">  interval: 1m30s</span><br><span class="line">  timeout: 10s</span><br><span class="line">  retries: 3</span><br><span class="line">  start_period: 40s</span><br></pre></td></tr></table></figure><p><code>test</code>指令必须为一个字符串或者一个列表.如果是个上例子中的列表格式.则第一个参数必须为<code>NONE</code>,<code>CMD</code>,或者<code>CMD-SHELL</code>.如果是字符串相当于指定了<code>CMD-SHELL</code>参数</p><p>下面2个写法和上文的例子效果一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test: [&quot;CMD-SHELL&quot;, &quot;curl -f http://localhost || exit 1&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test: curl -f https://localhost || exit 1</span><br></pre></td></tr></table></figure><p>要关闭健康检查,可以使用<code>disable:true</code>.等同于<code>test:[&quot;NONE&quot;]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">healthcheck:</span><br><span class="line">  disable: true</span><br></pre></td></tr></table></figure><h4 id="image"><a href="#image" class="headerlink" title="image"></a>image</h4><p>指定容器的启动镜像.可以是指定的repository/tag 或者一个镜像ID.如果本地不存在该镜像,会尝试去pull镜像到本地.如果指定了<code>build</code>指定,会使用指定的命令来构建一个镜像</p><p>下面这几种写法均正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image: redis</span><br><span class="line">image: ubuntu:14.04</span><br><span class="line">image: tutum/influxdb</span><br><span class="line">image: example-registry.com:4000/postgresql</span><br><span class="line">image: a4bc65fd</span><br></pre></td></tr></table></figure><h4 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h4><p>service的log配置.下面的例子中指定了一个syslog服务器的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: syslog</span><br><span class="line">  options:</span><br><span class="line">    syslog-address: &quot;tcp://192.168.0.42:123&quot;</span><br></pre></td></tr></table></figure><p><code>driver</code>为容器指定logging的驱动,一共以下3种驱动方式,默认是json-file</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver: &quot;json-file&quot;</span><br><span class="line">driver: &quot;syslog&quot;</span><br><span class="line">driver: &quot;none&quot;</span><br></pre></td></tr></table></figure><p>也可以限定json-file驱动的日志转出.例如下列指定了最大的日志文件大小和日志保留份数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">options:</span><br><span class="line">  max-size: &quot;200k&quot;</span><br><span class="line">  max-file: &quot;10&quot;</span><br></pre></td></tr></table></figure><h4 id="network-mode"><a href="#network-mode" class="headerlink" title="network_mode"></a>network_mode</h4><p>指定网络模式,有以下几种网络模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">network_mode: &quot;bridge&quot;</span><br><span class="line">network_mode: &quot;host&quot;</span><br><span class="line">network_mode: &quot;none&quot;</span><br><span class="line">network_mode: &quot;service:[service name]&quot;</span><br><span class="line">network_mode: &quot;container:[container name/id]&quot;</span><br></pre></td></tr></table></figure><h4 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h4><p>services加入的网络.这些网络名在顶级<code>network</code>指令中有指定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">  some-service:</span><br><span class="line">    networks:</span><br><span class="line">     - some-network</span><br><span class="line">     - other-network</span><br></pre></td></tr></table></figure><h4 id="IPV4-ADDRESS-IPV6-ADDRESS"><a href="#IPV4-ADDRESS-IPV6-ADDRESS" class="headerlink" title="IPV4_ADDRESS,IPV6_ADDRESS"></a>IPV4_ADDRESS,IPV6_ADDRESS</h4><p>为容器指定一个静态的IP地址.但是对应的Network顶级指令中必须指定一个ipam块,定义该网络的IP子网范围.例如</p><p>app_net网络的ipam快中指定了172.16.238.0/24的子网.然后为app service指定一个静态IP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  app:</span><br><span class="line">    image: nginx:alpine</span><br><span class="line">    networks:</span><br><span class="line">      app_net:</span><br><span class="line">        ipv4_address: 172.16.238.10</span><br><span class="line">        ipv6_address: 2001:3984:3989::10</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  app_net:</span><br><span class="line">    ipam:</span><br><span class="line">      driver: default</span><br><span class="line">      config:</span><br><span class="line">        - subnet: &quot;172.16.238.0/24&quot;</span><br><span class="line">        - subnet: &quot;2001:3984:3989::/64&quot;</span><br></pre></td></tr></table></figure><h4 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h4><p>暴露端口.下面是几种短格式写法.推荐将端口用双引号括起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ports:</span><br><span class="line"> - &quot;3000&quot;</span><br><span class="line"> - &quot;3000-3005&quot;</span><br><span class="line"> - &quot;8000:8000&quot;</span><br><span class="line"> - &quot;9090-9091:8080-8081&quot;</span><br><span class="line"> - &quot;49100:22&quot;</span><br><span class="line"> - &quot;127.0.0.1:8001:8001&quot;</span><br><span class="line"> - &quot;127.0.0.1:5000-5010:5000-5010&quot;</span><br><span class="line"> - &quot;6060:6060/udp&quot;</span><br></pre></td></tr></table></figure><blockquote><p>此外还有完整格式的写法.</p></blockquote><h4 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h4><p>默认的restart策略是<code>no</code>有以下四种重启策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">restart: &quot;no&quot;</span><br><span class="line">restart: always</span><br><span class="line">restart: on-failure</span><br><span class="line">restart: unless-stopped</span><br></pre></td></tr></table></figure><h3 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a>sysctls</h3><p>配置容器的内核参数.可以是数组或者字典类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sysctls:</span><br><span class="line">  net.core.somaxconn: 1024</span><br><span class="line">  net.ipv4.tcp_syncookies: 0</span><br><span class="line">  </span><br><span class="line">sysctls:</span><br><span class="line">  - net.core.somaxconn=1024</span><br><span class="line">  - net.ipv4.tcp_syncookies=0</span><br></pre></td></tr></table></figure><h3 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a>ulimits</h3><p>配置ulimits</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ulimits:</span><br><span class="line">  nproc: 65535</span><br><span class="line">  nofile:</span><br><span class="line">    soft: 20000</span><br><span class="line">    hard: 40000</span><br></pre></td></tr></table></figure><h3 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h3><p>挂载一个路径或者一个卷.</p><p>如果是在service层级挂载宿主机上的路径到容器,那么不需要在顶级指令中定义<code>volumes</code>key.但是如果是挂载一个卷到多个service,可以在顶级指令中定义个卷名.然后使用这个卷名去挂载</p><p>下面这个例子在顶级<code>volumes</code>指令中定义了2个卷名:mydata和dbdata. mydata被web service挂载.dbdata被db service挂载.下面2个挂载格式都可以.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    image: nginx:alpine</span><br><span class="line">    volumes:</span><br><span class="line">      - type: volume</span><br><span class="line">        source: mydata</span><br><span class="line">        target: /data</span><br><span class="line">        volume:</span><br><span class="line">          nocopy: true</span><br><span class="line">      - type: bind</span><br><span class="line">        source: ./static</span><br><span class="line">        target: /opt/app/static</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres:latest</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/var/run/postgres/postgres.sock:/var/run/postgres/postgres.sock&quot;</span><br><span class="line">      - &quot;dbdata:/var/lib/postgresql/data&quot;</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  mydata:</span><br><span class="line">  dbdata:</span><br></pre></td></tr></table></figure><p>简短格式写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">  # Just specify a path and let the Engine create a volume</span><br><span class="line">  - /var/lib/mysql</span><br><span class="line"></span><br><span class="line">  # Specify an absolute path mapping</span><br><span class="line">  - /opt/data:/var/lib/mysql</span><br><span class="line"></span><br><span class="line">  # Path on the host, relative to the Compose file</span><br><span class="line">  - ./cache:/tmp/cache</span><br><span class="line"></span><br><span class="line">  # User-relative path</span><br><span class="line">  - ~/configs:/etc/configs/:ro</span><br><span class="line"></span><br><span class="line">  # Named volume</span><br><span class="line">  - datavolume:/var/lib/mysql</span><br></pre></td></tr></table></figure><p>完整格式写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    image: nginx:alpine</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - type: volume</span><br><span class="line">        source: mydata</span><br><span class="line">        target: /data</span><br><span class="line">        volume:</span><br><span class="line">          nocopy: true</span><br><span class="line">      - type: bind</span><br><span class="line">        source: ./static</span><br><span class="line">        target: /opt/app/static</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  mydata:</span><br></pre></td></tr></table></figure><hr><h2 id="Volume块级别配置文件指令"><a href="#Volume块级别配置文件指令" class="headerlink" title="Volume块级别配置文件指令"></a>Volume块级别配置文件指令</h2><p>大部分volume的用法在上面都已经解释过了,Volume的顶级指令配置不多.</p><h4 id="driver"><a href="#driver" class="headerlink" title="driver"></a>driver</h4><p>指定volume卷的驱动,docker引擎默认指定的驱动是<code>local</code>.</p><hr><h2 id="Network块级别配置文件指令"><a href="#Network块级别配置文件指令" class="headerlink" title="Network块级别配置文件指令"></a>Network块级别配置文件指令</h2><p>详细的docker network特性以及所有network驱动请见:<a href="https://docs.docker.com/compose/networking/" target="_blank" rel="noopener">Network guide</a></p><p>默认情况下Compose启动单一网络,一个services的每个容器加入到默认的网络,并且该网络下的所有容器之间都能互相访问</p><p>假如下面的compose文件在<code>myapp</code>目录下.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8000:8000&quot;</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8001:5432&quot;</span><br></pre></td></tr></table></figure><p>当执行<code>docker-compose up</code>命令启动时,会执行以下几个步骤</p><p>1.创建一个<code>myapp_default</code>的网络</p><p>2.使用web的配置文件启动一个容器,加入到<code>myapp_default</code>网络中</p><p>3.使用db的配置文件启动一个容器.加入到<code>myapp_default</code>的网络中</p><p>所有容器成功启动后,每个容器都能访问对方的<code>hostname</code>和对方的IP地址.</p><p>另外,需要理解<code>HOST_PORT</code>和<code>COMTAINER_PORT</code>的区别.在上面这个例子中,db的<code>host_port</code>是8001,容器的端口是5432,services之间的容器都是通过<code>CONTAINER_PORT</code>也就是容器的IP进行通信的.例如访问数据库地址应该是:<code>postgres://db:5432</code></p><h4 id="driver-1"><a href="#driver-1" class="headerlink" title="driver"></a>driver</h4><p>指定网络驱动.在单主机下Docker引擎默认使用<code>bridge</code>模式.在swarm集群环境中,默认使用<code>overlay</code>模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver: overlay</span><br></pre></td></tr></table></figure><hr><h2 id="configs和secrets块级别配置文件指令"><a href="#configs和secrets块级别配置文件指令" class="headerlink" title="configs和secrets块级别配置文件指令"></a>configs和secrets块级别配置文件指令</h2><p>还不是很懂这个怎么用的,以后有空再研究</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;docker学习笔记——docker-compose&quot;&gt;&lt;a href=&quot;#docker学习笔记——docker-compose&quot; class=&quot;headerlink&quot; title=&quot;docker学习笔记——docker-compose&quot;&gt;&lt;/a&gt;docker学习笔记——docker-compose&lt;/h2&gt;&lt;p&gt;docker compose 定义并且运行多个docker容器.使用YAML风格文件定义一个compose文件.利用compose文件创建和启动所有服务.&lt;/p&gt;
&lt;p&gt;使用docker compose基本只需要3个步骤&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在Dockerfile文件定义app环境&lt;/li&gt;
&lt;li&gt;在docker-compose.yml文件中定义组成app的各个服务&lt;/li&gt;
&lt;li&gt;run docker-compose up 和compose 启动和运行app&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面文档均可以在docker-compose官方找到详细资料:&lt;a href=&quot;https://docs.docker.com/compose/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;docker-compose&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;docker-compose安装&quot;&gt;&lt;a href=&quot;#docker-compose安装&quot; class=&quot;headerlink&quot; title=&quot;docker-compose安装&quot;&gt;&lt;/a&gt;docker-compose安装&lt;/h3&gt;
    
    </summary>
    
      <category term="docker" scheme="https://jesse.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://jesse.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>kubernets探针</title>
    <link href="https://jesse.top/2020/06/26/kubernetes/kubernetes%E6%8E%A2%E9%92%88/"/>
    <id>https://jesse.top/2020/06/26/kubernetes/kubernetes探针/</id>
    <published>2020-06-26T03:59:58.000Z</published>
    <updated>2020-06-30T12:32:51.212Z</updated>
    
    <content type="html"><![CDATA[<h2 id="kubernets探针"><a href="#kubernets探针" class="headerlink" title="kubernets探针"></a>kubernets探针</h2><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>kubernetes一共有2种探针:</p><p><strong>存活探针</strong></p><p><strong>就绪探针</strong></p><hr><h2 id="就绪探针"><a href="#就绪探针" class="headerlink" title="就绪探针"></a>就绪探针</h2><h3 id="就绪探针工作介绍"><a href="#就绪探针工作介绍" class="headerlink" title="就绪探针工作介绍"></a>就绪探针工作介绍</h3><p>就绪探针会定期调用,检查特定的pod是否准备就绪接收客户端的请求.当容器启动时,会等待一个时间,然后执行第一次准备就绪检查.如果某个Pod没有通过探针探测,则会从服务中删除该pod,如果pod再次准备就绪,则会重新添加到Service</p><p>就绪探针确保客户端只与正常的Pod交互.</p><hr><h3 id="就绪探针的类型"><a href="#就绪探针的类型" class="headerlink" title="就绪探针的类型"></a>就绪探针的类型</h3><ul><li>Exec探针 . 使用command命令,如果命令结果返回0,则说明pod准备就绪.</li><li>HTTP GET探针. 向容器发送HTTP GET.通过响应状态码判断pod容器是否准备好</li><li>TCP socket探针.尝试连接Pod容器的TCP端口.判断pod容器的某个端口是否正常工作</li></ul><hr><a id="more"></a><h3 id="向pod容器添加探针"><a href="#向pod容器添加探针" class="headerlink" title="向pod容器添加探针"></a>向pod容器添加探针</h3><p>编辑kubia的rc配置文件,在spec.containers下添加readinessProbe配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ReplicationController</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia</span><br><span class="line">spec:</span><br><span class="line">  replicas: 4</span><br><span class="line">  selector:</span><br><span class="line">      app: kubia</span><br><span class="line">  template:</span><br><span class="line">    metadata:</span><br><span class="line">      labels:</span><br><span class="line">        app: kubia</span><br><span class="line"></span><br><span class="line">    spec:</span><br><span class="line">      containers:</span><br><span class="line">        - name: kubia</span><br><span class="line">          image: luksa/kubia</span><br><span class="line">          ports:</span><br><span class="line">          - containerPort: 8080</span><br><span class="line">          readinessProbe:</span><br><span class="line">            exec: #存活探针类型</span><br><span class="line">              command: #探针命令</span><br><span class="line">                - ls</span><br><span class="line">                - /var/ready</span><br></pre></td></tr></table></figure><blockquote><p>重新编辑rc文件后,存活探针并不会对已经存在的Pod生效.删除所有pod,等待rc重新创建</p></blockquote><p>让yaml文件生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl apply -f kubia-rc.yaml</span><br><span class="line">replicationcontroller/kubia unchanged</span><br></pre></td></tr></table></figure><p>删除Pods,重新创建后,查看pods的状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl get pods</span><br><span class="line">NAME                READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia-6gvhg         0/1     Running   0          61s</span><br><span class="line">kubia-qlpdt         0/1     Running   0          61s</span><br><span class="line">kubia-w8c82         0/1     Running   0          61s</span><br><span class="line">kubia-w9spj         0/1     Running   0          61s</span><br></pre></td></tr></table></figure><p>pods的READY是0.表示pod容器虽然正在运行中,但是未准备就绪</p><p>向其中一个pod容器创建/var/ready文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl exec kubia-6gvhg -- touch /var/ready</span><br></pre></td></tr></table></figure><p>但是容器并不会马上就绪.这是因为pod默认每隔10s探测一次.通过<code>kubectl describe pod kubia-6gvhg</code>可以看到就绪探针的策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl describe pods kubia-6gvhg</span><br><span class="line"></span><br><span class="line">Readiness:      exec [ls /var/ready] delay=0s timeout=1s period=10s #success=1 #failure=3</span><br><span class="line">Warning  Unhealthy  2m53s (x30 over 7m43s)  kubelet, k8s-node2  Readiness probe failed: ls: cannot access /var/ready: No such file or directory</span><br></pre></td></tr></table></figure><p>10s后,可以看到就只有一个pod准备就绪</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl get pods</span><br><span class="line">NAME                READY   STATUS    RESTARTS   AGE</span><br><span class="line">kubia-6gvhg         1/1     Running   0          9m45s</span><br><span class="line">kubia-qlpdt         0/1     Running   0          9m45s</span><br><span class="line">kubia-w8c82         0/1     Running   0          9m45s</span><br><span class="line">kubia-w9spj         0/1     Running   0          9m45s</span><br></pre></td></tr></table></figure><p>通过测试发现,客户端的请求永远只转发到已经准备就绪的Pod容器内,而其他容器则不接受请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[work@k8s-node1 ~]$ while true;do curl http://10.96.170.37;sleep 1;done</span><br><span class="line">You&apos;ve hit kubia-6gvhg</span><br><span class="line">You&apos;ve hit kubia-6gvhg</span><br><span class="line">You&apos;ve hit kubia-6gvhg</span><br><span class="line">You&apos;ve hit kubia-6gvhg</span><br><span class="line">You&apos;ve hit kubia-6gvhg</span><br><span class="line">You&apos;ve hit kubia-6gvhg</span><br><span class="line">You&apos;ve hit kubia-6gvhg</span><br></pre></td></tr></table></figure><p>其他两种探测类型的是否方法也类似</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;kubernets探针&quot;&gt;&lt;a href=&quot;#kubernets探针&quot; class=&quot;headerlink&quot; title=&quot;kubernets探针&quot;&gt;&lt;/a&gt;kubernets探针&lt;/h2&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;kubernetes一共有2种探针:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;存活探针&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;就绪探针&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&quot;就绪探针&quot;&gt;&lt;a href=&quot;#就绪探针&quot; class=&quot;headerlink&quot; title=&quot;就绪探针&quot;&gt;&lt;/a&gt;就绪探针&lt;/h2&gt;&lt;h3 id=&quot;就绪探针工作介绍&quot;&gt;&lt;a href=&quot;#就绪探针工作介绍&quot; class=&quot;headerlink&quot; title=&quot;就绪探针工作介绍&quot;&gt;&lt;/a&gt;就绪探针工作介绍&lt;/h3&gt;&lt;p&gt;就绪探针会定期调用,检查特定的pod是否准备就绪接收客户端的请求.当容器启动时,会等待一个时间,然后执行第一次准备就绪检查.如果某个Pod没有通过探针探测,则会从服务中删除该pod,如果pod再次准备就绪,则会重新添加到Service&lt;/p&gt;
&lt;p&gt;就绪探针确保客户端只与正常的Pod交互.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;就绪探针的类型&quot;&gt;&lt;a href=&quot;#就绪探针的类型&quot; class=&quot;headerlink&quot; title=&quot;就绪探针的类型&quot;&gt;&lt;/a&gt;就绪探针的类型&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Exec探针 . 使用command命令,如果命令结果返回0,则说明pod准备就绪.&lt;/li&gt;
&lt;li&gt;HTTP GET探针. 向容器发送HTTP GET.通过响应状态码判断pod容器是否准备好&lt;/li&gt;
&lt;li&gt;TCP socket探针.尝试连接Pod容器的TCP端口.判断pod容器的某个端口是否正常工作&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="kubernetes" scheme="https://jesse.top/categories/kubernetes/"/>
    
    
      <category term="k8s" scheme="https://jesse.top/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>kubernetes headless Service</title>
    <link href="https://jesse.top/2020/06/26/kubernetes/kubernetes%20StatefulSet/"/>
    <id>https://jesse.top/2020/06/26/kubernetes/kubernetes StatefulSet/</id>
    <published>2020-06-26T03:59:58.000Z</published>
    <updated>2020-06-30T12:32:51.211Z</updated>
    
    <content type="html"><![CDATA[<h2 id="kubernetes-StatefulSet"><a href="#kubernetes-StatefulSet" class="headerlink" title="kubernetes StatefulSet"></a>kubernetes StatefulSet</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>​     我们之前学习过ReplicaController(RC),ReplicaSet(RS),Deployment(deploy)等,这些资源均可以通过一个Pod模板创建多个Pod副本.这些pod除了IP和名字不一样外,其他均一模一样.</p><p>​     如果pod模板关联到特定的持久卷声明,那么这些pod都共享同一个存储.这些pod是完全一样,也无所谓运行在哪个节点上.可以任何删除和替换.</p><p>​     但是在实际场景中,并不是所有的应用都满足这样的要求.比如主从关系,主备关系,数据存储类应用等.这些场景每个pod都会在本地保留一份数据,而且与其他Pod有数据对应关系.如果pod一旦被删除,即便新创建个pod出来,实例之间的对应关系也会失败,从而导致应用失败.</p><p>   为了支持有状态的应用,Kubernetes在Deployment的基础上扩展出了StatefulSet资源</p><hr><h3 id="StatefulSet-特点"><a href="#StatefulSet-特点" class="headerlink" title="StatefulSet 特点"></a>StatefulSet 特点</h3><p>statefulSet的特点即是有状态的应用特点:</p><ol><li><p>稳定且需要唯一的网络标识符;</p><ul><li>这要求pod的主机名和IP地址永久不变,即使删除了一个pod,新创建的Pod也必须继承前一个Pod的主机标识符</li></ul></li></ol><ol start="2"><li><p>稳定且持久的存储;</p><ul><li>可实现持久存储,新增或者减少pod,存储不会随之变化,并且删除一个pod时,关联到此pod的存储不会随之删除</li></ul></li><li><p>要求有序,平滑的部署和扩展</p><ul><li>在Mysql等集群,要先启动主节点,然后启动从节点,第二从节点等等</li></ul></li><li><p>要求有序,平滑的终止和删除</p><ul><li>同样,应用的终止和删除也是有顺序的,按照启动的逆序进行.例如Mysql启动时,先启动主节点,再启动从节点.终止的时候,先关闭从节点,再关闭主节点</li></ul></li><li><p>有序的滚动更新</p><ul><li>在Mysql更新时,也应该先更新所有从节点.最后更新主节点</li></ul></li></ol><a id="more"></a><hr><h3 id="StatefulSet-依赖组件"><a href="#StatefulSet-依赖组件" class="headerlink" title="StatefulSet 依赖组件"></a>StatefulSet 依赖组件</h3><p>结合以上的特点,StatefulSet依赖以下组件:</p><ul><li>headless service(无头服务): 用于DNS发现各pod网络地址</li><li>pv存储卷: 底层存储卷</li><li>volumeClaimTemplate(PVC申请模板): 用于每个Pod申请独立的存储卷</li></ul><hr><h3 id="headless-Service"><a href="#headless-Service" class="headerlink" title="headless Service"></a>headless Service</h3><p>​     我们以前学习过,Service是Kubernetes项目中用来将一组Pod暴露给外界访问的一种机制.外部客户端通过Service地址可以随机访问到某个具体的Pod</p><p>​     之前学过几种Service类型,包括nodeport,loadbalancer等等.所有这类Service都有一个VIP(虚拟IP),访问Service VIP,Service会将请求转发到后端的Pod上,</p><p>​     还有一种Service是Headless Service(无头服务),这类Service自身不需要VIP,当DNS解析该Service时,会解析出Service后端的Pod地址.这样设置的好处是Kubernetes项目为Pod分配唯一的”可解析身份”,只要知道一个pod的名字和对应的Headless Service名字,就可以通过这条DNS访问到后端的Pod</p><hr><h3 id="持久存储"><a href="#持久存储" class="headerlink" title="持久存储"></a>持久存储</h3><p>我们知道通过headless Service使Pod有一个稳定的网络标识,那么存储呢?有状态的应用必须有自己独立的存储,即便这个pod被删除,新创建出来的pod(新pod与旧pod拥有相同的网络表示)也必须挂载相同的存储.</p><p>​      之前在学习kubernetes的存储时,我们学习过PV,PVC存储卷,通过pod模板关联一个持久卷声明就可以为pod提供一个持久卷存储.因为持久卷声明(PVC)和持久卷(PV)是一对一关系.但是之前接触过的ReplicationController,ReplicaSet,Deployment等资源创建的pod是同一个模板创建的,所以共享的是同一个持久卷存储.而StatefulSet要求每个pod都需要有独立的持久卷声明和存储.所以StatefulSet要求关联到一个或多个不同的持久卷声明模板.这些持久卷声明会在pod创建之前准备就绪,并且关联到每个pod中.</p><hr><h3 id="持久卷的创建和删除"><a href="#持久卷的创建和删除" class="headerlink" title="持久卷的创建和删除"></a>持久卷的创建和删除</h3><p>​      扩容一个StatefulSet副本时,会创建2个或者多个对象: pod实例已经与之关联的一个或者多个持久卷声明.但是当StatefulSet缩容时,只会删除一个Pod,而留下持久卷声明.这就意味着删除Pod时,与pod关联的持久卷存储数据并不会被删除.如果持久卷声明被手动删除,那么持久卷上的数据则会消失.</p><p>​     因为缩容会保留持久卷声明,所以在随后的扩容操作中,新的pod实例会使用绑定在持久卷上相同的声明和其上的数据.所以如果因为误操作而缩容一个StatefulSet副本后,可以做一次扩容操作,新的pod实例会运行到与之前完全一致的状态,甚至连pod名字也是一样的</p><hr><h3 id="部署StatefulSet应用"><a href="#部署StatefulSet应用" class="headerlink" title="部署StatefulSet应用"></a>部署StatefulSet应用</h3><p>部署StatefulSet应用之前,需要创建几个不同类型的对象.</p><ul><li><p>一个演示用的docker镜像</p></li><li><p>存储数据文件的持久卷(PV)</p></li><li><p>一个Headless Service服务实例</p></li><li><p>Statefulset模板</p></li></ul><h4 id="准备一个docker镜像"><a href="#准备一个docker镜像" class="headerlink" title="准备一个docker镜像"></a>准备一个docker镜像</h4><p>这里使用书上提供的luksa/kubia-pet镜像,这个镜像是一个Node应用,当应用接收到一个POST请求时,将请求中的body写入到某个文件,当接收到一个GET请求时,返回pod主机名以及改文件中的内容.</p><h4 id="创建持久化存储卷-pv"><a href="#创建持久化存储卷-pv" class="headerlink" title="创建持久化存储卷(pv)"></a>创建持久化存储卷(pv)</h4><p>因为稍后会调度StatefulSet创建3个副本.所以这里需要3个持久卷.如果计划调度更多的副本,则需要创建更多的持久卷..</p><p>之前在学习存储知识的时候介绍过存储卷,所以具体不演示,以下是创建3个PV持久卷的配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[root@k8s-master</span> <span class="string">~]#</span> <span class="string">cat</span> <span class="string">statefulset-kubia-pv.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="comment">#创建一个List列表资源,List的items下列出每个PV的配置</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">List</span></span><br><span class="line"><span class="attr">items:</span></span><br><span class="line"><span class="attr">  - apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">    kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">pv-1</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">       capacity:</span></span><br><span class="line"><span class="attr">         storage:</span> <span class="number">1</span><span class="string">Gi</span></span><br><span class="line"><span class="attr">       accessModes:</span></span><br><span class="line"><span class="bullet">         -</span> <span class="string">ReadWriteOnce</span></span><br><span class="line"><span class="attr">       persistentVolumeReclaimPolicy:</span> <span class="string">Recycle</span></span><br><span class="line"><span class="attr">       storageClassName:</span> <span class="string">nfs</span></span><br><span class="line"><span class="attr">       nfs:</span></span><br><span class="line"><span class="attr">         path:</span> <span class="string">/data/k8s/pv-1</span></span><br><span class="line"><span class="attr">         server:</span> <span class="number">172.16</span><span class="number">.20</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">    kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">pv-2</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">       capacity:</span></span><br><span class="line"><span class="attr">         storage:</span> <span class="number">1</span><span class="string">Gi</span></span><br><span class="line"><span class="attr">       accessModes:</span></span><br><span class="line"><span class="bullet">         -</span> <span class="string">ReadWriteOnce</span></span><br><span class="line"><span class="attr">       persistentVolumeReclaimPolicy:</span> <span class="string">Recycle</span></span><br><span class="line"><span class="attr">       storageClassName:</span> <span class="string">nfs</span></span><br><span class="line"><span class="attr">       nfs:</span></span><br><span class="line"><span class="attr">         path:</span> <span class="string">/data/k8s/pv-2</span></span><br><span class="line"><span class="attr">         server:</span> <span class="number">172.16</span><span class="number">.20</span><span class="number">.1</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  - apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">    kind:</span> <span class="string">PersistentVolume</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      name:</span> <span class="string">pv-3</span></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">       capacity:</span></span><br><span class="line"><span class="attr">         storage:</span> <span class="number">1</span><span class="string">Gi</span></span><br><span class="line"><span class="attr">       accessModes:</span></span><br><span class="line"><span class="bullet">         -</span> <span class="string">ReadWriteOnce</span></span><br><span class="line"><span class="attr">       persistentVolumeReclaimPolicy:</span> <span class="string">Recycle</span></span><br><span class="line"><span class="attr">       storageClassName:</span> <span class="string">nfs</span></span><br><span class="line"><span class="attr">       nfs:</span></span><br><span class="line"><span class="attr">         path:</span> <span class="string">/data/k8s/pv-3</span></span><br><span class="line"><span class="attr">         server:</span> <span class="number">172.16</span><span class="number">.20</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><blockquote><p>以前接触过在yaml文件中添加—3个横杠使的在一个文件中可以区分定义多个资源,这次定义一个List对象,然后把各个资源作为List对象的各个项目.这2种方法均可以在一个YAML文件中定义多个资源</p></blockquote><p>现在已经定义了个3个底层的PV持久卷</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl get pv</span><br><span class="line">NAME    CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM   STORAGECLASS   REASON   AGE</span><br><span class="line">mypv1   1Gi        RWO,ROX        Recycle          Available           nfs                     12d</span><br><span class="line">pv-1    1Gi        RWO            Recycle          Available           nfs                     4s</span><br><span class="line">pv-2    1Gi        RWO            Recycle          Available           nfs                     4s</span><br><span class="line">pv-3    1Gi        RWO            Recycle          Available           nfs                     4s</span><br></pre></td></tr></table></figure><hr><h3 id="创建Headless-Service"><a href="#创建Headless-Service" class="headerlink" title="创建Headless Service"></a>创建Headless Service</h3><p>下面是headless service的配置文件,唯一需要注意的是该类型服务的clusterIP属性必须为None</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiVersion:</span> <span class="string">v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">Service</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">statefulset-kubia-svc</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  clusterIP:</span> <span class="string">None</span></span><br><span class="line">  <span class="comment">#所有标签为statefulset-kubia的Pod都属于这个Service</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    app:</span> <span class="string">statefulset-kubia</span></span><br><span class="line"><span class="attr">  ports:</span></span><br><span class="line"><span class="attr">    - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">      port:</span> <span class="number">80</span></span><br></pre></td></tr></table></figure><p>创建服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl get svc</span><br><span class="line">NAME                    TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)        AGE</span><br><span class="line">statefulset-kubia-svc   ClusterIP      None            &lt;none&gt;        80/TCP         3s</span><br></pre></td></tr></table></figure><hr><h3 id="创建Statefuleset"><a href="#创建Statefuleset" class="headerlink" title="创建Statefuleset"></a>创建Statefuleset</h3><p>​      statefulset资源的配置和RS,deployment等没有太大的区别,这里使用了一个新的组件volumeClaimTemplates.其中定义了一个持久卷声明.该组件会为每个Pod创建一个独立的持久卷声明.</p><p>​      这个组件是在statefulset资源的spec全局对象下,虽然在pod的template模板中并没有创建持久卷声明(而是直接通过volumeMounts属性来挂在).但是Statefulset在创建时,会自动将volumeClaimTemplate定义的持久卷声明关联到pod中.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[root@k8s-master</span> <span class="string">~]#</span> <span class="string">cat</span> <span class="string">statefulset-kubia.yaml</span></span><br><span class="line"><span class="attr">apiVersion:</span> <span class="string">apps/v1</span></span><br><span class="line"><span class="attr">kind:</span> <span class="string">StatefulSet</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">  name:</span> <span class="string">statefulset-kubia-v1</span></span><br><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  serviceName:</span> <span class="string">statefulset-kubia-v1</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">3</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">       app:</span> <span class="string">statefulset-kubia</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  template:</span></span><br><span class="line"><span class="attr">    metadata:</span></span><br><span class="line"><span class="attr">      labels:</span></span><br><span class="line"><span class="attr">        app:</span> <span class="string">statefulset-kubia</span></span><br><span class="line"></span><br><span class="line"><span class="attr">    spec:</span></span><br><span class="line"><span class="attr">      containers:</span></span><br><span class="line"><span class="attr">      - name:</span> <span class="string">statefulset-kubia</span></span><br><span class="line"><span class="attr">        image:</span> <span class="string">luksa/kubia-pet</span></span><br><span class="line"><span class="attr">        ports:</span></span><br><span class="line"><span class="attr">          - name:</span> <span class="string">http</span></span><br><span class="line"><span class="attr">            containerPort:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">        volumeMounts:</span></span><br><span class="line"><span class="attr">            - name:</span> <span class="string">data</span></span><br><span class="line"><span class="attr">              mountPath:</span> <span class="string">/var/data</span></span><br><span class="line"></span><br><span class="line"><span class="attr">  volumeClaimTemplates:</span></span><br><span class="line"><span class="attr">       - metadata:</span></span><br><span class="line"><span class="attr">           name:</span> <span class="string">data</span></span><br><span class="line"><span class="attr">         spec:</span></span><br><span class="line"><span class="attr">           resources:</span></span><br><span class="line"><span class="attr">              requests:</span></span><br><span class="line"><span class="attr">                 storage:</span> <span class="number">1</span><span class="string">Gi</span></span><br><span class="line"><span class="attr">           storageClassName:</span> <span class="string">nfs</span></span><br><span class="line"><span class="attr">           accessModes:</span></span><br><span class="line"><span class="bullet">             -</span> <span class="string">ReadWriteOnce</span></span><br></pre></td></tr></table></figure><blockquote><p>注意:volumeClaimTemplates组件一定要声明存储类型storageClassName,如果没有声明这一点则Pod一直处于Pending状态.并且会有以下报错信息</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl describe po statefulset-kubia-v1-0</span><br><span class="line"></span><br><span class="line">  Warning  FailedScheduling  &lt;unknown&gt;  default-scheduler  error while running &quot;VolumeBinding&quot; filter plugin for pod &quot;statefulset-kubia-v1-0&quot;: pod has unbound immediate PersistentVolumeClaims</span><br></pre></td></tr></table></figure><p>查看PVC提示没有找到PV</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl describe pvc data-statefulset-kubia-v1-0</span><br><span class="line">Events:</span><br><span class="line">  Type    Reason         Age                  From                         Message</span><br><span class="line">  ----    ------         ----                 ----                         -------</span><br><span class="line">  Normal  FailedBinding  55s (x182 over 45m)  persistentvolume-controller  no persistent volumes available for this claim and no storage class is set</span><br></pre></td></tr></table></figure><p>   创建statefulset资源,列出pod资源.和rs,rc,deployment不同的是,他们会一次性创建完所有的pod,而statefulset会在每一个pod完全就绪后,才会创建第二个.</p><p>​    statefulset这样做是因为:状态明确的集群应用对同事有2个集群成员启动引起的竞争情况是非常敏感的.所以依次启动每个成员是比较安全可靠的.</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[root@k8s-master</span> <span class="string">~]#</span> <span class="string">kubectl</span> <span class="string">get</span> <span class="string">pods</span></span><br><span class="line"><span class="string">NAME</span>                     <span class="string">READY</span>   <span class="string">STATUS</span>    <span class="string">RESTARTS</span>   <span class="string">AGE</span></span><br><span class="line"><span class="string">statefulset-kubia-v1-0</span>   <span class="number">0</span><span class="string">/1</span>     <span class="string">Pending</span>   <span class="number">0</span>          <span class="number">74</span><span class="string">s</span></span><br></pre></td></tr></table></figure><hr><p>现在3个Pod副本都已经被创建完成.</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl get pods</span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">statefulset-kubia-v1-0   1/1     Running   0          12m</span><br><span class="line">statefulset-kubia-v1-1   1/1     Running   0          12m</span><br><span class="line">statefulset-kubia-v1-2   1/1     Running   0          12m</span><br></pre></td></tr></table></figure><p>statefulset自动创建了3个PVC,并且各自与3个pv自动关联</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># kubectl get pvc</span></span><br><span class="line">NAME                          STATUS   VOLUME   CAPACITY   ACCESS MODES   STORAGECLASS   AGE</span><br><span class="line">data-statefulset-kubia-v1-0   Bound    pv-2     1Gi        RWO            nfs            11m</span><br><span class="line">data-statefulset-kubia-v1-1   Bound    pv-3     1Gi        RWO            nfs            11m</span><br><span class="line">data-statefulset-kubia-v1-2   Bound    pv-1     1Gi        RWO            nfs            11m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[root@k8s-master ~]<span class="comment"># kubectl get pv</span></span><br><span class="line">NAME   CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS   CLAIM                                 STORAGECLASS   REASON   AGE</span><br><span class="line">pv-1   1Gi        RWO            Recycle          Bound    default/data-statefulset-kubia-v1-2   nfs                     5h18m</span><br><span class="line">pv-2   1Gi        RWO            Recycle          Bound    default/data-statefulset-kubia-v1-0   nfs                     5h18m</span><br><span class="line">pv-3   1Gi        RWO            Recycle          Bound    default/data-statefulset-kubia-v1-1   nfs                     5h18m</span><br><span class="line">[root@k8s-master ~]<span class="comment">#</span></span><br></pre></td></tr></table></figure><p>​       和RS,RC,Deployment等资源不同的是,Statefulset部署的pod名称并非是随机的,而是pod模板名加上一个序号,这个序号从0开始,依次增加.</p><p>​       PVC的名称格式是PVC的名字+pod名.每个pod自动创建一个PVC,并且该PVC自动关联到一个后端的PV持久卷</p><hr><h3 id="访问POD"><a href="#访问POD" class="headerlink" title="访问POD"></a>访问POD</h3><p>​     由于创建的Service类型是Headless service模式,所以不能通过它来访问pod,而是需要直接连接到每个后端单独的pod.(或者是创建一个普通的Service,但是这样也不允许访问指定的pod)</p><p>​    这次介绍如何通过API服务器与pod通信.API服务器可以通过代理直接连接到指定的pod.可以通过如下的URL</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;apiServerHost&gt;:&lt;port&gt;/api/v1/namespaces/default/pods/pods名称/proxy/&lt;path&gt;</span><br></pre></td></tr></table></figure><p> 在k8s的master节点运行下面命令,下面命令运行一个kubectl proxy.从而可以让proxy去API服务器通信,而不必使用麻烦的授权和SSL证书来直接与API服务器通信</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl proxy</span><br></pre></td></tr></table></figure><p>现在就可以直接访问Pod了.开启另一个master服务器终端.通过curl访问某个Pod.比如访问statefulset-kubia-v1-0这个Pod容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# curl localhost:8001/api/v1/namespaces/default/pods/statefulset-kubia-v1-0/proxy/</span><br><span class="line">You&apos;ve hit statefulset-kubia-v1-0</span><br><span class="line">Data stored on this pod: No data posted yet</span><br></pre></td></tr></table></figure><p>这种访问方式经过了2层的中间代理:</p><h5 id="1-curl命令发送给kubectl-proxy"><a href="#1-curl命令发送给kubectl-proxy" class="headerlink" title="1.curl命令发送给kubectl proxy"></a>1.curl命令发送给kubectl proxy</h5><h5 id="2-kubectl-proxy-带上认证TOKEN转发给API服务器"><a href="#2-kubectl-proxy-带上认证TOKEN转发给API服务器" class="headerlink" title="2. kubectl proxy 带上认证TOKEN转发给API服务器"></a>2. kubectl proxy 带上认证TOKEN转发给API服务器</h5><h5 id="3-API服务器再通过pod容器的实际IP地址将请求转发到后端的Pod"><a href="#3-API服务器再通过pod容器的实际IP地址将请求转发到后端的Pod" class="headerlink" title="3. API服务器再通过pod容器的实际IP地址将请求转发到后端的Pod"></a>3. API服务器再通过pod容器的实际IP地址将请求转发到后端的Pod</h5><p>下面是发送一个post请求到statefulset-kubia-v1-0的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# curl -X POST -d &quot;Hey There ! This greeting was submitted to statefulset-kubia-v1-0&quot; \</span><br><span class="line">&gt; localhost:8001/api/v1/namespaces/default/pods/statefulset-kubia-v1-0/proxy/</span><br><span class="line">Data stored on pod statefulset-kubia-v1-0</span><br><span class="line"></span><br><span class="line">#再次用GET请求,就可以返回刚才POST提交的数据</span><br><span class="line">[root@k8s-master ~]# curl localhost:8001/api/v1/namespaces/default/pods/statefulset-kubia-v1-0/proxy/</span><br><span class="line">You&apos;ve hit statefulset-kubia-v1-0</span><br><span class="line">Data stored on this pod: Hey There ! This greeting was submitted to statefulset-kubia-v1-0</span><br></pre></td></tr></table></figure><p>当我们访问其他的pod容器时,并没有返回写入的数据,这和期望的一致,说明每个节点都有各自独立的存储状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# curl localhost:8001/api/v1/namespaces/default/pods/statefulset-kubia-v1-1/proxy/</span><br><span class="line">You&apos;ve hit statefulset-kubia-v1-1</span><br><span class="line">Data stored on this pod: No data posted yet</span><br></pre></td></tr></table></figure><hr><h3 id="删除pod-重新调度"><a href="#删除pod-重新调度" class="headerlink" title="删除pod,重新调度"></a>删除pod,重新调度</h3><p>之前我们在statefulset-kubia-v1-0这个pod节点写入了一条数据,这次我们删除这个Pod,等它被重新调度,然后检查它是否还会返回与之前一致的数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl delete po statefulset-kubia-v1-0</span><br><span class="line">pod &quot;statefulset-kubia-v1-0&quot; deleted</span><br><span class="line"></span><br><span class="line">[root@k8s-master ~]# kubectl get po</span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE</span><br><span class="line">statefulset-kubia-v1-0   1/1     Running   0          2m</span><br><span class="line">statefulset-kubia-v1-1   1/1     Running   0          17h</span><br><span class="line">statefulset-kubia-v1-2   1/1     Running   0          17h</span><br><span class="line"></span><br><span class="line">[root@k8s-master ~]# curl localhost:8001/api/v1/namespaces/default/pods/statefulset-kubia-v1-0/proxy/</span><br><span class="line">You&apos;ve hit statefulset-kubia-v1-0</span><br><span class="line">Data stored on this pod: Hey There ! This greeting was submitted to statefulset-kubia-v1-0</span><br><span class="line">[root@k8s-master ~]#</span><br></pre></td></tr></table></figure><blockquote><p>删除一个Pod,当Pod重新被调度时不一定是原节点,有可能会调度到另外一个节点</p></blockquote><p>从上面的实验中可以得出2个结论:</p><ul><li>statefulset的pod被重新调度时,会新创建一个和之前一模一样的Pod(包括主机名称,pod名,存储)</li><li>当pod被删除,重新调度后持久化数据与之前一模一样.</li></ul><hr><h3 id="statefulSet滚动更新"><a href="#statefulSet滚动更新" class="headerlink" title="statefulSet滚动更新"></a>statefulSet滚动更新</h3><h4 id="1-7版本之前默认的On-Delete更新策略"><a href="#1-7版本之前默认的On-Delete更新策略" class="headerlink" title="1.7版本之前默认的On Delete更新策略"></a>1.7版本之前默认的On Delete更新策略</h4><p>​     statefulset在1.7版本开始支持滚动更新..在1.7版本之前默认的更新测量是<code>On Delete</code>.这种侧列和ReplicaSet类似.当更新了配置文件后,旧的pod并不会被自动删除,而是需要手动删除.</p><p>​    下面这个例子中,将镜像更换为luksa/kubia-pet-peers.副本数从3个增加到4个.(为此,我们需要提前再创建一个pv-4</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">编辑pv配置文件,增加pv-4(前提是nfs服务器上实现存在/data/k8s/pv-4目录</span></span><br><span class="line">[root@k8s-master ~]# vim statefulset-kubia-pv.yaml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">更新pv配置文件</span></span><br><span class="line">[root@k8s-master ~]# kubectl apply -f statefulset-kubia-pv.yaml</span><br><span class="line">Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply</span><br><span class="line">persistentvolume/pv-1 configured</span><br><span class="line">Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply</span><br><span class="line">persistentvolume/pv-2 configured</span><br><span class="line">Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply</span><br><span class="line">persistentvolume/pv-3 configured</span><br><span class="line">persistentvolume/pv-4 created</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">查看PV.</span></span><br><span class="line">[root@k8s-master ~]# kubectl get pv</span><br><span class="line">NAME   CAPACITY   ACCESS MODES   RECLAIM POLICY   STATUS      CLAIM                                 STORAGECLASS   REASON   AGE</span><br><span class="line">pv-1   1Gi        RWO            Recycle          Bound       default/data-statefulset-kubia-v1-2   nfs                     23h</span><br><span class="line">pv-2   1Gi        RWO            Recycle          Bound       default/data-statefulset-kubia-v1-0   nfs                     23h</span><br><span class="line">pv-3   1Gi        RWO            Recycle          Bound       default/data-statefulset-kubia-v1-1   nfs                     23h</span><br><span class="line">pv-4   1Gi        RWO            Recycle          Available                                         nfs                     9s</span><br><span class="line">[root@k8s-master ~]#</span><br></pre></td></tr></table></figure><p>更新statefulset配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#更新配置文件</span><br><span class="line">[root@k8s-master ~]# vim statefulset-kubia.yaml</span><br><span class="line">#应用配置文件</span><br><span class="line">[root@k8s-master ~]# kubectl apply -f statefulset-kubia.yaml</span><br><span class="line">Warning: kubectl apply should be used on resource created by either kubectl create --save-config or kubectl apply</span><br><span class="line">statefulset.apps/statefulset-kubia-v1 configured</span><br><span class="line"></span><br><span class="line">#查看Pod</span><br><span class="line">[root@k8s-master ~]# kubectl get pods</span><br><span class="line">NAME                     READY   STATUS              RESTARTS   AGE</span><br><span class="line">statefulset-kubia-v1-0   1/1     Running             0          70m</span><br><span class="line">statefulset-kubia-v1-1   1/1     Running             0          18h</span><br><span class="line">statefulset-kubia-v1-2   1/1     Running             0          18h</span><br><span class="line">statefulset-kubia-v1-3   0/1     ContainerCreating   0          5s</span><br><span class="line">[root@k8s-master ~]#</span><br></pre></td></tr></table></figure><p>通过Pod的存活字段可以看到之前旧版本的Pod并没有被自动删除,而是新增了一个副本.这和ReplicaSet的机制类似.</p><hr><h4 id="自动滚动更新策略"><a href="#自动滚动更新策略" class="headerlink" title="自动滚动更新策略"></a>自动滚动更新策略</h4><p>编辑statefulset配置文件,将镜像版本改回到luksa/kubia-pet</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spec:</span></span><br><span class="line"><span class="attr">  serviceName:</span> <span class="string">statefulset-kubia-v1</span></span><br><span class="line"><span class="attr">  replicas:</span> <span class="number">4</span></span><br><span class="line"><span class="attr">  selector:</span></span><br><span class="line"><span class="attr">    matchLabels:</span></span><br><span class="line"><span class="attr">       app:</span> <span class="string">statefulset-kubia</span></span><br><span class="line">  <span class="comment">#在spec字段配置更新策略,默认的type是On Delete,修改为RollingUpdate</span></span><br><span class="line"><span class="attr">  updateStrategy:</span></span><br><span class="line"><span class="attr">     type:</span> <span class="string">RollingUpdate</span></span><br></pre></td></tr></table></figure><p>应用新的配置文件,此时会触发自动更新</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># kubectl apply -f statefulset-kubia.yaml</span></span><br><span class="line">statefulset.apps/statefulset-kubia-v1 configured</span><br><span class="line">[root@k8s-master ~]<span class="comment"># kubectl get pods</span></span><br><span class="line">NAME                     READY   STATUS        RESTARTS   AGE</span><br><span class="line">statefulset-kubia-v1-0   1/1     Running       0          5m22s</span><br><span class="line">statefulset-kubia-v1-1   1/1     Running       0          6m12s</span><br><span class="line">statefulset-kubia-v1-2   1/1     Running       0          6m57s</span><br><span class="line">statefulset-kubia-v1-3   1/1     Terminating   0          7m39s</span><br><span class="line"></span><br><span class="line">[root@k8s-master ~]<span class="comment"># kubectl get pods</span></span><br><span class="line">NAME                     READY   STATUS        RESTARTS   AGE</span><br><span class="line">statefulset-kubia-v1-0   1/1     Running       0          6m55s</span><br><span class="line">statefulset-kubia-v1-1   1/1     Terminating   0          7m45s</span><br><span class="line">statefulset-kubia-v1-2   1/1     Running       0          14s</span><br><span class="line">statefulset-kubia-v1-3   1/1     Running       0          54s</span><br><span class="line"></span><br><span class="line">[root@k8s-master ~]<span class="comment"># kubectl get pods</span></span><br><span class="line">NAME                     READY   STATUS        RESTARTS   AGE</span><br><span class="line">statefulset-kubia-v1-0   1/1     Terminating   0          7m27s</span><br><span class="line">statefulset-kubia-v1-1   1/1     Running       0          7s</span><br><span class="line">statefulset-kubia-v1-2   1/1     Running       0          46s</span><br><span class="line">statefulset-kubia-v1-3   1/1     Running       0          86s</span><br></pre></td></tr></table></figure><p>发现了什么? 当滚动更新时,kubectl会以倒序的方式,从最末尾一个pod开始依次更新.</p><blockquote><p>StatefulSet的滚动更新策略不同于Deployment可以指定maxSuge参数指定一次同时更新的pod数量,而是只能单个方式进行依次更新</p></blockquote><blockquote><p>StatefulSet还支持partition(分区)的更新策略,具体可以查看官网</p></blockquote><p>无论是何种更新策略.Pod的数据(包括主机名,存储)都会持久化.再次访问第0个pod,存储数据依然存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# curl localhost:8001/api/v1/namespaces/default/pods/statefulset-kubia-v1-0/proxy/</span><br><span class="line">You&apos;ve hit statefulset-kubia-v1-0</span><br><span class="line">Data stored on this pod: Hey There ! This greeting was submitted to statefulset-kubia-v1-0</span><br></pre></td></tr></table></figure><hr><h3 id="StatefulSet-如何处理节点失效"><a href="#StatefulSet-如何处理节点失效" class="headerlink" title="StatefulSet 如何处理节点失效"></a>StatefulSet 如何处理节点失效</h3><p>在node2上关闭网卡来模拟这台服务器掉线,观察statefulSet处理节点失效的情况</p><blockquote><p>注意关闭节点网卡前请确保可以通过控制台连接服务器,因为这意味着无法ssh远程登录</p></blockquote><p>node2节点已经关闭,状态为notready</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl get node</span><br><span class="line">NAME         STATUS     ROLES    AGE   VERSION</span><br><span class="line">k8s-master   Ready      master   49d   v1.17.3</span><br><span class="line">k8s-node1    Ready      &lt;none&gt;   49d   v1.17.3</span><br><span class="line">k8s-node2    NotReady   &lt;none&gt;   49d   v1.17.3</span><br></pre></td></tr></table></figure><p>过一段时间后,所有node2节点上的Pod为Terminating终止状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># kubectl get pods -o wide</span></span><br><span class="line">NAME                     READY   STATUS        RESTARTS   AGE   IP               NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">statefulset-kubia-v1-0   1/1     Terminating   0          33m   10.100.169.174   k8s-node2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">statefulset-kubia-v1-1   1/1     Terminating   0          34m   10.100.169.173   k8s-node2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">statefulset-kubia-v1-2   1/1     Running       0          34m   10.100.36.97     k8s-node1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">statefulset-kubia-v1-3   1/1     Running       0          35m   10.100.36.99     k8s-node1   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><h5 id="删除不健康的Pod"><a href="#删除不健康的Pod" class="headerlink" title="删除不健康的Pod"></a>删除不健康的Pod</h5><p>当尝试手动删除pod时,发现永远都无法删除</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl delete po statefulset-kubia-v1-0</span><br><span class="line">pod &quot;statefulset-kubia-v1-0&quot; deleted</span><br><span class="line">^@</span><br><span class="line">^@</span><br></pre></td></tr></table></figure><p>在另一个终端上查看该pod.发现虽然pod被Terminating挂起,但是容器仍然处于运行状态</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]<span class="comment"># kubectl describe pods statefulset-kubia-v1-0</span></span><br><span class="line">Name:                      statefulset-kubia-v1-0</span><br><span class="line">Namespace:                 default</span><br><span class="line">Priority:                  0</span><br><span class="line">Node:                      k8s-node2/172.16.20.253</span><br><span class="line">Start Time:                Sun, 03 May 2020 10:54:17 +0800</span><br><span class="line">Labels:                    app=statefulset-kubia</span><br><span class="line">                           controller-revision-hash=statefulset-kubia-v1-74b44bc68b</span><br><span class="line">                           statefulset.kubernetes.io/pod-name=statefulset-kubia-v1-0</span><br><span class="line">Annotations:               cni.projectcalico.org/podIP: 10.100.169.174/32</span><br><span class="line">Status:                    Terminating (lasts 12m)</span><br><span class="line">Termination Grace Period:  30s</span><br><span class="line">IP:                        10.100.169.174</span><br><span class="line">IPs:</span><br><span class="line">  IP:           10.100.169.174</span><br><span class="line">Controlled By:  StatefulSet/statefulset-kubia-v1</span><br><span class="line">Containers:</span><br><span class="line">  statefulset-kubia:</span><br><span class="line">    Container ID:   docker://099628b95ded3644752a3de799ef338794704aaa4ebe4db5a966b821b2e9a71a</span><br><span class="line">    Image:          luksa/kubia-pet</span><br><span class="line">    Image ID:       docker-pullable://luksa/kubia-pet@sha256:4263bc375d3ae2f73fe7486818cab64c07f9cd4a645a7c71a07c1365a6e1a4d2</span><br><span class="line">    Port:           8080/TCP</span><br><span class="line">    Host Port:      0/TCP</span><br><span class="line">    State:          Running</span><br><span class="line">      Started:      Sun, 03 May 2020 10:54:21 +0800</span><br><span class="line">    Ready:          True</span><br><span class="line">    Restart Count:  0</span><br><span class="line">    Environment:    &lt;none&gt;</span><br><span class="line">    Mounts:</span><br><span class="line">      /var/data from data (rw)</span><br><span class="line">      /var/run/secrets/kubernetes.io/serviceaccount from default-token-jfrqr (ro)</span><br></pre></td></tr></table></figure><h5 id="强制删除"><a href="#强制删除" class="headerlink" title="强制删除"></a>强制删除</h5><p>带上参数<code>--force --grace-period 0</code>可以强制删除一个pod</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl delete po statefulset-kubia-v1-0 --force --grace-period 0</span><br><span class="line">warning: Immediate deletion does not wait for confirmation that the running resource has been terminated. The resource may continue to run on the cluster indefinitely.</span><br><span class="line">pod &quot;statefulset-kubia-v1-0&quot; force deleted</span><br><span class="line"></span><br><span class="line">[root@k8s-master ~]# kubectl get pods</span><br><span class="line">NAME                     READY   STATUS              RESTARTS   AGE</span><br><span class="line">statefulset-kubia-v1-0   0/1     ContainerCreating   0          5s</span><br><span class="line">statefulset-kubia-v1-1   1/1     Terminating         0          44m</span><br><span class="line">statefulset-kubia-v1-2   1/1     Running             0          44m</span><br><span class="line">statefulset-kubia-v1-3   1/1     Running             0          45m</span><br><span class="line"></span><br><span class="line">[root@k8s-master ~]# kubectl get pods -o wide</span><br><span class="line">NAME                     READY   STATUS        RESTARTS   AGE   IP               NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">statefulset-kubia-v1-0   1/1     Running       0          12s   10.100.36.101    k8s-node1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">statefulset-kubia-v1-1   1/1     Terminating   0          44m   10.100.169.173   k8s-node2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">statefulset-kubia-v1-2   1/1     Running       0          44m   10.100.36.97     k8s-node1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">statefulset-kubia-v1-3   1/1     Running       0          45m   10.100.36.99     k8s-node1   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><p>此时第0个pod已经重新创建,并且运行到node1节点,而另一个pod依然处于Terminating状态</p><h5 id="node2节点恢复正常"><a href="#node2节点恢复正常" class="headerlink" title="node2节点恢复正常"></a>node2节点恢复正常</h5><p>当节点恢复正常后,很快node和pod都全部恢复正常.此时第0个pod依然还是挂在在node1节点.第1个pod的状态迅速从Terminating状态变为Running状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl get pods -o wide</span><br><span class="line">NAME                     READY   STATUS    RESTARTS   AGE     IP               NODE        NOMINATED NODE   READINESS GATES</span><br><span class="line">statefulset-kubia-v1-0   1/1     Running   0          3m17s   10.100.36.101    k8s-node1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">statefulset-kubia-v1-1   1/1     Running   0          5s      10.100.169.172   k8s-node2   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">statefulset-kubia-v1-2   1/1     Running   0          47m     10.100.36.97     k8s-node1   &lt;none&gt;           &lt;none&gt;</span><br><span class="line">statefulset-kubia-v1-3   1/1     Running   0          48m     10.100.36.99     k8s-node1   &lt;none&gt;           &lt;none&gt;</span><br></pre></td></tr></table></figure><hr><h3 id="本章总结"><a href="#本章总结" class="headerlink" title="本章总结"></a>本章总结</h3><p>Stateful和RS,deployment的用法总体没有太大区别,下面是这2种资源的对比</p><table><thead><tr><th style="text-align:center">特性</th><th style="text-align:center">Deployment</th><th style="text-align:center">StatefulSet</th></tr></thead><tbody><tr><td style="text-align:center">是否暴露到外网</td><td style="text-align:center">可以</td><td style="text-align:center">一般不</td></tr><tr><td style="text-align:center">请求面向的对象</td><td style="text-align:center">ServiceName</td><td style="text-align:center">指定pod的域名</td></tr><tr><td style="text-align:center">灵活性</td><td style="text-align:center">通过Service(名称或者IP)访问后端Pod</td><td style="text-align:center">可以访问任意一个pod</td></tr><tr><td style="text-align:center">易用性</td><td style="text-align:center">只需要关心Service信息即可</td><td style="text-align:center">需要知道访问pod的名称,Headless Service名称</td></tr><tr><td style="text-align:center">PV/PVC稳定性</td><td style="text-align:center">无法保障绑定关系</td><td style="text-align:center">可以保障</td></tr><tr><td style="text-align:center">pod名称稳定性</td><td style="text-align:center">使用一个随机的名称后缀,重启后会随机生成另外一个.名称不重复</td><td style="text-align:center">稳定,每次都一样</td></tr><tr><td style="text-align:center">升级更新顺序</td><td style="text-align:center">随机启动.如果pod宕机重启,也是随机分配一个Node节点重新启动</td><td style="text-align:center">pod按顺序依次启动,如果pod宕机,依然使用相同的Node节点和名称</td></tr><tr><td style="text-align:center">停止顺序</td><td style="text-align:center">随机停止</td><td style="text-align:center">倒序停止</td></tr><tr><td style="text-align:center">集群内部服务发现</td><td style="text-align:center">只能通过Service访问随机的一个Pod</td><td style="text-align:center">可以打通pod之间的通信</td></tr><tr><td style="text-align:center">性能开销</td><td style="text-align:center">无需维护pod与node,pvc等关系</td><td style="text-align:center">需要维护额外的关系信息</td></tr></tbody></table><p>通过对比发现</p><ul><li>如果不需要额外数据依赖或者状态维护的部署,优先选择Deployment</li><li>如果单纯要做数据持久化,方式pod宕机数据丢失,直接使用PV/PVC就可以</li><li>如果是有多个副本,且每个副本挂载的PV存储数据不同,并且pod宕机重启后仍然关联到之前的PVC,并且数据需要持久化,考虑使用StatefulSet</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;kubernetes-StatefulSet&quot;&gt;&lt;a href=&quot;#kubernetes-StatefulSet&quot; class=&quot;headerlink&quot; title=&quot;kubernetes StatefulSet&quot;&gt;&lt;/a&gt;kubernetes StatefulSet&lt;/h2&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;​     我们之前学习过ReplicaController(RC),ReplicaSet(RS),Deployment(deploy)等,这些资源均可以通过一个Pod模板创建多个Pod副本.这些pod除了IP和名字不一样外,其他均一模一样.&lt;/p&gt;
&lt;p&gt;​     如果pod模板关联到特定的持久卷声明,那么这些pod都共享同一个存储.这些pod是完全一样,也无所谓运行在哪个节点上.可以任何删除和替换.&lt;/p&gt;
&lt;p&gt;​     但是在实际场景中,并不是所有的应用都满足这样的要求.比如主从关系,主备关系,数据存储类应用等.这些场景每个pod都会在本地保留一份数据,而且与其他Pod有数据对应关系.如果pod一旦被删除,即便新创建个pod出来,实例之间的对应关系也会失败,从而导致应用失败.&lt;/p&gt;
&lt;p&gt;   为了支持有状态的应用,Kubernetes在Deployment的基础上扩展出了StatefulSet资源&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;StatefulSet-特点&quot;&gt;&lt;a href=&quot;#StatefulSet-特点&quot; class=&quot;headerlink&quot; title=&quot;StatefulSet 特点&quot;&gt;&lt;/a&gt;StatefulSet 特点&lt;/h3&gt;&lt;p&gt;statefulSet的特点即是有状态的应用特点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;稳定且需要唯一的网络标识符;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这要求pod的主机名和IP地址永久不变,即使删除了一个pod,新创建的Pod也必须继承前一个Pod的主机标识符&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;ol start=&quot;2&quot;&gt;
&lt;li&gt;&lt;p&gt;稳定且持久的存储;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;可实现持久存储,新增或者减少pod,存储不会随之变化,并且删除一个pod时,关联到此pod的存储不会随之删除&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;要求有序,平滑的部署和扩展&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在Mysql等集群,要先启动主节点,然后启动从节点,第二从节点等等&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;要求有序,平滑的终止和删除&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;同样,应用的终止和删除也是有顺序的,按照启动的逆序进行.例如Mysql启动时,先启动主节点,再启动从节点.终止的时候,先关闭从节点,再关闭主节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;有序的滚动更新&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在Mysql更新时,也应该先更新所有从节点.最后更新主节点&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="kubernetes" scheme="https://jesse.top/categories/kubernetes/"/>
    
    
      <category term="k8s" scheme="https://jesse.top/tags/k8s/"/>
    
  </entry>
  
</feed>
