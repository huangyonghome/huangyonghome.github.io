<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jesse&#39;s home</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jesse.top/"/>
  <updated>2020-06-26T02:51:49.405Z</updated>
  <id>https://jesse.top/</id>
  
  <author>
    <name>Jesse</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://jesse.top/2020/06/26/%E7%9B%91%E6%8E%A7/zabbix%20%E9%80%9A%E8%BF%87Dell%20Idrac%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A1%AC%E4%BB%B6%E7%8A%B6%E6%80%81/"/>
    <id>https://jesse.top/2020/06/26/监控/zabbix 通过Dell Idrac监控服务器硬件状态/</id>
    <published>2020-06-26T06:27:16.901Z</published>
    <updated>2020-06-26T02:51:49.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Zabbix-通过Dell-Idrac监控服务器硬件状态"><a href="#Zabbix-通过Dell-Idrac监控服务器硬件状态" class="headerlink" title="Zabbix 通过Dell Idrac监控服务器硬件状态"></a>Zabbix 通过Dell Idrac监控服务器硬件状态</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近登陆vsphere控制台发现一台Dell服务器告警,已经损坏了.于是想通过zabbix监控Dell服务器的硬件状态.</p><p>有2种方法可以监控dell服务器的硬件状态</p><ul><li>通过Dell的OMSA工具监控</li><li>通过Dell的Idrac模块的SNMP协议监控</li></ul><p>Dell的OMSA工具需要安装在物理机系统上,我尝试过安装在vsphere的虚拟主机上,没办法获取到硬件状态.而且OMSA工具从Dell官网下载太慢.安装很麻烦</p><p>所以本文主要介绍如何通过idrac模块的snmp协议监控硬件状态.监控方法非常的简单</p><hr><h3 id="1-登陆服务器的idrac平台-开启snmp协议-v2版本"><a href="#1-登陆服务器的idrac平台-开启snmp协议-v2版本" class="headerlink" title="1.登陆服务器的idrac平台.开启snmp协议(v2版本)."></a>1.登陆服务器的idrac平台.开启snmp协议(v2版本).</h3><p>如果是idrac8版本,SNMP配置在左侧菜单栏<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果是idrac9版本,SNMP配置在菜单栏```iDRAC设置```---```服务```---```SNMP代理</span><br></pre></td></tr></table></figure></p><blockquote><p>根据我们的实际情况来看,无论是8还是9版本,SNMP都默认开启,端口是161,团体名是public</p></blockquote><h3 id="2-在zabbix服务端通过snmp命令检查是否能正确获取到服务器的snmp-oid"><a href="#2-在zabbix服务端通过snmp命令检查是否能正确获取到服务器的snmp-oid" class="headerlink" title="2.在zabbix服务端通过snmp命令检查是否能正确获取到服务器的snmp oid:"></a>2.在zabbix服务端通过snmp命令检查是否能正确获取到服务器的snmp oid:</h3><p>命令: <figure class="highlight plain"><figcaption><span>-v 2c -c 团体名 idrac IP地址```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>[work@server-4 ~]$ snmpwalk -v 2c -c public 172.16.250.53<br>SNMPv2-MIB::sysDescr.0 = STRING:<br>SNMPv2-MIB::sysObjectID.0 = OID: SNMPv2-SMI::enterprises.674.10892.5<br>DISMAN-EVENT-MIB::sysUpTimeInstance = Timeticks: (596160991) 69 days, 0:00:09.91<br>SNMPv2-MIB::sysContact.0 = STRING: \”<a href="mailto:support@dell.com" target="_blank" rel="noopener">support@dell.com</a>\”<br>SNMPv2-MIB::sysName.0 = STRING: iDRAC-3D38Y23<br>SNMPv2-MIB::sysLocation.0 = STRING: \”unknown\”<br>SNMPv2-MIB::sysORLastChange.0 = Timeticks: (1) 0:00:00.01<br>SNMPv2-MIB::sysORID.1 = OID: SNMPv2-MIB::snmpMIB<br>SNMPv2-MIB::sysORID.2 = OID: SNMP-VIEW-BASED-ACM-MIB::vacmBasicGroup<br>SNMPv2-MIB::sysORID.3 = OID: TCP-MIB::tcpMIB<br>SNMPv2-MIB::sysORID.4 = OID: IP-MIB::ip<br>SNMPv2-MIB::sysORID.5 = OID: UDP-MIB::udpMIB<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 3. 去github上下载idrac snmp监控模板</span><br><span class="line"></span><br><span class="line">地址: [idrac template](https://github.com/endersonmaia/zabbix-templates/tree/master/dell/idrac)</span><br><span class="line"></span><br><span class="line">模板文件我已经fork到了我自己的github仓库:[zabbix-templates](https://github.com/huangyonghome/zabbix-templates)</span><br><span class="line"></span><br><span class="line">**在dell/idrac下有3个文件:**</span><br><span class="line"></span><br><span class="line">```ValueMaps_Dell_iDRAC.zbx.xml```-------导入键值对映射 (需要zabbix3.0版本以上)</span><br><span class="line"></span><br><span class="line">```Template_Dell_iDRAC_SNMPv&#123;23&#125;.zbx.xml```-----监控模板(我们的idrac snmp协议是v2版本.所以采用snmpv2版本的模板)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 4.配置全局变量</span><br><span class="line"></span><br><span class="line">在Zabbix的```Administration```----```General```---右上角下拉框中选择宏Macros,新增宏定义:</span><br></pre></td></tr></table></figure></p><p>#我这里Idrac的snmp团体名是public<br>{$SNMP_COMMUNITY_IDRAC} =&gt; public<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 5.导入模板</span><br><span class="line"></span><br><span class="line">1.导入键值对映射```ValueMaps_Dell_iDRAC.zbx.xml</span><br></pre></td></tr></table></figure></p><p>2.导入监控模板<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 6.配置主机</span><br><span class="line"></span><br><span class="line">主机名和随意定义.定义snmp接口的地址为idrac接口IP地址,端口默认161.</span><br><span class="line"></span><br><span class="line">添加Template_Dell_iDRAC_SNMPv2模板</span><br><span class="line"></span><br><span class="line">&gt; 注意,snmp的地址是idrac地址,不是服务器iP地址</span><br><span class="line"></span><br><span class="line">模板里没有配置图形,如果有需要可以自己添加.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 7.验证</span><br><span class="line"></span><br><span class="line">刚好这台服务器的物理磁盘有问题.可以看到Zabbix成功的监控到这个问题,并且发送给钉钉告警.</span><br></pre></td></tr></table></figure></p><p>[故障]RAID Controller Error<br>告警级别：High<br>故障时间：2020.04.29 16:45:35<br>故障时长：1h 0m<br>IP地址：172.16.250.53<br>检测项：RAIDControllerStatus<br><em>NonCritical (4) </em><br>[exsi-idrac-53·故障 (31724858)]</p><p>[故障]Storage System Status Error<br>告警级别：Warning<br>故障时间：2020.04.29 16:45:35<br>故障时长：1h 0m<br>IP地址：172.16.250.53<br>检测项：GlobalSystemStorageStatus<br><em>NonCritical (4) </em><br>[exsi-idrac-53·故障 (31724857)]</p><p>[故障]Overall System Rollup Status Error<br>告警级别：Warning<br>故障时间：2020.04.29 16:45:35<br>故障时长：1h 0m<br>IP地址：172.16.250.53<br>检测项：GlobalSystemRollupStatus<br><em>NonCritical (4) </em><br>[exsi-idrac-53·故障 (31724855)]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">服务器磁盘修复以后,监控回复正常.监控各项指标的结果不再是4(NonCritical) 而是3(OK)</span><br></pre></td></tr></table></figure></p><p>work@server-4 ~]$ snmpwalk -v 2c -c public 172.16.250.53 1.3.6.1.4.1.674.10892.5.2.3.0<br>SNMPv2-SMI::enterprises.674.10892.5.2.3.0 = INTEGER: 3</p><p>[work@server-4 ~]$ snmpwalk -v 2c -c public 172.16.250.53 1.3.6.1.4.1.674.10892.5.5.1.20.130.1.1.37.1<br>SNMPv2-SMI::enterprises.674.10892.5.5.1.20.130.1.1.37.1 = INTEGER: 3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 问题</span><br><span class="line"></span><br><span class="line">目前发现一个模板的问题,在键值对映射中,Dell的OMSA(Open Manage System Status)键值对是这样映射的:</span><br></pre></td></tr></table></figure></p><p>Dell Open Manage System Status<br>1  Other<br>2  Unknown<br>3  OK<br>4  NonCritical<br>5  Critical<br>6  NonRecoverable<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在模板中,有一个触发器的名称是:Overall System Status Error</span><br><span class="line"></span><br><span class="line">表达式为```&#123;exsi-idrac-53:GlobalSystemStatus.last()&#125;&lt;&gt;3</span><br></pre></td></tr></table></figure></p><p>用意是监控系统状态,如果值不为3(OK)则告警.但是根据实际情况来看,这个监控项GlobalSystemStatus.SNMP OID:1.3.6.1.4.1.674.10892.2.2.1.0正常情况下的值为0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[work@server-4 ~]$ snmpwalk -v 2c -c public 172.16.250.53 1.3.6.1.4.1.674.10892.2.2.1.0</span><br><span class="line">SNMPv2-SMI::enterprises.674.10892.2.2.1.0 = INTEGER: 0</span><br></pre></td></tr></table></figure><p>所以在模板中修改Overall System Status Error触发器的表达式为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原表达式:</span><br><span class="line">&#123;Template Dell iDrac SNMPV2:GlobalSystemStatus.last()&#125;&lt;&gt;3 </span><br><span class="line"></span><br><span class="line">修改为:</span><br><span class="line">&#123;Template Dell iDrac SNMPV2:GlobalSystemStatus.last()&#125;&lt;&gt;3 and </span><br><span class="line">&#123;Template Dell iDrac SNMPV2:GlobalSystemStatus.last()&#125;&lt;&gt;0</span><br></pre></td></tr></table></figure><p>用意是这个监控项的结果既不等于3,又不等于0</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Zabbix-通过Dell-Idrac监控服务器硬件状态&quot;&gt;&lt;a href=&quot;#Zabbix-通过Dell-Idrac监控服务器硬件状态&quot; class=&quot;headerlink&quot; title=&quot;Zabbix 通过Dell Idrac监控服务器硬件状态&quot;&gt;&lt;/a&gt;Za
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jesse.top/2020/06/26/Linux-Service/systemd%E8%AF%A6%E8%A7%A3/"/>
    <id>https://jesse.top/2020/06/26/Linux-Service/systemd详解/</id>
    <published>2020-06-26T05:04:18.956Z</published>
    <updated>2020-06-26T06:50:44.952Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title:systemd介绍<br>date:2018-06-15 15:59:58<br>tags:systemd<br>categories:[Linux-Service ]<br>comments:true</p><h2 id="copyright-true"><a href="#copyright-true" class="headerlink" title="copyright:true"></a>copyright:true</h2><h1 id="systemd介绍"><a href="#systemd介绍" class="headerlink" title="systemd介绍"></a>systemd介绍</h1><p>systemd并不是一个命令,而是一组命令,涉及到系统管理的方方面面.以下是systemd的架构图</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016030703.png" alt=""></p><hr><a id="more"></a><h2 id="一-系统管理"><a href="#一-系统管理" class="headerlink" title="一.系统管理"></a>一.系统管理</h2><h3 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h3><hr><figure class="highlight plain"><figcaption><span>的主命令，用于管理系统。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="重启系统"><a href="#重启系统" class="headerlink" title="重启系统"></a>重启系统</h1><p>$ sudo systemctl reboot</p><h1 id="关闭系统，切断电源"><a href="#关闭系统，切断电源" class="headerlink" title="关闭系统，切断电源"></a>关闭系统，切断电源</h1><p>$ sudo systemctl poweroff</p><h1 id="CPU停止工作"><a href="#CPU停止工作" class="headerlink" title="CPU停止工作"></a>CPU停止工作</h1><p>$ sudo systemctl halt</p><h1 id="暂停系统"><a href="#暂停系统" class="headerlink" title="暂停系统"></a>暂停系统</h1><p>$ sudo systemctl suspend</p><h1 id="让系统进入冬眠状态"><a href="#让系统进入冬眠状态" class="headerlink" title="让系统进入冬眠状态"></a>让系统进入冬眠状态</h1><p>$ sudo systemctl hibernate</p><h1 id="让系统进入交互式休眠状态"><a href="#让系统进入交互式休眠状态" class="headerlink" title="让系统进入交互式休眠状态"></a>让系统进入交互式休眠状态</h1><p>$ sudo systemctl hybrid-sleep</p><h1 id="启动进入救援状态（单用户状态）"><a href="#启动进入救援状态（单用户状态）" class="headerlink" title="启动进入救援状态（单用户状态）"></a>启动进入救援状态（单用户状态）</h1><p>$ sudo systemctl rescue<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### systemd-analyze</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">`systemd-analyze`命令用于查看启动耗时。</span><br></pre></td></tr></table></figure></p><h1 id="查看启动耗时"><a href="#查看启动耗时" class="headerlink" title="查看启动耗时"></a>查看启动耗时</h1><p>$ systemd-analyze                                                                                       </p><h1 id="查看每个服务的启动耗时"><a href="#查看每个服务的启动耗时" class="headerlink" title="查看每个服务的启动耗时"></a>查看每个服务的启动耗时</h1><p>$ systemd-analyze blame</p><h1 id="显示瀑布状的启动过程流"><a href="#显示瀑布状的启动过程流" class="headerlink" title="显示瀑布状的启动过程流"></a>显示瀑布状的启动过程流</h1><p>$ systemd-analyze critical-chain</p><h1 id="显示指定服务的启动流"><a href="#显示指定服务的启动流" class="headerlink" title="显示指定服务的启动流"></a>显示指定服务的启动流</h1><p>$ systemd-analyze critical-chain atd.service<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### hostnamectl</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line">`hostnamectl`命令用于查看当前主机的信息。</span><br></pre></td></tr></table></figure></p><h1 id="显示当前主机的信息"><a href="#显示当前主机的信息" class="headerlink" title="显示当前主机的信息"></a>显示当前主机的信息</h1><p>$ hostnamectl</p><h1 id="设置主机名。"><a href="#设置主机名。" class="headerlink" title="设置主机名。"></a>设置主机名。</h1><p>$ sudo hostnamectl set-hostname rhel7<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### localectl</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line">`localectl`命令用于查看本地化设置。</span><br></pre></td></tr></table></figure></p><h1 id="查看本地化设置"><a href="#查看本地化设置" class="headerlink" title="查看本地化设置"></a>查看本地化设置</h1><p>$ localectl</p><h1 id="设置本地化参数。"><a href="#设置本地化参数。" class="headerlink" title="设置本地化参数。"></a>设置本地化参数。</h1><p>$ sudo localectl set-locale LANG=en_GB.utf8<br>$ sudo localectl set-keymap en_GB<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### timedatectl</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">`timedatectl`命令用于查看当前时区设置。</span><br></pre></td></tr></table></figure></p><h1 id="查看当前时区设置"><a href="#查看当前时区设置" class="headerlink" title="查看当前时区设置"></a>查看当前时区设置</h1><p>$ timedatectl</p><h1 id="显示所有可用的时区"><a href="#显示所有可用的时区" class="headerlink" title="显示所有可用的时区"></a>显示所有可用的时区</h1><p>$ timedatectl list-timezones                                                                                   </p><h1 id="设置当前时区"><a href="#设置当前时区" class="headerlink" title="设置当前时区"></a>设置当前时区</h1><p>$ sudo timedatectl set-timezone America/New_York<br>$ sudo timedatectl set-time YYYY-MM-DD<br>$ sudo timedatectl set-time HH:MM:SS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### loginctl</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">`loginctl`命令用于查看当前登录的用户。</span><br></pre></td></tr></table></figure></p><h1 id="列出当前session"><a href="#列出当前session" class="headerlink" title="列出当前session"></a>列出当前session</h1><p>$ loginctl list-sessions</p><h1 id="列出当前登录用户"><a href="#列出当前登录用户" class="headerlink" title="列出当前登录用户"></a>列出当前登录用户</h1><p>$ loginctl list-users</p><h1 id="列出显示指定用户的信息"><a href="#列出显示指定用户的信息" class="headerlink" title="列出显示指定用户的信息"></a>列出显示指定用户的信息</h1><p>$ loginctl show-user ruanyf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 二.Unit</span><br><span class="line"></span><br><span class="line">Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。</span><br><span class="line"></span><br><span class="line">Unit 一共分成12种。</span><br></pre></td></tr></table></figure></p><p>Service unit：系统服务<br>Target unit：多个 Unit 构成的一个组<br>Device Unit：硬件设备<br>Mount Unit：文件系统的挂载点<br>Automount Unit：自动挂载点<br>Path Unit：文件或路径<br>Scope Unit：不是由 Systemd 启动的外部进程<br>Slice Unit：进程组<br>Snapshot Unit：Systemd 快照，可以切回某个快照<br>Socket Unit：进程间通信的 socket<br>Swap Unit：swap 文件<br>Timer Unit：定时器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line">`systemctl list-units`命令可以查看当前系统的所有 Unit 。</span><br></pre></td></tr></table></figure></p><h1 id="列出正在运行的-Unit"><a href="#列出正在运行的-Unit" class="headerlink" title="列出正在运行的 Unit"></a>列出正在运行的 Unit</h1><p>$ systemctl list-units</p><h1 id="列出所有Unit，包括没有找到配置文件的或者启动失败的"><a href="#列出所有Unit，包括没有找到配置文件的或者启动失败的" class="headerlink" title="列出所有Unit，包括没有找到配置文件的或者启动失败的"></a>列出所有Unit，包括没有找到配置文件的或者启动失败的</h1><p>$ systemctl list-units –all</p><h1 id="列出所有没有运行的-Unit"><a href="#列出所有没有运行的-Unit" class="headerlink" title="列出所有没有运行的 Unit"></a>列出所有没有运行的 Unit</h1><p>$ systemctl list-units –all –state=inactive</p><h1 id="列出所有加载失败的-Unit"><a href="#列出所有加载失败的-Unit" class="headerlink" title="列出所有加载失败的 Unit"></a>列出所有加载失败的 Unit</h1><p>$ systemctl list-units –failed</p><h1 id="列出所有正在运行的、类型为-service-的-Unit"><a href="#列出所有正在运行的、类型为-service-的-Unit" class="headerlink" title="列出所有正在运行的、类型为 service 的 Unit"></a>列出所有正在运行的、类型为 service 的 Unit</h1><p>$ systemctl list-units –type=service<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### Unit 的状态</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">`systemctl status`命令用于查看系统状态和单个 Unit 的状态。</span><br></pre></td></tr></table></figure></p><h1 id="显示系统状态"><a href="#显示系统状态" class="headerlink" title="显示系统状态"></a>显示系统状态</h1><p>$ systemctl status</p><h1 id="显示单个-Unit-的状态"><a href="#显示单个-Unit-的状态" class="headerlink" title="显示单个 Unit 的状态"></a>显示单个 Unit 的状态</h1><p>$ systemctl status bluetooth.service</p><h1 id="显示远程主机的某个-Unit-的状态"><a href="#显示远程主机的某个-Unit-的状态" class="headerlink" title="显示远程主机的某个 Unit 的状态"></a>显示远程主机的某个 Unit 的状态</h1><p>$ systemctl -H <a href="mailto:root@rhel7.example.com" target="_blank" rel="noopener">root@rhel7.example.com</a> status httpd.service<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">除了`status`命令，`systemctl`还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。</span><br></pre></td></tr></table></figure></p><h1 id="显示某个-Unit-是否正在运行"><a href="#显示某个-Unit-是否正在运行" class="headerlink" title="显示某个 Unit 是否正在运行"></a>显示某个 Unit 是否正在运行</h1><p>$ systemctl is-active application.service</p><h1 id="显示某个-Unit-是否处于启动失败状态"><a href="#显示某个-Unit-是否处于启动失败状态" class="headerlink" title="显示某个 Unit 是否处于启动失败状态"></a>显示某个 Unit 是否处于启动失败状态</h1><p>$ systemctl is-failed application.service</p><h1 id="显示某个-Unit-服务是否建立了启动链接"><a href="#显示某个-Unit-服务是否建立了启动链接" class="headerlink" title="显示某个 Unit 服务是否建立了启动链接"></a>显示某个 Unit 服务是否建立了启动链接</h1><p>$ systemctl is-enabled application.service<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### Unit 管理</span><br><span class="line"></span><br><span class="line">对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。</span><br></pre></td></tr></table></figure></p><h1 id="立即启动一个服务"><a href="#立即启动一个服务" class="headerlink" title="立即启动一个服务"></a>立即启动一个服务</h1><p>$ sudo systemctl start apache.service</p><h1 id="立即停止一个服务"><a href="#立即停止一个服务" class="headerlink" title="立即停止一个服务"></a>立即停止一个服务</h1><p>$ sudo systemctl stop apache.service</p><h1 id="重启一个服务"><a href="#重启一个服务" class="headerlink" title="重启一个服务"></a>重启一个服务</h1><p>$ sudo systemctl restart apache.service</p><h1 id="杀死一个服务的所有子进程"><a href="#杀死一个服务的所有子进程" class="headerlink" title="杀死一个服务的所有子进程"></a>杀死一个服务的所有子进程</h1><p>$ sudo systemctl kill apache.service</p><h1 id="重新加载一个服务的配置文件"><a href="#重新加载一个服务的配置文件" class="headerlink" title="重新加载一个服务的配置文件"></a>重新加载一个服务的配置文件</h1><p>$ sudo systemctl reload apache.service</p><h1 id="重载所有修改过的配置文件"><a href="#重载所有修改过的配置文件" class="headerlink" title="重载所有修改过的配置文件"></a>重载所有修改过的配置文件</h1><p>$ sudo systemctl daemon-reload</p><h1 id="显示某个-Unit-的所有底层参数"><a href="#显示某个-Unit-的所有底层参数" class="headerlink" title="显示某个 Unit 的所有底层参数"></a>显示某个 Unit 的所有底层参数</h1><p>$ systemctl show httpd.service</p><h1 id="显示某个-Unit-的指定属性的值"><a href="#显示某个-Unit-的指定属性的值" class="headerlink" title="显示某个 Unit 的指定属性的值"></a>显示某个 Unit 的指定属性的值</h1><p>$ systemctl show -p CPUShares httpd.service</p><h1 id="设置某个-Unit-的指定属性"><a href="#设置某个-Unit-的指定属性" class="headerlink" title="设置某个 Unit 的指定属性"></a>设置某个 Unit 的指定属性</h1><p>$ sudo systemctl set-property httpd.service CPUShares=500<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 依赖关系</span><br><span class="line"></span><br><span class="line">Unit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。</span><br><span class="line"></span><br><span class="line">`systemctl list-dependencies`命令列出一个 Unit 的所有依赖。</span><br></pre></td></tr></table></figure></p><p>$ systemctl list-dependencies nginx.service<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上面命令的输出结果之中，有些依赖是 Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用`--all`参数。</span><br></pre></td></tr></table></figure></p><p>$ systemctl list-dependencies –all nginx.service<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 三.Unit 的配置文件</span><br><span class="line"></span><br><span class="line">### 概述</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。</span><br><span class="line"></span><br><span class="line">Systemd 默认从目录`/etc/systemd/system/`读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录`/usr/lib/systemd/system/`，真正的配置文件存放在那个目录。</span><br><span class="line"></span><br><span class="line">`systemctl enable`命令用于在上面两个目录之间，建立符号链接关系。</span><br></pre></td></tr></table></figure></p><p>$ sudo systemctl enable <a href="mailto:clamd@scan.service" target="_blank" rel="noopener">clamd@scan.service</a></p><h1 id="等同于"><a href="#等同于" class="headerlink" title="等同于"></a>等同于</h1><p>$ sudo ln -s <a href="mailto:&#39;/usr/lib/systemd/system/clamd@scan.service" target="_blank" rel="noopener">&#39;/usr/lib/systemd/system/clamd@scan.service</a>‘ <a href="mailto:&#39;/etc/systemd/system/multi-user.target.wants/clamd@scan.service" target="_blank" rel="noopener">&#39;/etc/systemd/system/multi-user.target.wants/clamd@scan.service</a>‘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果配置文件里面设置了开机启动，`systemctl enable`命令相当于激活开机启动。</span><br><span class="line"></span><br><span class="line">与之对应的，`systemctl disable`命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。</span><br></pre></td></tr></table></figure></p><p>$ sudo systemctl disable <a href="mailto:clamd@scan.service" target="_blank" rel="noopener">clamd@scan.service</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">配置文件的后缀名，就是该 Unit 的种类，比如`sshd.socket`。如果省略，Systemd 默认后缀名为`.service`，所以`sshd`会被理解成`sshd.service`。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 配置文件的状态</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">`systemctl list-unit-files`命令用于列出所有配置文件。</span><br></pre></td></tr></table></figure></p><h1 id="列出所有配置文件"><a href="#列出所有配置文件" class="headerlink" title="列出所有配置文件"></a>列出所有配置文件</h1><p>$ systemctl list-unit-files<br>这个命令的执行结果一共有4中状态.分别是:</p><p>enabled：已建立启动链接<br>disabled：没建立启动链接<br>static：该配置文件没有[Install]部分（无法执行），只能作为其他配置文件的依赖<br>masked：该配置文件被禁止建立启动链接</p><h1 id="列出指定类型的配置文件"><a href="#列出指定类型的配置文件" class="headerlink" title="列出指定类型的配置文件"></a>列出指定类型的配置文件</h1><p>$ systemctl list-unit-files –type=service</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 配置文件的格式</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">配置文件就是普通的文本文件，可以用文本编辑器打开。</span><br><span class="line"></span><br><span class="line">`systemctl cat`命令可以查看配置文件的内容。</span><br></pre></td></tr></table></figure><p>$ systemctl cat atd.service</p><p>[Unit]<br>Description=ATD daemon</p><p>[Service]<br>Type=forking<br>ExecStart=/usr/bin/atd</p><p>[Install]<br>WantedBy=multi-user.target<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如`[Unit]`。</span><br><span class="line"></span><br><span class="line">&gt;  注意，配置文件的区块名和字段名，都是大小写敏感的。</span><br><span class="line"></span><br><span class="line">每个区块内部是一些等号连接的键值对。(注意，键值对的等号两侧不能有空格。)</span><br><span class="line"></span><br><span class="line">一旦修改配置文件，就要让 SystemD 重新加载配置文件，然后重新启动，否则修改不会生效。</span><br></pre></td></tr></table></figure></p><p>$ sudo systemctl daemon-reload<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 配置文件的区块</span><br><span class="line"></span><br><span class="line">`[Unit]`区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。</span><br></pre></td></tr></table></figure></p><p>Description：简短描述<br>Documentation：文档地址<br>Requires：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败<br>Wants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败<br>BindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行<br>Before：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动<br>After：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动<br>Conflicts：这里指定的 Unit 不能与当前 Unit 同时运行<br>Condition…：当前 Unit 运行必须满足的条件，否则不会运行<br>Assert…：当前 Unit 运行必须满足的条件，否则会报启动失败<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`[Install]`通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。</span><br></pre></td></tr></table></figure></p><p>WantedBy：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中<br>RequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中<br>Alias：当前 Unit 可用于启动的别名<br>Also：当前 Unit 激活（enable）时，会被同时激活的其他 Unit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`[Service]`区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。</span><br></pre></td></tr></table></figure></p><p>Type：定义启动时的进程行为。它有以下几种值。<br>Type=simple：默认值，执行ExecStart指定的命令，启动主进程<br>Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出<br>Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行<br>Type=dbus：当前服务通过D-Bus启动<br>Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行<br>Type=idle：若有其他任务执行完毕，当前服务才会运行<br>ExecStart：启动当前服务的命令<br>ExecStartPre：启动当前服务之前执行的命令<br>ExecStartPost：启动当前服务之后执行的命令<br>ExecReload：重启当前服务时执行的命令<br>ExecStop：停止当前服务时执行的命令<br>ExecStopPost：停止当其服务之后执行的命令<br>RestartSec：自动重启当前服务间隔的秒数<br>Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog<br>TimeoutSec：定义 Systemd 停止当前服务之前等待的秒数<br>Environment：指定环境变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Unit 配置文件的完整字段清单，请参考[官方文档](https://www.freedesktop.org/software/systemd/man/systemd.unit.html)</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 四.Target</span><br><span class="line"></span><br><span class="line">启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。</span><br><span class="line"></span><br><span class="line">简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于&quot;状态点&quot;，启动某个 Target 就好比启动到某种状态。</span><br><span class="line"></span><br><span class="line">传统的`init`启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</span><br></pre></td></tr></table></figure></p><h1 id="查看当前系统的所有-Target"><a href="#查看当前系统的所有-Target" class="headerlink" title="查看当前系统的所有 Target"></a>查看当前系统的所有 Target</h1><p>$ systemctl list-unit-files –type=target</p><h1 id="查看一个-Target-包含的所有-Unit"><a href="#查看一个-Target-包含的所有-Unit" class="headerlink" title="查看一个 Target 包含的所有 Unit"></a>查看一个 Target 包含的所有 Unit</h1><p>$ systemctl list-dependencies multi-user.target</p><h1 id="查看启动时的默认-Target"><a href="#查看启动时的默认-Target" class="headerlink" title="查看启动时的默认 Target"></a>查看启动时的默认 Target</h1><p>$ systemctl get-default</p><h1 id="设置启动时的默认-Target"><a href="#设置启动时的默认-Target" class="headerlink" title="设置启动时的默认 Target"></a>设置启动时的默认 Target</h1><p>$ sudo systemctl set-default multi-user.target</p><h1 id="切换-Target-时，默认不关闭前一个-Target-启动的进程，"><a href="#切换-Target-时，默认不关闭前一个-Target-启动的进程，" class="headerlink" title="切换 Target 时，默认不关闭前一个 Target 启动的进程，"></a>切换 Target 时，默认不关闭前一个 Target 启动的进程，</h1><h1 id="systemctl-isolate-命令改变这种行为，"><a href="#systemctl-isolate-命令改变这种行为，" class="headerlink" title="systemctl isolate 命令改变这种行为，"></a>systemctl isolate 命令改变这种行为，</h1><h1 id="关闭前一个-Target-里面所有不属于后一个-Target-的进程"><a href="#关闭前一个-Target-里面所有不属于后一个-Target-的进程" class="headerlink" title="关闭前一个 Target 里面所有不属于后一个 Target 的进程"></a>关闭前一个 Target 里面所有不属于后一个 Target 的进程</h1><p>$ sudo systemctl isolate multi-user.target<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Target 与 传统 RunLevel 的对应关系如下。</span><br></pre></td></tr></table></figure></p><p>Traditional runlevel      New target name     Symbolically linked to…</p><p>Runlevel 0           |    runlevel0.target -&gt; poweroff.target<br>Runlevel 1           |    runlevel1.target -&gt; rescue.target<br>Runlevel 2           |    runlevel2.target -&gt; multi-user.target<br>Runlevel 3           |    runlevel3.target -&gt; multi-user.target<br>Runlevel 4           |    runlevel4.target -&gt; multi-user.target<br>Runlevel 5           |    runlevel5.target -&gt; graphical.target<br>Runlevel 6           |    runlevel6.target -&gt; reboot.target<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">它与`init`进程的主要差别如下。</span><br></pre></td></tr></table></figure></p><p>（1）默认的 RunLevel（在/etc/inittab文件设置）现在被默认的 Target 取代，位置是/etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。</p><p>（2）启动脚本的位置，以前是/etc/init.d目录，符号链接到不同的 RunLevel 目录 （比如/etc/rc3.d、/etc/rc5.d等），现在则存放在/lib/systemd/system和/etc/systemd/system目录。</p><p>（3）配置文件的位置，以前init进程的配置文件是/etc/inittab，各种服务的配置文件存放在/etc/sysconfig目录。现在的配置文件主要存放在/lib/systemd目录，在/etc/systemd目录里面的修改可以覆盖原始设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 五.日志管理 </span><br><span class="line"></span><br><span class="line">Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用`journalctl`一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是`/etc/systemd/journald.conf`。</span><br><span class="line"></span><br><span class="line">`journalctl`功能强大，用法非常多。</span><br></pre></td></tr></table></figure></p><h1 id="查看所有日志（默认情况下-，只保存本次启动的日志）"><a href="#查看所有日志（默认情况下-，只保存本次启动的日志）" class="headerlink" title="查看所有日志（默认情况下 ，只保存本次启动的日志）"></a>查看所有日志（默认情况下 ，只保存本次启动的日志）</h1><p>$ sudo journalctl</p><h1 id="查看内核日志（不显示应用日志）"><a href="#查看内核日志（不显示应用日志）" class="headerlink" title="查看内核日志（不显示应用日志）"></a>查看内核日志（不显示应用日志）</h1><p>$ sudo journalctl -k</p><h1 id="查看系统本次启动的日志"><a href="#查看系统本次启动的日志" class="headerlink" title="查看系统本次启动的日志"></a>查看系统本次启动的日志</h1><p>$ sudo journalctl -b<br>$ sudo journalctl -b -0</p><h1 id="查看上一次启动的日志（需更改设置）"><a href="#查看上一次启动的日志（需更改设置）" class="headerlink" title="查看上一次启动的日志（需更改设置）"></a>查看上一次启动的日志（需更改设置）</h1><p>$ sudo journalctl -b -1</p><h1 id="查看指定时间的日志"><a href="#查看指定时间的日志" class="headerlink" title="查看指定时间的日志"></a>查看指定时间的日志</h1><p>$ sudo journalctl –since=”2012-10-30 18:17:16”<br>$ sudo journalctl –since “20 min ago”<br>$ sudo journalctl –since yesterday<br>$ sudo journalctl –since “2015-01-10” –until “2015-01-11 03:00”<br>$ sudo journalctl –since 09:00 –until “1 hour ago”</p><h1 id="显示尾部的最新10行日志"><a href="#显示尾部的最新10行日志" class="headerlink" title="显示尾部的最新10行日志"></a>显示尾部的最新10行日志</h1><p>$ sudo journalctl -n</p><h1 id="显示尾部指定行数的日志"><a href="#显示尾部指定行数的日志" class="headerlink" title="显示尾部指定行数的日志"></a>显示尾部指定行数的日志</h1><p>$ sudo journalctl -n 20</p><h1 id="实时滚动显示最新日志"><a href="#实时滚动显示最新日志" class="headerlink" title="实时滚动显示最新日志"></a>实时滚动显示最新日志</h1><p>$ sudo journalctl -f</p><h1 id="查看指定服务的日志"><a href="#查看指定服务的日志" class="headerlink" title="查看指定服务的日志"></a>查看指定服务的日志</h1><p>$ sudo journalctl /usr/lib/systemd/systemd</p><h1 id="查看指定进程的日志"><a href="#查看指定进程的日志" class="headerlink" title="查看指定进程的日志"></a>查看指定进程的日志</h1><p>$ sudo journalctl _PID=1</p><h1 id="查看某个路径的脚本的日志"><a href="#查看某个路径的脚本的日志" class="headerlink" title="查看某个路径的脚本的日志"></a>查看某个路径的脚本的日志</h1><p>$ sudo journalctl /usr/bin/bash</p><h1 id="查看指定用户的日志"><a href="#查看指定用户的日志" class="headerlink" title="查看指定用户的日志"></a>查看指定用户的日志</h1><p>$ sudo journalctl _UID=33 –since today</p><h1 id="查看某个-Unit-的日志"><a href="#查看某个-Unit-的日志" class="headerlink" title="查看某个 Unit 的日志"></a>查看某个 Unit 的日志</h1><p>$ sudo journalctl -u nginx.service<br>$ sudo journalctl -u nginx.service –since today</p><h1 id="实时滚动显示某个-Unit-的最新日志"><a href="#实时滚动显示某个-Unit-的最新日志" class="headerlink" title="实时滚动显示某个 Unit 的最新日志"></a>实时滚动显示某个 Unit 的最新日志</h1><p>$ sudo journalctl -u nginx.service -f</p><h1 id="合并显示多个-Unit-的日志"><a href="#合并显示多个-Unit-的日志" class="headerlink" title="合并显示多个 Unit 的日志"></a>合并显示多个 Unit 的日志</h1><p>$ journalctl -u nginx.service -u php-fpm.service –since today</p><h1 id="查看指定优先级（及其以上级别）的日志，共有8级"><a href="#查看指定优先级（及其以上级别）的日志，共有8级" class="headerlink" title="查看指定优先级（及其以上级别）的日志，共有8级"></a>查看指定优先级（及其以上级别）的日志，共有8级</h1><h1 id="0-emerg"><a href="#0-emerg" class="headerlink" title="0: emerg"></a>0: emerg</h1><h1 id="1-alert"><a href="#1-alert" class="headerlink" title="1: alert"></a>1: alert</h1><h1 id="2-crit"><a href="#2-crit" class="headerlink" title="2: crit"></a>2: crit</h1><h1 id="3-err"><a href="#3-err" class="headerlink" title="3: err"></a>3: err</h1><h1 id="4-warning"><a href="#4-warning" class="headerlink" title="4: warning"></a>4: warning</h1><h1 id="5-notice"><a href="#5-notice" class="headerlink" title="5: notice"></a>5: notice</h1><h1 id="6-info"><a href="#6-info" class="headerlink" title="6: info"></a>6: info</h1><h1 id="7-debug"><a href="#7-debug" class="headerlink" title="7: debug"></a>7: debug</h1><p>$ sudo journalctl -p err -b</p><h1 id="日志默认分页输出，–no-pager-改为正常的标准输出"><a href="#日志默认分页输出，–no-pager-改为正常的标准输出" class="headerlink" title="日志默认分页输出，–no-pager 改为正常的标准输出"></a>日志默认分页输出，–no-pager 改为正常的标准输出</h1><p>$ sudo journalctl –no-pager</p><h1 id="以-JSON-格式（单行）输出"><a href="#以-JSON-格式（单行）输出" class="headerlink" title="以 JSON 格式（单行）输出"></a>以 JSON 格式（单行）输出</h1><p>$ sudo journalctl -b -u nginx.service -o json</p><h1 id="以-JSON-格式（多行）输出，可读性更好"><a href="#以-JSON-格式（多行）输出，可读性更好" class="headerlink" title="以 JSON 格式（多行）输出，可读性更好"></a>以 JSON 格式（多行）输出，可读性更好</h1><p>$ sudo journalctl -b -u nginx.serviceqq<br> -o json-pretty</p><h1 id="显示日志占据的硬盘空间"><a href="#显示日志占据的硬盘空间" class="headerlink" title="显示日志占据的硬盘空间"></a>显示日志占据的硬盘空间</h1><p>$ sudo journalctl –disk-usage</p><h1 id="指定日志文件占据的最大空间"><a href="#指定日志文件占据的最大空间" class="headerlink" title="指定日志文件占据的最大空间"></a>指定日志文件占据的最大空间</h1><p>$ sudo journalctl –vacuum-size=1G</p><h1 id="指定日志文件保存多久"><a href="#指定日志文件保存多久" class="headerlink" title="指定日志文件保存多久"></a>指定日志文件保存多久</h1><p>$ sudo journalctl –vacuum-time=1years<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title:systemd介绍&lt;br&gt;date:2018-06-15 15:59:58&lt;br&gt;tags:systemd&lt;br&gt;categories:[Linux-Service ]&lt;br&gt;comments:true&lt;/p&gt;
&lt;h2 id=&quot;copyright-true&quot;&gt;&lt;a href=&quot;#copyright-true&quot; class=&quot;headerlink&quot; title=&quot;copyright:true&quot;&gt;&lt;/a&gt;copyright:true&lt;/h2&gt;&lt;h1 id=&quot;systemd介绍&quot;&gt;&lt;a href=&quot;#systemd介绍&quot; class=&quot;headerlink&quot; title=&quot;systemd介绍&quot;&gt;&lt;/a&gt;systemd介绍&lt;/h1&gt;&lt;p&gt;systemd并不是一个命令,而是一组命令,涉及到系统管理的方方面面.以下是systemd的架构图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ruanyifeng.com/blogimg/asset/2016/bg2016030703.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jesse.top/2020/06/26/Linux-Web/nginx%E5%AE%89%E8%A3%85Lua%E6%A8%A1%E5%9D%97/"/>
    <id>https://jesse.top/2020/06/26/Linux-Web/nginx安装Lua模块/</id>
    <published>2020-06-26T04:13:21.631Z</published>
    <updated>2020-06-26T02:51:49.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装Lua模块"><a href="#安装Lua模块" class="headerlink" title="安装Lua模块"></a>安装Lua模块</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>nginx编译安装lua模块方法,在网上能搜到许多的文档.但是都千篇一律.根据笔者的实际配置经历,网上的文档在我们的服务器上编译会报错,原因是nginx的lua模块版本(网上文档都是采用v0.10.11版本的lua-nginx-module模块)和nginx不兼容,我尝试过Nginx1.12,1.13,1.17等多个版本均无法安装.</p><p>所以笔者最终采用的的lua-nginx-module模块是0.10.9rc7版本,这才成功编译安装lua模块.</p><blockquote><p> 编译过程中虽然会覆盖现有Nginx,但是基本上属于平滑过渡,不会影响Nginx正常运行.</p></blockquote><hr><h4 id="服务器现有环境介绍"><a href="#服务器现有环境介绍" class="headerlink" title="服务器现有环境介绍:"></a>服务器现有环境介绍:</h4><p>1.nginx版本:1.12</p><p>2.nginx安装方式: yum安装</p><hr><h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤:"></a>安装步骤:</h4><h5 id="1-安装luaJIT模块"><a href="#1-安装luaJIT模块" class="headerlink" title="1.安装luaJIT模块"></a>1.安装luaJIT模块</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line">wget http://luajit.org/download/LuaJIT-2.1.0-beta2.tar.gz</span><br><span class="line">tar zxf LuaJIT-2.1.0-beta2.tar.gz</span><br><span class="line">cd LuaJIT-2.1.0-beta2</span><br><span class="line"></span><br><span class="line">make PREFIX=/usr/local/luajit</span><br><span class="line">make install PREFIX=/usr/local/luajit</span><br></pre></td></tr></table></figure><h5 id="2-安装ngx-devel-kit模块"><a href="#2-安装ngx-devel-kit模块" class="headerlink" title="2.安装ngx_devel_kit模块"></a>2.安装ngx_devel_kit模块</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line">wget https://github.com/simpl/ngx_devel_kit/archive/v0.2.19.tar.gz</span><br><span class="line">tar -xzvf v0.2.19.tar.gz</span><br></pre></td></tr></table></figure><h5 id="3-安装nginx-lua模块-注意-最好是0-10-9rc7版本"><a href="#3-安装nginx-lua模块-注意-最好是0-10-9rc7版本" class="headerlink" title="3. 安装nginx_lua模块,注意,最好是0.10.9rc7版本"></a>3. 安装nginx_lua模块,注意,最好是0.10.9rc7版本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line">wget https://github.com/openresty/lua-nginx-module/archive/v0.10.9rc7tar.gz</span><br><span class="line">tar -zxvf v0.10.9rc7.tar.gz</span><br></pre></td></tr></table></figure><h5 id="4-执行下列命令"><a href="#4-执行下列命令" class="headerlink" title="4. 执行下列命令"></a>4. 执行下列命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo echo &quot;export LUAJIT_LIB=/usr/local/luajit/lib&quot; &gt;&gt; /etc/profile</span><br><span class="line">sudo echo &quot;export LUAJIT_INC=/usr/local/luajit/include/luajit-2.1&quot; &gt;&gt; /etc/profile</span><br></pre></td></tr></table></figure><h5 id="5-查看当前nginx模块环境"><a href="#5-查看当前nginx模块环境" class="headerlink" title="5.查看当前nginx模块环境"></a>5.查看当前nginx模块环境</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx -V</span><br><span class="line"></span><br><span class="line">configure arguments: --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-compat --with-file-aio --with-threads --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --with-cc-opt=&apos;-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -m64 -mtune=generic -fPIC&apos; --with-ld-opt=&apos;-Wl,-z,relro -Wl,-z,now -pie&apos;</span><br></pre></td></tr></table></figure><h5 id="6-下载1-17版本的nginx源码-也可以使用其他版本的Nginx"><a href="#6-下载1-17版本的nginx源码-也可以使用其他版本的Nginx" class="headerlink" title="6.下载1.17版本的nginx源码(也可以使用其他版本的Nginx)"></a>6.下载1.17版本的nginx源码(也可以使用其他版本的Nginx)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~/</span><br><span class="line">wget &apos;http://nginx.org/download/nginx-1.17.0.tar.gz&apos;</span><br><span class="line">tar -zxvf nginx-1.17.0.tar.gz</span><br><span class="line">cd nginx-1.17.0</span><br></pre></td></tr></table></figure><h5 id="7-重新编译nginx-在第五步的nginx编译参数最后加上下面lua编译参数"><a href="#7-重新编译nginx-在第五步的nginx编译参数最后加上下面lua编译参数" class="headerlink" title="7.重新编译nginx.在第五步的nginx编译参数最后加上下面lua编译参数"></a>7.重新编译nginx.在第五步的nginx编译参数最后加上下面lua编译参数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--add-module=/usr/local/src/ngx_devel_kit-0.2.19 --add-module=/usr/local/src/lua-nginx-module-0.10.9rc7</span><br><span class="line"></span><br><span class="line">#编译完后开始安装</span><br><span class="line">make -j2</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h5 id="8-检查nginx-版本和模块"><a href="#8-检查nginx-版本和模块" class="headerlink" title="8 检查nginx 版本和模块"></a>8 检查nginx 版本和模块</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#检查Nginx新版本</span><br><span class="line">[work@rainbow ~]$ nginx -v</span><br><span class="line">nginx version: nginx/1.17.0</span><br><span class="line"></span><br><span class="line">#检查lua模块是否生效.最后2行表示lua模块已经编译到Nginx中</span><br><span class="line">[work@rainbow ~]$ nginx -V</span><br><span class="line">nginx version: nginx/1.17.0</span><br><span class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC)</span><br><span class="line">built with OpenSSL 1.0.2k-fips  26 Jan 2017</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-compat --with-file-aio --with-threads --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --with-cc-opt=&apos;-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -m64 -mtune=generic -fPIC&apos; --with-ld-opt=&apos;-Wl,-z,relro -Wl,-z,now -pie&apos; --add-module=/usr/local/src/ngx_devel_kit-0.2.19 --add-module=/usr/local/lua-nginx-module-0.10.9rc7</span><br></pre></td></tr></table></figure><h5 id="9-如果上一步执行有问题则执行下列命令"><a href="#9-如果上一步执行有问题则执行下列命令" class="headerlink" title="9.如果上一步执行有问题则执行下列命令"></a>9.如果上一步执行有问题则执行下列命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;/usr/local/LuaJIT/lib&quot; &gt;&gt; /etc/ld.so.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure><h5 id="10-测试lua是否支持"><a href="#10-测试lua是否支持" class="headerlink" title="10.测试lua是否支持"></a>10.测试lua是否支持</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在Nginx配置文件中加入下列配置</span><br><span class="line"></span><br><span class="line">location /hello_lua &#123; </span><br><span class="line">      default_type &apos;text/plain&apos;; </span><br><span class="line">      content_by_lua &apos;ngx.say(&quot;hello, lua&quot;)&apos;; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#访问nginx测试是否返回hello lua</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装Lua模块&quot;&gt;&lt;a href=&quot;#安装Lua模块&quot; class=&quot;headerlink&quot; title=&quot;安装Lua模块&quot;&gt;&lt;/a&gt;安装Lua模块&lt;/h2&gt;&lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jesse.top/2020/06/26/experience/net.ipv4.tcp_tw_recycle%E8%B8%A9%E7%9A%84%E5%9D%91/"/>
    <id>https://jesse.top/2020/06/26/experience/net.ipv4.tcp_tw_recycle踩的坑/</id>
    <published>2020-06-26T04:09:07.903Z</published>
    <updated>2020-06-26T06:49:51.094Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title:net.ipv4.tcp_tw_recycle踩的坑<br>date:2019-01-7 09:59:58<br>tags:experence<br>categories:experence<br>comments:true</p><h2 id="copyright-true"><a href="#copyright-true" class="headerlink" title="copyright:true"></a>copyright:true</h2><h2 id="net-ipv4-tcp-tw-recycle踩的坑"><a href="#net-ipv4-tcp-tw-recycle踩的坑" class="headerlink" title="net.ipv4.tcp_tw_recycle踩的坑"></a>net.ipv4.tcp_tw_recycle踩的坑</h2><p>参考博文:<a href="https://www.cnxct.com/coping-with-the-tcp-time_wait-state-on-busy-linux-servers-in-chinese-and-dont-enable-tcp_tw_recycle/" target="_blank" rel="noopener">https://www.cnxct.com/coping-with-the-tcp-time_wait-state-on-busy-linux-servers-in-chinese-and-dont-enable-tcp_tw_recycle/</a></p><p>在做系统调优的时候希望能加快<code>TIME_WAIT</code>状态的回收，通常将<code>net.ipv4.tcp_tw_recycle</code>选项开启，但是,请注意这里有个坑</p><h3 id="故障现象"><a href="#故障现象" class="headerlink" title="故障现象"></a>故障现象</h3><p>我们阿里云上有一台BETA测试服务器自从上次将CPU配置从4核升级到8核,然后重启服务器以后..访问该服务器上的web网站经常出现卡顿的现象,大概是每隔几分钟出现一次,很快又恢复.</p><p>1.初步怀疑是BETA服务器性能不行,包括后端数据库拥挤导致</p><p>但是经过排查发现,故障发生时,服务器性能没有任何压力,后端数据库也正常.</p><p>2.在服务器上创建一个hello world 的静态网站,发现连静态网站都无法访问.</p><p>在访问网站的时候,长时间停留在TCP_NODELAY set阶段:</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$curl -vvv &quot;http://test.beta.haoshiqi.net&quot;</span><br><span class="line">* About to connect() to opadmin.beta.haoshiqi.net port 80 (#0)</span><br><span class="line">*   Trying 114.55.108.51...</span><br><span class="line">* TCP_NODELAY set</span><br></pre></td></tr></table></figure><p>通过telnet工具发现BETA服务器的80端口不通.</p><ol start="3"><li>转而怀疑是办公室网络问题.</li></ol><p>但是办公室访问其他阿里云服务器,访问线上环境,日常办公访问互联网又一切正常,在使用mtr,traceroute等工具排查路径节点时也一切正常,没有丢包线下.ping BETA服务器也没有任何丢包现象.</p><ol start="4"><li>转而怀疑是BETA服务器问题.</li></ol><p>但是在办公室网络访问出现故障时的同一时间,其他阿里云服务器访问BETA服务器上的网站又是一切正常,没有任何故障.用手机4G网络访问BETA也一切正常.</p><p>其他线索:</p><p>在晚上下班后,BETA服务器没有访问量时,从办公室访问BETA服务器一切正常,故障没有复现</p><p>5.经过抓包发现客户端发出了大量的TCP重传,但是服务器没有回应SYN报文.</p><p>BETA服务端tcpdump抓包命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -s 0 -i eth1 host 27.115.51.166 -w /tmp/beta_server.cap</span><br></pre></td></tr></table></figure><p>客户端本地tcpdump抓包命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -s 0 -i en4 host 114.55.108.51 -w ~/Desktop/beta.cap</span><br></pre></td></tr></table></figure><p>当故障出现时，服务器端其实是已经接送到TCP三次握手的SYN包，但不回应ACK给客户端，导致客户端一直处于等待状态.</p><hr><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>后来发现是系统内核优化时,开启了net.ipv4.tcp_tw_recycle参数.这个参数用来优化快速回收TIME_WAIT的socket.但是默认tcp_timestamps也是开启的.当开启了<code>tcp_tw_recycle和timestamps选项后，当连接进入</code>TIME_WAIT`状态后，会记录对应远端主机最后到达分节的时间戳。如果同样的主机有新的分节到达，且时间戳小于之前记录的时间戳，即视为无效，相应的数据包会被丢弃;</p><p>我们的BETA服务器在上班时间使用比较频繁.这也导致了在上班时间内一个公网IP（经过NAT）大量地去反问服务器，不同客户端的时间可能不一致，所以就会出现时间戳错乱的现象，于是后面的数据包就被丢弃了，具体的表现通常是是客户端明明发送的SYN，但服务端就是不响应ACK.</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>很多时候我们在做系统调优的情况时，都是直接在网上看一堆的内核参数，然后直接使用，却没有仔细研究过，很多时候，坑只有是自己拆过后才能记住，像这次这个<code>net.ipv4.tcp_tw_recycle</code>故障网上很多分享，看过和自己碰到过还真不一样，好记性不如烂笔头，慢慢记录，慢慢积累，坑应该会越来越少的；</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title:net.ipv4.tcp_tw_recycle踩的坑&lt;br&gt;date:2019-01-7 09:59:58&lt;br&gt;tags:experence&lt;br&gt;categories:experence&lt;br&gt;comments:true&lt;/p&gt;
&lt;h2 id=&quot;copyright-true&quot;&gt;&lt;a href=&quot;#copyright-true&quot; class=&quot;headerlink&quot; title=&quot;copyright:true&quot;&gt;&lt;/a&gt;copyright:true&lt;/h2&gt;&lt;h2 id=&quot;net-ipv4-tcp-tw-recycle踩的坑&quot;&gt;&lt;a href=&quot;#net-ipv4-tcp-tw-recycle踩的坑&quot; class=&quot;headerlink&quot; title=&quot;net.ipv4.tcp_tw_recycle踩的坑&quot;&gt;&lt;/a&gt;net.ipv4.tcp_tw_recycle踩的坑&lt;/h2&gt;&lt;p&gt;参考博文:&lt;a href=&quot;https://www.cnxct.com/coping-with-the-tcp-time_wait-state-on-busy-linux-servers-in-chinese-and-dont-enable-tcp_tw_recycle/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnxct.com/coping-with-the-tcp-time_wait-state-on-busy-linux-servers-in-chinese-and-dont-enable-tcp_tw_recycle/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在做系统调优的时候希望能加快&lt;code&gt;TIME_WAIT&lt;/code&gt;状态的回收，通常将&lt;code&gt;net.ipv4.tcp_tw_recycle&lt;/code&gt;选项开启，但是,请注意这里有个坑&lt;/p&gt;
&lt;h3 id=&quot;故障现象&quot;&gt;&lt;a href=&quot;#故障现象&quot; class=&quot;headerlink&quot; title=&quot;故障现象&quot;&gt;&lt;/a&gt;故障现象&lt;/h3&gt;&lt;p&gt;我们阿里云上有一台BETA测试服务器自从上次将CPU配置从4核升级到8核,然后重启服务器以后..访问该服务器上的web网站经常出现卡顿的现象,大概是每隔几分钟出现一次,很快又恢复.&lt;/p&gt;
&lt;p&gt;1.初步怀疑是BETA服务器性能不行,包括后端数据库拥挤导致&lt;/p&gt;
&lt;p&gt;但是经过排查发现,故障发生时,服务器性能没有任何压力,后端数据库也正常.&lt;/p&gt;
&lt;p&gt;2.在服务器上创建一个hello world 的静态网站,发现连静态网站都无法访问.&lt;/p&gt;
&lt;p&gt;在访问网站的时候,长时间停留在TCP_NODELAY set阶段:&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kong+postgresql+konga集群环境部署</title>
    <link href="https://jesse.top/2020/06/26/Linux-Web/kong%20postgresql%20konga/"/>
    <id>https://jesse.top/2020/06/26/Linux-Web/kong postgresql konga/</id>
    <published>2020-06-26T03:59:58.000Z</published>
    <updated>2020-06-26T03:09:18.121Z</updated>
    
    <content type="html"><![CDATA[<h2 id="kong-postgresql-konga集群环境部署"><a href="#kong-postgresql-konga集群环境部署" class="headerlink" title="kong+postgresql+konga集群环境部署"></a>kong+postgresql+konga集群环境部署</h2><h3 id="kong简介"><a href="#kong简介" class="headerlink" title="kong简介"></a>kong简介</h3><p>Kong是Mashape开源的一款API网关，起初是用来管理 Mashape 公司15000个微服务的，后来在2015年开源,现在已经在很多创业公司、大型企业和政府机构中广泛使用。基于nginx,Lua和Cassandra或PostgreSQL，支持分布式操作，有很强的可移植性和可扩展性。可以在任何一种基础设施上运行,作为应用和API之间的中间层，加上众多功能强大的插件，可以实现认证授权、访问控制等功能。并且提供易于使用的RESTful API来操作和配置系统。</p><p>有关kong的详细介绍请参考官网.</p><p>–</p><h3 id="postgreSQL简介"><a href="#postgreSQL简介" class="headerlink" title="postgreSQL简介"></a>postgreSQL简介</h3><p><a href="https://baike.baidu.com/item/PostgreSQL/530240" target="_blank" rel="noopener">PostgreSQL</a> 是一个免费的对象-关系数据库服务器(数据库管理系统)，它在灵活的 BSD-风格许可证下发行。它提供了相对其他开放源代码数据库系统(比如 MySQL 和 Firebird)，和专有系统(比如 Oracle、Sybase、IBM 的 DB2 和 Microsoft SQL Server)之外的另一种选择。</p><p>–</p><h3 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h3><ul><li><strong>kong cluster</strong></li></ul><p>kong 集群并不意味着客户端请求将会负载均衡到kong集群中的每个节点上，kong集群并不是开箱即用，仍然需要在kong集群多节点上层搭建负载均衡，以便分发请求。 一个kong集群只是意味着集群内的节点，都共享同样的配置。</p><p>有关Kong cluster集群的详细介绍请参考官网:<a href="https://docs.konghq.com/0.14.x/clustering/" target="_blank" rel="noopener">Kong cluser document</a></p><p>为了提高冗余性和健壮性.我们对kong的每个环节都进行了冗余设计.一个基本的kong集群架构大概如下图所示:</p><p><img src="https://img1.jesse.top/kong-flow.png" alt=""></p><a id="more"></a><p>–</p><h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3><p><strong>环境</strong>: </p><p>阿里云ECS Centos7.4操作系统<br>Kong: 1.0最新版<br>postgresql 9.6</p><p>konga 最新版</p><p><strong>集群架构说明:</strong></p><p>dwd-kong-node1节点服务器部署postgresql master主库</p><p>dwd-kong-node2节点服务器部署postgresql slave从库</p><p>在两个Kong节点服务器上都部署konga,但是konga指向postgresql master主库</p><p>–</p><h4 id="安装postgresql"><a href="#安装postgresql" class="headerlink" title="安装postgresql"></a>安装postgresql</h4><p>安装方式官网参考: <a href="https://www.postgresql.org/" target="_blank" rel="noopener">Installing Postgresql</a></p><p><strong>安装步骤</strong></p><p>1.安装Postgre9.6版本的Yum源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install https://download.postgresql.org/pub/repos/yum/9.6/redhat/rhel-7-x86_64/pgdg-centos96-9.6-3.noarch.rpm</span><br></pre></td></tr></table></figure><p>2.安装postgresql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install postgresql96 postgresql96-server -y</span><br></pre></td></tr></table></figure><p>3.切换到root用户下,初始化数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/pgsql-9.6/bin/postgresql96-setup initdb</span><br></pre></td></tr></table></figure><p>4.修改数据库的配置文件,监听所有接口</p><p>postgresql的配置文件默认路径在:/var/lib/pgsql/9.6/data/postgresql.conf</p><p>修改下列配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">listen_addresses = &apos;*&apos; #监听所有接口.由于我服务器只有内网地址,所有可以侦听在所有接口,(如果有公网地址,最好不要只样做)</span><br><span class="line">log_directory = &apos;/data/logs/postgre&apos; #指定日志文件的父目录</span><br></pre></td></tr></table></figure><p>5.修改数据库远程访问配置文件.开启远程访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /var/lib/pgsql/9.6/data/postgresql.conf/pg_hba.conf</span><br><span class="line"></span><br><span class="line">修改下列两项:</span><br><span class="line">#修改为md5认证,下列10.0.0.0/8是内网地址段</span><br><span class="line">host    all             all             127.0.0.1/32            md5</span><br><span class="line">host    all             all             10.0.0.0/8           md5</span><br></pre></td></tr></table></figure><p>6.创建日志目录,并且赋权给postgres用户(安装postgresql后默认会创建这个用户)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@dwd-kong-node1 data]# mkdir /data/logs/postgre</span><br><span class="line">[root@dwd-kong-node1 data]# chown -R postgre.postgre /data/logs/postgre</span><br></pre></td></tr></table></figure><p>7.启动postgresql数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable postgresql-9.6</span><br><span class="line">systemctl start postgresql-9.6</span><br></pre></td></tr></table></figure><hr><h3 id="创建数据库用户密码"><a href="#创建数据库用户密码" class="headerlink" title="创建数据库用户密码"></a>创建数据库用户密码</h3><p>1.切换到postgres用户,输入psql登陆数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@dwd-kong-node1 data]# su - postgres</span><br><span class="line">Last login: Mon Apr  8 09:27:12 CST 2019 on pts/0</span><br><span class="line">-bash-4.2$</span><br><span class="line">-bash-4.2$ psql</span><br><span class="line">psql (11.2, server 9.6.12)</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">postgres=#</span><br></pre></td></tr></table></figure><p>2.创建kong用户和kong数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER kong; </span><br><span class="line">CREATE DATABASE kong OWNER kong;</span><br></pre></td></tr></table></figure><p>3.创建konga的数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE konga OWNER kong;</span><br></pre></td></tr></table></figure><p>4.为kong用户创建一个密码,密码也是kong</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter user kong with password &apos;kong&apos;;</span><br></pre></td></tr></table></figure><p>5.输入\l,可以看到当前的数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">postgres=# \l</span><br><span class="line">                                  List of databases</span><br><span class="line">   Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges</span><br><span class="line">-----------+----------+----------+-------------+-------------+-----------------------</span><br><span class="line"> kong      | kong     | UTF8     | en_US.UTF-8 | en_US.UTF-8 |</span><br><span class="line"> konga     | kong     | UTF8     | en_US.UTF-8 | en_US.UTF-8 |</span><br><span class="line"> postgres  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |</span><br><span class="line"> template0 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +</span><br><span class="line">           |          |          |             |             | postgres=CTc/postgres</span><br><span class="line"> template1 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +</span><br><span class="line">           |          |          |             |             | postgres=CTc/postgres</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure><p>6.查看当前数据库有哪些用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">postgres=# select * from pg_roles;</span><br><span class="line">      rolname      | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolconnlimit | rolpassword | rolvaliduntil | rolbypassrls | rolconfig |  oid</span><br><span class="line">-------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+-------------+---------------+--------------+-----------+-------</span><br><span class="line"> postgres          | t        | t          | t             | t           | t           | t              |           -1 | ********    |               | t            |           |    10</span><br><span class="line"> pg_signal_backend | f        | t          | f             | f           | f           | f              |           -1 | ********    |               | f            |           |  4200</span><br><span class="line"> kong              | f        | t          | f             | f           | t           | f              |           -1 | ********    |               | f            |           | 16384</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure><hr><h4 id="安装Kong"><a href="#安装Kong" class="headerlink" title="安装Kong"></a>安装Kong</h4><p>安装方法可以参考官网:<a href="https://docs.konghq.com/install/centos/?_ga=2.110797315.728319704.1539597667-917309945.1539077269#packages" target="_blank" rel="noopener">Install Kong</a></p><p>1.下载,安装rpm安装包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget -O kong-community-edition-1.0.0.el7.noarch.rpm  https://kong.bintray.com/kong-community-edition-rpm/centos/7/:kong-community-edition-1.0.0.el7.noarch.rpm</span><br><span class="line"></span><br><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install kong-community-edition-1.0.0.el7.noarch.rpm</span><br></pre></td></tr></table></figure><p>2.dwd-kong-node1修改kong配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/kong</span><br><span class="line">sudo cp kong.conf.default kong.conf</span><br><span class="line"></span><br><span class="line">[root@dwd-kong-node1 data]#  sed -r &apos;/^[[:space:]]+#*/d&apos; /etc/kong/kong.conf | sed &apos;/^#/d&apos; | sed &apos;/^$/d&apos;</span><br><span class="line"></span><br><span class="line">prefix = /data/logs/kong/       # Working directory. Equivalent to Nginx&apos;s</span><br><span class="line">proxy_access_log = access.log       # Path for proxy port request access</span><br><span class="line">proxy_error_log = error.log         # Path for proxy port request error</span><br><span class="line">admin_listen = 0.0.0.0:8001     # Address and port on which Kong will expose</span><br><span class="line">database = postgres             # Determines which of PostgreSQL or Cassandra</span><br><span class="line">pg_host = 127.0.0.1             # The PostgreSQL host to connect to.</span><br><span class="line">pg_port = 5432                  # The port to connect to.</span><br><span class="line">pg_user = kong                  # The username to authenticate if required.</span><br><span class="line">pg_password = kong                 # The password to authenticate if required.</span><br><span class="line">pg_database = kong              # The database name to connect to.</span><br><span class="line">cluster_listen = 0.0.0.0:7946   # Address and port used to communicate with</span><br><span class="line">cluster_listen_rpc = 127.0.0.1:7373  # Address and port used to communicate</span><br></pre></td></tr></table></figure><p>3.dwd-kong-node2修改kong配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@dwd-kong-node2 system]# clear</span><br><span class="line">[root@dwd-kong-node2 system]# sed -r &apos;/^[[:space:]]+#*/d&apos; /etc/kong/kong.conf | sed &apos;/^#/d&apos; | sed &apos;/^$/d&apos;</span><br><span class="line">prefix = /data/logs/kong/       # Working directory. Equivalent to Nginx&apos;s</span><br><span class="line">proxy_access_log = access.log       # Path for proxy port request access</span><br><span class="line">proxy_error_log = error.log         # Path for proxy port request error</span><br><span class="line">database = postgres             # Determines which of PostgreSQL or Cassandra</span><br><span class="line">pg_host = 10.111.30.174             # The PostgreSQL host to connect to.</span><br><span class="line">pg_port = 5432                  # The port to connect to.</span><br><span class="line">pg_user = kong                  # The username to authenticate if required.</span><br><span class="line">pg_password = kong                 # The password to authenticate if required.</span><br><span class="line">pg_database = kong              # The database name to connect to.</span><br><span class="line">pg_ssl = off                    # Toggles client-server TLS connections</span><br><span class="line">pg_ssl_verify = off             # Toggles server certificate verification if</span><br><span class="line">cluster_listen = 0.0.0.0:7946   # Address and port used to communicate with</span><br><span class="line">cluster_listen_rpc = 127.0.0.1:7373  # Address and port used to communicate</span><br></pre></td></tr></table></figure><blockquote><p>唯一区别就是这里的数据库指向dwd-kong-node1上的postgresql(IP:10.111.30.174),而非本机.</p></blockquote><p>3.创建kong目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/logs/kong/</span><br></pre></td></tr></table></figure><p>4.在dwd-kong-node1上准备数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kong migrations bootstrap -c /etc/kong/kong.conf</span><br></pre></td></tr></table></figure><blockquote><p>由于dwd-kong-node2上指向了node1的数据库,所以在node2上不需要执行这个命令</p></blockquote><p>5.启动kong</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kong start -c /etc/kong/kong.conf</span><br></pre></td></tr></table></figure><p>查看端口.可以看到postgresql和kong的侦听端口都已经成功启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@dwd-kong-node1 data]# netstat -tulpn</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class="line">tcp        0      0 0.0.0.0:5432            0.0.0.0:*               LISTEN      26580/postmaster</span><br><span class="line">tcp        0      0 0.0.0.0:8443            0.0.0.0:*               LISTEN      24746/nginx: master</span><br><span class="line">tcp        0      0 0.0.0.0:5822            0.0.0.0:*               LISTEN      29688/sshd</span><br><span class="line">tcp        0      0 0.0.0.0:8000            0.0.0.0:*               LISTEN      24746/nginx: master</span><br><span class="line">tcp        0      0 0.0.0.0:8001            0.0.0.0:*               LISTEN      24746/nginx: master</span><br><span class="line">tcp6       0      0 :::5432                 :::*                    LISTEN      26580/postmaster</span><br><span class="line">udp        0      0 0.0.0.0:68              0.0.0.0:*                           748/dhclient</span><br><span class="line">udp        0      0 10.111.30.174:123       0.0.0.0:*                           6290/ntpd</span><br><span class="line">udp        0      0 127.0.0.1:123           0.0.0.0:*                           6290/ntpd</span><br><span class="line">udp        0      0 0.0.0.0:123             0.0.0.0:*                           6290/ntpd</span><br><span class="line">udp        0      0 0.0.0.0:34019           0.0.0.0:*                           748/dhclient</span><br><span class="line">udp6       0      0 :::31421                :::*                                748/dhclient</span><br><span class="line">udp6       0      0 :::123                  :::*                                6290/ntpd</span><br></pre></td></tr></table></figure><hr><h3 id="搭建konga"><a href="#搭建konga" class="headerlink" title="搭建konga"></a>搭建konga</h3><p>konga是管理kong各个组件(serveice,route,plugin,upstream,consumer)的可视化UI管理工具.在增删改查各个组件的配置时非常方便.</p><p>个人觉得UI界面比kong-dashboard要漂亮</p><p>konga的github参考:<a href="https://github.com/pantsel/konga" target="_blank" rel="noopener">konga</a></p><hr><p>1.确保需要有node.js环境.如果没有npm工具,必须先安装nodejs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@DWD-BETA kong]$ npm -v</span><br><span class="line">6.4.1</span><br><span class="line">[work@DWD-BETA kong]$ node -v</span><br><span class="line">v10.15.3</span><br></pre></td></tr></table></figure><p>2.安装bower,gulp包.安装git软件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install bower</span><br><span class="line">npm install gulp</span><br><span class="line">yum install git</span><br></pre></td></tr></table></figure><p>3.work用户下安装konga</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/pantsel/konga.git</span><br><span class="line">$ cd konga</span><br><span class="line">$ npm i</span><br></pre></td></tr></table></figure><p>4.编辑.env环境文件(dwd-kong-node2的文件内容中将下列的localhost修改为node1服务器的IP:10.111.30.174)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">work@dwd-kong-node1 konga]$ cat .env_example</span><br><span class="line">PORT=1337</span><br><span class="line">NODE_ENV=production</span><br><span class="line">KONGA_HOOK_TIMEOUT=120000</span><br><span class="line">DB_ADAPTER=postgres</span><br><span class="line">DB_URI=postgresql://localhost:5432/konga</span><br><span class="line">KONGA_LOG_LEVEL=warn</span><br><span class="line">TOKEN_SECRET=some_secret_token</span><br><span class="line">DB_USER=kong</span><br><span class="line">DB_PASSWORD=kong</span><br><span class="line">DB_DATABASE=konga</span><br></pre></td></tr></table></figure><p>5.启动konga</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">work@dwd-kong-node1 konga]$ npm start</span><br></pre></td></tr></table></figure><p>6.如果启动报错,则安装依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">work@dwd-kong-node1 konga]$ npm run bower-deps</span><br></pre></td></tr></table></figure><p>这个程序默认是前台启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[work@dwd-kong-node1 konga]$ npm start</span><br><span class="line"></span><br><span class="line">&gt; kongadmin@0.14.3 start /home/work/konga</span><br><span class="line">&gt; node --harmony app.js</span><br><span class="line"></span><br><span class="line">No DB Adapter defined. Using localDB...</span><br><span class="line">debug: Hook:api_health_checks:process() called</span><br><span class="line">debug: Hook:health_checks:process() called</span><br><span class="line">debug: Hook:start-scheduled-snapshots:process() called</span><br><span class="line">debug: Hook:upstream_health_checks:process() called</span><br><span class="line">debug: Hook:user_events_hook:process() called</span><br><span class="line">debug: User had models, so no seed needed</span><br><span class="line">debug: Kongnode had models, so no seed needed</span><br><span class="line">debug: Emailtransport seeds updated</span><br><span class="line">debug: -------------------------------------------------------</span><br><span class="line">debug: :: Mon Apr 08 2019 18:34:31 GMT+0800 (China Standard Time)</span><br><span class="line">debug: Environment : development</span><br><span class="line">debug: Port        : 1337</span><br><span class="line">debug: -------------------------------------------------------</span><br></pre></td></tr></table></figure><p>此时在浏览器输入:<a href="http://10.111.30.174:1337" target="_blank" rel="noopener">http://10.111.30.174:1337</a> 就能访问konga了.</p><hr><h3 id="systemctl管理kong和konga进程"><a href="#systemctl管理kong和konga进程" class="headerlink" title="systemctl管理kong和konga进程"></a>systemctl管理kong和konga进程</h3><ul><li>kong</li></ul><p>在/usr/lib/systemd/system路径下编辑kong.service文件.内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">work@dwd-kong-node1 system]$ pwd</span><br><span class="line">/usr/lib/systemd/system</span><br><span class="line">[work@dwd-kong-node1 system]$ cat kong.service</span><br><span class="line">[Unit]</span><br><span class="line">Description= kong service</span><br><span class="line">After=syslog.target network.target postgresql-9.6.target</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=work</span><br><span class="line">Group=work</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/kong start -c /etc/kong/kong.conf</span><br><span class="line">ExecReload=/usr/local/bin/kong reload -c /etc/kong/kong.conf</span><br><span class="line">ExecStop=/usr/local/bin/kong stop</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><ul><li>konga</li></ul><p>在/usr/lib/systemd/system路径下编辑konga.service文件.内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[work@dwd-kong-node1 system]$ cat konga.service</span><br><span class="line">[Unit]</span><br><span class="line">Description= konga service</span><br><span class="line">After=syslog.target network.target postgresql-9.6.target  kong.target</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=work</span><br><span class="line">Group=work</span><br><span class="line">Type=forking</span><br><span class="line">#需要指定工作目录,因为npm命令要在konga的目录下执行</span><br><span class="line">WorkingDirectory=/home/work/konga</span><br><span class="line">ExecStart=/usr/local/bin/npm start</span><br><span class="line">ExecStop=kill $(netstat -tlnp |grep 1337|  awk &apos;&#123;print $NF&#125;&apos; | awk -F &quot;/&quot; &apos;&#123;print $1&#125;&apos;)</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><ul><li>启动进程,且设置开机启动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[work@dwd-kong-node2 ~]$ sudo systemctl enable kong</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/kong.service to /usr/lib/systemd/system/kong.service.</span><br><span class="line">[work@dwd-kong-node2 ~]$ sudo systemctl enable konga.service</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/konga.service to /usr/lib/systemd/system/konga.service.</span><br><span class="line">[work@dwd-kong-node2 ~]$ sudo systemctl start kong.service</span><br><span class="line">[work@dwd-kong-node2 ~]$ sudo systemctl start konga.service</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;kong-postgresql-konga集群环境部署&quot;&gt;&lt;a href=&quot;#kong-postgresql-konga集群环境部署&quot; class=&quot;headerlink&quot; title=&quot;kong+postgresql+konga集群环境部署&quot;&gt;&lt;/a&gt;kong+postgresql+konga集群环境部署&lt;/h2&gt;&lt;h3 id=&quot;kong简介&quot;&gt;&lt;a href=&quot;#kong简介&quot; class=&quot;headerlink&quot; title=&quot;kong简介&quot;&gt;&lt;/a&gt;kong简介&lt;/h3&gt;&lt;p&gt;Kong是Mashape开源的一款API网关，起初是用来管理 Mashape 公司15000个微服务的，后来在2015年开源,现在已经在很多创业公司、大型企业和政府机构中广泛使用。基于nginx,Lua和Cassandra或PostgreSQL，支持分布式操作，有很强的可移植性和可扩展性。可以在任何一种基础设施上运行,作为应用和API之间的中间层，加上众多功能强大的插件，可以实现认证授权、访问控制等功能。并且提供易于使用的RESTful API来操作和配置系统。&lt;/p&gt;
&lt;p&gt;有关kong的详细介绍请参考官网.&lt;/p&gt;
&lt;p&gt;–&lt;/p&gt;
&lt;h3 id=&quot;postgreSQL简介&quot;&gt;&lt;a href=&quot;#postgreSQL简介&quot; class=&quot;headerlink&quot; title=&quot;postgreSQL简介&quot;&gt;&lt;/a&gt;postgreSQL简介&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/PostgreSQL/530240&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PostgreSQL&lt;/a&gt; 是一个免费的对象-关系数据库服务器(数据库管理系统)，它在灵活的 BSD-风格许可证下发行。它提供了相对其他开放源代码数据库系统(比如 MySQL 和 Firebird)，和专有系统(比如 Oracle、Sybase、IBM 的 DB2 和 Microsoft SQL Server)之外的另一种选择。&lt;/p&gt;
&lt;p&gt;–&lt;/p&gt;
&lt;h3 id=&quot;集群架构&quot;&gt;&lt;a href=&quot;#集群架构&quot; class=&quot;headerlink&quot; title=&quot;集群架构&quot;&gt;&lt;/a&gt;集群架构&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;kong cluster&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;kong 集群并不意味着客户端请求将会负载均衡到kong集群中的每个节点上，kong集群并不是开箱即用，仍然需要在kong集群多节点上层搭建负载均衡，以便分发请求。 一个kong集群只是意味着集群内的节点，都共享同样的配置。&lt;/p&gt;
&lt;p&gt;有关Kong cluster集群的详细介绍请参考官网:&lt;a href=&quot;https://docs.konghq.com/0.14.x/clustering/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kong cluser document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为了提高冗余性和健壮性.我们对kong的每个环节都进行了冗余设计.一个基本的kong集群架构大概如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img1.jesse.top/kong-flow.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux-Web" scheme="https://jesse.top/categories/Linux-Web/"/>
    
      <category term="kong" scheme="https://jesse.top/categories/Linux-Web/kong/"/>
    
    
      <category term="kong" scheme="https://jesse.top/tags/kong/"/>
    
  </entry>
  
  <entry>
    <title>docker安装最新版Kong(v1.0)+konga</title>
    <link href="https://jesse.top/2020/06/26/Linux-Web/docker%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88Kong(v1.0)%20konga/"/>
    <id>https://jesse.top/2020/06/26/Linux-Web/docker安装最新版Kong(v1.0) konga/</id>
    <published>2020-06-26T03:59:58.000Z</published>
    <updated>2020-06-26T02:58:34.379Z</updated>
    
    <content type="html"><![CDATA[<h3 id="docker安装最新版Kong-v1-0-konga"><a href="#docker安装最新版Kong-v1-0-konga" class="headerlink" title="docker安装最新版Kong(v1.0)+konga"></a>docker安装最新版Kong(v1.0)+konga</h3><p>参考以下文档:</p><p><a href="https://docs.konghq.com/install/docker/?_ga=2.167535422.1288669860.1553147426-917309945.1539077269" target="_blank" rel="noopener">Kong installation</a></p><p><a href="https://github.com/pantsel/konga#installation" target="_blank" rel="noopener">konga github</a></p><hr><h4 id="docker安装kong-postgresql"><a href="#docker安装kong-postgresql" class="headerlink" title="docker安装kong+postgresql"></a>docker安装kong+postgresql</h4><p>1.创建一个docker网络用于docker,postgresql和konga容器间通信</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create kong-net</span><br></pre></td></tr></table></figure><p>2.启动posgtresql容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name kong-database \</span><br><span class="line">               --network=kong-net \</span><br><span class="line">               -p 5432:5432 \</span><br><span class="line">               -e &quot;POSTGRES_USER=kong&quot; \</span><br><span class="line">               -e &quot;POSTGRES_DB=kong&quot; \</span><br><span class="line">               postgres:9.6</span><br></pre></td></tr></table></figure><p>3.初始化postgresql数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm \</span><br><span class="line">    --network=kong-net \</span><br><span class="line">    -e &quot;KONG_DATABASE=postgres&quot; \</span><br><span class="line">    -e &quot;KONG_PG_HOST=kong-database&quot; \</span><br><span class="line">    -e &quot;KONG_CASSANDRA_CONTACT_POINTS=kong-database&quot; \</span><br><span class="line">    kong:latest kong migrations bootstrap</span><br></pre></td></tr></table></figure><blockquote><p>注意两点:</p><p>1.最好是先删除本地的kong镜像.因为本地的Kong:lastest镜像不一定就是最新版</p><p>2.如果本地的kong:latest镜像地域0.15版本,则不支持bootstrap命令.可以将bootstrap命令替换成up</p></blockquote><a id="more"></a><p>4.启动kong容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name kong \</span><br><span class="line">     --network=kong-net \</span><br><span class="line">     -v /data/logs/kong:/var/log/kong \</span><br><span class="line">     -v /data/apps/kong/plugins/:/usr/local/share/lua/5.1/kong/plugins/ \</span><br><span class="line">     -e &quot;KONG_DATABASE=postgres&quot; \</span><br><span class="line">     -e &quot;KONG_PG_HOST=kong-database&quot; \</span><br><span class="line">     -e &quot;KONG_CASSANDRA_CONTACT_POINTS=kong-database&quot; \</span><br><span class="line">     -e &quot;KONG_PROXY_ACCESS_LOG=/var/log/kong/access.log&quot; \</span><br><span class="line">     -e &quot;KONG_ADMIN_ACCESS_LOG=/var/log/kong/admin_access.log&quot; \</span><br><span class="line">     -e &quot;KONG_PROXY_ERROR_LOG=/var/log/kong/error.log&quot; \</span><br><span class="line">     -e &quot;KONG_ADMIN_ERROR_LOG=/var/log/kong/admin_error.log&quot; \</span><br><span class="line">     -e &quot;KONG_ADMIN_LISTEN=0.0.0.0:8001, 0.0.0.0:8444 ssl&quot; \</span><br><span class="line">     -p 8000:8000 \</span><br><span class="line">     -p 8443:8443 \</span><br><span class="line">     -p 8001:8001 \</span><br><span class="line">     -p 8444:8444 \</span><br><span class="line">     kong:latest</span><br></pre></td></tr></table></figure><blockquote><p>这里我映射了kong的插件目录和日志目录. </p></blockquote><ul><li>注意:要先吧kong容器里的/usr/local/share/lua/5.1/kong/plugins/目录下内容复制到宿主机的/data/apps/kong/plugins/目录下.否则宿主机的空目录会覆盖容器的插件目录,导致容器无法启动.</li></ul><p>kong容器目录拷贝到宿主机方法如下:</p><p>1.先不挂载目录启动kong容器</p><p>2.执行命令拷贝kong容器的/usr/local/share/lua/5.1/kong/plugins/ 目录到宿主机/data/apps/kong/plugins/目录下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[work@docker ~]$docker cp kong:/usr/local/share/lua/5.1/kong/plugins/  /data/apps/kong/plugins/</span><br></pre></td></tr></table></figure><blockquote><p>如果不需要将容器的kong插件目录映射到宿主机的话,这一步可以不需要做</p></blockquote><p>容器已经成功启动:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@docker conf.d]$docker ps | grep -E &quot;kong|postgre&quot;</span><br><span class="line">10fc881cca4b        kong:latest                                 &quot;/docker-entrypoin...&quot;   About an hour ago   Up About an hour    0.0.0.0:8000-8001-&gt;8000-8001/tcp, 0.0.0.0:8443-8444-&gt;8443-8444/tcp                                             kong</span><br><span class="line"></span><br><span class="line">afd1487e29a0        postgres:9.6                                &quot;docker-entrypoint...&quot;   3 hours ago         Up 3 hours          0.0.0.0:5432-&gt;5432/tcp                                                                                         kong-database</span><br></pre></td></tr></table></figure><hr><h4 id="安装konga"><a href="#安装konga" class="headerlink" title="安装konga"></a>安装konga</h4><p>konga是管理kong的一个dashboard界面.</p><p>1.先初始化数据库.这里也是用后端的postgresql数据库.官方命令如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm pantsel/konga:latest -c prepare -a &#123;&#123;adapter&#125;&#125; -u &#123;&#123;connection-uri&#125;&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>argument</th><th>description</th><th>default</th></tr></thead><tbody><tr><td>-c</td><td>command</td><td>-</td></tr><tr><td>-a</td><td>adapter (can be <code>postgres</code> or <code>mysql</code>)</td><td>-</td></tr><tr><td>-u</td><td>full database connection url</td></tr></tbody></table><p>执行以下命令,初始化数据库:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm pantsel/konga:latest -c prepare -a postgres -u  postgres://kong@10.0.0.250:5432/konga</span><br></pre></td></tr></table></figure><blockquote><p>这里稍微有点疑问的是数据库的connection url ..完整的connection url地址是: postgres://user:password@host:port/konga</p><p> postgres:<a href="mailto://kong@10.0.0.250" target="_blank" rel="noopener">//kong@10.0.0.250</a>:5432/konga —— 这里kong代表用户名,由于没有密码所以没有指定密码.10.0.0.250是postgresql的host主机名.konga表示初始化一个数据库</p></blockquote><p>执行结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[work@docker ~]$docker run --rm pantsel/konga:latest -c prepare -a postgres -u  postgres://kong@10.0.0.250:5432/konga</span><br><span class="line">debug: Preparing database...</span><br><span class="line">Using postgres DB Adapter.</span><br><span class="line">Database `konga` does not exist. Creating...</span><br><span class="line">Database `konga` created! Continue...</span><br><span class="line">debug: Hook:api_health_checks:process() called</span><br><span class="line">debug: Hook:health_checks:process() called</span><br><span class="line">debug: Hook:start-scheduled-snapshots:process() called</span><br><span class="line">debug: Hook:upstream_health_checks:process() called</span><br><span class="line">debug: Hook:user_events_hook:process() called</span><br><span class="line">debug: Seeding User...</span><br><span class="line">debug: User seed planted</span><br><span class="line">debug: Seeding Kongnode...</span><br><span class="line">debug: Kongnode seed planted</span><br><span class="line">debug: Seeding Emailtransport...</span><br><span class="line">debug: Emailtransport seed planted</span><br><span class="line">debug: Database migrations completed!</span><br></pre></td></tr></table></figure><ol start="2"><li>启动konga</li></ol><p>命令格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 1337:1337 </span><br><span class="line">             --network &#123;&#123;kong-network&#125;&#125; \ // optional</span><br><span class="line">             -e &quot;TOKEN_SECRET=&#123;&#123;somerandomstring&#125;&#125;&quot; \</span><br><span class="line">             -e &quot;DB_ADAPTER=the-name-of-the-adapter&quot; \ // &apos;mongo&apos;,&apos;postgres&apos;,&apos;sqlserver&apos;  or &apos;mysql&apos;</span><br><span class="line">             -e &quot;DB_HOST=your-db-hostname&quot; \</span><br><span class="line">             -e &quot;DB_PORT=your-db-port&quot; \ // Defaults to the default db port</span><br><span class="line">             -e &quot;DB_USER=your-db-user&quot; \ // Omit if not relevant</span><br><span class="line">             -e &quot;DB_PASSWORD=your-db-password&quot; \ // Omit if not relevant</span><br><span class="line">             -e &quot;DB_DATABASE=your-db-name&quot; \ // Defaults to &apos;konga_database&apos;</span><br><span class="line">             -e &quot;DB_PG_SCHEMA=my-schema&quot;\ // Optionally define a schema when integrating with prostgres</span><br><span class="line">             -e &quot;NODE_ENV=production&quot; \ // or &apos;development&apos; | defaults to &apos;development&apos;</span><br><span class="line">             --name konga \</span><br><span class="line">             pantsel/konga</span><br></pre></td></tr></table></figure><p>执行如下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 1337:1337 -d \</span><br><span class="line">             --network=kong-net \</span><br><span class="line">             -e &quot;DB_ADAPTER=postgres&quot; \</span><br><span class="line">             -e &quot;DB_HOST=10.0.0.250&quot; \</span><br><span class="line">             -e &quot;DB_PORT=5432&quot; \</span><br><span class="line">             -e &quot;DB_USER=kong&quot; \</span><br><span class="line">             -e &quot;DB_DATABASE=konga&quot; \</span><br><span class="line">             -e &quot;NODE_ENV=production&quot; \</span><br><span class="line">             --name konga \</span><br><span class="line">             pantsel/konga</span><br></pre></td></tr></table></figure><p>容器成功启动:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beb70407b417        pantsel/konga                               &quot;/app/start.sh&quot;          2 hours ago         Up 2 hours          0.0.0.0:1337-&gt;1337/tcp                                                                                         konga</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;docker安装最新版Kong-v1-0-konga&quot;&gt;&lt;a href=&quot;#docker安装最新版Kong-v1-0-konga&quot; class=&quot;headerlink&quot; title=&quot;docker安装最新版Kong(v1.0)+konga&quot;&gt;&lt;/a&gt;docker安装最新版Kong(v1.0)+konga&lt;/h3&gt;&lt;p&gt;参考以下文档:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.konghq.com/install/docker/?_ga=2.167535422.1288669860.1553147426-917309945.1539077269&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kong installation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/pantsel/konga#installation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;konga github&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;docker安装kong-postgresql&quot;&gt;&lt;a href=&quot;#docker安装kong-postgresql&quot; class=&quot;headerlink&quot; title=&quot;docker安装kong+postgresql&quot;&gt;&lt;/a&gt;docker安装kong+postgresql&lt;/h4&gt;&lt;p&gt;1.创建一个docker网络用于docker,postgresql和konga容器间通信&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker network create kong-net&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2.启动posgtresql容器&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker run -d --name kong-database \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               --network=kong-net \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               -p 5432:5432 \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               -e &amp;quot;POSTGRES_USER=kong&amp;quot; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               -e &amp;quot;POSTGRES_DB=kong&amp;quot; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               postgres:9.6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3.初始化postgresql数据库&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker run --rm \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    --network=kong-net \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -e &amp;quot;KONG_DATABASE=postgres&amp;quot; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -e &amp;quot;KONG_PG_HOST=kong-database&amp;quot; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -e &amp;quot;KONG_CASSANDRA_CONTACT_POINTS=kong-database&amp;quot; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    kong:latest kong migrations bootstrap&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;注意两点:&lt;/p&gt;
&lt;p&gt;1.最好是先删除本地的kong镜像.因为本地的Kong:lastest镜像不一定就是最新版&lt;/p&gt;
&lt;p&gt;2.如果本地的kong:latest镜像地域0.15版本,则不支持bootstrap命令.可以将bootstrap命令替换成up&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux-Web" scheme="https://jesse.top/categories/Linux-Web/"/>
    
    
      <category term="nginx" scheme="https://jesse.top/tags/nginx/"/>
    
      <category term="web" scheme="https://jesse.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>harbor私有仓库部署</title>
    <link href="https://jesse.top/2020/06/26/docker/harbor%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E9%83%A8%E7%BD%B2/"/>
    <id>https://jesse.top/2020/06/26/docker/harbor私有仓库部署/</id>
    <published>2020-06-26T03:59:58.000Z</published>
    <updated>2020-06-26T03:03:12.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="harbor私有仓库部署"><a href="#harbor私有仓库部署" class="headerlink" title="harbor私有仓库部署"></a>harbor私有仓库部署</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>harbor是docker的私有仓库,可以部署在局域网服务器上,用来管理docker镜像.虽然docker官方也提供公共镜像仓库,但是由于是境外网站,拉取镜像速度非常慢,而且有被墙的可能.部署私有仓库非常有必要</p><p>harbor是vmware公司开源的企业级的docker registry管理项目.</p><blockquote><p>处于数据脱敏需要,以下内容中隐藏了真实域名.而使用hub.xxxxxx.com替代</p></blockquote><hr><h3 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h3><p>harbor github: <a href="https://github.com/goharbor/harbor" target="_blank" rel="noopener">goharbor/harbor</a></p><p>官网文档介绍: <a href="https://goharbor.io/docs/1.10/" target="_blank" rel="noopener">harbor doc</a></p><p>在部署中遇到的各种坑,都可以通过查阅文档,或者搜索github的issue解决</p><hr><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>harbor是docker-compose部署的.包括一系列组件:nginx.core,log,register等等.</p><p>但是由于本机已经存在一个Nginx镜像.所以用Nginx代理到harbor的Nginx.<strong>如果是独立的服务器部署Harbor的话,则不会存在这个问题,可以直接跳过这一章节.</strong></p><p>nginx代理框架大概是:</p><p><strong>nginx—-&gt;harbor-nginx—–&gt;habor</strong></p><p>由于docker提交镜像需要Https协议,所以:</p><p><strong>nginx—301跳转到nginx https—–&gt;harbor-nginx http—-&gt; habor</strong></p><p>但是这样的部署方式,有一个问题:</p><p>私有仓库可以正常login但是push镜像的时候,又提示未验证.</p><p>该问题尝试过很多解决方案,但是均无法解决</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@idc-function-docker ~]# docker login --username=admin -pHarbor12345 hub.xxxxxx.com</span><br><span class="line">WARNING! Using --password via the CLI is insecure. Use --password-stdin.</span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br><span class="line">[root@idc-function-docker ~]# docker push hub.xxxxxx.com/master/nginx:latest</span><br><span class="line">The push refers to repository [hub.xxxxxx.com/master/nginx]</span><br><span class="line">d37eecb5b769: Pushing [==================================================&gt;]  3.584kB</span><br><span class="line">99134ec7f247: Preparing</span><br><span class="line">c3a984abe8a8: Preparing</span><br><span class="line">unauthorized: authentication required</span><br></pre></td></tr></table></figure><p>所以现在的架构是</p><p><strong>nginx—301跳转到Nginx https——&gt; harbor-nginx https——&gt;harbor</strong></p><hr><h3 id="harbor部署前提条件"><a href="#harbor部署前提条件" class="headerlink" title="harbor部署前提条件"></a>harbor部署前提条件</h3><ul><li>安装docker-ce</li><li>安装docker-composer</li><li>准备一个空目录.比如/data.或者/data/harbor (注意,最好是空目录,不要和其他项目混杂一起)</li><li>安装好https域名证书</li></ul><hr><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>docker和docker-compose的安装就略过了.这里提一句,我用的是acme.sh部署letsencrypt的证书</p><p>接下来开始部署harbor</p><ul><li>1.去github下载离线安装包.离线安装包虽然比较大,但是安装过程快速,且不会中断</li></ul><p>这里安装的是最新版,v1.10.1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在github下载 harbor-offline-installer-v1.10.1.tgz</span><br><span class="line">tar xvf 解压</span><br></pre></td></tr></table></figure><ul><li>2.解压后,进入harbor文件,编辑harbor.yaml配置文件.需要改动以下几个地方</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">hostname hub.xxxxxx.com  #定义主机名,可以使用IP,也可以用域名</span><br><span class="line"></span><br><span class="line">#定义https的服务器证书和秘钥的文件路径</span><br><span class="line">https:</span><br><span class="line">  # https port for harbor, default is 443</span><br><span class="line">  port: 443</span><br><span class="line">  # The path of cert and key files for nginx</span><br><span class="line">  certificate: /data/letsencrypt/hub.xxxxxx.com/fullchain.cer</span><br><span class="line">  private_key: /data/letsencrypt/hub.xxxxxx.com/hub.xxxxxx.com.key</span><br><span class="line">  </span><br><span class="line">#这是harbor命令行和浏览器登陆的初始密码..用户名是admin</span><br><span class="line">harbor_admin_password: Harbor12345</span><br><span class="line"></span><br><span class="line">#这是数据目录,最好是一个空目录</span><br><span class="line">data_volume: /data/apps/harbor</span><br><span class="line"></span><br><span class="line">#日志文件保存路径</span><br><span class="line">log:</span><br><span class="line">    location: /data/logs/harbor</span><br></pre></td></tr></table></figure><ul><li>3.执行install.sh文件.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#该脚本会检查主机的环境,拉取相关镜像.以及根据配置文件生成docker-compose文件.</span><br><span class="line">[root@idc-function-docker harbor]#./install.sh</span><br></pre></td></tr></table></figure><blockquote><p> 这个脚本执行到最后会报错,提示80端口和nginx容器已经被占用了.但是没关系.</p></blockquote><ul><li>4.修改docker-composer文件.(如果本机上没有nginx或者80端口没有被占用,这一步可以不做)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#将Nginx容器名改成hub-nginx</span><br><span class="line">#将80和443的端口映射修改一下,比如我这里</span><br><span class="line">proxy:</span><br><span class="line">    image: goharbor/nginx-photon:v1.10.1</span><br><span class="line">    container_name: hub-nginx</span><br><span class="line">ports:</span><br><span class="line">      - 8081:8080</span><br><span class="line">      - 4443:8443</span><br></pre></td></tr></table></figure><ul><li><ol start="5"><li>启动docker-compose</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@idc-function-docker harbor]#docker-compose up -d</span><br></pre></td></tr></table></figure><ul><li><ol start="6"><li>宿主机的nginx开启代理. (如果不是采用nginx代理的话,可以忽略这一步)</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#我这里是有一个独立的Nginx容器</span><br><span class="line">[root@idc-function-docker harbor]# cat/data/conf/nginx/conf.d/dwd-docker-hub.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">  server_name hub.xxxxxx.com;</span><br><span class="line">  listen 443 ssl http2;</span><br><span class="line">  ssl_certificate  /data/letsencrypt/hub.xxxxxx.com/fullchain.cer;</span><br><span class="line">  ssl_certificate_key /data/letsencrypt/hub.xxxxxx.com/hub.xxxxxx.com.key;</span><br><span class="line">  include /data/letsencrypt/options-ssl-nginx.conf; # managed by Certbot</span><br><span class="line">  ssl_dhparam /data/letsencrypt/ssl-dhparams.pem; # managed by Certbot</span><br><span class="line"></span><br><span class="line">  add_header      Strict-Transport-Security &quot;max-age=31536000&quot; always;</span><br><span class="line">  location / &#123;</span><br><span class="line"></span><br><span class="line">    proxy_pass https://172.16.20.30:4443; #代理到宿主机的4443端口,宿主机会将4443代理到hub-docer容器的443端口</span><br><span class="line">    client_max_body_size 2000m; #这里要定义大一点,否则提交镜像的时候,会提示 413 Request Entity Too Large</span><br><span class="line">                proxy_buffering off;</span><br><span class="line">                proxy_ssl_verify off;</span><br><span class="line">                proxy_set_header Host $http_host;</span><br><span class="line">                proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">                proxy_set_header Connection &quot;Upgrade&quot;;</span><br><span class="line">                proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    if ($host = hub.xxxxxx.com)&#123;</span><br><span class="line">        return 301 https://$host$request_uri;</span><br><span class="line">    &#125; # managed by Certbot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  listen 80;</span><br><span class="line">    server_name hub.xxxxxx.com;</span><br><span class="line">    return 404; # managed by Certbot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此,部署就完成了.</p><p>我之前在部署的过程中遇到无数的坑,,可能都是由于harbor没有使用Https引起的</p><hr><p>浏览器访问<a href="https://hub.xxxxxx.com,用初始的账号密码登陆,可以新建项目,创建用户等" target="_blank" rel="noopener">https://hub.xxxxxx.com,用初始的账号密码登陆,可以新建项目,创建用户等</a>.</p><p>我这里创建了一个master的公开项目</p><hr><p>登陆和push镜像没有任何问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@idc-function-docker ~]# docker login --username=admin -pHarbor12345 hub.xxxxxx.com</span><br><span class="line">WARNING! Using --password via the CLI is insecure. Use --password-stdin.</span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br><span class="line">[root@idc-function-docker ~]# docker push hub.xxxxxx.com/master/nginx:latest</span><br><span class="line">The push refers to repository [hub.xxxxxx.com/master/nginx]</span><br><span class="line">d37eecb5b769: Layer already exists</span><br><span class="line">99134ec7f247: Layer already exists</span><br><span class="line">c3a984abe8a8: Layer already exists</span><br><span class="line">latest: digest: sha256:7ac7819e1523911399b798309025935a9968b277d86d50e5255465d6592c0266 size: 948</span><br><span class="line">[root@idc-function-docker ~]#</span><br></pre></td></tr></table></figure><p>在另外一台客户端上,尝试pull镜像不需要密码.如果需要密码pull镜像,可以将项目设置为私有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$docker pull  hub.xxxxxx.com/master/nginx:latest</span><br><span class="line">latest: Pulling from master/nginx</span><br><span class="line">Digest: sha256:7ac7819e1523911399b798309025935a9968b277d86d50e5255465d6592c0266</span><br><span class="line">Status: Downloaded newer image for hub.xxxxxx.com/master/nginx:latest</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;harbor私有仓库部署&quot;&gt;&lt;a href=&quot;#harbor私有仓库部署&quot; class=&quot;headerlink&quot; title=&quot;harbor私有仓库部署&quot;&gt;&lt;/a&gt;harbor私有仓库部署&lt;/h2&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;harbor是docker的私有仓库,可以部署在局域网服务器上,用来管理docker镜像.虽然docker官方也提供公共镜像仓库,但是由于是境外网站,拉取镜像速度非常慢,而且有被墙的可能.部署私有仓库非常有必要&lt;/p&gt;
&lt;p&gt;harbor是vmware公司开源的企业级的docker registry管理项目.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;处于数据脱敏需要,以下内容中隐藏了真实域名.而使用hub.xxxxxx.com替代&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;社区&quot;&gt;&lt;a href=&quot;#社区&quot; class=&quot;headerlink&quot; title=&quot;社区&quot;&gt;&lt;/a&gt;社区&lt;/h3&gt;&lt;p&gt;harbor github: &lt;a href=&quot;https://github.com/goharbor/harbor&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;goharbor/harbor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官网文档介绍: &lt;a href=&quot;https://goharbor.io/docs/1.10/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;harbor doc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在部署中遇到的各种坑,都可以通过查阅文档,或者搜索github的issue解决&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;框架&quot;&gt;&lt;a href=&quot;#框架&quot; class=&quot;headerlink&quot; title=&quot;框架&quot;&gt;&lt;/a&gt;框架&lt;/h3&gt;&lt;p&gt;harbor是docker-compose部署的.包括一系列组件:nginx.core,log,register等等.&lt;/p&gt;
&lt;p&gt;但是由于本机已经存在一个Nginx镜像.所以用Nginx代理到harbor的Nginx.&lt;strong&gt;如果是独立的服务器部署Harbor的话,则不会存在这个问题,可以直接跳过这一章节.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;nginx代理框架大概是:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;nginx—-&amp;gt;harbor-nginx—–&amp;gt;habor&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于docker提交镜像需要Https协议,所以:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;nginx—301跳转到nginx https—–&amp;gt;harbor-nginx http—-&amp;gt; habor&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是这样的部署方式,有一个问题:&lt;/p&gt;
&lt;p&gt;私有仓库可以正常login但是push镜像的时候,又提示未验证.&lt;/p&gt;
&lt;p&gt;该问题尝试过很多解决方案,但是均无法解决&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="https://jesse.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://jesse.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>k8s挂载NFS网络磁盘</title>
    <link href="https://jesse.top/2020/06/26/kubernetes/k8s%E6%8C%82%E8%BD%BDNFS%E7%BD%91%E7%BB%9C%E7%A3%81%E7%9B%98/"/>
    <id>https://jesse.top/2020/06/26/kubernetes/k8s挂载NFS网络磁盘/</id>
    <published>2020-06-26T03:59:58.000Z</published>
    <updated>2020-06-26T03:04:46.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="k8s挂载NFS网络磁盘"><a href="#k8s挂载NFS网络磁盘" class="headerlink" title="k8s挂载NFS网络磁盘"></a>k8s挂载NFS网络磁盘</h2><p>按照<kubernetes in="" action="">这本书NFS做持久化存储的例子,发现了一个坑.,启动pod失败,报如下错误</kubernetes></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown: changing ownership of &apos;/data/db&apos;: Operation not permitted</span><br></pre></td></tr></table></figure><p>网上也有人遇到这个问题.可以参考这篇文档: <a href="https://blog.csdn.net/herhun_chen/article/details/90247123" target="_blank" rel="noopener">Kubernetes 集群挂载NFS Volume</a></p><a id="more"></a><p>以下是pod的yaml文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-m01 ~]# cat mongodb-pod-nfs.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: mongodb</span><br><span class="line">spec:</span><br><span class="line">  volumes:</span><br><span class="line">     - name: mongodb-data</span><br><span class="line">       nfs:</span><br><span class="line">         server: 10.111.5.184</span><br><span class="line">         path: /data/k8s/</span><br><span class="line"></span><br><span class="line">  containers:</span><br><span class="line">     - image: mongo</span><br><span class="line">       name: mongodb</span><br><span class="line">       volumeMounts:</span><br><span class="line">         - name: mongodb-data</span><br><span class="line">           mountPath: /data/db</span><br><span class="line">       ports:</span><br><span class="line">         - containerPort: 27017</span><br><span class="line">           protocol: TCP</span><br></pre></td></tr></table></figure><p>出现这种<figure class="highlight plain"><figcaption><span>not permitted```的权限类问题,肯定是NFS的挂载有问题.但是在所有k8s的节点上往NFS共享磁盘写文件,又是正常的.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">解决这个问题需要在NFS服务器的```/etx/exports```配置文件修改成如下配置</span><br></pre></td></tr></table></figure></p><p>[work@hsq-beta-rpc ~]$cat /etc/exports<br>/data/k8s/ 10.111.0.0/16(rw,fsid=0,async,no_subtree_check,no_auth_nlm,insecure,no_root_squash)<br><code>`</code></p><blockquote><p>注意,以上配置其实是一行.没有换行</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;k8s挂载NFS网络磁盘&quot;&gt;&lt;a href=&quot;#k8s挂载NFS网络磁盘&quot; class=&quot;headerlink&quot; title=&quot;k8s挂载NFS网络磁盘&quot;&gt;&lt;/a&gt;k8s挂载NFS网络磁盘&lt;/h2&gt;&lt;p&gt;按照&lt;kubernetes in=&quot;&quot; action=&quot;&quot;&gt;这本书NFS做持久化存储的例子,发现了一个坑.,启动pod失败,报如下错误&lt;/kubernetes&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;chown: changing ownership of &amp;apos;/data/db&amp;apos;: Operation not permitted&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;网上也有人遇到这个问题.可以参考这篇文档: &lt;a href=&quot;https://blog.csdn.net/herhun_chen/article/details/90247123&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kubernetes 集群挂载NFS Volume&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="kubernetes" scheme="https://jesse.top/categories/kubernetes/"/>
    
    
      <category term="k8s" scheme="https://jesse.top/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>kong+casssandra集群环境部署</title>
    <link href="https://jesse.top/2020/06/26/Linux-Web/kong%20casssandra%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    <id>https://jesse.top/2020/06/26/Linux-Web/kong casssandra集群环境部署/</id>
    <published>2020-06-26T03:59:58.000Z</published>
    <updated>2020-06-26T03:07:42.986Z</updated>
    
    <content type="html"><![CDATA[<h2 id="kong-casssandra集群环境部署"><a href="#kong-casssandra集群环境部署" class="headerlink" title="kong+casssandra集群环境部署"></a>kong+casssandra集群环境部署</h2><h3 id="kong简介"><a href="#kong简介" class="headerlink" title="kong简介"></a>kong简介</h3><p>Kong是Mashape开源的一款API网关，起初是用来管理 Mashape 公司15000个微服务的，后来在2015年开源,现在已经在很多创业公司、大型企业和政府机构中广泛使用。基于nginx,Lua和Cassandra或PostgreSQL，支持分布式操作，有很强的可移植性和可扩展性。可以在任何一种基础设施上运行,作为应用和API之间的中间层，加上众多功能强大的插件，可以实现认证授权、访问控制等功能。并且提供易于使用的RESTful API来操作和配置系统。</p><p>有关kong的详细介绍请参考官网.</p><p>–</p><h3 id="cassandra简介"><a href="#cassandra简介" class="headerlink" title="cassandra简介"></a>cassandra简介</h3><p>Cassandra 是一个来自 Apache 的分布式数据库，具有高度可扩展性，可用于管理大量的结构化数据。它提供了高可用性，没有单点故障。kong支持PostgreSQL或者Cassandra两种数据库.这里我们选择了cassandra.</p><p>有关cassandra的详细介绍和使用方法.请参考官网</p><a id="more"></a><p>–</p><h3 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h3><ul><li><strong>kong cluster</strong></li></ul><p>kong 集群并不意味着客户端请求将会负载均衡到kong集群中的每个节点上，kong集群并不是开箱即用，仍然需要在kong集群多节点上层搭建负载均衡，以便分发请求。 一个kong集群只是意味着集群内的节点，都共享同样的配置。</p><p>有关Kong cluster集群的详细介绍请参考官网:<a href="https://docs.konghq.com/0.14.x/clustering/" target="_blank" rel="noopener">Kong cluser document</a></p><p>为了提高冗余性和健壮性.我们对kong的每个环节都进行了冗余设计.一个基本的kong集群架构大概如下图所示:</p><p><img src="http://pabkmteb4.bkt.clouddn.com/kong-flow.png" alt=""></p><p>–</p><h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3><p><strong>环境</strong>: </p><p>阿里云ECS Centos7.4操作系统<br>Kong: 0.14 最新版<br>Cassandra: 3.11 最新版</p><p>–</p><h4 id="安装Cassandra"><a href="#安装Cassandra" class="headerlink" title="安装Cassandra"></a>安装Cassandra</h4><p>安装方式官网参考: <a href="http://cassandra.apache.org/doc/latest/getting_started/installing.html#installation-from-binary-tarball-files" target="_blank" rel="noopener">Installing Cassandra</a></p><p><strong>安装前提条件</strong></p><p>1.安装JDK 8版本<br>2.安装2.7以上版本的Python.(cassandra管理工具:cqlsh 需要python2.7以上环境)</p><p><strong>安装步骤</strong></p><p>1.下载cassandra二进制文件.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirrors.tuna.tsinghua.edu.cn/apache/cassandra/3.11.3/apache-cassandra-3.11.3-bin.tar.gz</span><br></pre></td></tr></table></figure><p>2.将cassandra目录添加进环境变量.用work用户运行cassandra</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /usr/local/cassandra</span><br><span class="line">sudo chown -R work:work /usr/local/cassandra</span><br><span class="line">sudo tar -xvf apache-cassandra-3.11.3-bin.tar.gz -C /usr/local/cassandra</span><br><span class="line"></span><br><span class="line">cd /usr/local/cassandra</span><br><span class="line">sudo mv apache-cassandra-3.11.3/* .</span><br><span class="line">sudo rm apache-cassandra-3.11.3/ -rf</span><br></pre></td></tr></table></figure><p>添加进环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br><span class="line"></span><br><span class="line">export JAVA_HOME=/usr/local/java</span><br><span class="line">export CASSANDRA_HOME=/usr/local/cassandra</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$CASSANDRA_HOME/bin</span><br></pre></td></tr></table></figure><p>–</p><h4 id="配置Cassandra-以及cassandra集群"><a href="#配置Cassandra-以及cassandra集群" class="headerlink" title="配置Cassandra,以及cassandra集群"></a>配置Cassandra,以及cassandra集群</h4><p>1.编辑cassandra的cassandra.yml配置文件.修改下列配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 kong]$ vim /usr/local/cassandra/conf/cassandra.yaml</span><br><span class="line"></span><br><span class="line">#定义Cassandra集群名</span><br><span class="line">cluster_name: &apos;dwd_cassandra&apos;</span><br><span class="line">#定义hints路径.可以使用默认路径</span><br><span class="line">hints_directory: /data/cassandra/hints</span><br><span class="line"></span><br><span class="line">#采用密码方式连接数据库.默认情况下不需要任何用户密码就可以登录数据库</span><br><span class="line">authenticator: PasswordAuthenticator</span><br><span class="line"></span><br><span class="line">#定义数据库文件路径.可以使用默认/var/lib路径</span><br><span class="line">data_file_directories:</span><br><span class="line">      - /data/cassandra</span><br><span class="line"></span><br><span class="line">#定义commit日志路径.可以使用默认路径</span><br><span class="line">commitlog_directory: /data/cassandra/commitlog</span><br><span class="line"></span><br><span class="line">#缓存文件路径</span><br><span class="line">saved_caches_directory: /data/cassandra/saved_caches</span><br><span class="line"></span><br><span class="line">#关键配置,定义集群种子服务器地址.这里定义服务器的内网地址.不能使用0.0.0.0或者127的本机地址,可以加入多个集群节点的地址,IP地址之间用逗号分隔</span><br><span class="line">- seeds: &quot;10.25.87.159&quot;</span><br><span class="line"></span><br><span class="line">#listen地址</span><br><span class="line">listen_address: 10.25.87.159</span><br><span class="line"></span><br><span class="line">#rpc地址</span><br><span class="line">rpc_address: 10.25.87.159</span><br></pre></td></tr></table></figure><p>2.创建刚才定义的路径目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -pv /data/cassandra </span><br><span class="line">sudo chown -R work.work /data/</span><br></pre></td></tr></table></figure><p>3.启动cassandra.直接在命令行执行cassandra</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 kong]$ cassandra </span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">[work@kong-node1 kong]$ /usr/local/cassandra/bin/cassandra</span><br></pre></td></tr></table></figure><ol start="4"><li>使用cqlsh工具登陆cassandra数据库.创建cassandra用户密码,以及创建键空间</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#注意由于cassandra只侦听了内网的地址,因此要指定IP地址.</span><br><span class="line">#默认账号密码都是cassandra</span><br><span class="line">[work@kong-node1 kong]$ cqlsh 10.25.87.159  -ucassandra -pcassandra </span><br><span class="line"></span><br><span class="line">#创建一个kong用户.并且为超级用户</span><br><span class="line">cassandra@cqlsh&gt; create user kong with password &apos;kong&apos; superuser;</span><br><span class="line"></span><br><span class="line">#创建一个keyspace.命名为kong</span><br><span class="line">cassandra@cqlsh&gt; CREATE KEYSPACE kong WITH REPLICATION = &#123; &apos;class&apos; : &apos;SimpleStrategy&apos;, &apos;replication_factor&apos; : 1&#125;;</span><br><span class="line"></span><br><span class="line">cassandra@cqlsh&gt; exit</span><br></pre></td></tr></table></figure><p>5.删除自带的cassandra用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 cassandra]$ cqlsh 10.25.87.159  -ukong -pkong</span><br><span class="line">kong@cqlsh&gt; desc kong;</span><br><span class="line"></span><br><span class="line">CREATE KEYSPACE kong WITH replication = &#123;&apos;class&apos;: &apos;SimpleStrategy&apos;, &apos;replication_factor&apos;: &apos;1&apos;&#125;  AND durable_writes = true;</span><br><span class="line"></span><br><span class="line">kong@cqlsh&gt; drop user cassandra;</span><br></pre></td></tr></table></figure><p>–</p><h4 id="安装Kong"><a href="#安装Kong" class="headerlink" title="安装Kong"></a>安装Kong</h4><p>安装方法可以参考官网:<a href="https://docs.konghq.com/install/centos/?_ga=2.110797315.728319704.1539597667-917309945.1539077269#packages" target="_blank" rel="noopener">Install Kong</a></p><p>1.下载,安装rpm安装包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget -O kong-community-edition-0.14.1.el7.noarch.rpm  https://bintray.com/kong/kong-community-edition-rpm/download_file?file_path=centos/7/kong-community-edition-0.14.1.el7.noarch.rpm</span><br><span class="line"></span><br><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install kong-community-edition-0.14.1.el7.noarch.rpm</span><br></pre></td></tr></table></figure><p>2.修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/kong</span><br><span class="line">sudo cp kong.conf.default kong.conf</span><br><span class="line"></span><br><span class="line">sudo vim kong.conf</span><br><span class="line"></span><br><span class="line">#修改日志文件路径</span><br><span class="line">prefix = /data/kong/</span><br><span class="line"></span><br><span class="line">#由于磁盘空间有限,关闭kong的代理日志.后端真实服务器会记录nginx访问日志</span><br><span class="line">proxy_access_log = off</span><br><span class="line">proxy_error_log = off</span><br><span class="line"></span><br><span class="line">#在所有地址侦听管理端口,当然只侦听127地址会更安全.</span><br><span class="line">admin_listen = 0.0.0.0:8001, 0.0.0.0:8444 ssl</span><br><span class="line"></span><br><span class="line">#指定使用cassandra数据库</span><br><span class="line">database = cassandra</span><br><span class="line">#数据库地址,端口</span><br><span class="line">cassandra_contact_points = 10.25.87.159</span><br><span class="line">cassandra_port = 9042</span><br><span class="line"></span><br><span class="line">#上文定义的cassandra数据库的用户密码和键空间</span><br><span class="line">cassandra_keyspace = kong</span><br><span class="line">cassandra_username = kong</span><br><span class="line">cassandra_password = kong</span><br><span class="line"></span><br><span class="line">#kong官方建议的cassandra一致性机制</span><br><span class="line">cassandra_consistency = QUORUM</span><br><span class="line"></span><br><span class="line">#以下是集群的数据库和缓存方面的配置.详细介绍请参考官网</span><br><span class="line">db_update_frequency = 5</span><br><span class="line">db_update_propagation = 2</span><br></pre></td></tr></table></figure><p>3.创建kong目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/kong</span><br></pre></td></tr></table></figure><p>4.准备启动工作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kong migrations up -c /etc/kong/kong.conf</span><br></pre></td></tr></table></figure><p>5.启动kong</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kong start -c /etc/kong/kong.conf</span><br></pre></td></tr></table></figure><p>查看端口.可以看到cassandra和kong的侦听端口都已经成功启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">work@kong-node1 kong]$ netstat -tulnp</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class="line">tcp        0      0 0.0.0.0:8443            0.0.0.0:*               LISTEN      29342/nginx: master</span><br><span class="line">tcp        0      0 0.0.0.0:8444            0.0.0.0:*               LISTEN      29342/nginx: master</span><br><span class="line">tcp        0      0 127.0.0.1:7199          0.0.0.0:*               LISTEN      28598/java</span><br><span class="line">tcp        0      0 0.0.0.0:8000            0.0.0.0:*               LISTEN      29342/nginx: master</span><br><span class="line">tcp        0      0 0.0.0.0:8001            0.0.0.0:*               LISTEN      29342/nginx: master</span><br><span class="line">tcp        0      0 127.0.0.1:35503         0.0.0.0:*               LISTEN      28598/java</span><br><span class="line">tcp        0      0 10.25.87.159:9042       0.0.0.0:*               LISTEN      28598/java</span><br><span class="line">tcp        0      0 10.25.87.159:7000       0.0.0.0:*               LISTEN      28598/java</span><br></pre></td></tr></table></figure><hr><h3 id="部署另外一台kong和cassandra"><a href="#部署另外一台kong和cassandra" class="headerlink" title="部署另外一台kong和cassandra"></a>部署另外一台kong和cassandra</h3><p>今天在阿里云镜像了kong-node1的服务器.新的服务器名字为kong-node2.<br>软件已经安装,只需要修改部分配置</p><h5 id="修改node1和node2上的cassandra配置"><a href="#修改node1和node2上的cassandra配置" class="headerlink" title="修改node1和node2上的cassandra配置"></a>修改node1和node2上的cassandra配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在node1和node2上:</span><br><span class="line">[work@kong-node2 ~]$ vim /usr/local/cassandra/conf/cassandra.yaml</span><br><span class="line">#修改seeds配置.添加2台服务器的内网IP地址</span><br><span class="line">- seeds: &quot;10.25.87.159, 10.80.229.244&quot; </span><br><span class="line"></span><br><span class="line">在node2上修改侦听地址</span><br><span class="line">[work@kong-node2 ~]$ vim /usr/local/cassandra/conf/cassandra.yaml</span><br><span class="line">#将下列地址改成node2内网地址</span><br><span class="line">listen_address: 10.80.229.244</span><br><span class="line">rpc_address: 10.80.229.244</span><br></pre></td></tr></table></figure><h5 id="在node2上修改kong的配置文件"><a href="#在node2上修改kong的配置文件" class="headerlink" title="在node2上修改kong的配置文件:"></a>在node2上修改kong的配置文件:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">work@kong-node2 ~]$ vim /etc/kong/kong.conf</span><br><span class="line">#连接本机的cassandra数据库地址</span><br><span class="line">cassandra_contact_points = 10.80.229.244</span><br></pre></td></tr></table></figure><blockquote><p>note:千万不要启动node2上的cassandra.因为node2是从node1镜像过去的.所以数据库的token是一模一样的.</p></blockquote><h5 id="在node2上删除cassandra的数据库-这一步非常重要-因为这是从node1镜像过来的-所以node2上的数据库是node1的数据"><a href="#在node2上删除cassandra的数据库-这一步非常重要-因为这是从node1镜像过来的-所以node2上的数据库是node1的数据" class="headerlink" title="在node2上删除cassandra的数据库.这一步非常重要.因为这是从node1镜像过来的.所以node2上的数据库是node1的数据"></a>在node2上删除cassandra的数据库.这一步非常重要.因为这是从node1镜像过来的.所以node2上的数据库是node1的数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /data/cassandra/*</span><br></pre></td></tr></table></figure><h5 id="启动node2上的数据库"><a href="#启动node2上的数据库" class="headerlink" title="启动node2上的数据库"></a>启动node2上的数据库</h5><p>直接在命令行执行:cassandra</p><h5 id="查看cassandra的单台服务器状态"><a href="#查看cassandra的单台服务器状态" class="headerlink" title="查看cassandra的单台服务器状态"></a>查看cassandra的单台服务器状态</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 bin]$ nodetool info</span><br><span class="line">ID                     : 4fe1df37-e69e-4a25-acdc-4b2d73a92225</span><br><span class="line">Gossip active          : true</span><br><span class="line">Thrift active          : false</span><br><span class="line">Native Transport active: true</span><br><span class="line">Load                   : 522.87 KiB</span><br><span class="line">Generation No          : 1540372001</span><br><span class="line">Uptime (seconds)       : 63895</span><br><span class="line">Heap Memory (MB)       : 404.89 / 1004.00</span><br><span class="line">Off Heap Memory (MB)   : 0.00</span><br><span class="line">Data Center            : datacenter1</span><br><span class="line">Rack                   : rack1</span><br><span class="line">Exceptions             : 0</span><br><span class="line">Key Cache              : entries 59, size 5.03 KiB, capacity 50 MiB, 7540 hits, 7911 requests, 0.953 recent hit rate, 14400 save period in seconds</span><br><span class="line">Row Cache              : entries 0, size 0 bytes, capacity 0 bytes, 0 hits, 0 requests, NaN recent hit rate, 0 save period in seconds</span><br><span class="line">Counter Cache          : entries 0, size 0 bytes, capacity 25 MiB, 0 hits, 0 requests, NaN recent hit rate, 7200 save period in seconds</span><br><span class="line">Chunk Cache            : entries 28, size 1.75 MiB, capacity 219 MiB, 1237 misses, 26133 requests, 0.953 recent hit rate, NaN microseconds miss latency</span><br><span class="line">Percent Repaired       : 100.0%</span><br><span class="line">Token                  : (invoke with -T/--tokens to see all 256 tokens)</span><br></pre></td></tr></table></figure><h5 id="查看cassandra集群状态-可以看到集群中2台服务器"><a href="#查看cassandra集群状态-可以看到集群中2台服务器" class="headerlink" title="查看cassandra集群状态.可以看到集群中2台服务器"></a>查看cassandra集群状态.可以看到集群中2台服务器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 bin]$ nodetool status</span><br><span class="line">Datacenter: datacenter1</span><br><span class="line">=======================</span><br><span class="line">Status=Up/Down</span><br><span class="line">|/ State=Normal/Leaving/Joining/Moving</span><br><span class="line">--  Address        Load       Tokens       Owns (effective)  Host ID                               Rack</span><br><span class="line">UN  10.80.229.244  339.93 KiB  256          51.3%             04a75f63-be99-4f3e-93ff-937bbe9656d8  rack1</span><br><span class="line">UN  10.25.87.159   522.87 KiB  256          48.7%             4fe1df37-e69e-4a25-acdc-4b2d73a92225  rack1</span><br></pre></td></tr></table></figure><hr><h4 id="以下是我踩过的坑-在没有删除node2上的数据库文件情况下-直接启动cassnadra"><a href="#以下是我踩过的坑-在没有删除node2上的数据库文件情况下-直接启动cassnadra" class="headerlink" title="以下是我踩过的坑.在没有删除node2上的数据库文件情况下,直接启动cassnadra."></a>以下是我踩过的坑.在没有删除node2上的数据库文件情况下,直接启动cassnadra.</h4><p>启动node2的cassandra后.发现集群无法正常启动.使用cassandra自带的nodetool工具可以查看集群状态.这里只有自己一台服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node2 ~]$ nodetool status</span><br><span class="line">Datacenter: datacenter1</span><br><span class="line">=======================</span><br><span class="line">Status=Up/Down</span><br><span class="line">|/ State=Normal/Leaving/Joining/Moving</span><br><span class="line">--  Address        Load       Tokens       Owns (effective)  Host ID                               Rack</span><br><span class="line">UN  10.80.229.244  600.05 KiB  256          100.0%            4fe1df37-e69e-4a25-acdc-4b2d73a92225  rack1</span><br></pre></td></tr></table></figure><p>查看cassandra启动日志,发现日志提示和node1有一样的token:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">less /usr/local/cassandra/logs/system.log</span><br><span class="line"></span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,874 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token -9066137612411979055.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,874 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token -912539082610246005.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,874 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token -9125687604150710607.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,874 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token -9186325188411815558.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,874 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token -934168442605847346.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,874 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token -937629522304513228.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,874 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token -983284835358960159.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,875 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token 1111859401021864246.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,875 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token 1185525604491731552.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,875 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token 1209704333924286496.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,875 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token 1243859262038298713.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,875 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token 1284321765579584761.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,875 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token 1472069791929520463.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,875 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token 1479257042759500258.  Ignoring /10.25.87.159</span><br></pre></td></tr></table></figure><p>不仅如此,在node1上启动kong,提示cassandra数据库验证失败.以及提示kong需要migrations up(只需要在第一次启动kong时才需要migratios up):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 bin]$ kong restart -c /etc/kong/kong.conf</span><br><span class="line">Error: /usr/local/share/lua/5.1/kong/cmd/start.lua:37: [cassandra error] the current database schema does not match this version of Kong. Please run `kong migrations up` to update/initialize the database schema. Be aware that Kong migrations should only run from a single node, and that nodes running migrations concurrently will conflict with each other and might corrupt your database schema!</span><br></pre></td></tr></table></figure><p>kong migrations失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> work@kong-node1 bin]$ kong migrations up -c /etc/kong/kong.conf</span><br><span class="line">migrating core for keyspace kong</span><br><span class="line">core migrated up to: 2015-01-12-175310_skeleton</span><br><span class="line">Error: [cassandra error] Error during migration 2015-01-12-175310_init_schema: [Invalid] Undefined column name request_host</span><br></pre></td></tr></table></figure><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>启动node1和node2的cassandra</p><p>1.在node1和node2上drop kong的键空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 bin]$ cqlsh 10.25.87.159 -ukong -pkong</span><br><span class="line">Connected to dwd_cassandra at 10.25.87.159:9042.</span><br><span class="line">[cqlsh 5.0.1 | Cassandra 3.11.3 | CQL spec 3.4.4 | Native protocol v4]</span><br><span class="line">Use HELP for help.</span><br><span class="line">kong@cqlsh&gt; drop keyspace kong;</span><br><span class="line">kong@cqlsh&gt; exit</span><br><span class="line"></span><br><span class="line">[work@kong-node2 ~]$ cqlsh 10.80.229.244 -ukong -pkong</span><br><span class="line">Connected to dwd_cassandra at 10.80.229.244:9042.</span><br><span class="line">[cqlsh 5.0.1 | Cassandra 3.11.3 | CQL spec 3.4.4 | Native protocol v4]</span><br><span class="line">Use HELP for help.</span><br><span class="line">kong@cqlsh&gt; drop KEYSPACE kong;</span><br><span class="line">ConfigurationException: Cannot drop non existing keyspace &apos;kong&apos;.</span><br><span class="line">kong@cqlsh&gt; exit</span><br></pre></td></tr></table></figure><p>2.删除kong的键空间目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[work@kong-node1 bin]$ rm -rf  /data/cassandra/kong/</span><br><span class="line">[work@kong-node1 bin]$ ll /data/cassandra/kong/</span><br><span class="line">ls: cannot access /data/cassandra/kong/: No such file or directory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[work@kong-node2 ~]$ rm -rf /data/cassandra/kong/</span><br><span class="line">[work@kong-node2 ~]$ ll /data/cassandra/kong/</span><br><span class="line">ls: cannot access /data/cassandra/kong/: No such file or directory</span><br></pre></td></tr></table></figure><p>3.在node1上创建kong键空间.创建完毕后,应该会同步到node2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 bin]$ cqlsh 10.25.87.159 -ukong -pkong</span><br><span class="line">Connected to dwd_cassandra at 10.25.87.159:9042.</span><br><span class="line">[cqlsh 5.0.1 | Cassandra 3.11.3 | CQL spec 3.4.4 | Native protocol v4]</span><br><span class="line">Use HELP for help.</span><br><span class="line">kong@cqlsh&gt; CREATE KEYSPACE kong WITH REPLICATION = &#123; &apos;class&apos; : &apos;SimpleStrategy&apos;, &apos;replication_factor&apos; : 1&#125;;</span><br><span class="line">kong@cqlsh&gt; exit</span><br></pre></td></tr></table></figure><p>4.在node1上执行 kong migrations up ,执行完后同样会同步到node2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">work@kong-node1 bin]$ kong migrations up -c /etc/kong/kong.conf</span><br><span class="line">migrating core for keyspace kong</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">66 migrations ran</span><br><span class="line">waiting for Cassandra schema consensus (10000ms timeout)...</span><br><span class="line">Cassandra schema consensus: reached</span><br></pre></td></tr></table></figure><p>5.在node1和node2上启动kong</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 bin]$ kong restart -c /etc/kong/kong.conf</span><br><span class="line"></span><br><span class="line">[work@kong-node2 ~]$ kong start -c /etc/kong/kong.conf</span><br><span class="line">Kong started</span><br></pre></td></tr></table></figure><hr><h3 id="搭建kong-dashboard"><a href="#搭建kong-dashboard" class="headerlink" title="搭建kong-dashboard"></a>搭建kong-dashboard</h3><p>kong-dashboard是管理kong各个组件(serveice,route,plugin,upstream,consumer)的可视化UI管理工具.在增删改查各个组件的配置时非常方便.</p><p>现在kong-dashboard也支持到了最新版的kong和kong的最新组件.</p><p>kong-dashboard的github参考:<a href="https://github.com/PGBI/kong-dashboard" target="_blank" rel="noopener">kong-dashboar</a></p><hr><p>1.确保需要有node.js环境.如果没有npm工具,必须先安装nodejs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@DWD-BETA kong]$ npm -v</span><br><span class="line">5.6.0</span><br><span class="line">[work@DWD-BETA kong]$ node -v</span><br><span class="line">v8.10.0</span><br></pre></td></tr></table></figure><p>2.root用户执行下列安装命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@DWD-BETA ~]# npm install -g kong-dashboard</span><br><span class="line">/usr/local/src/nodejs/bin/kong-dashboard -&gt; /usr/local/src/nodejs/lib/node_modules/kong-dashboard/bin/kong-dashboard.js</span><br><span class="line">+ kong-dashboard@3.5.0</span><br><span class="line">added 184 packages in 28.8s</span><br></pre></td></tr></table></figure><p>3.启动kong-dashboard.启动方式有以下几种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Start Kong Dashboard</span><br><span class="line">kong-dashboard start --kong-url http://kong:8001</span><br><span class="line"></span><br><span class="line"># Start Kong Dashboard on a custom port</span><br><span class="line">kong-dashboard start \</span><br><span class="line">  --kong-url http://kong:8001 \</span><br><span class="line">  --port [port]</span><br><span class="line"></span><br><span class="line"># Start Kong Dashboard with basic auth</span><br><span class="line">kong-dashboard start \</span><br><span class="line">  --kong-url http://kong:8001 \</span><br><span class="line">  --basic-auth user1=password1 user2=password2</span><br><span class="line"></span><br><span class="line"># See full list of start options</span><br><span class="line">kong-dashboard start --help</span><br></pre></td></tr></table></figure><p>但是kong-dashboard是前台启动,没有deamnize模式.所以将kong-dashboard加入到supervisor进程管理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@DWD-BETA ~]# vim /etc/supervisor/conf.d/kong-dashboard.conf</span><br><span class="line"></span><br><span class="line">[program:kong-dashboard]</span><br><span class="line">command=/usr/local/src/nodejs/bin/kong-dashboard start --kong-url http://localhost:8001</span><br><span class="line">numprocs=1</span><br><span class="line">user=work</span><br><span class="line">stdout_logfile = /data/logs/kong/kong-dashboard.log</span><br><span class="line">redirect_stderr = true</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br></pre></td></tr></table></figure><p>修改权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@DWD-BETA ~]# chown -R work.work /etc/supervisor/conf.d/</span><br></pre></td></tr></table></figure><p>更新supervisor配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@DWD-BETA ~]# supervisorctl update kong-dashboard</span><br><span class="line">kong-dashboard: added process group</span><br></pre></td></tr></table></figure><p>但是由于我这台服务器上8080端口已经被使用,所以启动kong-dashboard报错:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">work@DWD-BETA kong]$ /usr/local/src/nodejs/bin/kong-dashboard start --kong-url http://localhost:8001</span><br><span class="line">Connecting to Kong on http://localhost:8001 ...</span><br><span class="line">Connected to Kong on http://localhost:8001.</span><br><span class="line">Kong version is 0.14.1</span><br><span class="line">Starting Kong Dashboard on port 8080</span><br><span class="line">events.js:183</span><br><span class="line">      throw er; // Unhandled &apos;error&apos; event</span><br><span class="line">      ^</span><br><span class="line"></span><br><span class="line">Error: listen EADDRINUSE :::8080</span><br><span class="line">    at Object._errnoException (util.js:1022:11)</span><br><span class="line">    at _exceptionWithHostPort (util.js:1044:20)</span><br><span class="line">    at Server.setupListenHandle [as _listen2] (net.js:1367:14)</span><br><span class="line">    at listenInCluster (net.js:1408:12)</span><br><span class="line">    at Server.listen (net.js:1492:7)</span><br><span class="line">    at Application.listen (/usr/local/src/nodejs/lib/node_modules/kong-dashboard/node_modules/koa/lib/application.js:65:19)</span><br><span class="line">    at Server.start (/usr/local/src/nodejs/lib/node_modules/kong-dashboard/lib/server.js:32:9)</span><br><span class="line">    at startKongDashboard (/usr/local/src/nodejs/lib/node_modules/kong-dashboard/bin/kong-dashboard.js:189:10)</span><br><span class="line">    at request.get.then.then (/usr/local/src/nodejs/lib/node_modules/kong-dashboard/bin/kong-dashboard.js:178:5)</span><br><span class="line">    at &lt;anonymous&gt;</span><br></pre></td></tr></table></figure><p>8080端口被jenkins占用了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@DWD-BETA kong]$ netstat -tulnp | grep 8080</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      17955/java</span><br></pre></td></tr></table></figure><p>更换kong-dashboard端口为8081</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[program:kong-dashboard]</span><br><span class="line">command=/usr/local/src/nodejs/bin/kong-dashboard  start --kong-url http://localhost:8001 --port 8081</span><br><span class="line">numprocs=1</span><br><span class="line">user=work</span><br><span class="line">stdout_logfile = /data/logs/kong/kong-dashboard.log</span><br><span class="line">redirect_stderr = true</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br></pre></td></tr></table></figure><p>更新supervisor后,仍然无法启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[work@DWD-BETA kong]$ supervisorctl update kong-dashboard</span><br><span class="line">kong-dashboard: stopped</span><br><span class="line">kong-dashboard: updated process group</span><br><span class="line">[work@DWD-BETA kong]$ supervisorctl status kong-dashboard</span><br><span class="line">kong-dashboard                   BACKOFF   Exited too quickly (process log may have details)</span><br></pre></td></tr></table></figure><p>手动启动正常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[work@DWD-BETA kong]$ /usr/local/src/nodejs/bin/kong-dashboard  start --kong-url http://localhost:8001 --port 8081</span><br><span class="line">Connecting to Kong on http://localhost:8001 ...</span><br><span class="line">Connected to Kong on http://localhost:8001.</span><br><span class="line">Kong version is 0.14.1</span><br><span class="line">Starting Kong Dashboard on port 8081</span><br><span class="line">Kong Dashboard has started on port 8081</span><br><span class="line">^C</span><br></pre></td></tr></table></figure><p>查看supervisor启动日志文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[work@DWD-BETA kong]$ less /data/logs/kong/kong-dashboard.log</span><br><span class="line">/usr/bin/env: node: No such file or directory</span><br><span class="line">/usr/bin/env: node: No such file or directory</span><br><span class="line">/usr/bin/env: node: No such file or directory</span><br><span class="line">/usr/bin/env: node: No such file or directory</span><br></pre></td></tr></table></figure><p>网上查找解决方案.说是要链接以下文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/bin/nodejs /usr/bin/node</span><br></pre></td></tr></table></figure><p>但是这台服务器上nodejs路径不同,所以执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[work@DWD-BETA kong]$ sudo ln -s /usr/local/src/nodejs /usr/bin/node</span><br></pre></td></tr></table></figure><p>仍然无法启动,提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/env: node: Permission denied</span><br><span class="line">/usr/bin/env: node: Permission denied</span><br><span class="line">/usr/bin/env: node: Permission denied</span><br><span class="line">/usr/bin/env: node: Permission denied</span><br><span class="line">/usr/bin/env: node: Permission denied</span><br><span class="line">/usr/bin/env: node: Permission denied</span><br></pre></td></tr></table></figure><p>修改kong-dashboard启动用户为root.仍然无法启动.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[program:kong-dashboard]</span><br><span class="line">command=/usr/local/src/nodejs/bin/kong-dashboard  start --kong-url http://127.0.0.1:8001 --port 8081</span><br><span class="line">numprocs=1</span><br><span class="line">user=root</span><br><span class="line">stdout_logfile = /data/logs/kong/kong-dashboard.log</span><br><span class="line">redirect_stderr = true</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br></pre></td></tr></table></figure><hr><p>操作失误在创建软件的时候,删除了nodejs源目录.重新安装了npm和kong-dashboard</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">解压nodejs包到:/usr/local/node/</span><br><span class="line"></span><br><span class="line">#设置环境变量: </span><br><span class="line">[root@DWD-BETA ~]# cat /etc/profile | tail -2</span><br><span class="line">export NODEJS_HOME=/usr/local/node/</span><br><span class="line">export PATH=$PATH:$NODEJS_HOME/bin</span><br><span class="line"></span><br><span class="line">[root@DWD-BETA ~]# node -v</span><br><span class="line">v8.10.0</span><br><span class="line">[root@DWD-BETA ~]# npm -v</span><br><span class="line">5.6.0</span><br></pre></td></tr></table></figure><p>创建链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@DWD-BETA ~]# ln -s /usr/local/node/bin/node /usr/bin/node</span><br><span class="line">root@DWD-BETA ~]# ll /usr/bin/node -d</span><br><span class="line">lrwxrwxrwx 1 root root 24 Nov  3 11:25 /usr/bin/node -&gt; /usr/local/node/bin/node</span><br></pre></td></tr></table></figure><p>修改supervisor配置文件中的命令路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[program:kong-dashboard]</span><br><span class="line">command=/usr/local/node/bin/kong-dashboard  start --kong-url http://127.0.0.1:8001 --port 8081</span><br><span class="line">numprocs=1</span><br><span class="line">priority=3</span><br><span class="line">user=root</span><br><span class="line">stdout_logfile = /data/logs/kong/kong-dashboard.log</span><br><span class="line">redirect_stderr = true</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br></pre></td></tr></table></figure><p>启动kong-dashboard</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@DWD-BETA ~]# supervisorctl update kong-dashboard</span><br><span class="line">kong-dashboard: stopped</span><br><span class="line">kong-dashboard: updated process group</span><br><span class="line"></span><br><span class="line">[root@DWD-BETA ~]# supervisorctl status kong-dashboard</span><br><span class="line">kong-dashboard                   RUNNING   pid 16635, uptime 0:05:02</span><br></pre></td></tr></table></figure><p>启动完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@DWD-BETA ~]# netstat -tulnp | grep 8081</span><br><span class="line">tcp6       0      0 :::8081                 :::*                    LISTEN      16635/node</span><br></pre></td></tr></table></figure><hr><h3 id="将cassandra加入到supervisor进程管理"><a href="#将cassandra加入到supervisor进程管理" class="headerlink" title="将cassandra加入到supervisor进程管理"></a>将cassandra加入到supervisor进程管理</h3><p>cassandra加入supervisor进程托管遇到不少问题.踩过以下2个坑:</p><p>1.启动报错,提示需要更高级版本的java.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cassandra 3.0 and later require Java 8u40 or later.</span><br><span class="line">Cassandra 3.0 and later require Java 8u40 or later.</span><br><span class="line">Cassandra 3.0 and later require Java 8u40 or later.</span><br><span class="line">Cassandra 3.0 and later require Java 8u40 or later.</span><br><span class="line">Cassandra 3.0 and later require Java 8u40 or later.</span><br><span class="line">Cassandra 3.0 and later require Java 8u40 or later.</span><br><span class="line">Cassandra 3.0 and later require Java 8u40 or later.</span><br></pre></td></tr></table></figure><p>我的解决方案:</p><ul><li>在cassandra的supervisor配置文件中加入环境变量:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">environment=JAVA_HOME=&quot;/usr/local/java&quot;  #这样cassandra会识别用户自定义安装的Java.</span><br></pre></td></tr></table></figure><ul><li>配置软链</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/local/java/bin/java /usr/bin/java</span><br></pre></td></tr></table></figure><p>2.仍然无法启动,因为命令行是以daemon方式启动.在cassandra的supervisor配置文件中的启动参数加入-f选项.</p><p>最终的cassandra配置文件如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[program:cassandra]</span><br><span class="line">command=/usr/local/cassandra/bin/cassandra -f</span><br><span class="line">directory=/usr/local/cassandra/</span><br><span class="line">environment=JAVA_HOME=&quot;/usr/local/java&quot;</span><br><span class="line">enviroment=PATH=&quot;$JAVA_HOME/bin:$PATH&quot;</span><br><span class="line">priority=0</span><br><span class="line">numprocs=1</span><br><span class="line">user=work</span><br><span class="line">stdout_logfile = /data/logs/cassandra/cassandra_supervisor.log</span><br><span class="line">redirect_stderr = true</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br></pre></td></tr></table></figure><hr><h3 id="将kong加入到supervisor"><a href="#将kong加入到supervisor" class="headerlink" title="将kong加入到supervisor"></a>将kong加入到supervisor</h3><p>1.由于默认kong启动是以daemon方式启动.所以修改/etc/kong/kong.conf配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#将下列行修改为off,且取消注释</span><br><span class="line">nginx_daemon = off</span><br></pre></td></tr></table></figure><p>2.编辑kong的supervisor配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[program:kong]</span><br><span class="line">command=/usr/local/bin/kong start -c /etc/kong/kong.conf</span><br><span class="line">numprocs=1</span><br><span class="line">priority=0</span><br><span class="line">user=work</span><br><span class="line">stdout_logfile = /data/logs/kong/kong_supervisor.log</span><br><span class="line">redirect_stderr = true</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br></pre></td></tr></table></figure><blockquote><p>注意由于kong启动的时候会连接后端的cassandra数据库,所以需要先启动cassandra,再启动kong.这就是为什么supervisor里要加入priority参数.优先级越小,启动顺序越优先.停止顺序越靠后.     </p></blockquote><p><strong>但是经过我的验证,发现priority参数没什么鸟用.当我start all,stop all时.永远是cassandra进程首先启动和关闭,无论priority优先级是大还是小.而不是supervisor官网介绍的那样效果</strong></p><p>启动没问题:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node2 ~]$ supervisorctl status</span><br><span class="line">cassandra                        RUNNING   pid 13531, uptime 0:10:09</span><br><span class="line">kong                             RUNNING   pid 14460, uptime 0:00:35</span><br><span class="line">kong-dashboard                   RUNNING   pid 14496, uptime 0:00:17</span><br></pre></td></tr></table></figure><p>但是发现supervisor管理kong进程有很严重的问题.</p><p>因为kong启动后包括2个进程:kong和nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">work@kong-node1 conf.d]$ ps aux | grep kong</span><br><span class="line">work      3198  0.2  0.0 130104  2700 ?        S    17:12   0:00 perl /usr/local/openresty/bin/resty /usr/local/bin/kong start -c /etc/kong/kong.conf</span><br><span class="line">work      3215  6.3  0.1 259600 11800 ?        S    17:12   0:00 nginx: master process /usr/local/openresty/nginx/sbin/nginx -p /data/kong -c nginx.conf</span><br></pre></td></tr></table></figure><p>.这个时候如果用supervisorctl restart kong进程会出现无法启动的情况.这是因为supervisor kill掉了kong进程.但是没有kill Ningx进程.所以重新启动kong的时候,由于nginx进程仍然存在,故无法启动.例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 conf.d]$ ps aux | grep kong</span><br><span class="line">work      2917  0.0  0.1 259600 11820 ?        S    17:05   0:00 nginx: master process /usr/local/openresty/nginx/sbin/nginx -p /data/kong -c nginx.conf</span><br><span class="line">work      3191  0.0  0.0 112704   976 pts/0    S+   17:11   0:00 grep --color=auto kong</span><br><span class="line">[work@kong-node1 conf.d]$ kill 2917</span><br><span class="line">[work@kong-node1 conf.d]$ ps aux | grep kong</span><br><span class="line">work      3193  0.0  0.0 112704   976 pts/0    S+   17:11   0:00 grep --color=auto kong</span><br><span class="line">[work@kong-node1 conf.d]$ supervisorctl start kong</span><br><span class="line">kong: started</span><br><span class="line"></span><br><span class="line">#kong启动后包含2个进程</span><br><span class="line">[work@kong-node1 conf.d]$ ps aux | grep kong</span><br><span class="line">work      3198  0.2  0.0 130104  2700 ?        S    17:12   0:00 perl /usr/local/openresty/bin/resty /usr/local/bin/kong start -c /etc/kong/kong.conf</span><br><span class="line">work      3215  6.3  0.1 259600 11800 ?        S    17:12   0:00 nginx: master process /usr/local/openresty/nginx/sbin/nginx -p /data/kong -c nginx.conf</span><br><span class="line">work      3228  0.0  0.0 112704   976 pts/0    R+   17:12   0:00 grep --color=auto kong</span><br><span class="line"></span><br><span class="line">#supervisor关闭了Kong进程后,无法启动.</span><br><span class="line">[work@kong-node1 conf.d]$ supervisorctl restart kong</span><br><span class="line">kong: stopped</span><br><span class="line">kong: ERROR (spawn error)</span><br><span class="line"></span><br><span class="line">#因为虽然kong进程杀死了.但是nginx进程还在.所以kong的8000端口仍然被占用</span><br><span class="line">[work@kong-node1 conf.d]$ ps aux | grep kong</span><br><span class="line">work      3215  0.1  0.1 259600 11800 ?        S    17:12   0:00 nginx: master process /usr/local/openresty/nginx/sbin/nginx -p /data/kong -c nginx.conf</span><br><span class="line">work      3307  0.0  0.0 112704   976 pts/0    S+   17:15   0:00 grep --color=auto kong</span><br><span class="line"></span><br><span class="line">#查看启动日志,提示kong进程已经启动了.</span><br><span class="line">Error: Kong is already running in /data/kong</span><br><span class="line"></span><br><span class="line">  Run with --v (verbose) or --vv (debug) for more details</span><br></pre></td></tr></table></figure><p><strong>暂时就不用supervisor管理了,采用命令行直接启动方式</strong></p><hr><p><strong>命令行启动kong.只有一个Nginx进程.没有Perl进程.不知道何故</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node2 conf.d]$kong start -c /etc/kong/kong.conf</span><br><span class="line">Kong started</span><br><span class="line">[work@kong-node2 conf.d]$ps aux | grep kong</span><br><span class="line">work     15558  0.0  0.0 259600  6540 ?        Ss   17:29   0:00 nginx: master process /usr/local/openresty/nginx/sbin/nginx -p /data/kong -c nginx.conf</span><br></pre></td></tr></table></figure><hr><h3 id="将kong-Cassandra加入到systemctl管理工具"><a href="#将kong-Cassandra加入到systemctl管理工具" class="headerlink" title="将kong,Cassandra加入到systemctl管理工具"></a>将kong,Cassandra加入到systemctl管理工具</h3><ul><li><strong>cassandra</strong></li></ul><p>systemctl文件如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 ~]$cd /usr/lib/systemd/system</span><br><span class="line">[work@kong-node1 system]$vim cassandra.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Cassandra</span><br><span class="line">After=network.target</span><br><span class="line">Before=kong.target </span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=work</span><br><span class="line">Group=work</span><br><span class="line">ExecStart=/usr/local/cassandra/bin/cassandra -f</span><br><span class="line">ExecStop=kill $(pgrep -f cassandra)</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><blockquote><p>注意.如果java是二进制包,则需要将Bin文件链接到系统环境变量目录下.因为systemctl不会读取profile环境,所以不能识别到java.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 system]$which java</span><br><span class="line">/usr/bin/java</span><br><span class="line">[work@kong-node1 system]$ll /usr/bin/java</span><br><span class="line">lrwxrwxrwx 1 root root 24 Nov 14 17:46 /usr/bin/java -&gt; /usr/local/java/bin/java</span><br></pre></td></tr></table></figure><p>第二种方法是在systemctl中指定环境变量.指定environment参数(这种方法理论可行,但是没有论证)</p><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Cassandra</span><br><span class="line">After=network.target</span><br><span class="line">Before=kong.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=work</span><br><span class="line">Group=work</span><br><span class="line">environment=JAVA_HOME=/usr/local/java</span><br><span class="line">environment=PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">ExecStart=/usr/local/cassandra/bin/cassandra -f</span><br><span class="line">ExecStop=kill $(pgrep -f cassandra)</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><hr><ul><li><strong>kong</strong></li></ul><p>在同目录下编辑kong服务配置.</p><blockquote><p>注意,需要在cassandra后端数据库启动后,才能启动kong服务</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 system]$vim kong.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description= kong service</span><br><span class="line">After=syslog.target network.target cassandra.target</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=work</span><br><span class="line">Group=work</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/kong start -c /etc/kong/kong.conf</span><br><span class="line">ExecReload=/usr/local/bin/kong reload -c /etc/kong/kong.conf</span><br><span class="line">ExecStop=/usr/local/bin/kong stop</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><ul><li><strong>在kong-node2上启动kong-dashbaord</strong></li></ul><blockquote><p>dashbaord服务启动需要在cassandra,kong服务启动之后</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node2 system]$vim kong-dashboard.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=kong-dashboard</span><br><span class="line">After=network.target cassandra.target kong.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=work</span><br><span class="line">Group=work</span><br><span class="line">ExecStart=/usr/local/bin/kong-dashboard start --kong-url http://10.111.30.158:8001</span><br><span class="line">ExecStop=kill $(pgrep -f kong-dashboard)</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><ul><li>加入到开启自启动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable cassandra</span><br><span class="line">systemctl enable kong</span><br><span class="line">systemctl enable kong-dashboard</span><br></pre></td></tr></table></figure><p>经过反复论证,systemctl可以管理以上服务.</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;kong-casssandra集群环境部署&quot;&gt;&lt;a href=&quot;#kong-casssandra集群环境部署&quot; class=&quot;headerlink&quot; title=&quot;kong+casssandra集群环境部署&quot;&gt;&lt;/a&gt;kong+casssandra集群环境部署&lt;/h2&gt;&lt;h3 id=&quot;kong简介&quot;&gt;&lt;a href=&quot;#kong简介&quot; class=&quot;headerlink&quot; title=&quot;kong简介&quot;&gt;&lt;/a&gt;kong简介&lt;/h3&gt;&lt;p&gt;Kong是Mashape开源的一款API网关，起初是用来管理 Mashape 公司15000个微服务的，后来在2015年开源,现在已经在很多创业公司、大型企业和政府机构中广泛使用。基于nginx,Lua和Cassandra或PostgreSQL，支持分布式操作，有很强的可移植性和可扩展性。可以在任何一种基础设施上运行,作为应用和API之间的中间层，加上众多功能强大的插件，可以实现认证授权、访问控制等功能。并且提供易于使用的RESTful API来操作和配置系统。&lt;/p&gt;
&lt;p&gt;有关kong的详细介绍请参考官网.&lt;/p&gt;
&lt;p&gt;–&lt;/p&gt;
&lt;h3 id=&quot;cassandra简介&quot;&gt;&lt;a href=&quot;#cassandra简介&quot; class=&quot;headerlink&quot; title=&quot;cassandra简介&quot;&gt;&lt;/a&gt;cassandra简介&lt;/h3&gt;&lt;p&gt;Cassandra 是一个来自 Apache 的分布式数据库，具有高度可扩展性，可用于管理大量的结构化数据。它提供了高可用性，没有单点故障。kong支持PostgreSQL或者Cassandra两种数据库.这里我们选择了cassandra.&lt;/p&gt;
&lt;p&gt;有关cassandra的详细介绍和使用方法.请参考官网&lt;/p&gt;
    
    </summary>
    
      <category term="Linux-Web" scheme="https://jesse.top/categories/Linux-Web/"/>
    
      <category term="kong" scheme="https://jesse.top/categories/Linux-Web/kong/"/>
    
    
      <category term="kong" scheme="https://jesse.top/tags/kong/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jesse.top/2020/06/26/Linux-Web/kong%20API%E7%BD%91%E5%85%B3%E4%BB%8B%E7%BB%8D%E5%8F%8AAPI%E6%8E%A5%E5%8F%A3%E9%85%8D%E7%BD%AE/"/>
    <id>https://jesse.top/2020/06/26/Linux-Web/kong API网关介绍及API接口配置/</id>
    <published>2020-06-26T03:05:39.216Z</published>
    <updated>2020-06-26T02:51:43.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="kong-API网关介绍及API接口配置"><a href="#kong-API网关介绍及API接口配置" class="headerlink" title="kong API网关介绍及API接口配置"></a>kong API网关介绍及API接口配置</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;kong-API网关介绍及API接口配置&quot;&gt;&lt;a href=&quot;#kong-API网关介绍及API接口配置&quot; class=&quot;headerlink&quot; title=&quot;kong API网关介绍及API接口配置&quot;&gt;&lt;/a&gt;kong API网关介绍及API接口配置&lt;/h2&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux 使用parted+LVM分区</title>
    <link href="https://jesse.top/2020/06/26/Linux-Basic/Skills/Linux%20%E4%BD%BF%E7%94%A8parted%20LVM%E5%88%86%E5%8C%BA/"/>
    <id>https://jesse.top/2020/06/26/Linux-Basic/Skills/Linux 使用parted LVM分区/</id>
    <published>2020-06-26T02:59:58.000Z</published>
    <updated>2020-06-26T03:10:46.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux-使用parted-LVM分区"><a href="#Linux-使用parted-LVM分区" class="headerlink" title="Linux 使用parted+LVM分区"></a>Linux 使用parted+LVM分区</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>fdisk使用MBR分区硬盘,但是最大只能识别到2T的磁盘,如果单块磁盘超过2T则需要使用GPT分区格式</p><hr><h4 id="分区步骤"><a href="#分区步骤" class="headerlink" title="分区步骤"></a>分区步骤</h4><p>分区方法和fdisk大同小异</p><ul><li>1.parted 磁盘名 .进入交互式界面</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@archiver-mysql ~]# parted /dev/vdb</span><br><span class="line">GNU Parted 3.1</span><br><span class="line">Using /dev/vdb</span><br><span class="line">Welcome to GNU Parted! Type &apos;help&apos; to view a list of commands.</span><br></pre></td></tr></table></figure><ul><li>2.mklabel gpt 转换为gpt分区</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parted) mklabel gpt</span><br><span class="line">Warning: The existing disk label on /dev/vdb will be destroyed and all data on this disk will be lost. Do you want to continue?</span><br><span class="line">Yes/No? yes</span><br></pre></td></tr></table></figure><p>3.mkpart分区</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(parted) mkpart</span><br><span class="line">Partition name?  []? data  </span><br><span class="line">File system type?  [ext2]? ext4</span><br><span class="line">Start?</span><br><span class="line">Start?</span><br><span class="line">Start? 0% #起始和结束为止要用百分比格式,使4K对齐</span><br><span class="line">End? 100%</span><br><span class="line"></span><br><span class="line">#也可以直接在一条命令上输入</span><br><span class="line">mkpart data ext4 0% 100%</span><br></pre></td></tr></table></figure><p>至此,gpt分区就完成了.可以看到单块磁盘有5T空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(parted) print</span><br><span class="line">Model: Virtio Block Device (virtblk)</span><br><span class="line">Disk /dev/vdb: 5498GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags:</span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    File system  Name  Flags</span><br><span class="line"> 1      1049kB  5498GB  5498GB               data</span><br></pre></td></tr></table></figure><hr><h3 id="二-LVM分区"><a href="#二-LVM分区" class="headerlink" title="二 LVM分区"></a>二 LVM分区</h3><p>步骤一样</p><ul><li>1.pvcreate /dev/vdb1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@archiver-mysql ~]# pvcreate /dev/vdb1</span><br><span class="line">WARNING: ext4 signature detected on /dev/vdb1 at offset 1080. Wipe it? [y/n]: y</span><br><span class="line">  Wiping ext4 signature on /dev/vdb1.</span><br><span class="line">  Physical volume &quot;/dev/vdb1&quot; successfully created.</span><br><span class="line">  </span><br><span class="line">  [root@archiver-mysql ~]# pvdisplay</span><br><span class="line">  &quot;/dev/vdb1&quot; is a new physical volume of &quot;&lt;5.00 TiB&quot;</span><br><span class="line">  --- NEW Physical volume ---</span><br><span class="line">  PV Name               /dev/vdb1</span><br><span class="line">  VG Name</span><br><span class="line">  PV Size               &lt;5.00 TiB</span><br><span class="line">  Allocatable           NO</span><br><span class="line">  PE Size               0</span><br><span class="line">  Total PE              0</span><br><span class="line">  Free PE               0</span><br><span class="line">  Allocated PE          0</span><br><span class="line">  PV UUID               0SKSgB-TBHZ-PKU8-La1Q-dG00-23Df-4ZXoy4</span><br></pre></td></tr></table></figure><ul><li>2.vgextend vg名 pv名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@archiver-mysql ~]# vgdisplay</span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               mysql_log_vggroup  #这个是vg名字</span><br><span class="line">  System ID</span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        1</span><br><span class="line">  Metadata Sequence No  2</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                1</span><br><span class="line">  Open LV               1</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                1</span><br><span class="line">  Act PV                1</span><br><span class="line">  VG Size               &lt;100.00 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              25599</span><br><span class="line">  Alloc PE / Size       25599 / &lt;100.00 GiB</span><br><span class="line">  Free  PE / Size       0 / 0</span><br><span class="line">  VG UUID               JERXbu-vnc0-X2Kz-1PRH-2Q4v-kIc3-bRjNkE</span><br><span class="line">  </span><br><span class="line">  [root@archiver-mysql ~]# vgcreate mysql_data_vggroup /dev/vdb1 #这是vgcreate命令</span><br><span class="line">  Volume group &quot;mysql_data_vggroup&quot; successfully created</span><br></pre></td></tr></table></figure><ul><li>3.lvcreate -n lv卷名字  -l +100%free vg卷名字</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@archiver-mysql ~]# lvcreate -n mysql_data_lvgroup -l +100%free mysql_data_vggroup</span><br></pre></td></tr></table></figure><ul><li>4.格式化卷</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@archiver-mysql ~]# mkfs.ext4 /dev/mysql_data_vggroup/mysql_data_lvgroup</span><br></pre></td></tr></table></figure><ul><li><ol start="5"><li>挂载</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@archiver-mysql ~]# mount /dev/mysql_data_vggroup/mysql_data_lvgroup /data</span><br></pre></td></tr></table></figure><ul><li>6.别忘记写入/etc/fstab开启自启文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;/dev/mapper/mysql_data_vggroup-mysql_data_lvgroup /data ext4 defaults 0 0&quot; &gt;&gt; /etc/fstab</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Linux-使用parted-LVM分区&quot;&gt;&lt;a href=&quot;#Linux-使用parted-LVM分区&quot; class=&quot;headerlink&quot; title=&quot;Linux 使用parted+LVM分区&quot;&gt;&lt;/a&gt;Linux 使用parted+LVM分区&lt;/h2&gt;&lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;&lt;p&gt;fdisk使用MBR分区硬盘,但是最大只能识别到2T的磁盘,如果单块磁盘超过2T则需要使用GPT分区格式&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;分区步骤&quot;&gt;&lt;a href=&quot;#分区步骤&quot; class=&quot;headerlink&quot; title=&quot;分区步骤&quot;&gt;&lt;/a&gt;分区步骤&lt;/h4&gt;&lt;p&gt;分区方法和fdisk大同小异&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.parted 磁盘名 .进入交互式界面&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@archiver-mysql ~]# parted /dev/vdb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;GNU Parted 3.1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Using /dev/vdb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Welcome to GNU Parted! Type &amp;apos;help&amp;apos; to view a list of commands.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;2.mklabel gpt 转换为gpt分区&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(parted) mklabel gpt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Warning: The existing disk label on /dev/vdb will be destroyed and all data on this disk will be lost. Do you want to continue?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Yes/No? yes&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3.mkpart分区&lt;/p&gt;
    
    </summary>
    
      <category term="Linux-Basic" scheme="https://jesse.top/categories/Linux-Basic/"/>
    
      <category term="Skills" scheme="https://jesse.top/categories/Linux-Basic/Skills/"/>
    
    
      <category term="LVM" scheme="https://jesse.top/tags/LVM/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jesse.top/2020/06/26/Linux-Basic/SSL/gitlab%E6%9B%B4%E6%96%B0SSL%E8%AF%81%E4%B9%A6/"/>
    <id>https://jesse.top/2020/06/26/Linux-Basic/SSL/gitlab更新SSL证书/</id>
    <published>2020-06-26T02:59:37.826Z</published>
    <updated>2020-06-26T02:51:43.987Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>由于letsencrypt证书有效期太短.gitlab不是很方便自动续约.所以在阿里云上购买证书,然后下载到到服务器.(由于gitlab底层是基于nginx,所以下载证书也是选择Nginx格式)</p><hr><p>找出gitlab证书存放位置:</p><p>1.在gitlab配置文件下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@gitlab:~# cd /etc/gitlab</span><br><span class="line">root@gitlab:/etc/gitlab# ls</span><br><span class="line">gitlab.rb  gitlab.rb.bak  gitlab.rb.bak2  gitlab-secrets.json  trusted-certs</span><br></pre></td></tr></table></figure><p>2.打开gitlab.rb配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@gitlab:/etc/gitlab# vim gitlab.rb</span><br><span class="line"></span><br><span class="line">#可以找到下列两行配置.这个就是gitlab的ssl证书存放路径</span><br><span class="line">nginx[&apos;ssl_certificate&apos;] = &quot;/etc/ssl/private/gitlab.pem&quot;</span><br><span class="line">nginx[&apos;ssl_certificate_key&apos;] = &quot;/etc/ssl/private/gitlab.key&quot;</span><br></pre></td></tr></table></figure><p>在gitlab的nginx配置文件下也可以找到相关配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@gitlab:/etc/gitlab# cd /var/opt/gitlab/nginx/conf/</span><br><span class="line">root@gitlab:/var/opt/gitlab/nginx/conf# ls</span><br><span class="line">gitlab-http.conf  gitlab-http.conf.bak  nginx.conf  nginx-status.conf</span><br><span class="line"></span><br><span class="line">#在gitlab-http.conf的nginx配置文件中也定义了ssl路径:</span><br><span class="line"></span><br><span class="line">root@gitlab:/var/opt/gitlab/nginx/conf# cat gitlab-http.conf | grep ssl_certificate</span><br><span class="line">  ssl_certificate /etc/ssl/private/gitlab.pem;</span><br><span class="line">  ssl_certificate_key /etc/ssl/private/gitlab.key;</span><br></pre></td></tr></table></figure><p>3.将阿里云下载下来的证书上传到gitlab的/etc/ssl/private目录中</p><p>4.重命名目前的证书文件为*.bak 将新的证书文件(.pem和.key)命名为gitlab.key和gitlab.pem</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@gitlab:/etc/ssl/private# ll</span><br><span class="line">total 28</span><br><span class="line">drwx--x--- 2 root ssl-cert 4096 Dec 18 18:30 ./</span><br><span class="line">drwxr-xr-x 4 root root     4096 Jan 17  2018 ../</span><br><span class="line">-rwxr-xr-x 1 root root     1679 Dec 18 18:29 gitlab.key*</span><br><span class="line">-rwxr-xr-x 1 work work     1675 Dec 25  2017 gitlab.key.bak*</span><br><span class="line">-rwxr-xr-x 1 root root     3663 Dec 18 18:29 gitlab.pem*</span><br><span class="line">-rwxr-xr-x 1 work work     3313 Dec 25  2017 gitlab.pem.bak*</span><br><span class="line">-rw-r----- 1 root ssl-cert 1704 Jun  9  2017 ssl-cert-snakeoil.key</span><br></pre></td></tr></table></figure><p>5.重启gitlab程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@gitlab:/etc/ssl/private# gitlab-ctl restart</span><br><span class="line">ok: run: gitaly: (pid 1442) 1s</span><br><span class="line">ok: run: gitlab-monitor: (pid 1449) 1s</span><br><span class="line">ok: run: gitlab-workhorse: (pid 1452) 0s</span><br><span class="line">ok: run: logrotate: (pid 1463) 1s</span><br><span class="line">ok: run: nginx: (pid 1469) 0s</span><br><span class="line">ok: run: node-exporter: (pid 1478) 0s</span><br><span class="line">ok: run: postgres-exporter: (pid 1484) 1s</span><br><span class="line">ok: run: postgresql: (pid 1494) 0s</span><br><span class="line">ok: run: prometheus: (pid 1503) 1s</span><br><span class="line">ok: run: redis: (pid 1517) 1s</span><br><span class="line">ok: run: redis-exporter: (pid 1521) 0s</span><br><span class="line">ok: run: sidekiq: (pid 1532) 0s</span><br><span class="line">ok: run: unicorn: (pid 1537) 1s</span><br><span class="line">root@gitlab:/etc/ssl/private#</span><br></pre></td></tr></table></figure><p>重新登录gitlab发现新的证书已经生效</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;由于letsencrypt证书有效期太短.gitlab不是很方便自动续约.所以在阿里云上购买证书,然后下载到到服务器.(由于gitlab底层
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>27.Python之路 - 面向对象多态</title>
    <link href="https://jesse.top/2020/06/26/python/04-Object-Oriented/03-Python%E4%B9%8B%E8%B7%AF%20-%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%A4%9A%E6%80%81/"/>
    <id>https://jesse.top/2020/06/26/python/04-Object-Oriented/03-Python之路 - 面向对象之多态/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:30:06.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-面向对象多态"><a href="#Python之路-面向对象多态" class="headerlink" title="Python之路 - 面向对象多态"></a>Python之路 - 面向对象多态</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>上一篇中已经得知 , 继承可以扩展已存在的代码模块(类) , 其目的是为了解决<strong><em>代码重用</em></strong> 问题</p><p>多态则是为了实现另一个目的 : 接口重用</p><h2 id="多态-🍀"><a href="#多态-🍀" class="headerlink" title="多态  🍀"></a>多态  🍀</h2><p>多态 (Polymorphism) 按字面的意思就是”多种状态” , 比如动物有多种形态 , 人 , 猫 , 狗 ; 文件也有多种格式 exe , txt , md(MarkDown格式) , 这就是多态</p><p> 在面向对象语言中 , 接口的多种不同的实现方式即为多态 </p><blockquote><p>多态性是允许你将父对象设置成为一个或多个他的子对象相等的技术 , 赋值之后 , 父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作</p></blockquote><p>静态多态性</p><a id="more"></a><p>必须在编译时就能确定其处理方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n1 = <span class="number">12</span></span><br><span class="line">n2 = <span class="number">34</span></span><br><span class="line"><span class="comment"># int类型相加</span></span><br><span class="line">print(n1 + n2)</span><br><span class="line">s1 = <span class="string">'hello '</span></span><br><span class="line">s2 = <span class="string">'word'</span></span><br><span class="line"><span class="comment"># str类型相加</span></span><br><span class="line">print(s1 + s2)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">46</span></span><br><span class="line"><span class="string">hello word</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>如上述例子我们利用运算符 “+”,  完成了两种情况下的运算 , 并且Python解释器在执行前就已确定处理方式 , 即编译过程中就已经知道了调用哪个函数 </p><p>动态多态性</p><p>编译时无法立即确定其处理方式 , 只有在执行时才确定处理方式 , 注意一定要同名 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta,abstractclassmethod</span><br><span class="line"><span class="comment"># 接口继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">    @abstractclassmethod</span></span><br><span class="line">    <span class="comment"># 约束派生类必须有talk方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"喵喵喵"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"汪汪汪"</span>)</span><br><span class="line">c = Cat()</span><br><span class="line">d = Dog()</span><br><span class="line"><span class="comment"># 因为接口的缘故,我们无需考虑实例化后的对象具体是什么类型,因为动物都有talk方法,所以我们可以直接使用</span></span><br><span class="line">c.talk()</span><br><span class="line">d.talk()</span><br><span class="line"><span class="comment"># 我们进行接口统一</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(obj)</span>:</span></span><br><span class="line">    obj.talk()</span><br><span class="line">talk(c)</span><br><span class="line">talk(d)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">喵喵喵</span></span><br><span class="line"><span class="string">汪汪汪</span></span><br><span class="line"><span class="string">喵喵喵</span></span><br><span class="line"><span class="string">汪汪汪</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>上栗中, Python解释器在解释时是无法确定处理方式的 , 因为存在几个同名的方法 , 编译时并不能确定是哪一个 , 只有在执行时 , 才能确定使用哪个类中的talk() 方法 , 这就是动态多态性</p><p>小结:</p><ol><li>静态多态性与动态多态性的区别在于 , 编译时是否能确定其处理方式</li><li>通过多态可以实现用一个函数名调用不同内容的函数</li></ol><h2 id="多态性的好处-🍀"><a href="#多态性的好处-🍀" class="headerlink" title="多态性的好处  🍀"></a>多态性的好处  🍀</h2><p>多态性是面向对象的三大特性之一 , 有很多人说Python不支持多态 , 事实上Python处处是多态 , 比如内置函数len() 就是多态的一种体现 </p><p>多态的作用: </p><ol><li><p>增加了程序的灵活性</p><p>以不变应万变 , 不论对象有多少中形态 , 使用者都是同一种形式去调用 , 如 talk(obj)</p></li><li><p>增加了程序的可扩展性</p><p>通过继承Animal类派生了一个新的类 , 使用者无需更改自己的代码 , 依旧利用 talk(obj) 进行调用</p></li></ol><p>对于多态 , 可能会觉得比较模糊 , 这是因为 , 我们在写程序时不知不觉就用上了 , 哈哈所以还是说处处是多态</p><h2 id="鸭子类型-🍀"><a href="#鸭子类型-🍀" class="headerlink" title="鸭子类型  🍀"></a>鸭子类型  🍀</h2><p>Python崇尚鸭子类型</p><p>以下是维基百科中对鸭子类型得论述 :</p><p>在程序设计中 , 鸭子类型 (英语 : duck typing) 是动态类型的一种风格。在这种风格中 , 一个对象有效的语义 , 不是由继承自特定的类或实现特定的接口 , 而是由当前方法和属性的集合决定 . 这个概念的名字来源于由James Whitcomb Riley提出的鸭子测试 , “ 鸭子测试 “可以这样表述：</p><p>“ 如果走起来像鸭子 , 游泳起来像鸭子 , 叫起来也像鸭子 , 那么它就是鸭子 “</p><p><strong>在鸭子类型中 , 关注的不是对象的类型本身 , 而是它是如何使用的</strong> . 例如 , 在不使用鸭子类型的语言中 , 我们可以编写一个函数 , 它接受一个类型为鸭的对象 , 并调用它的走和叫方法 . 在使用鸭子类型的语言中 , 这样的一个函数可以接受一个任意类型的对象 , 并调用它的走和叫方法 . 如果这些需要被调用的方法不存在 , 那么将引发一个运行时错误 . 任何拥有这样的正确的走和叫方法的对象都可被函数接受的这种行为引出了以上表述 , 这种决定类型的方式因此得名。</p><p>鸭子类型通常得益于不测试方法和函数中参数的类型 , 而是依赖文档 , 清晰的代码和测试来确保正确使用 . 从静态类型语言转向动态类型语言的用户通常试图添加一些静态的 ( 在运行之前的 ) 类型检查 , 从而影响了鸭子类型的益处和可伸缩性 , 并约束了语言的动态特性</p><p>例1 : 利用标准库中定义的各种 ‘ 与文件类似的对象 ‘ , 尽管这些对象的工作方式像文件 , 但他们没有继承内置对象的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文本文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TxtFile</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 磁盘文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiskFile</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>二者都像鸭子, 二者看起来都像文件,因而就可以当文件一样去用</p><p>例2 : 序列类型有多种形态 : 字符串 , 列表 , 元组 , 但他们没有直接的继承关系</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 三者都是序列类型</span></span><br><span class="line">name = <span class="string">'Lyon'</span></span><br><span class="line">namel = [<span class="string">'Lyon'</span>]</span><br><span class="line">namet = (<span class="string">'Lyon'</span>,)</span><br><span class="line"><span class="comment"># 字符串,列表,元组并没有直接关系,都可以调用len(),并且我们无需考虑类型</span></span><br><span class="line">print(len(name))</span><br><span class="line">print(len(namel))</span><br><span class="line">print(len(namet))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-面向对象多态&quot;&gt;&lt;a href=&quot;#Python之路-面向对象多态&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 面向对象多态&quot;&gt;&lt;/a&gt;Python之路 - 面向对象多态&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;上一篇中已经得知 , 继承可以扩展已存在的代码模块(类) , 其目的是为了解决&lt;strong&gt;&lt;em&gt;代码重用&lt;/em&gt;&lt;/strong&gt; 问题&lt;/p&gt;
&lt;p&gt;多态则是为了实现另一个目的 : 接口重用&lt;/p&gt;
&lt;h2 id=&quot;多态-🍀&quot;&gt;&lt;a href=&quot;#多态-🍀&quot; class=&quot;headerlink&quot; title=&quot;多态  🍀&quot;&gt;&lt;/a&gt;多态  🍀&lt;/h2&gt;&lt;p&gt;多态 (Polymorphism) 按字面的意思就是”多种状态” , 比如动物有多种形态 , 人 , 猫 , 狗 ; 文件也有多种格式 exe , txt , md(MarkDown格式) , 这就是多态&lt;/p&gt;
&lt;p&gt; 在面向对象语言中 , 接口的多种不同的实现方式即为多态 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;多态性是允许你将父对象设置成为一个或多个他的子对象相等的技术 , 赋值之后 , 父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;静态多态性&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Object-Oriented" scheme="https://jesse.top/categories/python/Object-Oriented/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>33.Python之路 - 特殊操作符</title>
    <link href="https://jesse.top/2020/06/26/python/04-Object-Oriented/Python%E4%B9%8B%E8%B7%AF%20-%20%E7%89%B9%E6%AE%8A%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>https://jesse.top/2020/06/26/python/04-Object-Oriented/Python之路 - 特殊操作符/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:33:37.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-特殊操作符"><a href="#Python之路-特殊操作符" class="headerlink" title="Python之路 - 特殊操作符"></a>Python之路 - 特殊操作符</h1><h2 id="介绍-🍀"><a href="#介绍-🍀" class="headerlink" title="介绍  🍀"></a>介绍  🍀</h2><p>在 Python 中 , 我们自定义类都是基于 Object 对象实现的 , 而在 Object 对象中有一些特殊的操作符 (<code>__method__</code>) 控制着整个对象的行为 , 所以 , 如果我们想对对象的行为进行控制 , 我们就需要自己来实现这些方法 ; 当然很多人称这些方法为 Python 魔法方法 (魔术方法) </p><p>下面 , 看看这些方法吧</p><h2 id="基本行为-🍀"><a href="#基本行为-🍀" class="headerlink" title="基本行为  🍀"></a>基本行为  🍀</h2><table><thead><tr><th>操作符</th><th>控制行为</th><th>调用说明</th></tr></thead><tbody><tr><td><code>__new__</code></td><td>对象创建</td><td><code>__init__</code> 只是用处初始化 , <code>__new__</code> 调用的结果会交给 <code>__init__</code> 进一步处理</td></tr><tr><td><code>__init__</code></td><td>对象初始化</td><td>构造函数 , 进行属性设置</td></tr><tr><td><code>__del__</code></td><td>对象删除</td><td>析构函数 , 进行对象的销毁</td></tr><tr><td><code>__repr__</code></td><td>对象显示 , 针对对象</td><td>终端显示 , 返回值必须为字符串 , 实例见表下方</td></tr><tr><td><code>__str__</code></td><td>对象显示 , 针对 <code>print</code></td><td><code>print</code> 显示结果 , 返回值必须为字符串 , 如果未实现该方法 , <code>print</code> 将使用 <code>__repr__</code></td></tr><tr><td><code>__bytes__</code></td><td>字节对象转换</td><td>返回值必须为一个bytes对象 , bytes(obj)</td></tr><tr><td><code>__format__</code></td><td>格式化字符串</td><td>返回值必须为字符串对象 , format(obj)</td></tr><tr><td><code>__lt__</code></td><td><code>&lt;</code> 运算</td><td><code>x &lt; y</code> , 返回布尔值 , 下同</td></tr><tr><td><code>__le__</code></td><td><code>&lt;=</code> 运算</td><td><code>x &lt;= y</code></td></tr><tr><td><code>__eq__</code></td><td><code>=</code> 运算</td><td><code>x == y</code></td></tr><tr><td><code>__ne__</code></td><td><code>!=</code> 运算</td><td><code>x != y</code></td></tr><tr><td><code>__gt__</code></td><td><code>&gt;</code> 运算</td><td><code>x &gt; y</code></td></tr><tr><td><code>__ge__</code></td><td><code>&gt;=</code> 运算</td><td><code>x &gt;= y</code></td></tr><tr><td><code>__hash__</code></td><td>可哈希</td><td>返回一个哈希对象 , hash(obj) , 注意 : 定义该方法同时应该定义 <code>__eq__</code></td></tr><tr><td><code>__bool__</code></td><td>真假测试</td><td>返回布尔值</td></tr><tr><td><code>__call__</code></td><td>对象调用</td><td>在对象被调用时执行</td></tr><tr><td><code>__len__</code></td><td><code>len()</code></td><td>使用 <code>len(obj)</code> 时被调用 , 为防止值测试抛出 <code>OverflowError</code> , 必须定义 <code>__bool__()</code></td></tr></tbody></table><p><code>__repr__</code> 与 <code>__str__</code> 对比实例 : </p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;repr:%s&gt;'</span> % self.name</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;str:%s&gt;'</span> % self.name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终端结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Foo(<span class="string">'Lyon'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj</span><br><span class="line">&lt;repr:Lyon&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(obj)</span><br><span class="line">&lt;str:Lyon&gt;</span><br></pre></td></tr></table></figure><h2 id="访问行为-🍀"><a href="#访问行为-🍀" class="headerlink" title="访问行为  🍀"></a>访问行为  🍀</h2><table><thead><tr><th>操作符</th><th>控制行为</th><th>调用说明</th></tr></thead><tbody><tr><td><code>__getattr__</code></td><td><code>.</code> 属性访问运算</td><td>获取 <code>x.name</code> , <code>__getattribute__</code> 查询失败后被调用 , 下方实例进一步说明</td></tr><tr><td><code>__getattribute__</code></td><td><code>.</code> 属性访问运算</td><td>获取 <code>x.name</code> , 查询属性时被调用</td></tr><tr><td><code>__setattr__</code></td><td><code>.</code> 属性赋值运算</td><td><code>self.attr = value → self.__setattr__(&quot;attr&quot;, value)</code> , 见下方实例进一步说明</td></tr><tr><td><code>__delattr__</code></td><td><code>.</code> 属性删除运算</td><td><code>del obj.name</code> 时被调用</td></tr><tr><td><code>__dir__</code></td><td><code>dir</code> 运算</td><td><code>dir()</code> 调用时被调用 , 必须返回一个序列 , <code>dir()</code> 会将序列转换成 list 并排序</td></tr></tbody></table><p><code>__getattr__</code> 说明实例 : </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __getattr__</span></span><br><span class="line"><span class="comment"># 注意在定义__getattr__或者__getattribute__时,不要出现 self. 因为这样会导致递归调用</span></span><br><span class="line"><span class="comment"># 正确的方式是,使用object的__getattr__,__getattribute__,或者直接定义返回值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Attribute &lt;%s&gt; fetch failure'</span> % item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="comment"># return object.__getattribute__(self, item)</span></span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">"name"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'Lyon'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(item)</span><br><span class="line"></span><br><span class="line">x = Foo(<span class="string">'Lyon'</span>)</span><br><span class="line">print(x.name)</span><br><span class="line">print(x.age)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">Lyon</span></span><br><span class="line"><span class="string">Attribute &lt;age&gt; fetch failure</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p> <code>__setattr__</code>  说明实例 : </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __setattr__</span></span><br><span class="line"><span class="comment"># 与__getattr__一样,在定义__setattr__时,不要出现 self. 因为这样会导致递归调用</span></span><br><span class="line"><span class="comment"># 正确的方式是,使用object的__setattr__,或者使用self.__dict__[key]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        <span class="comment"># object.__setattr__(self, key, value)</span></span><br><span class="line">        <span class="keyword">if</span> key == <span class="string">"name"</span>:</span><br><span class="line">            self.__dict__[key] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(key + <span class="string">' not allowed'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = Foo(<span class="string">'Lyon'</span>)</span><br><span class="line">x.name = <span class="string">"Kenneth"</span></span><br><span class="line">x.age = <span class="number">18</span></span><br><span class="line">print(x.__dict__)</span><br><span class="line">module1</span><br></pre></td></tr></table></figure><h2 id="描述器行为-🍀"><a href="#描述器行为-🍀" class="headerlink" title="描述器行为  🍀"></a>描述器行为  🍀</h2><table><thead><tr><th>操作符</th><th>控制行为</th><th>调用说明</th></tr></thead><tbody><tr><td><code>__get__</code></td><td><code>.</code> 对象访问运算</td><td>访问对象时被调用 , 对象访问意指 <code>.</code> 后面接的不是一个属性而是一个对象 , 见下方实例说明</td></tr><tr><td><code>__set__</code></td><td><code>.</code> 对象赋值运算</td><td>对象赋值时被调用</td></tr><tr><td><code>__delete__</code></td><td><code>.</code> 对象删除运算</td><td>对象删除时被调用</td></tr><tr><td><code>__set_name__</code></td><td>所有者创建</td><td>在创建所有者时被调用 , Python 3.6 新增</td></tr></tbody></table><p><code>__get__</code> , <code>__set__</code> , <code>__delete__</code> 实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关于对象访问一说,是建立在两个的使用基础上的</span></span><br><span class="line"><span class="comment"># 单纯来讲,就是所有者类中的一个属性,是另一个类的实例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dependency</span>:</span></span><br><span class="line">    <span class="string">""" 附属类 """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print(<span class="string">'%s.%s is called...'</span> % (<span class="string">'Dependency'</span>, <span class="string">'__get__'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        print(<span class="string">'%s.%s is called...'</span> % (<span class="string">'Dependency'</span>, <span class="string">'__set__'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">        print(<span class="string">'%s.%s is called...'</span> % (<span class="string">'Dependency'</span>, <span class="string">'__delete__'</span>))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Owner</span>:</span></span><br><span class="line">    <span class="string">""" 所有者类 """</span></span><br><span class="line">    dependency = Dependency()</span><br><span class="line"></span><br><span class="line">o = Owner()</span><br><span class="line">o.dependency</span><br><span class="line">o.dependency = <span class="string">'Lyon'</span></span><br><span class="line"><span class="keyword">del</span> o.dependency</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">Dependency.__get__ is called...</span></span><br><span class="line"><span class="string">Dependency.__set__ is called...</span></span><br><span class="line"><span class="string">Dependency.__delete__ is called...</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p><code>__set_name__</code> 是在上例 <code>Owner</code> 实例创建时被调用 , Python 3.6 新增</p><h2 id="容器行为-🍀"><a href="#容器行为-🍀" class="headerlink" title="容器行为  🍀"></a>容器行为  🍀</h2><table><thead><tr><th>操作符</th><th>控制行为</th><th>调用说明</th></tr></thead><tbody><tr><td><code>__getitem__</code></td><td>序列方式访问</td><td><code>self[key]</code> 时被调用</td></tr><tr><td><code>__missing__</code></td><td>序列方式访问失败</td><td><code>self[key]</code> 时 key 不在字典中被调用</td></tr><tr><td><code>__setitem__</code></td><td>序列方式赋值</td><td><code>self[key] = value</code> 时被调用</td></tr><tr><td><code>__delitem__</code></td><td>序列方式删除</td><td><code>del self[key]</code> 时被调用</td></tr><tr><td><code>__iter__</code></td><td>迭代环境</td><td>通过 <code>iter(obj)</code> 调用 , 如使用for循环进行遍历</td></tr><tr><td><code>__reversed__</code></td><td><code>reversed()</code></td><td><code>reversed(obj)</code> 时被调用</td></tr><tr><td><code>__contains__</code></td><td>成员关系 <code>in</code></td><td><code>item in self</code> 时调用</td></tr></tbody></table><h2 id="运算行为-🍀"><a href="#运算行为-🍀" class="headerlink" title="运算行为  🍀"></a>运算行为  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本运算行为</span></span><br><span class="line">object.__add__(self, other)              <span class="comment"># +</span></span><br><span class="line">object.__sub__(self, other)              <span class="comment"># -</span></span><br><span class="line">object.__mul__(self, other)              <span class="comment"># *</span></span><br><span class="line">object.__matmul__(self, other)           <span class="comment"># @</span></span><br><span class="line">object.__truediv__(self, other)          <span class="comment"># /</span></span><br><span class="line">object.__floordiv__(self, other)         <span class="comment"># //</span></span><br><span class="line">object.__mod__(self, other)              <span class="comment"># %</span></span><br><span class="line">object.__divmod__(self, other)           <span class="comment"># divmod()</span></span><br><span class="line">object.__pow__(self, other[, modulo])    <span class="comment"># pow()  **</span></span><br><span class="line">object.__lshift__(self, other)           <span class="comment"># &lt;&lt;</span></span><br><span class="line">object.__rshift__(self, other)           <span class="comment"># &gt;&gt;</span></span><br><span class="line">object.__and__(self, other)              <span class="comment"># &amp;</span></span><br><span class="line">object.__xor__(self, other)              <span class="comment"># ^</span></span><br><span class="line">object.__or__(self, other)               <span class="comment"># |</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二进制运算行为</span></span><br><span class="line">object.__radd__(self, other)             </span><br><span class="line">object.__rsub__(self, other)             </span><br><span class="line">object.__rmul__(self, other)             </span><br><span class="line">object.__rmatmul__(self, other)          </span><br><span class="line">object.__rtruediv__(self, other)        </span><br><span class="line">object.__rfloordiv__(self, other)       </span><br><span class="line">object.__rmod__(self, other)             </span><br><span class="line">object.__rdivmod__(self, other)  </span><br><span class="line">object.__rpow__(self, other)</span><br><span class="line">object.__rlshift__(self, other)         </span><br><span class="line">object.__rrshift__(self, other)          </span><br><span class="line">object.__rand__(self, other)            </span><br><span class="line">object.__rxor__(self, other)           </span><br><span class="line">object.__ror__(self, other) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 加=运算行为</span></span><br><span class="line">object.__iadd__(self, other)             <span class="comment"># +=</span></span><br><span class="line">object.__isub__(self, other)             <span class="comment"># -=</span></span><br><span class="line">object.__imul__(self, other)             <span class="comment"># *=</span></span><br><span class="line">object.__imatmul__(self, other)</span><br><span class="line">object.__itruediv__(self, other)</span><br><span class="line">object.__ifloordiv__(self, other)</span><br><span class="line">object.__imod__(self, other)</span><br><span class="line">object.__ipow__(self, other[, modulo])</span><br><span class="line">object.__ilshift__(self, other)</span><br><span class="line">object.__irshift__(self, other)</span><br><span class="line">object.__iand__(self, other)</span><br><span class="line">object.__ixor__(self, other)</span><br><span class="line">object.__ior__(self, other)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一元算数运算</span></span><br><span class="line">object.__neg__(self)</span><br><span class="line">object.__pos__(self)</span><br><span class="line">object.__abs__(self)</span><br><span class="line">object.__invert__(self)</span><br><span class="line"></span><br><span class="line"><span class="comment"># complex(),int(),float()</span></span><br><span class="line">object.__complex__(self)</span><br><span class="line">object.__int__(self)</span><br><span class="line">object.__float__(self)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整数值hex(X),bin(X),oct(X),o[X],O[X:]</span></span><br><span class="line">object.__index__(self)</span><br><span class="line"></span><br><span class="line"><span class="comment"># round(),trunc(),floor(),ceil()</span></span><br><span class="line">object.__round__(self[, ndigits])</span><br><span class="line">object.__trunc__(self)</span><br><span class="line">object.__floor__(self)</span><br><span class="line">object.__ceil__(self)</span><br></pre></td></tr></table></figure><h2 id="上下文管理行为-🍀"><a href="#上下文管理行为-🍀" class="headerlink" title="上下文管理行为  🍀"></a>上下文管理行为  🍀</h2><table><thead><tr><th>操作符</th><th>控制行为</th><th>调用说明</th></tr></thead><tbody><tr><td><code>__enter__</code></td><td>进入上下文环境</td><td>使用with进入上下文环境时被调用</td></tr><tr><td><code>__exit__</code></td><td>退出上下文环境</td><td>退出上下文环境时被调用</td></tr></tbody></table><p>实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 返回值赋值给as指定变量</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        print(<span class="string">'exc_type'</span>,exc_type)  <span class="comment"># 异常类型</span></span><br><span class="line">        print(<span class="string">'exc_val'</span>,exc_val)    <span class="comment"># 异常值</span></span><br><span class="line">        print(<span class="string">'exc_tb'</span>,exc_tb)      <span class="comment"># 追溯信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span>                 <span class="comment"># 返回值为True,那么异常会被清空,就好像啥都没发生一样,</span></span><br><span class="line">                                    <span class="comment"># with后的语句正常执行</span></span><br><span class="line">                                    <span class="comment"># 为False异常会抛出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Foo(<span class="string">'Lyon'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">raise</span> AttributeError(<span class="string">'ignore exception'</span>)</span><br><span class="line">print(<span class="string">'over'</span>)</span><br></pre></td></tr></table></figure><h2 id="slots-🍀"><a href="#slots-🍀" class="headerlink" title="__slots__  🍀"></a>__slots__  🍀</h2><p><code>__slots__</code> 的作用是阻止在实例化类时为实例分配dict , 默认情况下每个类都会有一个dict,通过<code>__dict__</code> 访问 , 这个dict维护了这个实例的所有属性 </p><p>作用 : </p><ul><li>减少内存使用</li><li>限制对实例添加新的属性</li></ul><p>缺点 : </p><ul><li>不可被继承</li><li>不可动弹添加新属性</li></ul><p>实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    __slots__ = [<span class="string">'name'</span>, <span class="string">'age'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">f = Foo(<span class="string">'Lyon'</span>, <span class="number">18</span>)</span><br><span class="line">print(f.name)</span><br><span class="line">print(f.age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 报错</span></span><br><span class="line">f.sex = <span class="string">'Man'</span></span><br></pre></td></tr></table></figure><p>更多 <a href="https://docs.python.org/3/reference/datamodel.html#object.__index__" target="_blank" rel="noopener">Data model</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-特殊操作符&quot;&gt;&lt;a href=&quot;#Python之路-特殊操作符&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 特殊操作符&quot;&gt;&lt;/a&gt;Python之路 - 特殊操作符&lt;/h1&gt;&lt;h2 id=&quot;介绍-🍀&quot;&gt;&lt;a href=&quot;#介绍-🍀&quot; class=&quot;headerlink&quot; title=&quot;介绍  🍀&quot;&gt;&lt;/a&gt;介绍  🍀&lt;/h2&gt;&lt;p&gt;在 Python 中 , 我们自定义类都是基于 Object 对象实现的 , 而在 Object 对象中有一些特殊的操作符 (&lt;code&gt;__method__&lt;/code&gt;) 控制着整个对象的行为 , 所以 , 如果我们想对对象的行为进行控制 , 我们就需要自己来实现这些方法 ; 当然很多人称这些方法为 Python 魔法方法 (魔术方法) &lt;/p&gt;
&lt;p&gt;下面 , 看看这些方法吧&lt;/p&gt;
&lt;h2 id=&quot;基本行为-🍀&quot;&gt;&lt;a href=&quot;#基本行为-🍀&quot; class=&quot;headerlink&quot; title=&quot;基本行为  🍀&quot;&gt;&lt;/a&gt;基本行为  🍀&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作符&lt;/th&gt;
&lt;th&gt;控制行为&lt;/th&gt;
&lt;th&gt;调用说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__new__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对象创建&lt;/td&gt;
&lt;td&gt;&lt;code&gt;__init__&lt;/code&gt; 只是用处初始化 , &lt;code&gt;__new__&lt;/code&gt; 调用的结果会交给 &lt;code&gt;__init__&lt;/code&gt; 进一步处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__init__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对象初始化&lt;/td&gt;
&lt;td&gt;构造函数 , 进行属性设置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__del__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对象删除&lt;/td&gt;
&lt;td&gt;析构函数 , 进行对象的销毁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__repr__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对象显示 , 针对对象&lt;/td&gt;
&lt;td&gt;终端显示 , 返回值必须为字符串 , 实例见表下方&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__str__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对象显示 , 针对 &lt;code&gt;print&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;print&lt;/code&gt; 显示结果 , 返回值必须为字符串 , 如果未实现该方法 , &lt;code&gt;print&lt;/code&gt; 将使用 &lt;code&gt;__repr__&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__bytes__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;字节对象转换&lt;/td&gt;
&lt;td&gt;返回值必须为一个bytes对象 , bytes(obj)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__format__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;格式化字符串&lt;/td&gt;
&lt;td&gt;返回值必须为字符串对象 , format(obj)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__lt__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; 运算&lt;/td&gt;
&lt;td&gt;&lt;code&gt;x &amp;lt; y&lt;/code&gt; , 返回布尔值 , 下同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__le__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt; 运算&lt;/td&gt;
&lt;td&gt;&lt;code&gt;x &amp;lt;= y&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__eq__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;=&lt;/code&gt; 运算&lt;/td&gt;
&lt;td&gt;&lt;code&gt;x == y&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__ne__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;!=&lt;/code&gt; 运算&lt;/td&gt;
&lt;td&gt;&lt;code&gt;x != y&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__gt__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; 运算&lt;/td&gt;
&lt;td&gt;&lt;code&gt;x &amp;gt; y&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__ge__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt; 运算&lt;/td&gt;
&lt;td&gt;&lt;code&gt;x &amp;gt;= y&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__hash__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;可哈希&lt;/td&gt;
&lt;td&gt;返回一个哈希对象 , hash(obj) , 注意 : 定义该方法同时应该定义 &lt;code&gt;__eq__&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__bool__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;真假测试&lt;/td&gt;
&lt;td&gt;返回布尔值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__call__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对象调用&lt;/td&gt;
&lt;td&gt;在对象被调用时执行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__len__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;len()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;使用 &lt;code&gt;len(obj)&lt;/code&gt; 时被调用 , 为防止值测试抛出 &lt;code&gt;OverflowError&lt;/code&gt; , 必须定义 &lt;code&gt;__bool__()&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;__repr__&lt;/code&gt; 与 &lt;code&gt;__str__&lt;/code&gt; 对比实例 : &lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Object-Oriented" scheme="https://jesse.top/categories/python/Object-Oriented/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>21.Python之路 - 正则表达式</title>
    <link href="https://jesse.top/2020/06/26/python/03-Modules/05-Python%E4%B9%8B%E8%B7%AF%20-%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://jesse.top/2020/06/26/python/03-Modules/05-Python之路 - 正则表达式/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:04:10.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-正则表达式"><a href="#Python之路-正则表达式" class="headerlink" title="Python之路 - 正则表达式"></a>Python之路 - 正则表达式</h1><h2 id="正则介绍-🍀"><a href="#正则介绍-🍀" class="headerlink" title="正则介绍  🍀"></a>正则介绍  🍀</h2><p>正则表达式并不是python的一部分，而是在各个编程语言都有的一种用于处理字符串的强大工具。</p><p>使用正则处理字符串在效率上可能不如str自带的方法，但是它的功能十分强大。python中的正则封装在re模块中。</p><a id="more"></a><h2 id="匹配方法-🍀"><a href="#匹配方法-🍀" class="headerlink" title="匹配方法  🍀"></a>匹配方法  🍀</h2><p>首先将匹配方法进行说明，即re模块的内置方法</p><blockquote><p><code>re.match</code>(<em>pattern</em>, <em>string</em>, <em>flags=0</em>) :  👈</p></blockquote><p>从字符串的开头开始匹配，匹配成功返回一个<code>_sre.SRE_Match</code>类型，可用<code>.group()</code> 取出结果，失败返回None</p><p><em>pattern</em> : 匹配格式</p><p><em>string</em> : 要匹配的字符串</p><p><em>flags</em> : 编译标志位，用于修改正则表达式的匹配方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入re模块，后续方法实例省略这一步</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = re.match(<span class="string">'lyon'</span>,<span class="string">'lyon'</span>)</span><br><span class="line"><span class="comment"># 查看类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(res)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">_sre</span>.<span class="title">SRE_Match</span>'&gt;</span></span><br><span class="line"><span class="class"># 用.<span class="title">group</span><span class="params">()</span>取出结果</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">res</span>.<span class="title">group</span><span class="params">()</span></span></span><br><span class="line"><span class="class">'<span class="title">lyon</span>'</span></span><br></pre></td></tr></table></figure><blockquote><p><code>re.search</code>(<em>pattern</em>, <em>string</em>, <em>flags=0</em>) :  👈</p></blockquote><p>扫描整个字符串，匹配成功则返回匹配到的第一个对象（<code>_sre.SRE_Match</code>类型），失败返回None</p><p><em>pattern</em> : 匹配格式</p><p><em>string</em> : 要匹配的字符串</p><p><em>flags</em> : 编译标志位，用于修改正则表达式的匹配方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匹配数字</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">'\d+'</span>,<span class="string">'abc123abc'</span>).group()</span><br><span class="line"><span class="string">'123'</span></span><br></pre></td></tr></table></figure><blockquote><p><code>re.findall</code>(<em>pattern</em>, <em>string</em>, <em>flags=0</em>) :  👈</p></blockquote><p>匹配字符串所有的内容，把匹配到的字符串以列表的形式返回</p><p><em>pattern</em> : 匹配格式</p><p><em>string</em> : 要匹配的字符串</p><p><em>flags</em> : 编译标志位，用于修改正则表达式的匹配方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匹配数字</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">'\d'</span>,<span class="string">'abc123abc456'</span>)</span><br><span class="line">[<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>]</span><br></pre></td></tr></table></figure><blockquote><p><code>re.split</code>(<em>pattern</em>, <em>string</em>, <em>maxsplit=0</em>, <em>flags=0</em>) :  👈</p></blockquote><p>指定格式进行切分，返回一个列表</p><p><em>pattern</em> :  切分格式</p><p><em>string</em> : 要切分的字符串</p><p><em>maxsplit</em> : 切分次数</p><p><em>flags</em> : 编译标志位，用于修改正则表达式的匹配方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以数字进行切分</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">'\d+'</span>,<span class="string">'abc123abc123+-*/45'</span>)</span><br><span class="line">[<span class="string">'abc'</span>, <span class="string">'abc'</span>, <span class="string">'+-*/'</span>, <span class="string">''</span>]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>str1 = ‘alex,jerry;jesse|lyon wusir’<br>print(re.split(“ |,|;||“,str1)) </p><blockquote><blockquote><blockquote><p>[‘alex’, ‘jerry’, ‘jesse’, ‘lyon’, ‘wusir’]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; `re.sub`(*pattern*, *repl*, *string*, *count=0*, *flags=0*) : 👈</span><br><span class="line"></span><br><span class="line">替换匹配到的字符串并返回替换后的结果</span><br><span class="line"></span><br><span class="line">*pattern* : 匹配格式</span><br><span class="line"></span><br><span class="line">*repl* : 替换格式</span><br><span class="line"></span><br><span class="line">*string* : 要匹配替换的字符串</span><br><span class="line"></span><br><span class="line">*flags* : 编译标志位，用于修改正则表达式的匹配方式</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">&gt;&gt;&gt; re.sub(&quot;abc&quot;,&quot;def&quot;,&quot;abc123abc&quot;)</span><br><span class="line">&apos;def123def&apos;</span><br><span class="line"># 只替换查找到的字符串一次</span><br><span class="line">&gt;&gt;&gt; re.sub(&quot;abc&quot;,&quot;def&quot;,&quot;abc123abc&quot;,count=1)</span><br><span class="line">&apos;def123abc&apos;</span><br></pre></td></tr></table></figure></p></blockquote></blockquote></blockquote><p><em>flags说明（轻轻了解） :</em></p><table><thead><tr><th>标志</th><th>说明</th></tr></thead><tbody><tr><td>re.I  (re.IGNORECASE)</td><td>忽略大小写（括号内为全拼写法，效果一样）</td></tr><tr><td>re.M  (MULTILINE)</td><td>多行模式，改变 ‘^’ 和 ‘$’ 的行为 （改变？见下节匹配模式）</td></tr><tr><td>re.S  (DOTALL)</td><td>任意匹配模式，改变 ‘ . ‘  的行为（同上）</td></tr><tr><td>re.L  (LOCALE)</td><td>做本地化识别（locale-aware）匹配，法语等</td></tr><tr><td>re.X  (VERBOSE)</td><td>该标志通过给予更灵活的格式以便将正则表达式写得更易于理解</td></tr><tr><td>re.U</td><td>根据Unicode字符集解析字符，这个标志影响\w,\W,\b,\B</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略大小写</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">'a'</span>,<span class="string">'aA123aAAA'</span>,flags=re.I)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'A'</span>, <span class="string">'a'</span>, <span class="string">'A'</span>, <span class="string">'A'</span>, <span class="string">'A'</span>]</span><br></pre></td></tr></table></figure><p><em>注意转义的问题：当我们的匹配格式中有我们需要匹配的特殊字符，如 ‘ \ ‘、’ </em> ‘、’ + ‘等，为了让解释器知道我们这是需要匹配的，我们可以在格式前加 ‘r’ 进行转义，或者在每个需要匹配的之前加个 ‘ \ ‘来完成转义。*</p><p><em><code>.group()</code>小知识：</em></p><p>在我们使用<code>.group()</code>方法时，要注意如果我们的正则表达式没有匹配到结果，即返回None时，用<code>.group()</code>时就会报错，因为<code>&quot;NoneType&quot;</code>是没有该方法的，只有<code>_sre.SRE_Match</code>类型才能使用该方法。</p><h2 id="匹配模式-🍀"><a href="#匹配模式-🍀" class="headerlink" title="匹配模式   🍀"></a>匹配模式   🍀</h2><h3 id="字符匹配-🍡"><a href="#字符匹配-🍡" class="headerlink" title="字符匹配   🍡"></a>字符匹配   🍡</h3><table><thead><tr><th style="text-align:left">字符</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left">.</td><td>默认匹配除\n之外的任意一个字符，若指定flag DOTALL,则匹配任意字符，包括换行</td></tr><tr><td style="text-align:left">\d \D</td><td>匹配数字0-9/非数字</td></tr><tr><td style="text-align:left">\s</td><td>匹配空白字符、\t、\n、\r , re.search(“\s+”,”ab\tc1\n3”).group() 结果 ‘\t’</td></tr><tr><td style="text-align:left">\S</td><td>非空白字符</td></tr><tr><td style="text-align:left">\w</td><td>匹配[A-Za-z0-9]</td></tr><tr><td style="text-align:left">\W</td><td>匹配非[A-Za-z0-9]</td></tr><tr><td style="text-align:left">\b</td><td>匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td></tr><tr><td style="text-align:left">\B</td><td>匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td></tr></tbody></table><h3 id="次数匹配-🍡"><a href="#次数匹配-🍡" class="headerlink" title="次数匹配  🍡"></a>次数匹配  🍡</h3><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>*</td><td>匹配*号前的字符0次或多次，re.findall(“ab*”,”cabb3abcbbac”)  结果为[‘abb’, ‘ab’, ‘a’]</td></tr><tr><td>+</td><td>匹配前一个字符1次或多次，re.findall(“ab+”,”ab+cd+abb+bba”) 结果[‘ab’, ‘abb’]</td></tr><tr><td>?</td><td>匹配前一个字符0次或者1次</td></tr><tr><td>{m}</td><td>匹配前一个字符m次</td></tr><tr><td>{n,m}</td><td>匹配前一个字符n到m次，re.findall(“ab{1,3}”,”abb abc abbcbbb”) 结果’abb’, ‘ab’, ‘abb’]</td></tr><tr><td>*?/+?/??</td><td>转为非贪婪模式（尽可能少的匹配）</td></tr><tr><td>[…]</td><td>字符集，匹配字符集中任意字符，字符集可给出范围或者逐个列出</td></tr></tbody></table><h3 id="边界匹配-🍡"><a href="#边界匹配-🍡" class="headerlink" title="边界匹配  🍡"></a>边界匹配  🍡</h3><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>^</td><td>匹配字符串开头，若指定flags MULTILINE，这种也可以匹配上，(r’^a’,’\nabc\neee’,flags=re.MULTILINE)</td></tr><tr><td>$</td><td>匹配字符结尾，或e.search(“foo$”,”bfoo\nsdfsf”,flags=re.MULTILINE).group()也可以</td></tr><tr><td>\A</td><td>只从字符开头匹配，re.search(“\Aabc”,”alexabc”) 是匹配不到的</td></tr><tr><td>\Z</td><td>匹配字符结尾，同$</td></tr></tbody></table><h3 id="分组匹配-🍡"><a href="#分组匹配-🍡" class="headerlink" title="分组匹配  🍡"></a>分组匹配  🍡</h3><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">丨</td><td style="text-align:left">匹配丨左或丨右的字符，re.search(“abc丨ABC”,”ABCBabcCD”).group() 结果’ABC’</td></tr><tr><td style="text-align:left">(…)</td><td style="text-align:left">分组匹配，re.search(“(abc){2}a(123丨456)c”, “abcabca456c”).group() 结果 abcabca456c</td></tr><tr><td style="text-align:left">(?P\&lt;..&gt;)</td><td style="text-align:left">命名分组匹配 re.search(“(?P\<province>[0-9]{4})(?P\<city>[0-9]{2})(?P\<birthday>[0-9]{4})”,”371481199306143242”).groupdict(“city”) 结果{‘province’: ‘3714’, ‘city’: ‘81’, ‘birthday’: ‘1993’}</birthday></city></province></td></tr></tbody></table><h2 id="分组匹配-🍀"><a href="#分组匹配-🍀" class="headerlink" title="分组匹配 🍀"></a>分组匹配 🍀</h2><p>分组就是用一对圆括号“()”括起来的正则表达式，匹配出的内容就表示一个分组.用match方法 可以匹配一个分组,然后用group()来取出分组匹配到的内容.<br>分组匹配类似于shell里的sed分组()匹配.</p><p>注意:<br>1.正则表达式有一个隐含的全局分组0<br>2.match方法是从字符串起始位置开始匹配.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#例子1:</span><br><span class="line"></span><br><span class="line">str1 = &apos;010-12345&apos;</span><br><span class="line">r = re.compile(&apos;(\d&#123;3&#125;)-(\d&#123;5&#125;)&apos;)</span><br><span class="line">res = re.match(r,str1)</span><br><span class="line"></span><br><span class="line">print(res.group(0))  #打印全局匹配到的字符串</span><br><span class="line">print(res.group(1))  #打印第一个分组(\d&#123;3&#125;)匹配到的字符串</span><br><span class="line">print(res.group(2))  #打印第二个分组(\d&#123;5&#125;)匹配到的字符串</span><br><span class="line">print(res.groups())  #元祖形式返回分组1和2</span><br><span class="line"></span><br><span class="line">#例子2</span><br><span class="line">str3 = &apos;&lt;script src=&quot;https://ss1.bdstatic.com/&quot;&apos;</span><br><span class="line"></span><br><span class="line">#这里采用分组匹配,匹配到的是https://ss1.bdstatic.com/ URL地址</span><br><span class="line">print(re.findall(&apos;src=(&quot;.*?&quot;)&apos;,str3))</span><br><span class="line">res = re.match(&apos;&lt;script src=(&quot;.*?&quot;)&apos;,str3) #注意match方法是从起始位置开始匹配.所以直接写src=(&quot;.*?&quot;)是匹配不到的</span><br><span class="line">print(res.group(1))</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匹配丨左或丨右的字符.</span><br></pre></td></tr></table></figure></h2><p>str1 = “company companies compan comp companiessss”<br>print(re.findall(“company|companies”,str1))</p><blockquote><blockquote><blockquote><p>[‘company’, ‘companies’, ‘companies’]</p></blockquote></blockquote></blockquote><p>#上面写的有点low.如果换个写法<br>print(re.findall(“compan(y|ies)”,str1))</p><p>#打印结果如下: 正则表达式将()作为了一个分组来匹配y和ies.而不是将compan(y|ies)作为一个整体</p><blockquote><blockquote><blockquote><p>[‘y’, ‘ies’, ‘ies’]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用```?:```的写法解决上面的问题</span><br></pre></td></tr></table></figure></p></blockquote></blockquote></blockquote><p>print(re.findall(“compan(?:y|ies)”,str1))</p><blockquote><blockquote><blockquote><p>[‘company’, ‘companies’, ‘companies’]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 贪婪和非贪婪匹配 🍀</span><br><span class="line"></span><br><span class="line">* 贪婪模式: 默认的匹配方式,意思是尽可能多的匹配字符</span><br></pre></td></tr></table></figure></p></blockquote></blockquote></blockquote><p>s = “this is a number 234-235-22-423”</p><p>r = re.match(“.+(\d+-\d+-\d+-\d+)”,s)<br>print(r.group(1))</p><blockquote><blockquote><blockquote><p>4-235-22-423<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在上面这个例子中,前面的```.+``` 尽可能长的匹配,所以开头一直匹配到了&quot;this is a number 23&quot;. \d+ 只匹配到了最后一个数字4.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 非贪婪模式: 总是尝试匹配尽可能少的字符。在&quot;*&quot;,&quot;?&quot;,&quot;+&quot;,&quot;&#123;m,n&#125;&quot;后面加上？，使贪婪变成非贪婪。此时的```?```不再表示匹配前一个字符0次或者多次的意思,而是作为限制符.意思就是只要匹配到,就取出</span><br></pre></td></tr></table></figure></p></blockquote></blockquote></blockquote><p>s = “this is a number 234-235-22-423”</p><p>r = re.match(“.+?(\d+-\d+-\d+-\d+)”,s)<br>print(r.group(1))</p><blockquote><blockquote><blockquote><p>234-235-22-423<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">在上面这个例子中,```.+```只匹配到&apos;&apos;&apos;this is a number&apos;&apos;&apos;.234数字被\d+匹配到了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 匹配方法补充  🍀</span><br><span class="line"></span><br><span class="line">补充方法</span><br><span class="line"></span><br><span class="line">&gt; `re.subn`(pattern, repl, string, count=0, flags=0) :  </span><br><span class="line"></span><br><span class="line">返回替换后的字符串和替换次数</span><br><span class="line"></span><br><span class="line">&gt; `re.escape`(pattern) :                                </span><br><span class="line"></span><br><span class="line">自动进行转义，除了ASCII字母、数字和&apos;_&apos;之外</span><br><span class="line"></span><br><span class="line">&gt; `re.compile`(pattern, flags=0) :                      </span><br><span class="line"></span><br><span class="line">生成一个_sre.SRE_Pattern对象，以便多次调用</span><br><span class="line"></span><br><span class="line">&gt; `re.finditer`(pattern, string, flags=0) :             </span><br><span class="line"></span><br><span class="line">返回一个匹配结果的迭代器，可迭代取值</span><br><span class="line"></span><br><span class="line">&gt; `re.fullmatch`(pattern, string, flags=0) :            </span><br><span class="line"></span><br><span class="line">完整匹配，不完整则返回None</span><br><span class="line"></span><br><span class="line">&gt; `re.template`(pattern, flags=0) :                     </span><br><span class="line"></span><br><span class="line">没人知道是干嘛的，跟compile差不多</span><br><span class="line"></span><br><span class="line">&gt; `re.purge()` :                              </span><br><span class="line"></span><br><span class="line">清除正则表达式缓存</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">当你在程序中使用 re 模块，无论是先使用 compile 还是直接使用比如 findall 来使用正则表达式操作文本，re 模块都会将正则表达式先编译一下， 并且会将编译过后的正则表达式放到缓存中，这样下次使用同样的正则表达式的时候就不需要再次编译， 因为编译其实是很费时的，这样可以提升效率，而默认缓存的正则表达式的个数是 100, 当你需要频繁使用少量正则表达式的时候，缓存可以提升效率，而使用的正则表达式过多时，缓存带来的优势就不明显了</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">## 正则实例  🍀</span><br></pre></td></tr></table></figure></p></blockquote></blockquote></blockquote><p>str1 = “a1b atb aTb a3b a1b a-b a%b a!b a9b aYb a&amp;b”</p><p>#取出中间为特殊字符<br>print(re.findall(‘a[%!-&amp;]b’,str1))</p><p>#取出中间为数字的<br>print(re.findall(‘a[0-9]b’,str1))<br>print(re.findall(‘a[\d]b’,str1))</p><p>#取出中间为小数字母的<br>print(re.findall(‘a[a-z]b’,str1))</p><p>#取出中间为大写字母的的<br>print(re.findall(‘a[A-Z]b’,str1))</p><p>#取出字母或者数字的<br>print(re.findall(‘a[\w]b’,str1))</p><p>#取出中间不为数字的<br>print(re.findall(‘a[\D]b’,str1))<br>print(re.findall(‘a[^0-9]b’,str1))<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">连续匹配</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"># 导入模块</span><br><span class="line">&gt;&gt;&gt; import re</span><br><span class="line"># 获取字符串</span><br><span class="line">&gt;&gt;&gt; source =&apos;192.168.0.1 25/Oct/2012:14:46:34 &quot;GET /api HTTP/1.1&quot; 200 44 &quot;http://abc.com/search&quot; &quot;Mozilla/5.0&quot;&apos;</span><br><span class="line"># 设置匹配格式</span><br><span class="line">&gt;&gt;&gt; res = re.match(&apos;^(?P&lt;remote_ip&gt;[^ ]*) (?P&lt;date&gt;[^ ]*) &quot;(?P&lt;request&gt;[^&quot;]*)&quot; (?P&lt;status&gt;[^ ]*) (?P&lt;size&gt;[^ ]*) &quot;(?P&lt;referrer&gt;[^&quot;]*)&quot; &quot;(?P&lt;user_agent&gt;[^&quot;]*)&quot;&apos;,source)</span><br><span class="line"># 返回一个字典，groupdict中的key为组名，value为值</span><br><span class="line">&gt;&gt;&gt; source_dic = res.groupdict()</span><br><span class="line"># for循环打印</span><br><span class="line">&gt;&gt;&gt; for k in source_dic:</span><br><span class="line">        #打印key和vaule</span><br><span class="line">...     print(k+&quot;: &quot;+source_dic[k])</span><br><span class="line">...</span><br><span class="line"># 打印结果</span><br><span class="line">date: 25/Oct/2012:14:46:34</span><br><span class="line">remote_ip: 192.168.0.1</span><br><span class="line">referrer: http://abc.com/search</span><br><span class="line">status: 200</span><br><span class="line">user_agent: Mozilla/5.0</span><br><span class="line">size: 44</span><br><span class="line">request: GET /api HTTP/1.1</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-正则表达式&quot;&gt;&lt;a href=&quot;#Python之路-正则表达式&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 正则表达式&quot;&gt;&lt;/a&gt;Python之路 - 正则表达式&lt;/h1&gt;&lt;h2 id=&quot;正则介绍-🍀&quot;&gt;&lt;a href=&quot;#正则介绍-🍀&quot; class=&quot;headerlink&quot; title=&quot;正则介绍  🍀&quot;&gt;&lt;/a&gt;正则介绍  🍀&lt;/h2&gt;&lt;p&gt;正则表达式并不是python的一部分，而是在各个编程语言都有的一种用于处理字符串的强大工具。&lt;/p&gt;
&lt;p&gt;使用正则处理字符串在效率上可能不如str自带的方法，但是它的功能十分强大。python中的正则封装在re模块中。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Modules" scheme="https://jesse.top/categories/python/Modules/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>26.Python之路 - 面向对象之继承</title>
    <link href="https://jesse.top/2020/06/26/python/04-Object-Oriented/02-Python%E4%B9%8B%E8%B7%AF%20-%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%BB%A7%E6%89%BF/"/>
    <id>https://jesse.top/2020/06/26/python/04-Object-Oriented/02-Python之路 - 面向对象之继承/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:29:44.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-面向对象之继承"><a href="#Python之路-面向对象之继承" class="headerlink" title="Python之路 - 面向对象之继承"></a>Python之路 - 面向对象之继承</h1><h2 id="抽象与继承-🍀"><a href="#抽象与继承-🍀" class="headerlink" title="抽象与继承  🍀"></a>抽象与继承  🍀</h2><p><strong>抽象</strong> </p><blockquote><p>抽象是从众多的事物中抽取出共同的、本质性的特征，而舍弃其非本质的特征</p></blockquote><p>比如 🍎 , 🍌 , 🍇 ,  等 , 它们共同的特性就是水果 , 我们得出水果这个概念的过程就是一个抽象的过程 , 抽象能使复杂度降低 , 好让人们能够以宏观的角度来了解许多特定的事态</p><p>有抽象就会有具体 , 我们会用抽象的对象来表示一类事物 , 而用具体的对象表示某个事物 , 比如苹果 , 香蕉 , 葡萄都是具体的对象 , 水果则是抽象的对象</p><p><strong>继承</strong> </p><blockquote><p>继承是基于抽象的结果</p></blockquote><p>抽象可以让我们来以宏观的角度了解一类事物事物 , 并且这类事物都拥有该抽象中所有的特征 , 相当于继承了该抽象中的特征 , 这样我们就可以只将这类事物不同的特征放到具体中 , 而不需要再次关心共同特征 , 所以<strong><em>先有抽象后才能有继承</em></strong> </p><p>介绍抽象的概念时利用了水果来进行说明 , 为了更好的理解 , 继承就用动物为例子</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'-----------抽象出动物类-----------'</span></span><br><span class="line"><span class="comment"># 从狗和猫中抽取共同的特征,它们都能吃,喝,睡,玩</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">(object)</span>:</span>           </span><br><span class="line">    <span class="comment"># 吃                 </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span>        </span><br><span class="line">        <span class="keyword">pass</span>              </span><br><span class="line">    <span class="comment"># 喝                  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drink</span><span class="params">(self)</span>:</span>      </span><br><span class="line">        <span class="keyword">pass</span>              </span><br><span class="line">    <span class="comment"># 睡                  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(self)</span>:</span>      </span><br><span class="line">        <span class="keyword">pass</span>           </span><br><span class="line">    <span class="comment"># 玩</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="string">'------------具体动物类------------'</span></span><br><span class="line"><span class="comment"># 所有的类默认是继承了object类的,让'猫'类继承动物类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="comment"># 抓老鼠</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">catch_mouse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 让'狗'类继承动物类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="comment"># 跳墙</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump_wall</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>我们把🌰栗子中的Animal类叫做父类 , 基类或超类 , Cat和Dog类叫做子类或派生类 </p><blockquote><p>简单的继承方式就是在类名后面加入要继承的类</p></blockquote><p>使用继承可以减少我们代码重用 , 简化代码</p><h2 id="新式类与经典类-🍀"><a href="#新式类与经典类-🍀" class="headerlink" title="新式类与经典类  🍀"></a>新式类与经典类  🍀</h2><p>在说新式类与经典类之前 , 先说一说单继承和多继承</p><p><strong>单继承与多继承</strong> </p><blockquote><p>单继承就是只以一个类作为父类进行继承</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 继承基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subclass</span><span class="params">(Parent)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><blockquote><p>多继承就是同时以多个类做为基类进行继承</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义第一个基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent1</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 定义第二个基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent2</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 定义第三个基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent3</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 继承三个基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subclass1</span><span class="params">(Parent1,Parent2,Parent3)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>在多继承中我们需要考虑一个继承优先的问题 , 就像上面的例子 , 如果我们所定义的三个父类中 , 都拥有一个同样的方法那么Python解释器会怎么去继承父类的方法? 三个同名的方法明显只能选择其中一个进行继承 , 这就关系到经典类和新式类了</p><p><strong>经典类和新式类</strong> </p><p>经典的东西都是比较旧的 , so ,  在Python 2.x 中默认都是经典类 , 只有显示继承了object才是新式类 ; 而Python 3.x 中默认都是新式类 , 不必显示的继承object</p><blockquote><p>经典类与新式类在声明时的区别在于 , 新式类需要加上object关键字</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 2.x 环境下</span></span><br><span class="line"><span class="comment"># 经典类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 新式类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python 3.x 环境下</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><blockquote><p>经典类与新式类多继承顺序的区别在于 , 经典类会按照<code>深度优先</code> (纵向)的方式查找 , 新式类会按照<code>广度优先</code> (横向)的方式查找</p></blockquote><p><strong>实例环境Python2</strong> </p><p>经典类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 经典类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"This is from A"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span>  <span class="string">"This is from C"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B,C)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">obj = D()</span><br><span class="line">obj.display()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果: This is from A</span></span><br><span class="line"><span class="string">说明:经典类深度优先,我们通过实例调用display方法时,Python解释器会先找B类,如果B类中没有就会去B类的父类(即A类)中查找,如果在所有的父类中都没有找到需要的方法,才会开始继续找下一个继承的类(即C类)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>新式类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新式类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"This is from A"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span>  <span class="string">"This is from C"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B,C)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">obj = D()</span><br><span class="line">obj.display()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果: This is from C</span></span><br><span class="line"><span class="string">说明:新式类广度优先,Python解释器首先到B类进行查找,B类中没有就直接去C类中找,并不会去B类的父类(A类)中去查找,如果C类中没有才会再去B类的父类(A类)中查找,最后如果没找到就会报错</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="派生-🍀"><a href="#派生-🍀" class="headerlink" title="派生  🍀"></a>派生  🍀</h2><p>利用继承机制 , 新的类可以从已有的类中派生</p><p>子类继承了父类 , 父类派生了子类 , 继承是站在子类的角度 , 派生是站在父类的角度 , 我们在子类中可以添加新的属性或方法 . 但是要注意父类属性名与子类属性名相同 , 以及父类与子类中方法名的情况 , 说的有点绕了 , 通过实例进一步描述</p><p>属性名 , 方法名不发生冲突</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="comment"># 基类属性</span></span><br><span class="line">    country = <span class="string">'China'</span></span><br><span class="line">    <span class="comment"># 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="comment"># 工作方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am working ..."</span>)</span><br><span class="line"><span class="comment"># 派生一个子类,继承基类中的属性和方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="comment"># 子类属性</span></span><br><span class="line">    male = <span class="string">'man'</span></span><br><span class="line">    <span class="comment"># 新增睡觉方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am sleeping ..."</span>)</span><br><span class="line"><span class="comment"># 实例化子类</span></span><br><span class="line">man = Man(<span class="string">'Lyon'</span>, <span class="number">18</span>) </span><br><span class="line"><span class="comment"># 调用从基类继承过来的工作方法</span></span><br><span class="line">man.work()</span><br><span class="line"><span class="comment"># 访问从基类继承过来的国家属性</span></span><br><span class="line">print(man.country)</span><br><span class="line"><span class="comment"># 调用子类中的睡觉方法</span></span><br><span class="line">man.sleep()</span><br><span class="line"><span class="comment"># 访问子类中的male属性</span></span><br><span class="line">print(man.male) </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">I am working ...</span></span><br><span class="line"><span class="string">China</span></span><br><span class="line"><span class="string">I am sleepiing ...</span></span><br><span class="line"><span class="string">man</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>属性或方法冲突 , 会按照加载顺序进行覆盖 , 定义过程就已完成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python解释器开始执行,将Person类的名字以及类中包含的属性名方法名加载到Person类的命名空间</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    country = <span class="string">'China'</span></span><br><span class="line">    <span class="comment"># 注意构造方法也是方法,Python解释器加载时仅仅会将__init__这个名字加载到命名空间,并不会执行内部代码</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="comment"># 加载方法名</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am working ..."</span>)</span><br><span class="line"><span class="comment"># Python解释器将Man类的名字加载到Man的命名空间,随后由于Person类在这步之前已经完成加载,此时就会通过Person类名从Person的命名空间中取出属性和方法名加载到Man类的命名空间</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="comment"># 由于上一已完成Person类中的同名__init__的加载,此时会将其覆盖</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, male, country)</span>:</span></span><br><span class="line">        self.male = male</span><br><span class="line">        self.country = country</span><br><span class="line">    <span class="comment"># 同__init__,将同名work覆盖</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I don't like working ..."</span>)</span><br><span class="line">    <span class="comment"># 加载到Man类的命名空间</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am sleepiing ..."</span>)</span><br><span class="line"><span class="comment"># 实例化Man类</span></span><br><span class="line">man = Man(<span class="string">'male'</span>, <span class="string">'America'</span>)</span><br><span class="line"><span class="comment"># 此work为覆盖后的work即子类自己的work</span></span><br><span class="line">man.work()</span><br><span class="line"><span class="comment"># country为父类的类属性,在实例化时被实例属性覆盖</span></span><br><span class="line">print(man.country)</span><br><span class="line"><span class="comment"># 调用子类中的sleep方法</span></span><br><span class="line">man.sleep()</span><br><span class="line"><span class="comment"># 打印实例属性male</span></span><br><span class="line">print(man.male)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">I don't like working ...</span></span><br><span class="line"><span class="string">America</span></span><br><span class="line"><span class="string">I am sleepiing ...</span></span><br><span class="line"><span class="string">male</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>当然我们在使用时仅需注意一下几点:</p><ol><li>重名时 , 会以子类的方法或属性为主 , 因为父类的会被覆盖</li><li>构造方法里是实例属性 , 子类如果也有构造方法 , 以子类的构造方法为主</li></ol><p>通俗的讲 : <code>我有就用我的 , 没有就拿你的</code> </p><p>但是上述派生中有两个问题:</p><ol><li>当子类父类都有构造方法时 , 如果子类需要父类构造方法中的实例属性怎么办 ?</li><li>当子类父类都有同名方法时 , 如果子类需要用父类中的方法怎么办?</li></ol><p>这两个问题放到下节 <code>super</code>  中解决</p><h2 id="super-🍀"><a href="#super-🍀" class="headerlink" title="super  🍀"></a>super  🍀</h2><p>先解决上节中的两个问题 , 既然父类中的方法被覆盖掉了 , 那么我们不妨再加载一次父类中的方法 , 将子类中的再次覆盖</p><p>解决问题1 : 子类父类构造方法中实例属性集合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="comment"># 实例属性集合也还是要传参的,只是传入后各拿各的</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, male)</span>:</span></span><br><span class="line">        self.male = male</span><br><span class="line">        <span class="comment"># 通过类名.方法调用Person类中的__init__方法,即将__init__中的代码拿过来用了一遍</span></span><br><span class="line">        Person.__init__(self, name, age)</span><br><span class="line"><span class="comment"># 实例化Man类</span></span><br><span class="line">man = Man(<span class="string">'Lyon'</span>, <span class="number">18</span>, <span class="string">'male'</span>)</span><br><span class="line"><span class="comment"># 访问man中的name实例属性</span></span><br><span class="line">print(man.name)</span><br><span class="line"><span class="comment"># 访问man中的age实例属性</span></span><br><span class="line">print(man.age)</span><br><span class="line"><span class="comment"># 访问man中的male</span></span><br><span class="line">print(man.male)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">Lyon</span></span><br><span class="line"><span class="string">18</span></span><br><span class="line"><span class="string">male</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>解决问题2 : 使用父类中的重名方法</p><p>对于第二个问题明显不能利用问题1同样的方式了 , 因为调用就意味着执行 , 虽然我们可以以问题1中的方式执行父类的方法 , 但是子类的方法也还是会照常执行 , so , 我们得换个方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am working ..."</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I don't like working ..."</span>)</span><br><span class="line">man = Man()</span><br><span class="line"><span class="comment"># 将实例man作为self传入Person类中的work方法</span></span><br><span class="line"><span class="comment"># Person().work()</span></span><br><span class="line">Person.work(man)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果: I am working ...</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>两个问题解决了 , 但是我们发现通过这两种方式来解决会对后期修改造成非常大的麻烦 , 只要类名一变 , 那么我们就得一个个修改 , 开发中来个100个就够你改半小时了 … 所以就有了super</p><blockquote><p>super</p></blockquote><p>super只能用在新式类中 , 在经典类中则只能按照上面的方式进行处理了</p><p>截取官方文档中的一部分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相当于super(type, obj),first argument一般是self实例本身</span></span><br><span class="line">super() -&gt; same as super(__class__, &lt;first argument&gt;)</span><br><span class="line"><span class="comment"># 返回非绑定父类对象</span></span><br><span class="line">super(type) -&gt; unbound super object</span><br><span class="line"><span class="comment"># 返回父类的实例</span></span><br><span class="line">super(type, obj) -&gt; bound super object; requires isinstance(obj, type)</span><br><span class="line"><span class="comment"># 返回父类的实例</span></span><br><span class="line">super(type, type2) -&gt; bound super object; requires issubclass(type2, type)</span><br><span class="line"><span class="comment"># type参数为子类</span></span><br></pre></td></tr></table></figure><p>Python中一切皆对象 , 所以其实super是一个类 , 在我们使用super时事实上调用了super类的初始化函数 , 产生了一个super对象</p><p>首先用super的方式解决上面的问题吧</p><p>问题1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, male)</span>:</span></span><br><span class="line">        self.male = male</span><br><span class="line">        super().__init__(name, age)</span><br></pre></td></tr></table></figure><p>问题2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am working ..."</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I don't like working ..."</span>)</span><br><span class="line">man = Man()</span><br><span class="line"><span class="comment"># super的第一个参数是要找父类的那个类</span></span><br><span class="line">super(Man,man).work()</span><br></pre></td></tr></table></figure><p>但是在我们使用多继承时 , 这两者的区别就能显现出来了</p><p>使用__init__ </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"This is from A"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"This is from B"</span>)</span><br><span class="line">        A.__init__(self)</span><br><span class="line">        print(<span class="string">"This is from B"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"This is from C"</span>)</span><br><span class="line">        A.__init__(self)</span><br><span class="line">        print(<span class="string">"This is from C"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B,C)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"This is from D"</span>)</span><br><span class="line">        B.__init__(self)</span><br><span class="line">        C.__init__(self)</span><br><span class="line">        print(<span class="string">"This is from D"</span>)</span><br><span class="line">d = D()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">This is from D</span></span><br><span class="line"><span class="string">This is from B</span></span><br><span class="line"><span class="string">This is from A</span></span><br><span class="line"><span class="string">This is from B</span></span><br><span class="line"><span class="string">This is from C</span></span><br><span class="line"><span class="string">This is from A</span></span><br><span class="line"><span class="string">This is from C</span></span><br><span class="line"><span class="string">This is from D</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>使用super</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"This is from A"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"This is from B"</span>)</span><br><span class="line">        super().__init__()</span><br><span class="line">        print(<span class="string">"This is from B"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"This is from C"</span>)</span><br><span class="line">        super().__init__()</span><br><span class="line">        print(<span class="string">"This is from C"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B,C)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"This is from D"</span>)</span><br><span class="line">        super().__init__()</span><br><span class="line">        print(<span class="string">"This is from D"</span>)</span><br><span class="line">d = D()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">This is from D</span></span><br><span class="line"><span class="string">This is from B</span></span><br><span class="line"><span class="string">This is from C</span></span><br><span class="line"><span class="string">This is from A</span></span><br><span class="line"><span class="string">This is from C</span></span><br><span class="line"><span class="string">This is from B</span></span><br><span class="line"><span class="string">This is from D</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>用__init__ 和 super我们得到的结果是不一样的 , 因为super是一个类名 , super( ) 事实上调用了super类的初始化函数 , 产生了一个super对象 , 所以使用super可以避免父类被重复调用</p><p>PS : super的查找方式遵循MRO表中的顺序 , MRO表后续文章中在研究</p><h2 id="抽象类与接口-🍀"><a href="#抽象类与接口-🍀" class="headerlink" title="抽象类与接口  🍀"></a>抽象类与接口  🍀</h2><p>Python本身不提供抽象类和接口机制</p><p>抽象类</p><blockquote><p>在Java中抽象类的定义是这样的 : 由abstract 修饰的类叫抽象类 , 该类不能被实例化 , 并且仅支持单继承</p></blockquote><p>在Python中如果要实现抽象类 , 需要借助abc模块 .  ABC是Abstract Base Class的缩写</p><p>在abc模块中有一个用来生成抽象类的元类 <code>ABCMeta</code> </p><p>生成抽象类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入抽象元类和抽象方法</span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta,abstractmethod</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Abstract_class</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line">    <span class="comment"># 使用抽象方法进行约束</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="comment"># 父类可以简单实现,子类必须实现</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'hello func'</span>)</span><br></pre></td></tr></table></figure><p>抽象类提供了继承的概念 , 它的出发点就是为了继承 , 否则它没有存在的任何意义 , 所以说定义的抽象类一定是用来继承的</p><p>接口</p><blockquote><p>在Java中接口是一个抽象类型 , 是抽象方法的集合 , 接口通常以interface来声明 . 一个类通过继承接口的方式 , 从而来继承接口的抽象方法 , 达到约束的目的</p></blockquote><p>在Python中默认是没有的 , 所以我们如果要使用接口 , 有两种方法 , 第一种就是我们在抽象类的基础上进行定义 , 第二种则是借助第三方模块 <code>zope.interface</code> </p><p>这里我们只说第一中方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入抽象元类和抽象方法</span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta,abstractmethod</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Abstract_class</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line">    <span class="comment"># 使用抽象方法进行约束</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="comment"># 父类不能实现,子类必须实现</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>与抽象类中的例子比较 , 因为在Python中抽象类与接口类这两者区分并不清晰 , 我们在对于方法是否实现上 , 修改之后基本就实现了一个接口</p><blockquote><p>什么时候使用抽象类与接口</p></blockquote><ul><li>当几个子类的父类,有相同的功能需要被实现的时候,就使用<code>抽象类</code></li><li>当几个子类,有相同的功能,但是实现各不相同的时候,就使用<code>接口</code> (接口归一)</li></ul><p>接口归一实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"><span class="comment"># 定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Payment</span><span class="params">(metaclass = ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, money)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 继承接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Applepay</span><span class="params">(Payment)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, money)</span>:</span></span><br><span class="line">        print(<span class="string">'The payment method is Applepay , &#123;&#125;'</span>.format(money))</span><br><span class="line"><span class="comment"># 继承接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zhifubao</span><span class="params">(Payment)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, money)</span>:</span></span><br><span class="line">        print(<span class="string">'The payment method is Zhiwubaopay , &#123;&#125;'</span>.format(money))</span><br><span class="line"><span class="comment"># 继承接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wexin</span><span class="params">(Payment)</span>:</span></span><br><span class="line">    <span class="comment"># 没有接口中的pay方法,实例化时就报错</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fuqian</span><span class="params">(self, money)</span>:</span></span><br><span class="line">        print(<span class="string">'The payment method is Wexinpay , &#123;&#125;'</span>.format(money))</span><br><span class="line"><span class="comment"># 接口归一</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">payment</span><span class="params">(obj,money)</span>:</span></span><br><span class="line">    obj.pay(money)</span><br><span class="line"><span class="comment"># 实例化就报错,没有pay方法</span></span><br><span class="line"><span class="comment"># wexin = Wexin()</span></span><br><span class="line">zhifubao = Zhifubao()</span><br><span class="line">apple = Applepay()</span><br><span class="line">payment(zhifubao,<span class="number">100</span>)</span><br><span class="line">payment(apple,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p><strong><em>总结</em></strong> </p><ol><li>抽象类与接口都不能被实例化 (抽象方法约束)  , 所以必须被继承才能使用</li><li>抽象类中的方法能够被实现 , 接口中的方法不能被实现</li><li>抽象类中可以有构造方法 , 接口中不可有</li><li>抽象类最好不要用多继承 , 而接口类可以</li></ol><h2 id="isinstance-和-issubclass-🍀"><a href="#isinstance-和-issubclass-🍀" class="headerlink" title="isinstance 和 issubclass  🍀"></a>isinstance 和 issubclass  🍀</h2><p>isinstance(obj, cls) 检查obj是否是类cls的对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">obj = Foo()</span><br><span class="line">print(isinstance(obj, Foo))</span><br><span class="line">print(isinstance(obj, object))</span><br><span class="line">print(isinstance(obj, type))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">True  #obj是类Foo的对象</span></span><br><span class="line"><span class="string">True  #obj是object的对象,Foo类继承了object类</span></span><br><span class="line"><span class="string">False #object类是有type类的实例</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>issubclass(sub, super) 检查sub类是否是super类的派生类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">print(issubclass(B, B))</span><br><span class="line">print(issubclass(B, A))</span><br><span class="line">print(issubclass(B, object))</span><br><span class="line">print(issubclass(B, type))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">True  #B类是自己的派生类</span></span><br><span class="line"><span class="string">True  #B类是A类的派生类</span></span><br><span class="line"><span class="string">True  #B类是object类的派生类,因为A类继承了object类</span></span><br><span class="line"><span class="string">False #B类不是type类的派生类,type类实例化产生了object类</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-面向对象之继承&quot;&gt;&lt;a href=&quot;#Python之路-面向对象之继承&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 面向对象之继承&quot;&gt;&lt;/a&gt;Python之路 - 面向对象之继承&lt;/h1&gt;&lt;h2 id=&quot;抽象与继承-🍀&quot;&gt;&lt;a href=&quot;#抽象与继承-🍀&quot; class=&quot;headerlink&quot; title=&quot;抽象与继承  🍀&quot;&gt;&lt;/a&gt;抽象与继承  🍀&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;抽象&lt;/strong&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;抽象是从众多的事物中抽取出共同的、本质性的特征，而舍弃其非本质的特征&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如 🍎 , 🍌 , 🍇 ,  等 , 它们共同的特性就是水果 , 我们得出水果这个概念的过程就是一个抽象的过程 , 抽象能使复杂度降低 , 好让人们能够以宏观的角度来了解许多特定的事态&lt;/p&gt;
&lt;p&gt;有抽象就会有具体 , 我们会用抽象的对象来表示一类事物 , 而用具体的对象表示某个事物 , 比如苹果 , 香蕉 , 葡萄都是具体的对象 , 水果则是抽象的对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;继承&lt;/strong&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;继承是基于抽象的结果&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;抽象可以让我们来以宏观的角度了解一类事物事物 , 并且这类事物都拥有该抽象中所有的特征 , 相当于继承了该抽象中的特征 , 这样我们就可以只将这类事物不同的特征放到具体中 , 而不需要再次关心共同特征 , 所以&lt;strong&gt;&lt;em&gt;先有抽象后才能有继承&lt;/em&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;介绍抽象的概念时利用了水果来进行说明 , 为了更好的理解 , 继承就用动物为例子&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Object-Oriented" scheme="https://jesse.top/categories/python/Object-Oriented/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>45.Python之路 - 并发编程之IO多路复用</title>
    <link href="https://jesse.top/2020/06/26/python/06-Concurrent/06-Python%E4%B9%8B%E8%B7%AF%20-%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8BIO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/"/>
    <id>https://jesse.top/2020/06/26/python/06-Concurrent/06-Python之路 - 并发编程之IO多路复用/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:40:55.190Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-并发编程之IO多路复用"><a href="#Python之路-并发编程之IO多路复用" class="headerlink" title="Python之路 - 并发编程之IO多路复用"></a>Python之路 - 并发编程之IO多路复用</h1><h2 id="前言-🍀"><a href="#前言-🍀" class="headerlink" title="前言  🍀"></a>前言  🍀</h2><p>在网络编程中 , 如果服务端需要面临同时接收上千甚至上万次的客户端请求 , 利用 “进程池” 或 “线程池” 或许可以缓解部分压力 , 但是并不是一个好的选择 , 因为超过数量还是得等 ; 又或者线程一旦进行堵塞 ; 以及任务之间的高度独立 , 并不需要互相通信或者等待时 , 我们就需要用到I/O多路复用(IO Multiplexing) 了 , 又叫做事件驱动IO (Event driven IO)</p><h2 id="I-O多路复用-🍀"><a href="#I-O多路复用-🍀" class="headerlink" title="I/O多路复用  🍀"></a>I/O多路复用  🍀</h2><blockquote><p>I/O多路复用是指单个线程中 , 通过记录跟踪每个I/O流(sock)的状态 , 来同时管理多个I/O流</p></blockquote><p>在I/O多路复用中只要一遇到IO就注册一个事件 , 然后主程序就可以继续干其他的事情了 , 直到IO处理完毕 , 继续恢复之前中断的任务 , 也就是说<strong>一个线程可以同时处理多个请求</strong> </p><p>举🌰</p><p>在UI编程中 , 常常要对鼠标点击进行响应 , 还要同时对键盘敲击也进行响应 </p><p><strong>多进程多线程方式 : </strong> </p><p>创建一个进程 , 进程中由两个线程 , 一个循环检测鼠标点击 , 一个循环检测键盘敲击 , 一旦检测到有情况就再开一个线程去处理 , 然后一直开下去……基本上是由创建进程/线程 , 维护进程/线程来解决的 , 这样对于CPU的资源是很浪费的</p><p><strong>IO多路复用(事件驱动) : </strong> </p><p>创建一个事件(消息)队列 , 鼠标点击就往队列中增加一个鼠标点击事件 , 键盘敲击就往队列中增加一个键盘敲击事件 , 创建一个线程(IO线程)负责不断从队列中取出事件 , 根据不同的事件 , 调用不同的函数 , 如onClick() , onKeyDown()等 , 即一个线程解决了所有事件的问题 , 这就是复用</p><p><strong>比较 :</strong>  与多进程多线程技术相比 , I/O多路复用最大的优势是系统开销小 , 系统不必创建进程/线程 , 也不必维护这些进程/线程 , 从而大大减小了系统的开销</p><p>目前常见支持I/O多路复用的系统调用select , poll , epoll ,I/O多路复用就是通过一种机制 , 一个进程可以监视多个描述符 , 一旦某个描述符就绪(一般是读就绪或者写就绪) , 能够通知程序进行相应的读写操作</p><p>而I/O多路复用的具体实现就是 , select , poll , epoll</p><hr><a id="more"></a><h2 id="Select-🍀"><a href="#Select-🍀" class="headerlink" title="Select  🍀"></a>Select  🍀</h2><p>select 监视的文件描述符(FD)分3类 , 分别是writefds、readfds和exceptfds , 程序启动后select函数会阻塞 , 直到有描述符就绪(有数据 可读、可写、或者有except) , 或者超时(timeout指定等待时间 , 如果立即返回设为null即可) , 函数返回 , 当select函数返回后 , 可以通过遍历fdset , 来找到就绪的描述符</p><p>I/O多路复用概念被提出来后 , select是第一个实现的 , select虽然实现了I/O多路复用 , 但是暴露出了很多问题 : </p><ul><li><p>select 会修改传入的参数数组 , 这对于一个需要调用很多次的函数 , 是非常不友好的</p></li><li><p>select 如果任何一个sokc(I/O stream) 出现了数据 , select仅仅会返回 , 但是并不会告诉你是哪个sock上有数据 , 于是你只能自己一个一个的找 , 十几个sock还好 , 但是数量一旦多了 , 这无谓的开销可就大了 </p></li><li><p>select 只能监视1024个链接 </p></li><li><p>select对socket进行扫描时是线性扫描 , 即采用轮询的方法 , 效率较低</p></li><li><p>select 不是线程安全的 , 如果你把一个sock(I/O stream) 加入到select , 然后突然另外一个线程发现这个sock不用 , 需要收回 , 那么对不起 , select不支持 , 并且如果你想关掉这个sock , 那么select的标准行为是不可预测的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">If a file descriptor being monitored by select() is closed in another thread , the result is unspecified</span><br></pre></td></tr></table></figure><p>Python实现select模型代码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> select</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">sk1 = socket.socket()</span><br><span class="line">sk1.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8002</span>, ))</span><br><span class="line">sk1.listen()</span><br><span class="line">demo_li = [sk1]</span><br><span class="line">outputs = []</span><br><span class="line">message_dict = &#123;&#125;</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    r_list, w_list, e_list = select.select(sk1, outputs, [], <span class="number">1</span>)</span><br><span class="line">    print(len(demo_li),r_list)</span><br><span class="line">    <span class="keyword">for</span> sk1_or_conn <span class="keyword">in</span> r_list:</span><br><span class="line">        <span class="keyword">if</span> sk1_or_conn == sk1:</span><br><span class="line">            conn, address = sk1_or_conn.accept()</span><br><span class="line">            demo_li.append(conn)</span><br><span class="line">            message_dict[conn] = []</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                data_bytes = sk1_or_conn.recv(<span class="number">1024</span>)</span><br><span class="line">                <span class="comment"># data_str = str(data_bytes, encoding="utf-8")</span></span><br><span class="line">                <span class="comment"># print(data_str)</span></span><br><span class="line">                <span class="comment"># sk1_or_conn.sendall(bytes(data_str+"good", encoding="utf-8"))</span></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                demo_li.remove(sk1_or_conn)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                data_str = str(data_bytes, encoding=<span class="string">"utf-8"</span>)</span><br><span class="line">                message_dict[sk1_or_conn].append(data_str)</span><br><span class="line">                outputs.append(sk1_or_conn)</span><br><span class="line">    <span class="keyword">for</span> conn <span class="keyword">in</span> w_list:</span><br><span class="line">        recv_str = message_dict[conn][<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">del</span> message_dict[conn][<span class="number">0</span>]</span><br><span class="line">        conn.sendall(bytes(recv_str+<span class="string">"Good"</span>, encoding=<span class="string">"utf-8"</span>))</span><br><span class="line">        outputs.remove(conn)</span><br></pre></td></tr></table></figure></li></ul><h2 id="Poll-🍀"><a href="#Poll-🍀" class="headerlink" title="Poll  🍀"></a>Poll  🍀</h2><p>poll本质上和select没有区别 , 它将用户传入的数组拷贝到内核空间 , 然后查询每个fd对应的设备状态 , 如果设备就绪则在设备等待队列中加入一项并继续遍历 , 如果遍历完所有fd后没有发现就绪设备 , 则挂起当前进程 , 直到设备就绪或者主动超时 , 被唤醒后它又要再次遍历fd , 这个过程经历了多次无谓的遍历</p><p>它没有最大连接数的限制 , 原因是它是基于链表来存储的 , 但是同样有缺点 :</p><ul><li>大量的fd的数组被整体复制于用户态和内核地址空间之间 , 而不管这样的复制是不是有意义</li><li>poll还有一个特点是”水平触发” , 如果报告了fd后 , 没有被处理 , 那么下次poll时会再次报告该fd</li><li>同样不是线程安全的</li></ul><h2 id="Epoll-🍀"><a href="#Epoll-🍀" class="headerlink" title="Epoll  🍀"></a>Epoll  🍀</h2><p>poll是在2.6内核中提出的 , 是之前的select和poll的增强版本 , 相对于select和poll来说 , epoll更加灵活 , 没有描述符限制 ; epoll使用一个文件描述符管理多个描述符 , 将用户关系的文件描述符的事件存放到内核的一个事件表中 , 这样在用户空间和内核空间的copy只需一次</p><p><strong>基本原理 : </strong> </p><p>epoll支持水平触发和边缘触发 , 最大的特点在于边缘触发 , 它只告诉进程哪些fd刚刚变为就绪态 , 并且只会通知一次 ; 还有一个特点是 , epoll使用”事件”的就绪通知方式 , 通过epoll_ctl注册fd , 一旦该fd就绪 , 内核就会采用类似callback的回调机制来激活该fd , epoll_wait便可以收到通知</p><p><strong>epoll的优点 : </strong></p><ul><li>没有最大并发连接的限制 , 能打开的FD的上限远大于1024(1G的内存上能监听约10万个端口)</li><li>效率提升 , 不是轮询的方式 , 不会随着FD数目的增加效率下降 , 只有活跃可用的FD才会调用callback函数 ; 即Epoll最大的优点就在于它只管你”活跃”的连接 , 而跟连接总数无关 , 因此在实际的网络环境中 , Epoll的效率就会远远高于select和poll</li><li>内存拷贝 , 利用mmap()文件映射内存加速与内核空间的消息传递 ; 即epoll使用mmap减少复制开销</li><li>是线程安全的</li></ul><p>epoll对文件描述符的操作有两种模式 : LT(level trigger)和ET(edge trigger) , LT模式是默认模式 , LT模式与ET模式的区别如下 : </p><p><strong>LT模式  : </strong>当epoll_wait检测到描述符事件发生并将此事件通知应用程序 , 应用程序可以不立即处理该事件 , 下次调用epoll_wait时 , 会再次响应应用程序并通知此事件</p><p><strong>ET模式 : </strong>当epoll_wait检测到描述符事件发生并将此事件通知应用程序 , 应用程序必须立即处理该事件 , 如果不处理 , 下次调用epoll_wait时 , 不会再次响应应用程序并通知此事件</p><p><strong>LT模式</strong> LT(level triggered)是缺省的工作方式 , 并且同时支持block和no-block socket , 在这种做法中 , 内核告诉你一个文件描述符是否就绪了 , 然后你可以对这个就绪的fd进行IO操作 , 如果你不作任何操作 , 内核还是会继续通知你的</p><p><strong>ET模式</strong> ET(edge-triggered)是高速工作方式 , 只支持no-block socket , 在这种模式下 , 当描述符从未就绪变为就绪时 , 内核通过epoll告诉你 , 然后它会假设你知道文件描述符已经就绪 , 并且不会再为那个文件描述符发送更多的就绪通知 , 直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如 , 你在发送 , 接收或者接收请求 , 或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误) , 但是请注意 , 如果一直不对这个fd作IO操作(从而导致它再次变成未就绪) , 内核不会发送更多的通知(only once) , ET模式在很大程度上减少了epoll事件被重复触发的次数 , 因此效率要比LT模式高 , epoll工作在ET模式的时候 , 必须使用非阻塞套接口 , 以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死</p><p>在select/poll中 , 进程只有在调用一定的方法后 , 内核才对所有监视的文件描述符进行扫描 , 而epoll事先通过epoll_ctl()来注册一个文件描述符 , 一旦基于某个文件描述符就绪时 , 内核会采用类似callback的回调机制 , 迅速激活这个文件描述符 , 当进程调用epoll_wait()时便得到通知 (此处去掉了遍历文件描述符 , 而是通过监听回调的的机制 , 这正是epoll的魅力所在)</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-并发编程之IO多路复用&quot;&gt;&lt;a href=&quot;#Python之路-并发编程之IO多路复用&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 并发编程之IO多路复用&quot;&gt;&lt;/a&gt;Python之路 - 并发编程之IO多路复用&lt;/h1&gt;&lt;h2 id=&quot;前言-🍀&quot;&gt;&lt;a href=&quot;#前言-🍀&quot; class=&quot;headerlink&quot; title=&quot;前言  🍀&quot;&gt;&lt;/a&gt;前言  🍀&lt;/h2&gt;&lt;p&gt;在网络编程中 , 如果服务端需要面临同时接收上千甚至上万次的客户端请求 , 利用 “进程池” 或 “线程池” 或许可以缓解部分压力 , 但是并不是一个好的选择 , 因为超过数量还是得等 ; 又或者线程一旦进行堵塞 ; 以及任务之间的高度独立 , 并不需要互相通信或者等待时 , 我们就需要用到I/O多路复用(IO Multiplexing) 了 , 又叫做事件驱动IO (Event driven IO)&lt;/p&gt;
&lt;h2 id=&quot;I-O多路复用-🍀&quot;&gt;&lt;a href=&quot;#I-O多路复用-🍀&quot; class=&quot;headerlink&quot; title=&quot;I/O多路复用  🍀&quot;&gt;&lt;/a&gt;I/O多路复用  🍀&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;I/O多路复用是指单个线程中 , 通过记录跟踪每个I/O流(sock)的状态 , 来同时管理多个I/O流&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在I/O多路复用中只要一遇到IO就注册一个事件 , 然后主程序就可以继续干其他的事情了 , 直到IO处理完毕 , 继续恢复之前中断的任务 , 也就是说&lt;strong&gt;一个线程可以同时处理多个请求&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;举🌰&lt;/p&gt;
&lt;p&gt;在UI编程中 , 常常要对鼠标点击进行响应 , 还要同时对键盘敲击也进行响应 &lt;/p&gt;
&lt;p&gt;&lt;strong&gt;多进程多线程方式 : &lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;创建一个进程 , 进程中由两个线程 , 一个循环检测鼠标点击 , 一个循环检测键盘敲击 , 一旦检测到有情况就再开一个线程去处理 , 然后一直开下去……基本上是由创建进程/线程 , 维护进程/线程来解决的 , 这样对于CPU的资源是很浪费的&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;IO多路复用(事件驱动) : &lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;创建一个事件(消息)队列 , 鼠标点击就往队列中增加一个鼠标点击事件 , 键盘敲击就往队列中增加一个键盘敲击事件 , 创建一个线程(IO线程)负责不断从队列中取出事件 , 根据不同的事件 , 调用不同的函数 , 如onClick() , onKeyDown()等 , 即一个线程解决了所有事件的问题 , 这就是复用&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;比较 :&lt;/strong&gt;  与多进程多线程技术相比 , I/O多路复用最大的优势是系统开销小 , 系统不必创建进程/线程 , 也不必维护这些进程/线程 , 从而大大减小了系统的开销&lt;/p&gt;
&lt;p&gt;目前常见支持I/O多路复用的系统调用select , poll , epoll ,I/O多路复用就是通过一种机制 , 一个进程可以监视多个描述符 , 一旦某个描述符就绪(一般是读就绪或者写就绪) , 能够通知程序进行相应的读写操作&lt;/p&gt;
&lt;p&gt;而I/O多路复用的具体实现就是 , select , poll , epoll&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Concurrent" scheme="https://jesse.top/categories/python/Concurrent/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>21.Python之路 - 序列化</title>
    <link href="https://jesse.top/2020/06/26/python/03-Modules/06-Python%E4%B9%8B%E8%B7%AF%20-%20%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://jesse.top/2020/06/26/python/03-Modules/06-Python之路 - 序列化/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:04:42.183Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-序列化"><a href="#Python之路-序列化" class="headerlink" title="Python之路 - 序列化"></a>Python之路 - 序列化</h1><h2 id="介绍-🍀"><a href="#介绍-🍀" class="headerlink" title="介绍  🍀"></a>介绍  🍀</h2><p>先说个例子 , 当我们将一个字典或者列表再或者变量存入磁盘中 , 而存入磁盘后原本数据类型就得不到保持了 . 这个时候我们就得用序列化和反序列化了</p><p>序列化是将对象进行存储时保持当时对象的状态 , 实现其生命周期的延长 </p><p>反序列化则是将存储的对象读取出来并转成原本的数据类型</p><p>序列化的目的</p><ol><li>以某种存储形式使自定义对象持久化</li><li>将对象从一个地方传递到另一个地方</li><li>使程序更具维护性</li></ol><a id="more"></a><p><strong><em>此时应该想到 eval :</em></strong>那么问题来了 , 序列化所达到的功能我用eval()也能达到啊 , eval()直接就可以把字符串转换成python解释器能解释的代码 , 即可以直接将字符串中的字典 , 列表都转成原来的数据类型 . 但是要注意的是 , eval本来就是将字符串内容转换成python可以执行的代码 , 并执行它 , 这样看来eval就不安全了 , 因为如果在我能读取的内容中含有一些其他的 ‘ 危险代码 ‘ 如 ‘ 删除文件 ‘ , 于是造成了毁灭性的打击 , 所以eval是存在风险的 </p><p>Python为我们提供了三个序列化工具 , 分别是 json , pickle , shelve</p><h2 id="json-🍀"><a href="#json-🍀" class="headerlink" title="json  🍀"></a>json  🍀</h2><p>用于字符串和python数据类型之间进行转换 , 因为json表示出来就是一个字符串</p><p>json模块提供了四个方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>dump</td><td>接收一个文件句柄 , 将原数据类型转换成字符串写入文件</td></tr><tr><td>load</td><td>接收一个文件句柄 , 将文件中的字符串转换成原数据类型返回</td></tr><tr><td>dumps</td><td>接收一个数据类型 , 将其转换成字符串</td></tr><tr><td>loads</td><td>接收一个字符串 , 将其转换成原数据类型</td></tr></tbody></table><p>dump 和 load 实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入json模块</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># 创建一个文件句柄</span></span><br><span class="line">f = open(<span class="string">'json_file'</span>,<span class="string">'w'</span>)</span><br><span class="line"><span class="comment"># 创建一个字典</span></span><br><span class="line">dic = &#123;<span class="string">'k1'</span>:<span class="string">'v1'</span>,<span class="string">'k2'</span>:<span class="string">'v2'</span>&#125;</span><br><span class="line"><span class="comment"># 将字典转换成字符串写入文件</span></span><br><span class="line">json.dump(dic,f)</span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">f.close()</span><br><span class="line"><span class="comment"># 创建一个文件句柄</span></span><br><span class="line">f = open(<span class="string">'json_file'</span>)</span><br><span class="line"><span class="comment"># 将文件中的字符串读出并转换成原数据类型</span></span><br><span class="line">dic2 = json.load(f)</span><br><span class="line"><span class="comment"># 关闭文件句柄</span></span><br><span class="line">f.close()</span><br><span class="line"><span class="comment"># 打印类型和结果</span></span><br><span class="line">print(type(dic2),dic2)</span><br><span class="line"><span class="comment"># &lt;class 'dict'&gt; &#123;'k1': 'v1', 'k2': 'v2'&#125;</span></span><br></pre></td></tr></table></figure><p>dumps 和 loads 实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入json模块</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># 创建一个新列表</span></span><br><span class="line">lst = [<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>]</span><br><span class="line"><span class="comment"># 将列表转换成字符串,用j_d来接收返回值</span></span><br><span class="line">j_d = json.dumps(lst)</span><br><span class="line"><span class="comment"># 将字符串转换成原数据类型,用j_s来接收返回值</span></span><br><span class="line">j_s = json.loads(j_d)</span><br><span class="line"><span class="comment"># 打印j_d的值以及类型</span></span><br><span class="line">print(j_d,type(j_d))</span><br><span class="line"><span class="comment"># ["1", "2", "3", "4"] &lt;class 'str'&gt;</span></span><br><span class="line"><span class="comment"># 打印j_s的值以及类型</span></span><br><span class="line">print(j_s,type(j_s))</span><br><span class="line"><span class="comment"># ['1', '2', '3', '4'] &lt;class 'list'&gt;</span></span><br></pre></td></tr></table></figure><p>loads的特殊情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入json模块</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># 创建一个字符串,内部为一个字典</span></span><br><span class="line">dic_s = <span class="string">"&#123;'k1':'v1','k2':'v2','k3':3&#125;"</span></span><br><span class="line"><span class="comment"># 将字符串转换成字典</span></span><br><span class="line">json.loads(dic_s)</span><br><span class="line"><span class="comment"># 解释器出现报错</span></span><br><span class="line"><span class="comment"># json.decoder.JSONDecodeError: Expecting property name enclosed in double quotes: line 1 column 2 (char 1)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">报错原因,用json的loads功能时,字符串类型的字典中的字符串必须由 "" 表示</span></span><br><span class="line"><span class="string">即上面的dic_s应该改为 '&#123;"k1":"v1","k2":"v2","k3":3&#125;'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">结论:用json的loads功能时,字符串类型的字典中的字符串必须由 "" 表示</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>PS : json可用于不同语言之间的数据交换</p><h2 id="pickle-🍀"><a href="#pickle-🍀" class="headerlink" title="pickle   🍀"></a>pickle   🍀</h2><p>用于python特有的类型和python的数据类型间进行转换</p><p>pickle模块也提供了四个方法 , 与json一样 dumps , dump , loads , load</p><p>由于pickle是对于python特有的类型 , 所以 load 和 loads方法不仅支持字典 , 列表  , 它还能把python中任意的数据类型进行序列化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">-------dumps和loads--------</span><br><span class="line"><span class="comment"># 导入pickle模块</span></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="comment"># 创建一个字典</span></span><br><span class="line">dic = &#123;<span class="string">'k1'</span>:<span class="string">'v1'</span>,<span class="string">'k2'</span>:<span class="string">'v2'</span>&#125;</span><br><span class="line"><span class="comment"># 将字典转换成二进制内容</span></span><br><span class="line">p_d = pickle.dumps(dic)</span><br><span class="line"><span class="comment"># 将二进制内容转换成字典</span></span><br><span class="line">p_l = pickle.loads(p_d)</span><br><span class="line"><span class="comment"># 打印p_d</span></span><br><span class="line">print(p_d)  </span><br><span class="line"><span class="comment"># b'\x80\x03&#125;q\x00(X\x02\x00\x00\x00k2q\x01X\x02\x00\x00\x00v2q\x02X\x02\x00\x00\x00k1q\x03X\x02\x00\x00\x00v1q\x04u.'</span></span><br><span class="line"><span class="comment"># 打印p_d的类型</span></span><br><span class="line">print(type(p_d))</span><br><span class="line"><span class="comment"># &lt;class 'bytes'&gt;</span></span><br><span class="line"><span class="comment"># 打印p_l</span></span><br><span class="line">print(p_l)</span><br><span class="line"><span class="comment"># &#123;'k2': 'v2', 'k1': 'v1'&#125;</span></span><br><span class="line"><span class="comment"># 打印p_l的类型</span></span><br><span class="line">print(type(p_l))</span><br><span class="line"><span class="comment"># &lt;class 'dict'&gt;</span></span><br><span class="line">---------dump 和 load---------</span><br><span class="line"><span class="comment"># 创建一个文件句柄</span></span><br><span class="line">f = open(<span class="string">'pickle_file'</span>,<span class="string">'wb'</span>)</span><br><span class="line"><span class="comment"># 写入内容</span></span><br><span class="line">pickle.dump(<span class="string">'lyon'</span>,f)</span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">f.close()</span><br><span class="line"><span class="comment"># 创建一个文件句柄</span></span><br><span class="line">f = open(<span class="string">'pickle_file'</span>,<span class="string">'rb'</span>)</span><br><span class="line"><span class="comment"># 读出内容</span></span><br><span class="line">p_f = pickle.load(f)</span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">f.close()</span><br><span class="line"><span class="comment"># 打印</span></span><br><span class="line">print(p_f)</span><br><span class="line"><span class="comment"># lyon</span></span><br></pre></td></tr></table></figure><p><strong>但是pickle仅仅只能对python中的数据进行序列化 , 反序列化时其他语言就无法读懂了这是什么了</strong> , 所以我们一般用推荐使用json</p><h2 id="shelve-🍀"><a href="#shelve-🍀" class="headerlink" title="shelve  🍀"></a>shelve  🍀</h2><p>shelve也是python提供给我们的序列化工具 , 比pickle用起来简单一些</p><p>shelve只提供给我们一个open方法 , 是用key来访问的 ,  使用起来和字典类似</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入shelve模块</span></span><br><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line"><span class="comment"># shelve提供open方法</span></span><br><span class="line">f = shelve.open(<span class="string">'shelve_file'</span>)</span><br><span class="line"><span class="comment"># 直接对文件句柄进行操作,就可以写入文件中</span></span><br><span class="line">f[<span class="string">'key'</span>] = &#123;<span class="string">'int'</span>:<span class="number">10</span>, <span class="string">'float'</span>:<span class="number">9.5</span>, <span class="string">'string'</span>:<span class="string">'Sample data'</span>&#125;  </span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">f.close()</span><br><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line">f1 = shelve.open(<span class="string">'shelve_file'</span>)</span><br><span class="line"><span class="comment"># 直接用key取值,key不存在就报错</span></span><br><span class="line">existing = f1[<span class="string">'key'</span>]</span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">f1.close()</span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line">print(existing)</span><br><span class="line"><span class="comment"># &#123;'float': 9.5, 'int': 10, 'string': 'Sample data'&#125;</span></span><br></pre></td></tr></table></figure><p>shelve不支持多个应用同时往一个数据库进行操作 , 所以当我们知道我们的应用如果只进行操作 , 我们可以设置shelve.open() 方法的参数来进行</p><p> shelve.open(filename, flag=’c’, protocol=None, writeback=False)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line"><span class="comment"># flag参数为设置操作模式,r 设置只读模式</span></span><br><span class="line">f = shelve.open(<span class="string">'shelve_file'</span>, flag=<span class="string">'r'</span>)</span><br><span class="line">existing = f[<span class="string">'key'</span>]</span><br><span class="line">f.close()</span><br><span class="line">print(existing)</span><br></pre></td></tr></table></figure><p><code>writeback</code>参数 , 可以减少我们出错的概率 , 并且让对象的持久化对用户更加的透明了 ; 但这种方式并不是所有的情况下都需要 , 首先 , 使用writeback以后 , shelf在open()的时候会增加额外的内存消耗 , 并且当数据库在close()的时候会将缓存中的每一个对象都写入到数据库 , 这也会带来额外的等待时间 , 因为shelve没有办法知道缓存中哪些对象修改了 , 哪些对象没有修改 , 因此所有的对象都会被写入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line">f1 = shelve.open(<span class="string">'shelve_file'</span>)</span><br><span class="line">print(f1[<span class="string">'key'</span>])</span><br><span class="line">f1[<span class="string">'key'</span>][<span class="string">'new_value'</span>] = <span class="string">'this was not here before'</span></span><br><span class="line">f1.close()</span><br><span class="line"><span class="comment"># 设置writeback</span></span><br><span class="line">f2 = shelve.open(<span class="string">'shelve_file'</span>, writeback=<span class="keyword">True</span>)</span><br><span class="line">print(f2[<span class="string">'key'</span>])</span><br><span class="line">f2[<span class="string">'key'</span>][<span class="string">'new_value'</span>] = <span class="string">'this was not here before'</span></span><br><span class="line">f2.close()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-序列化&quot;&gt;&lt;a href=&quot;#Python之路-序列化&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 序列化&quot;&gt;&lt;/a&gt;Python之路 - 序列化&lt;/h1&gt;&lt;h2 id=&quot;介绍-🍀&quot;&gt;&lt;a href=&quot;#介绍-🍀&quot; class=&quot;headerlink&quot; title=&quot;介绍  🍀&quot;&gt;&lt;/a&gt;介绍  🍀&lt;/h2&gt;&lt;p&gt;先说个例子 , 当我们将一个字典或者列表再或者变量存入磁盘中 , 而存入磁盘后原本数据类型就得不到保持了 . 这个时候我们就得用序列化和反序列化了&lt;/p&gt;
&lt;p&gt;序列化是将对象进行存储时保持当时对象的状态 , 实现其生命周期的延长 &lt;/p&gt;
&lt;p&gt;反序列化则是将存储的对象读取出来并转成原本的数据类型&lt;/p&gt;
&lt;p&gt;序列化的目的&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;以某种存储形式使自定义对象持久化&lt;/li&gt;
&lt;li&gt;将对象从一个地方传递到另一个地方&lt;/li&gt;
&lt;li&gt;使程序更具维护性&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Modules" scheme="https://jesse.top/categories/python/Modules/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>46.Python之路 - 实现线程池</title>
    <link href="https://jesse.top/2020/06/26/python/06-Concurrent/Python%E4%B9%8B%E8%B7%AF%20-%20%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://jesse.top/2020/06/26/python/06-Concurrent/Python之路 - 实现线程池/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:40:53.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-实现线程池-🍀"><a href="#Python之路-实现线程池-🍀" class="headerlink" title="Python之路 - 实现线程池  🍀"></a>Python之路 - 实现线程池  🍀</h1><h2 id="方式一-🍀"><a href="#方式一-🍀" class="headerlink" title="方式一  🍀"></a>方式一  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max_num=<span class="number">20</span>)</span>:</span></span><br><span class="line">        self.queue = Queue.Queue(max_num)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(max_num):</span><br><span class="line">            self.queue.put(threading.Thread)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_thread</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.queue.get()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_thread</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.queue.put(threading.Thread)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">使用:</span></span><br><span class="line"><span class="string">pool = ThreadPool(10)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def func(arg, p):</span></span><br><span class="line"><span class="string">    import time</span></span><br><span class="line"><span class="string">    time.sleep(2)</span></span><br><span class="line"><span class="string">    p.add_thread()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">for i in range(30):</span></span><br><span class="line"><span class="string">    thread = pool.get_thread()</span></span><br><span class="line"><span class="string">    t = thread(target=func, args=(i, pool))</span></span><br><span class="line"><span class="string">    t.start()</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方式二-🍀"><a href="#方式二-🍀" class="headerlink" title="方式二  🍀"></a>方式二  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">StopEvent = object()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max_num, max_task_num = None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> max_task_num:</span><br><span class="line">            self.q = queue.Queue(max_task_num)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.q = queue.Queue()</span><br><span class="line">        self.max_num = max_num</span><br><span class="line">        self.cancel = <span class="keyword">False</span></span><br><span class="line">        self.terminal = <span class="keyword">False</span></span><br><span class="line">        self.generate_list = []</span><br><span class="line">        self.free_list = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, func, args, callback=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        线程池执行一个任务</span></span><br><span class="line"><span class="string">        :param func: 任务函数</span></span><br><span class="line"><span class="string">        :param args: 任务函数所需参数</span></span><br><span class="line"><span class="string">        :param callback: 任务执行失败或成功后执行的回调函数，回调函数有两个参数1、任务函数执行状态；2、任务函数返回值（默认为None，即：不执行回调函数）</span></span><br><span class="line"><span class="string">        :return: 如果线程池已经终止，则返回True否则None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.cancel:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> len(self.free_list) == <span class="number">0</span> <span class="keyword">and</span> len(self.generate_list) &lt; self.max_num:</span><br><span class="line">            self.generate_thread()</span><br><span class="line">        w = (func, args, callback,)</span><br><span class="line">        self.q.put(w)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_thread</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        创建一个线程</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        t = threading.Thread(target=self.call)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        循环去获取任务函数并执行任务函数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        current_thread = threading.currentThread()</span><br><span class="line">        self.generate_list.append(current_thread)</span><br><span class="line"></span><br><span class="line">        event = self.q.get()</span><br><span class="line">        <span class="keyword">while</span> event != StopEvent:</span><br><span class="line"></span><br><span class="line">            func, arguments, callback = event</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                result = func(*arguments)</span><br><span class="line">                success = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                success = <span class="keyword">False</span></span><br><span class="line">                result = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> callback <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    callback(success, result)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">with</span> self.worker_state(self.free_list, current_thread):</span><br><span class="line">                <span class="keyword">if</span> self.terminal:</span><br><span class="line">                    event = StopEvent</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    event = self.q.get()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">            self.generate_list.remove(current_thread)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        执行完所有的任务后，所有线程停止</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.cancel = <span class="keyword">True</span></span><br><span class="line">        full_size = len(self.generate_list)</span><br><span class="line">        <span class="keyword">while</span> full_size:</span><br><span class="line">            self.q.put(StopEvent)</span><br><span class="line">            full_size -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">terminate</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        无论是否还有任务，终止线程</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.terminal = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.generate_list:</span><br><span class="line">            self.q.put(StopEvent)</span><br><span class="line"></span><br><span class="line">        self.q.queue.clear()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @contextlib.contextmanager</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">worker_state</span><span class="params">(self, state_list, worker_thread)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        用于记录线程中正在等待的线程数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        state_list.append(worker_thread)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            state_list.remove(worker_thread)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">pool = ThreadPool(5)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def callback(status, result):</span></span><br><span class="line"><span class="string">    # status, execute action status</span></span><br><span class="line"><span class="string">    # result, execute action return value</span></span><br><span class="line"><span class="string">    pass</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def action(i):</span></span><br><span class="line"><span class="string">    print(i)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">for i in range(30):</span></span><br><span class="line"><span class="string">    ret = pool.run(action, (i,), callback)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">time.sleep(5)</span></span><br><span class="line"><span class="string">print(len(pool.generate_list), len(pool.free_list))</span></span><br><span class="line"><span class="string">print(len(pool.generate_list), len(pool.free_list))</span></span><br><span class="line"><span class="string">pool.close()</span></span><br><span class="line"><span class="string">pool.terminate()</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-实现线程池-🍀&quot;&gt;&lt;a href=&quot;#Python之路-实现线程池-🍀&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 实现线程池  🍀&quot;&gt;&lt;/a&gt;Python之路 - 实现线程池  🍀&lt;/h1&gt;&lt;h2 id=&quot;方式一-🍀&quot;&gt;&lt;a href=&quot;#方式一-🍀&quot; class=&quot;headerlink&quot; title=&quot;方式一  🍀&quot;&gt;&lt;/a&gt;方式一  🍀&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Queue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; threading&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ThreadPool&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(object)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, max_num=&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.queue = Queue.Queue(max_num)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; xrange(max_num):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self.queue.put(threading.Thread)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;get_thread&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; self.queue.get()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add_thread&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.queue.put(threading.Thread)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;使用:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;pool = ThreadPool(10)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;def func(arg, p):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    import time&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    time.sleep(2)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    p.add_thread()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;for i in range(30):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    thread = pool.get_thread()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    t = thread(target=func, args=(i, pool))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    t.start()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Concurrent" scheme="https://jesse.top/categories/python/Concurrent/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>44.Python之路 - 并发编程之协程</title>
    <link href="https://jesse.top/2020/06/26/python/06-Concurrent/05-Python%E4%B9%8B%E8%B7%AF%20-%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%8D%8F%E7%A8%8B/"/>
    <id>https://jesse.top/2020/06/26/python/06-Concurrent/05-Python之路 - 并发编程之协程/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:40:28.555Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-并发编程之协程"><a href="#Python之路-并发编程之协程" class="headerlink" title="Python之路 - 并发编程之协程"></a>Python之路 - 并发编程之协程</h1><h2 id="前言-🍀"><a href="#前言-🍀" class="headerlink" title="前言  🍀"></a>前言  🍀</h2><p>在前面的文章中 , 基本已经可以解决并发编程中的基本问题了 , 但是如果我们要利用单线程来实现并发 , 线程是轻量级的进程 , 为了使计算机资源能更充分的利用 , 那么我们就需要用到协程了</p><p>并发的本质就是<em>上下文切换</em>加上<em>保存状态</em> , 那么我们就可以想到关键字<code>yield</code> , 我们在生成器篇章中 , 就是利用了<code>yield</code>实现了状态的保存 , 来看一个廖大大的例子</p><p>生产者消费者模型yield版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">()</span>:</span></span><br><span class="line">    r = <span class="string">''</span></span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        n = <span class="keyword">yield</span> r</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> n:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'[CONSUMER] Consuming %s...'</span> % n)</span><br><span class="line">        r = <span class="string">'200 OK'</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">produce</span><span class="params">(c)</span>:</span></span><br><span class="line">    c.send(<span class="keyword">None</span>)</span><br><span class="line">    n = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> n &lt; <span class="number">5</span>:</span><br><span class="line">        n = n + <span class="number">1</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        print(<span class="string">'[PRODUCER] Producing %s...'</span> % n)</span><br><span class="line">        r = c.send(n)</span><br><span class="line">        print(<span class="string">'[PRODUCER] Consumer return: %s'</span> % r)</span><br><span class="line">    c.close()</span><br><span class="line">c = consumer()</span><br><span class="line">produce(c)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string"># yiled可以保存状态,yield的状态保存与操作系统的保存线程状态很像,但是yield是代码级别控制的,更轻量级</span></span><br><span class="line"><span class="string"># send可以把一个函数的结果传给另外一个函数,以此实现单线程内程序之间的切换 </span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>上述例子中<code>yield</code>确实实现了并发 , 但是并没有实现遇到IO操作进行自动切换 , 所以协程出场了</p><a id="more"></a><h2 id="协程-🍀"><a href="#协程-🍀" class="headerlink" title="协程  🍀"></a>协程  🍀</h2><p>首先通过上述例子 , 我们知道 , 对于单线程下 , 我们不可避免程序中出现IO操作 , 但是如果我们能够在自己的程序中去实现这一步 , 线程可以最大限度地处于就绪态 , 相当于我们在用户程序级别将自己的IO操作最大限度地隐藏起来 , 这样线程的计算效率将会得到进一步的提升</p><blockquote><p>协程(Coroutine) : 是单线程下的并发 , 又称微线程 , 纤程 . 协程是一种用户态的轻量级线程 , 即协程有用户自己控制调度</p></blockquote><p>协程的本质就是在单线程下 , 由用户自己控制一个任务遇到IO阻塞了就切换另外一个任务去执行 , 以此来提升效率</p><p>在单线程内开启协程 , 一旦遇到IO , 就会从应用程序级别控制切换 , 非IO操作的切换与效率无关</p><p>使用协程的优缺点</p><p>优点 : </p><ol><li>协程的切换开销更小 , 属于程序级别的切换 , 更加轻量级</li><li>单线程内就可以实现并发的效果 , 最大限度利用CPU</li></ol><p>缺点 : </p><ol><li>协程的本质是单线程下 , 无法利用多核 , 可以是一个程序开启多个进程 , 每个进程内开启多个线程 , 每个线程内开启协程</li><li>协程指的是单个线程 , 因而一旦协程出现阻塞  将会阻塞整个线程</li></ol><h2 id="Greenlet-🍀"><a href="#Greenlet-🍀" class="headerlink" title="Greenlet  🍀"></a>Greenlet  🍀</h2><p>我们在前面已经用<code>yield</code>实现了协程 , 但是使用<code>yield</code>需要先得到初始化一次的生成器 , 然后再调用send , 这无疑是非常麻烦的 , 所以我们可以使用<code>greenlet</code>模块可以非常简单地实现协程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> greenlet</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"%s eat 1"</span> % name)</span><br><span class="line">    <span class="comment"># 如果协程从来没有被执行过,就会调用self.run()</span></span><br><span class="line">    <span class="comment"># 切换到play协程</span></span><br><span class="line">    g2.switch(<span class="string">"Lyon"</span>)</span><br><span class="line">    <span class="comment"># 执行完毕</span></span><br><span class="line">    print(<span class="string">"%s eat 2"</span> % name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"%s play 1"</span> % name)</span><br><span class="line">    <span class="comment"># 切换到eat协程</span></span><br><span class="line">    g1.switch()</span><br><span class="line">    <span class="comment"># 没有切换回来,所以不执行</span></span><br><span class="line">    print(<span class="string">"%s play 2"</span> % name)</span><br><span class="line"><span class="comment"># 创建一个协程对象,不会执行</span></span><br><span class="line"><span class="comment"># greenlet(run=None, parent=None)</span></span><br><span class="line">g1 = greenlet.greenlet(eat)</span><br><span class="line">g2 = greenlet.greenlet(play)</span><br><span class="line">g1.switch(<span class="string">"Lyon"</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">Lyon eat 1</span></span><br><span class="line"><span class="string">Lyon play 1</span></span><br><span class="line"><span class="string">Lyon eat 2</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>greenlet在没有IO的情况下或者没有重复开辟内存空间的操作下 , 反而会降低程序的执行速度 , 因为greenlet仅仅是单纯的切换 , 比如下面的例子</p><p>普通版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add1</span><span class="params">()</span>:</span></span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000000</span>):</span><br><span class="line">        num *= i</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add2</span><span class="params">()</span>:</span></span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000000</span>):</span><br><span class="line">        num *= i</span><br><span class="line">start_time = time.time()</span><br><span class="line">add1()</span><br><span class="line">add2()</span><br><span class="line">end_time = time.time()</span><br><span class="line">print(end_time - start_time)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">1.015699863433838</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>greenlet版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> greenlet</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add1</span><span class="params">()</span>:</span></span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000000</span>):</span><br><span class="line">        num *= i</span><br><span class="line">        g2.switch()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add2</span><span class="params">()</span>:</span></span><br><span class="line">    num = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10000000</span>):</span><br><span class="line">        num *= i</span><br><span class="line">        g1.switch()</span><br><span class="line">start_time = time.time()</span><br><span class="line">g1 = greenlet.greenlet(add1)</span><br><span class="line">g2 = greenlet.greenlet(add2)</span><br><span class="line">g1.switch()</span><br><span class="line">end_time = time.time()</span><br><span class="line">print(end_time - start_time)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">6.432543992996216</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>greenlet只是提供了一种比<code>generator</code>(yield)更加快捷的切换方式 , 当切到一个任务执行时如果遇到IO , 那就原地阻塞 , 仍然是没有解决遇到IO自动切换来提升效率的问题 , 所以为了真正的提高效率 , 我们就需要使用Gevent模块了</p><h2 id="Gevent-🍀"><a href="#Gevent-🍀" class="headerlink" title="Gevent  🍀"></a>Gevent  🍀</h2><p>Gevent是一个第三方库 , 可以通过gevent轻松实现并发同步或异步编程 , 在gevent中用到的主要模式是Greenlet , 它是以C扩展模块形式接入Python的轻量级协程 </p><p>简单使用介绍</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在gevent库中,主要使用Greenlet模式</span></span><br><span class="line"><span class="comment"># 创建一个协程对象,参数通过Greenlet.__init__传递</span></span><br><span class="line">g = gevent.spawn(run=<span class="keyword">None</span>, *args, **kwargs)</span><br><span class="line"><span class="comment"># 等待协程执行完毕,或者超时结束</span></span><br><span class="line">g.join(timeout=<span class="keyword">None</span>)</span><br><span class="line"><span class="comment"># 将上述两步并一步</span></span><br><span class="line">gevent.joinall(greenlets, timeout=<span class="keyword">None</span>, raise_error=<span class="keyword">False</span>, count=<span class="keyword">None</span>)</span><br><span class="line"><span class="comment"># 让协程睡眠</span></span><br><span class="line">gevent.sleep(seconds=<span class="number">0</span>, ref=<span class="keyword">True</span>)</span><br><span class="line"><span class="comment"># 更多详细介绍请阅读官方文档</span></span><br></pre></td></tr></table></figure><p>IO阻塞自动切换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'%s eat 1'</span> % name)</span><br><span class="line">    <span class="comment"># 睡2秒</span></span><br><span class="line">    gevent.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">'%s eat 2'</span> % name)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">'%s play 1'</span> % name)</span><br><span class="line">    <span class="comment"># 睡1秒</span></span><br><span class="line">    gevent.sleep(<span class="number">1</span>)</span><br><span class="line">    print(<span class="string">'%s play 2'</span> % name)</span><br><span class="line"><span class="comment"># 创建协程实例</span></span><br><span class="line">g1 = gevent.spawn(eat, <span class="string">'Lyon'</span>)</span><br><span class="line">g2 = gevent.spawn(play, <span class="string">'Lyon'</span>)</span><br><span class="line"><span class="comment"># join中由执行开关</span></span><br><span class="line">g1.join()</span><br><span class="line">g2.join()</span><br><span class="line"><span class="comment"># gevent.joinall([g1,g2])</span></span><br><span class="line">print(<span class="string">'End of main thread...'</span>)</span><br></pre></td></tr></table></figure><p>PS : 上例中gevent.sleep(2) 模拟的是gevent可以识别的IO阻塞 , 如果是不能直接识别的需要将<code>from gevent import monkey ; monkey.patch_all()</code>放到文件的开头</p><p>Gevent同步与异步</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> spawn, joinall, monkey</span><br><span class="line"><span class="comment"># 打补丁,使其能直接识别</span></span><br><span class="line">monkey.patch_all()</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">task</span><span class="params">(pid)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Some non-deterministic task</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    time.sleep(<span class="number">0.5</span>)</span><br><span class="line">    print(<span class="string">'Task %s done'</span> % pid)</span><br><span class="line"><span class="comment"># 异步执行</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">synchronous</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        task(i)</span><br><span class="line"><span class="comment"># 同步执行</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">asynchronous</span><span class="params">()</span>:</span></span><br><span class="line">    greenlet_list = [spawn(task, i) <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">    joinall(greenlet_list)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'Synchronous:'</span>)</span><br><span class="line">    synchronous()</span><br><span class="line">    print(<span class="string">'Asynchronous:'</span>)</span><br><span class="line">    asynchronous()</span><br></pre></td></tr></table></figure><h2 id="Gevent实例-🍀"><a href="#Gevent实例-🍀" class="headerlink" title="Gevent实例  🍀"></a>Gevent实例  🍀</h2><p>爬虫</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line">monkey.patch_all()</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_page</span><span class="params">(url)</span>:</span></span><br><span class="line">    print(<span class="string">'GET: %s'</span> % url)</span><br><span class="line">    response = requests.get(url)</span><br><span class="line">    <span class="keyword">if</span> response.status_code == <span class="number">200</span>:</span><br><span class="line">        print(<span class="string">'%d bytes received from %s'</span> % (len(response.text), url))</span><br><span class="line">start_time = time.time()</span><br><span class="line">gevent.joinall([</span><br><span class="line">    gevent.spawn(get_page, <span class="string">'https://www.python.org/'</span>),</span><br><span class="line">    gevent.spawn(get_page, <span class="string">'https://www.yahoo.com/'</span>),</span><br><span class="line">])</span><br><span class="line">end_time = time.time()</span><br><span class="line">print(<span class="string">'run time is %s'</span> % (end_time - start_time))</span><br></pre></td></tr></table></figure><p>socket并发</p><p>server.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> gevent <span class="keyword">import</span> monkey</span><br><span class="line">monkey.patch_all()</span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> gevent</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server</span><span class="params">(server_ip, port)</span>:</span></span><br><span class="line">    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">    s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, <span class="number">1</span>)</span><br><span class="line">    s.bind((server_ip, port))</span><br><span class="line">    s.listen(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        conn,addr = s.accept()</span><br><span class="line">        gevent.spawn(talk, conn, addr)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(conn, addr)</span>:</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            res = conn.recv(<span class="number">1024</span>)</span><br><span class="line">            print(<span class="string">'Client %s:%s msg: %s'</span> % (addr[<span class="number">0</span>], addr[<span class="number">1</span>], res))</span><br><span class="line">            conn.send(res.upper())</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        conn.close()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    server(<span class="string">'127.0.0.1'</span>, <span class="number">8080</span>)</span><br></pre></td></tr></table></figure><p>client.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">client = socket.socket(socket.AF_INET,socket.SOCK_STREAM)</span><br><span class="line">client.connect((<span class="string">'127.0.0.1'</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    msg = input(<span class="string">'&gt;&gt;: '</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> msg:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    client.send(msg.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">    msg = client.recv(<span class="number">1024</span>)</span><br><span class="line">    print(msg.decode(<span class="string">'utf-8'</span>))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-并发编程之协程&quot;&gt;&lt;a href=&quot;#Python之路-并发编程之协程&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 并发编程之协程&quot;&gt;&lt;/a&gt;Python之路 - 并发编程之协程&lt;/h1&gt;&lt;h2 id=&quot;前言-🍀&quot;&gt;&lt;a href=&quot;#前言-🍀&quot; class=&quot;headerlink&quot; title=&quot;前言  🍀&quot;&gt;&lt;/a&gt;前言  🍀&lt;/h2&gt;&lt;p&gt;在前面的文章中 , 基本已经可以解决并发编程中的基本问题了 , 但是如果我们要利用单线程来实现并发 , 线程是轻量级的进程 , 为了使计算机资源能更充分的利用 , 那么我们就需要用到协程了&lt;/p&gt;
&lt;p&gt;并发的本质就是&lt;em&gt;上下文切换&lt;/em&gt;加上&lt;em&gt;保存状态&lt;/em&gt; , 那么我们就可以想到关键字&lt;code&gt;yield&lt;/code&gt; , 我们在生成器篇章中 , 就是利用了&lt;code&gt;yield&lt;/code&gt;实现了状态的保存 , 来看一个廖大大的例子&lt;/p&gt;
&lt;p&gt;生产者消费者模型yield版&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; time&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;consumer&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    r = &lt;span class=&quot;string&quot;&gt;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    time.sleep(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        n = &lt;span class=&quot;keyword&quot;&gt;yield&lt;/span&gt; r&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;not&lt;/span&gt; n:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        time.sleep(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&lt;span class=&quot;string&quot;&gt;&#39;[CONSUMER] Consuming %s...&#39;&lt;/span&gt; % n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        r = &lt;span class=&quot;string&quot;&gt;&#39;200 OK&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;produce&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(c)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    c.send(&lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    n = &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;while&lt;/span&gt; n &amp;lt; &lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        n = n + &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        time.sleep(&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&lt;span class=&quot;string&quot;&gt;&#39;[PRODUCER] Producing %s...&#39;&lt;/span&gt; % n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        r = c.send(n)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&lt;span class=&quot;string&quot;&gt;&#39;[PRODUCER] Consumer return: %s&#39;&lt;/span&gt; % r)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    c.close()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;c = consumer()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;produce(c)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;# yiled可以保存状态,yield的状态保存与操作系统的保存线程状态很像,但是yield是代码级别控制的,更轻量级&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;# send可以把一个函数的结果传给另外一个函数,以此实现单线程内程序之间的切换 &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;上述例子中&lt;code&gt;yield&lt;/code&gt;确实实现了并发 , 但是并没有实现遇到IO操作进行自动切换 , 所以协程出场了&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Concurrent" scheme="https://jesse.top/categories/python/Concurrent/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
</feed>
