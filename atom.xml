<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jesse&#39;s home</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jesse.top/"/>
  <updated>2020-06-26T06:51:03.473Z</updated>
  <id>https://jesse.top/</id>
  
  <author>
    <name>Jesse</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="https://jesse.top/2020/06/26/Linux-Service/%E4%BD%BF%E7%94%A8supervisor%E6%89%98%E7%AE%A1elasticsearch%E8%BF%9B%E7%A8%8B/"/>
    <id>https://jesse.top/2020/06/26/Linux-Service/使用supervisor托管elasticsearch进程/</id>
    <published>2020-06-26T06:33:18.939Z</published>
    <updated>2020-06-26T06:51:03.473Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title:使用supervisor托管elasticsearch进程<br>date:2018-06-15 15:59:58<br>tags:supervisor<br>categories:Linux-Service<br>comments:true</p><h2 id="copyright-true"><a href="#copyright-true" class="headerlink" title="copyright:true"></a>copyright:true</h2><h1 id="使用supervisor托管elasticsearch进程"><a href="#使用supervisor托管elasticsearch进程" class="headerlink" title="使用supervisor托管elasticsearch进程"></a>使用supervisor托管elasticsearch进程</h1><h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>线上出现过一次ES集群故障:<a href="https://tower.im/teams/682393/documents/81875/?fullscreen=false" target="_blank" rel="noopener">记一次线上ES集群故障</a><br>此文主要介绍ES集群健壮性的整改措施.主要在以下几个方面:</p><ol><li>新增一台ES集群Master节点,使节点数达到3个,从而可以容忍一个master节点故障</li><li>使用supervisor托管elasticsearch进程</li><li>使用systemd托管supervisord.使supervisord开机自动启动</li></ol><a id="more"></a><hr><h2 id="详细措施"><a href="#详细措施" class="headerlink" title="详细措施"></a>详细措施</h2><p>1.在supervisor的conf.d的目录下新增elasticsearch.conf配置文件.内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[program:elasticsearch]</span><br><span class="line">#启动命令,前台启动,不需要-d参数</span><br><span class="line">command=/data/app/elasticsearch-2.4.6/bin/elasticsearch</span><br><span class="line">autorestart=true</span><br><span class="line">autostart=true</span><br><span class="line">stderr_logfile=/data/logs/elasticsearch/hsq_elasticsearch.error.log</span><br><span class="line">stdout_logfile=/data/logs/elasticsearch/hsq_elasticsearch.log</span><br><span class="line">#JAVA_HOME的路径</span><br><span class="line">environment=JAVA_HOME=/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.222.b10-0.el7_6.x86_64/jre</span><br><span class="line">#elasticsearch的启动内存堆栈大小.这个环境变量可以在/etc/profile中定义.但是supervisord无法识别shell终端的环境变量</span><br><span class="line">environment=ES_HEAP_SIZE=24g</span><br><span class="line">#最大文件打开数,同样,最好是在这里的配置文件定义一下.</span><br><span class="line">environment=MAX_OPEN_FILES=102400</span><br><span class="line">#启动用户.注意.elasticsearch不能用root启动</span><br><span class="line">user=work</span><br><span class="line">#进程终止信号</span><br><span class="line">stopsignal=INT</span><br><span class="line">#进程重启间隔</span><br><span class="line">startsecs=10</span><br></pre></td></tr></table></figure><p>以上就是elasticsearch的配置文件.但是经过我测试,在部分服务器上,ES启动后无法使用预期的ES_HEAP_SIZE变量.所以我选择是在elasticsearch的启动文件中直接写死.</p><p>在/data/app/elasticsearch-2.4.6/bin/elasticsearch/bin/elasticsearch.in.sh启动文件中的如下位置新增一行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@hsq-es-node3 ~]# cat /data/app/elasticsearch-2.4.6/bin/elasticsearch.in.sh</span><br><span class="line"></span><br><span class="line">#这里写死ES_HEAP_SIZE内存数</span><br><span class="line">ES_HEAP_SIZE=24g</span><br><span class="line"></span><br><span class="line">if [ &quot;x$ES_MIN_MEM&quot; = &quot;x&quot; ]; then</span><br><span class="line">    ES_MIN_MEM=256m</span><br><span class="line">fi</span><br><span class="line">if [ &quot;x$ES_MAX_MEM&quot; = &quot;x&quot; ]; then</span><br><span class="line">    ES_MAX_MEM=1g</span><br><span class="line">fi</span><br><span class="line">if [ &quot;x$ES_HEAP_SIZE&quot; != &quot;x&quot; ]; then</span><br><span class="line">    ES_MIN_MEM=$ES_HEAP_SIZE</span><br><span class="line">    ES_MAX_MEM=$ES_HEAP_SIZE</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><ol start="2"><li>使用systemd托管supervisord实现开机自启</li></ol><p>在/usr/lib/systemd/system/路径下新增supervisord.service文件.内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description=Supervisor daemon</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/bin/supervisord -c /etc/supervisord/supervisord.conf</span><br><span class="line">ExecStop=/usr/bin/supervisorctl -c /etc/supervisord/supervisord.conf  shutdown</span><br><span class="line">ExecReload=/usr/bin/supervisorctl -c /etc/supervisord/supervisord.conf reload</span><br><span class="line">KillMode=process</span><br><span class="line">Restart=on-failure</span><br><span class="line">RestartSec=42s</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><p>加入开机启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable supervisord</span><br></pre></td></tr></table></figure><ol start="3"><li>手动kill掉正在运行中的supervisord和elasticsearch进程.</li></ol><blockquote><p>注意观察当前是否有其他重要进程由supervisor托管</p></blockquote><p>然后使用<figure class="highlight plain"><figcaption><span>start supervisord```启动supervisor.此时elasticsearch会自动启动</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line">## ES集群新增master节点</span><br><span class="line"></span><br><span class="line">编辑elasticsearch.yaml文件.修改如下字段</span><br></pre></td></tr></table></figure></p><p>node.master: true<br>node.data: false<br>node.client: false</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">此时该节点启动后,就只做为master节点运行.</span><br><span class="line"></span><br><span class="line">在其他ES节点上修改配置中的以下配置,将所有节点的IP和端口添加进列表:</span><br></pre></td></tr></table></figure><p>discovery.zen.ping.unicast.hosts: [“10.111.30.202:9300”,”10.111.30.207:9300”,”10.111.30.206:9300”,”10.111.30.193:9300”,”10.111.30.197:9300”]<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title:使用supervisor托管elasticsearch进程&lt;br&gt;date:2018-06-15 15:59:58&lt;br&gt;tags:supervisor&lt;br&gt;categories:Linux-Service&lt;br&gt;comments:true&lt;/p&gt;
&lt;h2 id=&quot;copyright-true&quot;&gt;&lt;a href=&quot;#copyright-true&quot; class=&quot;headerlink&quot; title=&quot;copyright:true&quot;&gt;&lt;/a&gt;copyright:true&lt;/h2&gt;&lt;h1 id=&quot;使用supervisor托管elasticsearch进程&quot;&gt;&lt;a href=&quot;#使用supervisor托管elasticsearch进程&quot; class=&quot;headerlink&quot; title=&quot;使用supervisor托管elasticsearch进程&quot;&gt;&lt;/a&gt;使用supervisor托管elasticsearch进程&lt;/h1&gt;&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;线上出现过一次ES集群故障:&lt;a href=&quot;https://tower.im/teams/682393/documents/81875/?fullscreen=false&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;记一次线上ES集群故障&lt;/a&gt;&lt;br&gt;此文主要介绍ES集群健壮性的整改措施.主要在以下几个方面:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;新增一台ES集群Master节点,使节点数达到3个,从而可以容忍一个master节点故障&lt;/li&gt;
&lt;li&gt;使用supervisor托管elasticsearch进程&lt;/li&gt;
&lt;li&gt;使用systemd托管supervisord.使supervisord开机自动启动&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jesse.top/2020/06/26/%E7%9B%91%E6%8E%A7/zabbix%20%E9%80%9A%E8%BF%87Dell%20Idrac%E7%9B%91%E6%8E%A7%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%A1%AC%E4%BB%B6%E7%8A%B6%E6%80%81/"/>
    <id>https://jesse.top/2020/06/26/监控/zabbix 通过Dell Idrac监控服务器硬件状态/</id>
    <published>2020-06-26T06:27:16.901Z</published>
    <updated>2020-06-26T02:51:49.405Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Zabbix-通过Dell-Idrac监控服务器硬件状态"><a href="#Zabbix-通过Dell-Idrac监控服务器硬件状态" class="headerlink" title="Zabbix 通过Dell Idrac监控服务器硬件状态"></a>Zabbix 通过Dell Idrac监控服务器硬件状态</h2><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近登陆vsphere控制台发现一台Dell服务器告警,已经损坏了.于是想通过zabbix监控Dell服务器的硬件状态.</p><p>有2种方法可以监控dell服务器的硬件状态</p><ul><li>通过Dell的OMSA工具监控</li><li>通过Dell的Idrac模块的SNMP协议监控</li></ul><p>Dell的OMSA工具需要安装在物理机系统上,我尝试过安装在vsphere的虚拟主机上,没办法获取到硬件状态.而且OMSA工具从Dell官网下载太慢.安装很麻烦</p><p>所以本文主要介绍如何通过idrac模块的snmp协议监控硬件状态.监控方法非常的简单</p><hr><h3 id="1-登陆服务器的idrac平台-开启snmp协议-v2版本"><a href="#1-登陆服务器的idrac平台-开启snmp协议-v2版本" class="headerlink" title="1.登陆服务器的idrac平台.开启snmp协议(v2版本)."></a>1.登陆服务器的idrac平台.开启snmp协议(v2版本).</h3><p>如果是idrac8版本,SNMP配置在左侧菜单栏<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果是idrac9版本,SNMP配置在菜单栏```iDRAC设置```---```服务```---```SNMP代理</span><br></pre></td></tr></table></figure></p><blockquote><p>根据我们的实际情况来看,无论是8还是9版本,SNMP都默认开启,端口是161,团体名是public</p></blockquote><h3 id="2-在zabbix服务端通过snmp命令检查是否能正确获取到服务器的snmp-oid"><a href="#2-在zabbix服务端通过snmp命令检查是否能正确获取到服务器的snmp-oid" class="headerlink" title="2.在zabbix服务端通过snmp命令检查是否能正确获取到服务器的snmp oid:"></a>2.在zabbix服务端通过snmp命令检查是否能正确获取到服务器的snmp oid:</h3><p>命令: <figure class="highlight plain"><figcaption><span>-v 2c -c 团体名 idrac IP地址```</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>[work@server-4 ~]$ snmpwalk -v 2c -c public 172.16.250.53<br>SNMPv2-MIB::sysDescr.0 = STRING:<br>SNMPv2-MIB::sysObjectID.0 = OID: SNMPv2-SMI::enterprises.674.10892.5<br>DISMAN-EVENT-MIB::sysUpTimeInstance = Timeticks: (596160991) 69 days, 0:00:09.91<br>SNMPv2-MIB::sysContact.0 = STRING: \”<a href="mailto:support@dell.com" target="_blank" rel="noopener">support@dell.com</a>\”<br>SNMPv2-MIB::sysName.0 = STRING: iDRAC-3D38Y23<br>SNMPv2-MIB::sysLocation.0 = STRING: \”unknown\”<br>SNMPv2-MIB::sysORLastChange.0 = Timeticks: (1) 0:00:00.01<br>SNMPv2-MIB::sysORID.1 = OID: SNMPv2-MIB::snmpMIB<br>SNMPv2-MIB::sysORID.2 = OID: SNMP-VIEW-BASED-ACM-MIB::vacmBasicGroup<br>SNMPv2-MIB::sysORID.3 = OID: TCP-MIB::tcpMIB<br>SNMPv2-MIB::sysORID.4 = OID: IP-MIB::ip<br>SNMPv2-MIB::sysORID.5 = OID: UDP-MIB::udpMIB<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 3. 去github上下载idrac snmp监控模板</span><br><span class="line"></span><br><span class="line">地址: [idrac template](https://github.com/endersonmaia/zabbix-templates/tree/master/dell/idrac)</span><br><span class="line"></span><br><span class="line">模板文件我已经fork到了我自己的github仓库:[zabbix-templates](https://github.com/huangyonghome/zabbix-templates)</span><br><span class="line"></span><br><span class="line">**在dell/idrac下有3个文件:**</span><br><span class="line"></span><br><span class="line">```ValueMaps_Dell_iDRAC.zbx.xml```-------导入键值对映射 (需要zabbix3.0版本以上)</span><br><span class="line"></span><br><span class="line">```Template_Dell_iDRAC_SNMPv&#123;23&#125;.zbx.xml```-----监控模板(我们的idrac snmp协议是v2版本.所以采用snmpv2版本的模板)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 4.配置全局变量</span><br><span class="line"></span><br><span class="line">在Zabbix的```Administration```----```General```---右上角下拉框中选择宏Macros,新增宏定义:</span><br></pre></td></tr></table></figure></p><p>#我这里Idrac的snmp团体名是public<br>{$SNMP_COMMUNITY_IDRAC} =&gt; public<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 5.导入模板</span><br><span class="line"></span><br><span class="line">1.导入键值对映射```ValueMaps_Dell_iDRAC.zbx.xml</span><br></pre></td></tr></table></figure></p><p>2.导入监控模板<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 6.配置主机</span><br><span class="line"></span><br><span class="line">主机名和随意定义.定义snmp接口的地址为idrac接口IP地址,端口默认161.</span><br><span class="line"></span><br><span class="line">添加Template_Dell_iDRAC_SNMPv2模板</span><br><span class="line"></span><br><span class="line">&gt; 注意,snmp的地址是idrac地址,不是服务器iP地址</span><br><span class="line"></span><br><span class="line">模板里没有配置图形,如果有需要可以自己添加.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">### 7.验证</span><br><span class="line"></span><br><span class="line">刚好这台服务器的物理磁盘有问题.可以看到Zabbix成功的监控到这个问题,并且发送给钉钉告警.</span><br></pre></td></tr></table></figure></p><p>[故障]RAID Controller Error<br>告警级别：High<br>故障时间：2020.04.29 16:45:35<br>故障时长：1h 0m<br>IP地址：172.16.250.53<br>检测项：RAIDControllerStatus<br><em>NonCritical (4) </em><br>[exsi-idrac-53·故障 (31724858)]</p><p>[故障]Storage System Status Error<br>告警级别：Warning<br>故障时间：2020.04.29 16:45:35<br>故障时长：1h 0m<br>IP地址：172.16.250.53<br>检测项：GlobalSystemStorageStatus<br><em>NonCritical (4) </em><br>[exsi-idrac-53·故障 (31724857)]</p><p>[故障]Overall System Rollup Status Error<br>告警级别：Warning<br>故障时间：2020.04.29 16:45:35<br>故障时长：1h 0m<br>IP地址：172.16.250.53<br>检测项：GlobalSystemRollupStatus<br><em>NonCritical (4) </em><br>[exsi-idrac-53·故障 (31724855)]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">服务器磁盘修复以后,监控回复正常.监控各项指标的结果不再是4(NonCritical) 而是3(OK)</span><br></pre></td></tr></table></figure></p><p>work@server-4 ~]$ snmpwalk -v 2c -c public 172.16.250.53 1.3.6.1.4.1.674.10892.5.2.3.0<br>SNMPv2-SMI::enterprises.674.10892.5.2.3.0 = INTEGER: 3</p><p>[work@server-4 ~]$ snmpwalk -v 2c -c public 172.16.250.53 1.3.6.1.4.1.674.10892.5.5.1.20.130.1.1.37.1<br>SNMPv2-SMI::enterprises.674.10892.5.5.1.20.130.1.1.37.1 = INTEGER: 3<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 问题</span><br><span class="line"></span><br><span class="line">目前发现一个模板的问题,在键值对映射中,Dell的OMSA(Open Manage System Status)键值对是这样映射的:</span><br></pre></td></tr></table></figure></p><p>Dell Open Manage System Status<br>1  Other<br>2  Unknown<br>3  OK<br>4  NonCritical<br>5  Critical<br>6  NonRecoverable<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在模板中,有一个触发器的名称是:Overall System Status Error</span><br><span class="line"></span><br><span class="line">表达式为```&#123;exsi-idrac-53:GlobalSystemStatus.last()&#125;&lt;&gt;3</span><br></pre></td></tr></table></figure></p><p>用意是监控系统状态,如果值不为3(OK)则告警.但是根据实际情况来看,这个监控项GlobalSystemStatus.SNMP OID:1.3.6.1.4.1.674.10892.2.2.1.0正常情况下的值为0</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[work@server-4 ~]$ snmpwalk -v 2c -c public 172.16.250.53 1.3.6.1.4.1.674.10892.2.2.1.0</span><br><span class="line">SNMPv2-SMI::enterprises.674.10892.2.2.1.0 = INTEGER: 0</span><br></pre></td></tr></table></figure><p>所以在模板中修改Overall System Status Error触发器的表达式为:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">原表达式:</span><br><span class="line">&#123;Template Dell iDrac SNMPV2:GlobalSystemStatus.last()&#125;&lt;&gt;3 </span><br><span class="line"></span><br><span class="line">修改为:</span><br><span class="line">&#123;Template Dell iDrac SNMPV2:GlobalSystemStatus.last()&#125;&lt;&gt;3 and </span><br><span class="line">&#123;Template Dell iDrac SNMPV2:GlobalSystemStatus.last()&#125;&lt;&gt;0</span><br></pre></td></tr></table></figure><p>用意是这个监控项的结果既不等于3,又不等于0</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Zabbix-通过Dell-Idrac监控服务器硬件状态&quot;&gt;&lt;a href=&quot;#Zabbix-通过Dell-Idrac监控服务器硬件状态&quot; class=&quot;headerlink&quot; title=&quot;Zabbix 通过Dell Idrac监控服务器硬件状态&quot;&gt;&lt;/a&gt;Za
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jesse.top/2020/06/26/Linux-Service/systemd%E8%AF%A6%E8%A7%A3/"/>
    <id>https://jesse.top/2020/06/26/Linux-Service/systemd详解/</id>
    <published>2020-06-26T05:04:18.956Z</published>
    <updated>2020-06-26T06:50:44.952Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title:systemd介绍<br>date:2018-06-15 15:59:58<br>tags:systemd<br>categories:[Linux-Service ]<br>comments:true</p><h2 id="copyright-true"><a href="#copyright-true" class="headerlink" title="copyright:true"></a>copyright:true</h2><h1 id="systemd介绍"><a href="#systemd介绍" class="headerlink" title="systemd介绍"></a>systemd介绍</h1><p>systemd并不是一个命令,而是一组命令,涉及到系统管理的方方面面.以下是systemd的架构图</p><p><img src="http://www.ruanyifeng.com/blogimg/asset/2016/bg2016030703.png" alt=""></p><hr><a id="more"></a><h2 id="一-系统管理"><a href="#一-系统管理" class="headerlink" title="一.系统管理"></a>一.系统管理</h2><h3 id="systemctl"><a href="#systemctl" class="headerlink" title="systemctl"></a>systemctl</h3><hr><figure class="highlight plain"><figcaption><span>的主命令，用于管理系统。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="重启系统"><a href="#重启系统" class="headerlink" title="重启系统"></a>重启系统</h1><p>$ sudo systemctl reboot</p><h1 id="关闭系统，切断电源"><a href="#关闭系统，切断电源" class="headerlink" title="关闭系统，切断电源"></a>关闭系统，切断电源</h1><p>$ sudo systemctl poweroff</p><h1 id="CPU停止工作"><a href="#CPU停止工作" class="headerlink" title="CPU停止工作"></a>CPU停止工作</h1><p>$ sudo systemctl halt</p><h1 id="暂停系统"><a href="#暂停系统" class="headerlink" title="暂停系统"></a>暂停系统</h1><p>$ sudo systemctl suspend</p><h1 id="让系统进入冬眠状态"><a href="#让系统进入冬眠状态" class="headerlink" title="让系统进入冬眠状态"></a>让系统进入冬眠状态</h1><p>$ sudo systemctl hibernate</p><h1 id="让系统进入交互式休眠状态"><a href="#让系统进入交互式休眠状态" class="headerlink" title="让系统进入交互式休眠状态"></a>让系统进入交互式休眠状态</h1><p>$ sudo systemctl hybrid-sleep</p><h1 id="启动进入救援状态（单用户状态）"><a href="#启动进入救援状态（单用户状态）" class="headerlink" title="启动进入救援状态（单用户状态）"></a>启动进入救援状态（单用户状态）</h1><p>$ sudo systemctl rescue<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### systemd-analyze</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">`systemd-analyze`命令用于查看启动耗时。</span><br></pre></td></tr></table></figure></p><h1 id="查看启动耗时"><a href="#查看启动耗时" class="headerlink" title="查看启动耗时"></a>查看启动耗时</h1><p>$ systemd-analyze                                                                                       </p><h1 id="查看每个服务的启动耗时"><a href="#查看每个服务的启动耗时" class="headerlink" title="查看每个服务的启动耗时"></a>查看每个服务的启动耗时</h1><p>$ systemd-analyze blame</p><h1 id="显示瀑布状的启动过程流"><a href="#显示瀑布状的启动过程流" class="headerlink" title="显示瀑布状的启动过程流"></a>显示瀑布状的启动过程流</h1><p>$ systemd-analyze critical-chain</p><h1 id="显示指定服务的启动流"><a href="#显示指定服务的启动流" class="headerlink" title="显示指定服务的启动流"></a>显示指定服务的启动流</h1><p>$ systemd-analyze critical-chain atd.service<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### hostnamectl</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line">`hostnamectl`命令用于查看当前主机的信息。</span><br></pre></td></tr></table></figure></p><h1 id="显示当前主机的信息"><a href="#显示当前主机的信息" class="headerlink" title="显示当前主机的信息"></a>显示当前主机的信息</h1><p>$ hostnamectl</p><h1 id="设置主机名。"><a href="#设置主机名。" class="headerlink" title="设置主机名。"></a>设置主机名。</h1><p>$ sudo hostnamectl set-hostname rhel7<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### localectl</span><br><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line">`localectl`命令用于查看本地化设置。</span><br></pre></td></tr></table></figure></p><h1 id="查看本地化设置"><a href="#查看本地化设置" class="headerlink" title="查看本地化设置"></a>查看本地化设置</h1><p>$ localectl</p><h1 id="设置本地化参数。"><a href="#设置本地化参数。" class="headerlink" title="设置本地化参数。"></a>设置本地化参数。</h1><p>$ sudo localectl set-locale LANG=en_GB.utf8<br>$ sudo localectl set-keymap en_GB<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### timedatectl</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">`timedatectl`命令用于查看当前时区设置。</span><br></pre></td></tr></table></figure></p><h1 id="查看当前时区设置"><a href="#查看当前时区设置" class="headerlink" title="查看当前时区设置"></a>查看当前时区设置</h1><p>$ timedatectl</p><h1 id="显示所有可用的时区"><a href="#显示所有可用的时区" class="headerlink" title="显示所有可用的时区"></a>显示所有可用的时区</h1><p>$ timedatectl list-timezones                                                                                   </p><h1 id="设置当前时区"><a href="#设置当前时区" class="headerlink" title="设置当前时区"></a>设置当前时区</h1><p>$ sudo timedatectl set-timezone America/New_York<br>$ sudo timedatectl set-time YYYY-MM-DD<br>$ sudo timedatectl set-time HH:MM:SS<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### loginctl</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">`loginctl`命令用于查看当前登录的用户。</span><br></pre></td></tr></table></figure></p><h1 id="列出当前session"><a href="#列出当前session" class="headerlink" title="列出当前session"></a>列出当前session</h1><p>$ loginctl list-sessions</p><h1 id="列出当前登录用户"><a href="#列出当前登录用户" class="headerlink" title="列出当前登录用户"></a>列出当前登录用户</h1><p>$ loginctl list-users</p><h1 id="列出显示指定用户的信息"><a href="#列出显示指定用户的信息" class="headerlink" title="列出显示指定用户的信息"></a>列出显示指定用户的信息</h1><p>$ loginctl show-user ruanyf<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 二.Unit</span><br><span class="line"></span><br><span class="line">Systemd 可以管理所有系统资源。不同的资源统称为 Unit（单位）。</span><br><span class="line"></span><br><span class="line">Unit 一共分成12种。</span><br></pre></td></tr></table></figure></p><p>Service unit：系统服务<br>Target unit：多个 Unit 构成的一个组<br>Device Unit：硬件设备<br>Mount Unit：文件系统的挂载点<br>Automount Unit：自动挂载点<br>Path Unit：文件或路径<br>Scope Unit：不是由 Systemd 启动的外部进程<br>Slice Unit：进程组<br>Snapshot Unit：Systemd 快照，可以切回某个快照<br>Socket Unit：进程间通信的 socket<br>Swap Unit：swap 文件<br>Timer Unit：定时器<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">----</span><br><span class="line"></span><br><span class="line">`systemctl list-units`命令可以查看当前系统的所有 Unit 。</span><br></pre></td></tr></table></figure></p><h1 id="列出正在运行的-Unit"><a href="#列出正在运行的-Unit" class="headerlink" title="列出正在运行的 Unit"></a>列出正在运行的 Unit</h1><p>$ systemctl list-units</p><h1 id="列出所有Unit，包括没有找到配置文件的或者启动失败的"><a href="#列出所有Unit，包括没有找到配置文件的或者启动失败的" class="headerlink" title="列出所有Unit，包括没有找到配置文件的或者启动失败的"></a>列出所有Unit，包括没有找到配置文件的或者启动失败的</h1><p>$ systemctl list-units –all</p><h1 id="列出所有没有运行的-Unit"><a href="#列出所有没有运行的-Unit" class="headerlink" title="列出所有没有运行的 Unit"></a>列出所有没有运行的 Unit</h1><p>$ systemctl list-units –all –state=inactive</p><h1 id="列出所有加载失败的-Unit"><a href="#列出所有加载失败的-Unit" class="headerlink" title="列出所有加载失败的 Unit"></a>列出所有加载失败的 Unit</h1><p>$ systemctl list-units –failed</p><h1 id="列出所有正在运行的、类型为-service-的-Unit"><a href="#列出所有正在运行的、类型为-service-的-Unit" class="headerlink" title="列出所有正在运行的、类型为 service 的 Unit"></a>列出所有正在运行的、类型为 service 的 Unit</h1><p>$ systemctl list-units –type=service<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### Unit 的状态</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">`systemctl status`命令用于查看系统状态和单个 Unit 的状态。</span><br></pre></td></tr></table></figure></p><h1 id="显示系统状态"><a href="#显示系统状态" class="headerlink" title="显示系统状态"></a>显示系统状态</h1><p>$ systemctl status</p><h1 id="显示单个-Unit-的状态"><a href="#显示单个-Unit-的状态" class="headerlink" title="显示单个 Unit 的状态"></a>显示单个 Unit 的状态</h1><p>$ systemctl status bluetooth.service</p><h1 id="显示远程主机的某个-Unit-的状态"><a href="#显示远程主机的某个-Unit-的状态" class="headerlink" title="显示远程主机的某个 Unit 的状态"></a>显示远程主机的某个 Unit 的状态</h1><p>$ systemctl -H <a href="mailto:root@rhel7.example.com" target="_blank" rel="noopener">root@rhel7.example.com</a> status httpd.service<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">除了`status`命令，`systemctl`还提供了三个查询状态的简单方法，主要供脚本内部的判断语句使用。</span><br></pre></td></tr></table></figure></p><h1 id="显示某个-Unit-是否正在运行"><a href="#显示某个-Unit-是否正在运行" class="headerlink" title="显示某个 Unit 是否正在运行"></a>显示某个 Unit 是否正在运行</h1><p>$ systemctl is-active application.service</p><h1 id="显示某个-Unit-是否处于启动失败状态"><a href="#显示某个-Unit-是否处于启动失败状态" class="headerlink" title="显示某个 Unit 是否处于启动失败状态"></a>显示某个 Unit 是否处于启动失败状态</h1><p>$ systemctl is-failed application.service</p><h1 id="显示某个-Unit-服务是否建立了启动链接"><a href="#显示某个-Unit-服务是否建立了启动链接" class="headerlink" title="显示某个 Unit 服务是否建立了启动链接"></a>显示某个 Unit 服务是否建立了启动链接</h1><p>$ systemctl is-enabled application.service<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### Unit 管理</span><br><span class="line"></span><br><span class="line">对于用户来说，最常用的是下面这些命令，用于启动和停止 Unit（主要是 service）。</span><br></pre></td></tr></table></figure></p><h1 id="立即启动一个服务"><a href="#立即启动一个服务" class="headerlink" title="立即启动一个服务"></a>立即启动一个服务</h1><p>$ sudo systemctl start apache.service</p><h1 id="立即停止一个服务"><a href="#立即停止一个服务" class="headerlink" title="立即停止一个服务"></a>立即停止一个服务</h1><p>$ sudo systemctl stop apache.service</p><h1 id="重启一个服务"><a href="#重启一个服务" class="headerlink" title="重启一个服务"></a>重启一个服务</h1><p>$ sudo systemctl restart apache.service</p><h1 id="杀死一个服务的所有子进程"><a href="#杀死一个服务的所有子进程" class="headerlink" title="杀死一个服务的所有子进程"></a>杀死一个服务的所有子进程</h1><p>$ sudo systemctl kill apache.service</p><h1 id="重新加载一个服务的配置文件"><a href="#重新加载一个服务的配置文件" class="headerlink" title="重新加载一个服务的配置文件"></a>重新加载一个服务的配置文件</h1><p>$ sudo systemctl reload apache.service</p><h1 id="重载所有修改过的配置文件"><a href="#重载所有修改过的配置文件" class="headerlink" title="重载所有修改过的配置文件"></a>重载所有修改过的配置文件</h1><p>$ sudo systemctl daemon-reload</p><h1 id="显示某个-Unit-的所有底层参数"><a href="#显示某个-Unit-的所有底层参数" class="headerlink" title="显示某个 Unit 的所有底层参数"></a>显示某个 Unit 的所有底层参数</h1><p>$ systemctl show httpd.service</p><h1 id="显示某个-Unit-的指定属性的值"><a href="#显示某个-Unit-的指定属性的值" class="headerlink" title="显示某个 Unit 的指定属性的值"></a>显示某个 Unit 的指定属性的值</h1><p>$ systemctl show -p CPUShares httpd.service</p><h1 id="设置某个-Unit-的指定属性"><a href="#设置某个-Unit-的指定属性" class="headerlink" title="设置某个 Unit 的指定属性"></a>设置某个 Unit 的指定属性</h1><p>$ sudo systemctl set-property httpd.service CPUShares=500<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 依赖关系</span><br><span class="line"></span><br><span class="line">Unit 之间存在依赖关系：A 依赖于 B，就意味着 Systemd 在启动 A 的时候，同时会去启动 B。</span><br><span class="line"></span><br><span class="line">`systemctl list-dependencies`命令列出一个 Unit 的所有依赖。</span><br></pre></td></tr></table></figure></p><p>$ systemctl list-dependencies nginx.service<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">上面命令的输出结果之中，有些依赖是 Target 类型（详见下文），默认不会展开显示。如果要展开 Target，就需要使用`--all`参数。</span><br></pre></td></tr></table></figure></p><p>$ systemctl list-dependencies –all nginx.service<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 三.Unit 的配置文件</span><br><span class="line"></span><br><span class="line">### 概述</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">每一个 Unit 都有一个配置文件，告诉 Systemd 怎么启动这个 Unit 。</span><br><span class="line"></span><br><span class="line">Systemd 默认从目录`/etc/systemd/system/`读取配置文件。但是，里面存放的大部分文件都是符号链接，指向目录`/usr/lib/systemd/system/`，真正的配置文件存放在那个目录。</span><br><span class="line"></span><br><span class="line">`systemctl enable`命令用于在上面两个目录之间，建立符号链接关系。</span><br></pre></td></tr></table></figure></p><p>$ sudo systemctl enable <a href="mailto:clamd@scan.service" target="_blank" rel="noopener">clamd@scan.service</a></p><h1 id="等同于"><a href="#等同于" class="headerlink" title="等同于"></a>等同于</h1><p>$ sudo ln -s <a href="mailto:&#39;/usr/lib/systemd/system/clamd@scan.service" target="_blank" rel="noopener">&#39;/usr/lib/systemd/system/clamd@scan.service</a>‘ <a href="mailto:&#39;/etc/systemd/system/multi-user.target.wants/clamd@scan.service" target="_blank" rel="noopener">&#39;/etc/systemd/system/multi-user.target.wants/clamd@scan.service</a>‘<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果配置文件里面设置了开机启动，`systemctl enable`命令相当于激活开机启动。</span><br><span class="line"></span><br><span class="line">与之对应的，`systemctl disable`命令用于在两个目录之间，撤销符号链接关系，相当于撤销开机启动。</span><br></pre></td></tr></table></figure></p><p>$ sudo systemctl disable <a href="mailto:clamd@scan.service" target="_blank" rel="noopener">clamd@scan.service</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">配置文件的后缀名，就是该 Unit 的种类，比如`sshd.socket`。如果省略，Systemd 默认后缀名为`.service`，所以`sshd`会被理解成`sshd.service`。</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 配置文件的状态</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">`systemctl list-unit-files`命令用于列出所有配置文件。</span><br></pre></td></tr></table></figure></p><h1 id="列出所有配置文件"><a href="#列出所有配置文件" class="headerlink" title="列出所有配置文件"></a>列出所有配置文件</h1><p>$ systemctl list-unit-files<br>这个命令的执行结果一共有4中状态.分别是:</p><p>enabled：已建立启动链接<br>disabled：没建立启动链接<br>static：该配置文件没有[Install]部分（无法执行），只能作为其他配置文件的依赖<br>masked：该配置文件被禁止建立启动链接</p><h1 id="列出指定类型的配置文件"><a href="#列出指定类型的配置文件" class="headerlink" title="列出指定类型的配置文件"></a>列出指定类型的配置文件</h1><p>$ systemctl list-unit-files –type=service</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">### 配置文件的格式</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">配置文件就是普通的文本文件，可以用文本编辑器打开。</span><br><span class="line"></span><br><span class="line">`systemctl cat`命令可以查看配置文件的内容。</span><br></pre></td></tr></table></figure><p>$ systemctl cat atd.service</p><p>[Unit]<br>Description=ATD daemon</p><p>[Service]<br>Type=forking<br>ExecStart=/usr/bin/atd</p><p>[Install]<br>WantedBy=multi-user.target<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">从上面的输出可以看到，配置文件分成几个区块。每个区块的第一行，是用方括号表示的区别名，比如`[Unit]`。</span><br><span class="line"></span><br><span class="line">&gt;  注意，配置文件的区块名和字段名，都是大小写敏感的。</span><br><span class="line"></span><br><span class="line">每个区块内部是一些等号连接的键值对。(注意，键值对的等号两侧不能有空格。)</span><br><span class="line"></span><br><span class="line">一旦修改配置文件，就要让 SystemD 重新加载配置文件，然后重新启动，否则修改不会生效。</span><br></pre></td></tr></table></figure></p><p>$ sudo systemctl daemon-reload<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 配置文件的区块</span><br><span class="line"></span><br><span class="line">`[Unit]`区块通常是配置文件的第一个区块，用来定义 Unit 的元数据，以及配置与其他 Unit 的关系。它的主要字段如下。</span><br></pre></td></tr></table></figure></p><p>Description：简短描述<br>Documentation：文档地址<br>Requires：当前 Unit 依赖的其他 Unit，如果它们没有运行，当前 Unit 会启动失败<br>Wants：与当前 Unit 配合的其他 Unit，如果它们没有运行，当前 Unit 不会启动失败<br>BindsTo：与Requires类似，它指定的 Unit 如果退出，会导致当前 Unit 停止运行<br>Before：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之后启动<br>After：如果该字段指定的 Unit 也要启动，那么必须在当前 Unit 之前启动<br>Conflicts：这里指定的 Unit 不能与当前 Unit 同时运行<br>Condition…：当前 Unit 运行必须满足的条件，否则不会运行<br>Assert…：当前 Unit 运行必须满足的条件，否则会报启动失败<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`[Install]`通常是配置文件的最后一个区块，用来定义如何启动，以及是否开机启动。它的主要字段如下。</span><br></pre></td></tr></table></figure></p><p>WantedBy：它的值是一个或多个 Target，当前 Unit 激活时（enable）符号链接会放入/etc/systemd/system目录下面以 Target 名 + .wants后缀构成的子目录中<br>RequiredBy：它的值是一个或多个 Target，当前 Unit 激活时，符号链接会放入/etc/systemd/system目录下面以 Target 名 + .required后缀构成的子目录中<br>Alias：当前 Unit 可用于启动的别名<br>Also：当前 Unit 激活（enable）时，会被同时激活的其他 Unit<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`[Service]`区块用来 Service 的配置，只有 Service 类型的 Unit 才有这个区块。它的主要字段如下。</span><br></pre></td></tr></table></figure></p><p>Type：定义启动时的进程行为。它有以下几种值。<br>Type=simple：默认值，执行ExecStart指定的命令，启动主进程<br>Type=forking：以 fork 方式从父进程创建子进程，创建后父进程会立即退出<br>Type=oneshot：一次性进程，Systemd 会等当前服务退出，再继续往下执行<br>Type=dbus：当前服务通过D-Bus启动<br>Type=notify：当前服务启动完毕，会通知Systemd，再继续往下执行<br>Type=idle：若有其他任务执行完毕，当前服务才会运行<br>ExecStart：启动当前服务的命令<br>ExecStartPre：启动当前服务之前执行的命令<br>ExecStartPost：启动当前服务之后执行的命令<br>ExecReload：重启当前服务时执行的命令<br>ExecStop：停止当前服务时执行的命令<br>ExecStopPost：停止当其服务之后执行的命令<br>RestartSec：自动重启当前服务间隔的秒数<br>Restart：定义何种情况 Systemd 会自动重启当前服务，可能的值包括always（总是重启）、on-success、on-failure、on-abnormal、on-abort、on-watchdog<br>TimeoutSec：定义 Systemd 停止当前服务之前等待的秒数<br>Environment：指定环境变量<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Unit 配置文件的完整字段清单，请参考[官方文档](https://www.freedesktop.org/software/systemd/man/systemd.unit.html)</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 四.Target</span><br><span class="line"></span><br><span class="line">启动计算机的时候，需要启动大量的 Unit。如果每一次启动，都要一一写明本次启动需要哪些 Unit，显然非常不方便。Systemd 的解决方案就是 Target。</span><br><span class="line"></span><br><span class="line">简单说，Target 就是一个 Unit 组，包含许多相关的 Unit 。启动某个 Target 的时候，Systemd 就会启动里面所有的 Unit。从这个意义上说，Target 这个概念类似于&quot;状态点&quot;，启动某个 Target 就好比启动到某种状态。</span><br><span class="line"></span><br><span class="line">传统的`init`启动模式里面，有 RunLevel 的概念，跟 Target 的作用很类似。不同的是，RunLevel 是互斥的，不可能多个 RunLevel 同时启动，但是多个 Target 可以同时启动。</span><br></pre></td></tr></table></figure></p><h1 id="查看当前系统的所有-Target"><a href="#查看当前系统的所有-Target" class="headerlink" title="查看当前系统的所有 Target"></a>查看当前系统的所有 Target</h1><p>$ systemctl list-unit-files –type=target</p><h1 id="查看一个-Target-包含的所有-Unit"><a href="#查看一个-Target-包含的所有-Unit" class="headerlink" title="查看一个 Target 包含的所有 Unit"></a>查看一个 Target 包含的所有 Unit</h1><p>$ systemctl list-dependencies multi-user.target</p><h1 id="查看启动时的默认-Target"><a href="#查看启动时的默认-Target" class="headerlink" title="查看启动时的默认 Target"></a>查看启动时的默认 Target</h1><p>$ systemctl get-default</p><h1 id="设置启动时的默认-Target"><a href="#设置启动时的默认-Target" class="headerlink" title="设置启动时的默认 Target"></a>设置启动时的默认 Target</h1><p>$ sudo systemctl set-default multi-user.target</p><h1 id="切换-Target-时，默认不关闭前一个-Target-启动的进程，"><a href="#切换-Target-时，默认不关闭前一个-Target-启动的进程，" class="headerlink" title="切换 Target 时，默认不关闭前一个 Target 启动的进程，"></a>切换 Target 时，默认不关闭前一个 Target 启动的进程，</h1><h1 id="systemctl-isolate-命令改变这种行为，"><a href="#systemctl-isolate-命令改变这种行为，" class="headerlink" title="systemctl isolate 命令改变这种行为，"></a>systemctl isolate 命令改变这种行为，</h1><h1 id="关闭前一个-Target-里面所有不属于后一个-Target-的进程"><a href="#关闭前一个-Target-里面所有不属于后一个-Target-的进程" class="headerlink" title="关闭前一个 Target 里面所有不属于后一个 Target 的进程"></a>关闭前一个 Target 里面所有不属于后一个 Target 的进程</h1><p>$ sudo systemctl isolate multi-user.target<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">Target 与 传统 RunLevel 的对应关系如下。</span><br></pre></td></tr></table></figure></p><p>Traditional runlevel      New target name     Symbolically linked to…</p><p>Runlevel 0           |    runlevel0.target -&gt; poweroff.target<br>Runlevel 1           |    runlevel1.target -&gt; rescue.target<br>Runlevel 2           |    runlevel2.target -&gt; multi-user.target<br>Runlevel 3           |    runlevel3.target -&gt; multi-user.target<br>Runlevel 4           |    runlevel4.target -&gt; multi-user.target<br>Runlevel 5           |    runlevel5.target -&gt; graphical.target<br>Runlevel 6           |    runlevel6.target -&gt; reboot.target<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">它与`init`进程的主要差别如下。</span><br></pre></td></tr></table></figure></p><p>（1）默认的 RunLevel（在/etc/inittab文件设置）现在被默认的 Target 取代，位置是/etc/systemd/system/default.target，通常符号链接到graphical.target（图形界面）或者multi-user.target（多用户命令行）。</p><p>（2）启动脚本的位置，以前是/etc/init.d目录，符号链接到不同的 RunLevel 目录 （比如/etc/rc3.d、/etc/rc5.d等），现在则存放在/lib/systemd/system和/etc/systemd/system目录。</p><p>（3）配置文件的位置，以前init进程的配置文件是/etc/inittab，各种服务的配置文件存放在/etc/sysconfig目录。现在的配置文件主要存放在/lib/systemd目录，在/etc/systemd目录里面的修改可以覆盖原始设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">## 五.日志管理 </span><br><span class="line"></span><br><span class="line">Systemd 统一管理所有 Unit 的启动日志。带来的好处就是，可以只用`journalctl`一个命令，查看所有日志（内核日志和应用日志）。日志的配置文件是`/etc/systemd/journald.conf`。</span><br><span class="line"></span><br><span class="line">`journalctl`功能强大，用法非常多。</span><br></pre></td></tr></table></figure></p><h1 id="查看所有日志（默认情况下-，只保存本次启动的日志）"><a href="#查看所有日志（默认情况下-，只保存本次启动的日志）" class="headerlink" title="查看所有日志（默认情况下 ，只保存本次启动的日志）"></a>查看所有日志（默认情况下 ，只保存本次启动的日志）</h1><p>$ sudo journalctl</p><h1 id="查看内核日志（不显示应用日志）"><a href="#查看内核日志（不显示应用日志）" class="headerlink" title="查看内核日志（不显示应用日志）"></a>查看内核日志（不显示应用日志）</h1><p>$ sudo journalctl -k</p><h1 id="查看系统本次启动的日志"><a href="#查看系统本次启动的日志" class="headerlink" title="查看系统本次启动的日志"></a>查看系统本次启动的日志</h1><p>$ sudo journalctl -b<br>$ sudo journalctl -b -0</p><h1 id="查看上一次启动的日志（需更改设置）"><a href="#查看上一次启动的日志（需更改设置）" class="headerlink" title="查看上一次启动的日志（需更改设置）"></a>查看上一次启动的日志（需更改设置）</h1><p>$ sudo journalctl -b -1</p><h1 id="查看指定时间的日志"><a href="#查看指定时间的日志" class="headerlink" title="查看指定时间的日志"></a>查看指定时间的日志</h1><p>$ sudo journalctl –since=”2012-10-30 18:17:16”<br>$ sudo journalctl –since “20 min ago”<br>$ sudo journalctl –since yesterday<br>$ sudo journalctl –since “2015-01-10” –until “2015-01-11 03:00”<br>$ sudo journalctl –since 09:00 –until “1 hour ago”</p><h1 id="显示尾部的最新10行日志"><a href="#显示尾部的最新10行日志" class="headerlink" title="显示尾部的最新10行日志"></a>显示尾部的最新10行日志</h1><p>$ sudo journalctl -n</p><h1 id="显示尾部指定行数的日志"><a href="#显示尾部指定行数的日志" class="headerlink" title="显示尾部指定行数的日志"></a>显示尾部指定行数的日志</h1><p>$ sudo journalctl -n 20</p><h1 id="实时滚动显示最新日志"><a href="#实时滚动显示最新日志" class="headerlink" title="实时滚动显示最新日志"></a>实时滚动显示最新日志</h1><p>$ sudo journalctl -f</p><h1 id="查看指定服务的日志"><a href="#查看指定服务的日志" class="headerlink" title="查看指定服务的日志"></a>查看指定服务的日志</h1><p>$ sudo journalctl /usr/lib/systemd/systemd</p><h1 id="查看指定进程的日志"><a href="#查看指定进程的日志" class="headerlink" title="查看指定进程的日志"></a>查看指定进程的日志</h1><p>$ sudo journalctl _PID=1</p><h1 id="查看某个路径的脚本的日志"><a href="#查看某个路径的脚本的日志" class="headerlink" title="查看某个路径的脚本的日志"></a>查看某个路径的脚本的日志</h1><p>$ sudo journalctl /usr/bin/bash</p><h1 id="查看指定用户的日志"><a href="#查看指定用户的日志" class="headerlink" title="查看指定用户的日志"></a>查看指定用户的日志</h1><p>$ sudo journalctl _UID=33 –since today</p><h1 id="查看某个-Unit-的日志"><a href="#查看某个-Unit-的日志" class="headerlink" title="查看某个 Unit 的日志"></a>查看某个 Unit 的日志</h1><p>$ sudo journalctl -u nginx.service<br>$ sudo journalctl -u nginx.service –since today</p><h1 id="实时滚动显示某个-Unit-的最新日志"><a href="#实时滚动显示某个-Unit-的最新日志" class="headerlink" title="实时滚动显示某个 Unit 的最新日志"></a>实时滚动显示某个 Unit 的最新日志</h1><p>$ sudo journalctl -u nginx.service -f</p><h1 id="合并显示多个-Unit-的日志"><a href="#合并显示多个-Unit-的日志" class="headerlink" title="合并显示多个 Unit 的日志"></a>合并显示多个 Unit 的日志</h1><p>$ journalctl -u nginx.service -u php-fpm.service –since today</p><h1 id="查看指定优先级（及其以上级别）的日志，共有8级"><a href="#查看指定优先级（及其以上级别）的日志，共有8级" class="headerlink" title="查看指定优先级（及其以上级别）的日志，共有8级"></a>查看指定优先级（及其以上级别）的日志，共有8级</h1><h1 id="0-emerg"><a href="#0-emerg" class="headerlink" title="0: emerg"></a>0: emerg</h1><h1 id="1-alert"><a href="#1-alert" class="headerlink" title="1: alert"></a>1: alert</h1><h1 id="2-crit"><a href="#2-crit" class="headerlink" title="2: crit"></a>2: crit</h1><h1 id="3-err"><a href="#3-err" class="headerlink" title="3: err"></a>3: err</h1><h1 id="4-warning"><a href="#4-warning" class="headerlink" title="4: warning"></a>4: warning</h1><h1 id="5-notice"><a href="#5-notice" class="headerlink" title="5: notice"></a>5: notice</h1><h1 id="6-info"><a href="#6-info" class="headerlink" title="6: info"></a>6: info</h1><h1 id="7-debug"><a href="#7-debug" class="headerlink" title="7: debug"></a>7: debug</h1><p>$ sudo journalctl -p err -b</p><h1 id="日志默认分页输出，–no-pager-改为正常的标准输出"><a href="#日志默认分页输出，–no-pager-改为正常的标准输出" class="headerlink" title="日志默认分页输出，–no-pager 改为正常的标准输出"></a>日志默认分页输出，–no-pager 改为正常的标准输出</h1><p>$ sudo journalctl –no-pager</p><h1 id="以-JSON-格式（单行）输出"><a href="#以-JSON-格式（单行）输出" class="headerlink" title="以 JSON 格式（单行）输出"></a>以 JSON 格式（单行）输出</h1><p>$ sudo journalctl -b -u nginx.service -o json</p><h1 id="以-JSON-格式（多行）输出，可读性更好"><a href="#以-JSON-格式（多行）输出，可读性更好" class="headerlink" title="以 JSON 格式（多行）输出，可读性更好"></a>以 JSON 格式（多行）输出，可读性更好</h1><p>$ sudo journalctl -b -u nginx.serviceqq<br> -o json-pretty</p><h1 id="显示日志占据的硬盘空间"><a href="#显示日志占据的硬盘空间" class="headerlink" title="显示日志占据的硬盘空间"></a>显示日志占据的硬盘空间</h1><p>$ sudo journalctl –disk-usage</p><h1 id="指定日志文件占据的最大空间"><a href="#指定日志文件占据的最大空间" class="headerlink" title="指定日志文件占据的最大空间"></a>指定日志文件占据的最大空间</h1><p>$ sudo journalctl –vacuum-size=1G</p><h1 id="指定日志文件保存多久"><a href="#指定日志文件保存多久" class="headerlink" title="指定日志文件保存多久"></a>指定日志文件保存多久</h1><p>$ sudo journalctl –vacuum-time=1years<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title:systemd介绍&lt;br&gt;date:2018-06-15 15:59:58&lt;br&gt;tags:systemd&lt;br&gt;categories:[Linux-Service ]&lt;br&gt;comments:true&lt;/p&gt;
&lt;h2 id=&quot;copyright-true&quot;&gt;&lt;a href=&quot;#copyright-true&quot; class=&quot;headerlink&quot; title=&quot;copyright:true&quot;&gt;&lt;/a&gt;copyright:true&lt;/h2&gt;&lt;h1 id=&quot;systemd介绍&quot;&gt;&lt;a href=&quot;#systemd介绍&quot; class=&quot;headerlink&quot; title=&quot;systemd介绍&quot;&gt;&lt;/a&gt;systemd介绍&lt;/h1&gt;&lt;p&gt;systemd并不是一个命令,而是一组命令,涉及到系统管理的方方面面.以下是systemd的架构图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://www.ruanyifeng.com/blogimg/asset/2016/bg2016030703.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;hr&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jesse.top/2020/06/26/Linux-Web/nginx%E5%AE%89%E8%A3%85Lua%E6%A8%A1%E5%9D%97/"/>
    <id>https://jesse.top/2020/06/26/Linux-Web/nginx安装Lua模块/</id>
    <published>2020-06-26T04:13:21.631Z</published>
    <updated>2020-06-26T02:51:49.552Z</updated>
    
    <content type="html"><![CDATA[<h2 id="安装Lua模块"><a href="#安装Lua模块" class="headerlink" title="安装Lua模块"></a>安装Lua模块</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>nginx编译安装lua模块方法,在网上能搜到许多的文档.但是都千篇一律.根据笔者的实际配置经历,网上的文档在我们的服务器上编译会报错,原因是nginx的lua模块版本(网上文档都是采用v0.10.11版本的lua-nginx-module模块)和nginx不兼容,我尝试过Nginx1.12,1.13,1.17等多个版本均无法安装.</p><p>所以笔者最终采用的的lua-nginx-module模块是0.10.9rc7版本,这才成功编译安装lua模块.</p><blockquote><p> 编译过程中虽然会覆盖现有Nginx,但是基本上属于平滑过渡,不会影响Nginx正常运行.</p></blockquote><hr><h4 id="服务器现有环境介绍"><a href="#服务器现有环境介绍" class="headerlink" title="服务器现有环境介绍:"></a>服务器现有环境介绍:</h4><p>1.nginx版本:1.12</p><p>2.nginx安装方式: yum安装</p><hr><h4 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤:"></a>安装步骤:</h4><h5 id="1-安装luaJIT模块"><a href="#1-安装luaJIT模块" class="headerlink" title="1.安装luaJIT模块"></a>1.安装luaJIT模块</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line">wget http://luajit.org/download/LuaJIT-2.1.0-beta2.tar.gz</span><br><span class="line">tar zxf LuaJIT-2.1.0-beta2.tar.gz</span><br><span class="line">cd LuaJIT-2.1.0-beta2</span><br><span class="line"></span><br><span class="line">make PREFIX=/usr/local/luajit</span><br><span class="line">make install PREFIX=/usr/local/luajit</span><br></pre></td></tr></table></figure><h5 id="2-安装ngx-devel-kit模块"><a href="#2-安装ngx-devel-kit模块" class="headerlink" title="2.安装ngx_devel_kit模块"></a>2.安装ngx_devel_kit模块</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line">wget https://github.com/simpl/ngx_devel_kit/archive/v0.2.19.tar.gz</span><br><span class="line">tar -xzvf v0.2.19.tar.gz</span><br></pre></td></tr></table></figure><h5 id="3-安装nginx-lua模块-注意-最好是0-10-9rc7版本"><a href="#3-安装nginx-lua模块-注意-最好是0-10-9rc7版本" class="headerlink" title="3. 安装nginx_lua模块,注意,最好是0.10.9rc7版本"></a>3. 安装nginx_lua模块,注意,最好是0.10.9rc7版本</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /usr/local/src</span><br><span class="line">wget https://github.com/openresty/lua-nginx-module/archive/v0.10.9rc7tar.gz</span><br><span class="line">tar -zxvf v0.10.9rc7.tar.gz</span><br></pre></td></tr></table></figure><h5 id="4-执行下列命令"><a href="#4-执行下列命令" class="headerlink" title="4. 执行下列命令"></a>4. 执行下列命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo echo &quot;export LUAJIT_LIB=/usr/local/luajit/lib&quot; &gt;&gt; /etc/profile</span><br><span class="line">sudo echo &quot;export LUAJIT_INC=/usr/local/luajit/include/luajit-2.1&quot; &gt;&gt; /etc/profile</span><br></pre></td></tr></table></figure><h5 id="5-查看当前nginx模块环境"><a href="#5-查看当前nginx模块环境" class="headerlink" title="5.查看当前nginx模块环境"></a>5.查看当前nginx模块环境</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">nginx -V</span><br><span class="line"></span><br><span class="line">configure arguments: --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-compat --with-file-aio --with-threads --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --with-cc-opt=&apos;-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -m64 -mtune=generic -fPIC&apos; --with-ld-opt=&apos;-Wl,-z,relro -Wl,-z,now -pie&apos;</span><br></pre></td></tr></table></figure><h5 id="6-下载1-17版本的nginx源码-也可以使用其他版本的Nginx"><a href="#6-下载1-17版本的nginx源码-也可以使用其他版本的Nginx" class="headerlink" title="6.下载1.17版本的nginx源码(也可以使用其他版本的Nginx)"></a>6.下载1.17版本的nginx源码(也可以使用其他版本的Nginx)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cd ~/</span><br><span class="line">wget &apos;http://nginx.org/download/nginx-1.17.0.tar.gz&apos;</span><br><span class="line">tar -zxvf nginx-1.17.0.tar.gz</span><br><span class="line">cd nginx-1.17.0</span><br></pre></td></tr></table></figure><h5 id="7-重新编译nginx-在第五步的nginx编译参数最后加上下面lua编译参数"><a href="#7-重新编译nginx-在第五步的nginx编译参数最后加上下面lua编译参数" class="headerlink" title="7.重新编译nginx.在第五步的nginx编译参数最后加上下面lua编译参数"></a>7.重新编译nginx.在第五步的nginx编译参数最后加上下面lua编译参数</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">--add-module=/usr/local/src/ngx_devel_kit-0.2.19 --add-module=/usr/local/src/lua-nginx-module-0.10.9rc7</span><br><span class="line"></span><br><span class="line">#编译完后开始安装</span><br><span class="line">make -j2</span><br><span class="line">make install</span><br></pre></td></tr></table></figure><h5 id="8-检查nginx-版本和模块"><a href="#8-检查nginx-版本和模块" class="headerlink" title="8 检查nginx 版本和模块"></a>8 检查nginx 版本和模块</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#检查Nginx新版本</span><br><span class="line">[work@rainbow ~]$ nginx -v</span><br><span class="line">nginx version: nginx/1.17.0</span><br><span class="line"></span><br><span class="line">#检查lua模块是否生效.最后2行表示lua模块已经编译到Nginx中</span><br><span class="line">[work@rainbow ~]$ nginx -V</span><br><span class="line">nginx version: nginx/1.17.0</span><br><span class="line">built by gcc 4.8.5 20150623 (Red Hat 4.8.5-36) (GCC)</span><br><span class="line">built with OpenSSL 1.0.2k-fips  26 Jan 2017</span><br><span class="line">TLS SNI support enabled</span><br><span class="line">configure arguments: --prefix=/etc/nginx --sbin-path=/usr/sbin/nginx --modules-path=/usr/lib64/nginx/modules --conf-path=/etc/nginx/nginx.conf --error-log-path=/var/log/nginx/error.log --http-log-path=/var/log/nginx/access.log --pid-path=/var/run/nginx.pid --lock-path=/var/run/nginx.lock --http-client-body-temp-path=/var/cache/nginx/client_temp --http-proxy-temp-path=/var/cache/nginx/proxy_temp --http-fastcgi-temp-path=/var/cache/nginx/fastcgi_temp --http-uwsgi-temp-path=/var/cache/nginx/uwsgi_temp --http-scgi-temp-path=/var/cache/nginx/scgi_temp --user=nginx --group=nginx --with-compat --with-file-aio --with-threads --with-http_addition_module --with-http_auth_request_module --with-http_dav_module --with-http_flv_module --with-http_gunzip_module --with-http_gzip_static_module --with-http_mp4_module --with-http_random_index_module --with-http_realip_module --with-http_secure_link_module --with-http_slice_module --with-http_ssl_module --with-http_stub_status_module --with-http_sub_module --with-http_v2_module --with-mail --with-mail_ssl_module --with-stream --with-stream_realip_module --with-stream_ssl_module --with-stream_ssl_preread_module --with-cc-opt=&apos;-O2 -g -pipe -Wall -Wp,-D_FORTIFY_SOURCE=2 -fexceptions -fstack-protector-strong --param=ssp-buffer-size=4 -grecord-gcc-switches -m64 -mtune=generic -fPIC&apos; --with-ld-opt=&apos;-Wl,-z,relro -Wl,-z,now -pie&apos; --add-module=/usr/local/src/ngx_devel_kit-0.2.19 --add-module=/usr/local/lua-nginx-module-0.10.9rc7</span><br></pre></td></tr></table></figure><h5 id="9-如果上一步执行有问题则执行下列命令"><a href="#9-如果上一步执行有问题则执行下列命令" class="headerlink" title="9.如果上一步执行有问题则执行下列命令"></a>9.如果上一步执行有问题则执行下列命令</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;/usr/local/LuaJIT/lib&quot; &gt;&gt; /etc/ld.so.conf</span><br><span class="line">ldconfig</span><br></pre></td></tr></table></figure><h5 id="10-测试lua是否支持"><a href="#10-测试lua是否支持" class="headerlink" title="10.测试lua是否支持"></a>10.测试lua是否支持</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">在Nginx配置文件中加入下列配置</span><br><span class="line"></span><br><span class="line">location /hello_lua &#123; </span><br><span class="line">      default_type &apos;text/plain&apos;; </span><br><span class="line">      content_by_lua &apos;ngx.say(&quot;hello, lua&quot;)&apos;; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#访问nginx测试是否返回hello lua</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;安装Lua模块&quot;&gt;&lt;a href=&quot;#安装Lua模块&quot; class=&quot;headerlink&quot; title=&quot;安装Lua模块&quot;&gt;&lt;/a&gt;安装Lua模块&lt;/h2&gt;&lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jesse.top/2020/06/26/experience/net.ipv4.tcp_tw_recycle%E8%B8%A9%E7%9A%84%E5%9D%91/"/>
    <id>https://jesse.top/2020/06/26/experience/net.ipv4.tcp_tw_recycle踩的坑/</id>
    <published>2020-06-26T04:09:07.903Z</published>
    <updated>2020-06-26T06:49:51.094Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title:net.ipv4.tcp_tw_recycle踩的坑<br>date:2019-01-7 09:59:58<br>tags:experence<br>categories:experence<br>comments:true</p><h2 id="copyright-true"><a href="#copyright-true" class="headerlink" title="copyright:true"></a>copyright:true</h2><h2 id="net-ipv4-tcp-tw-recycle踩的坑"><a href="#net-ipv4-tcp-tw-recycle踩的坑" class="headerlink" title="net.ipv4.tcp_tw_recycle踩的坑"></a>net.ipv4.tcp_tw_recycle踩的坑</h2><p>参考博文:<a href="https://www.cnxct.com/coping-with-the-tcp-time_wait-state-on-busy-linux-servers-in-chinese-and-dont-enable-tcp_tw_recycle/" target="_blank" rel="noopener">https://www.cnxct.com/coping-with-the-tcp-time_wait-state-on-busy-linux-servers-in-chinese-and-dont-enable-tcp_tw_recycle/</a></p><p>在做系统调优的时候希望能加快<code>TIME_WAIT</code>状态的回收，通常将<code>net.ipv4.tcp_tw_recycle</code>选项开启，但是,请注意这里有个坑</p><h3 id="故障现象"><a href="#故障现象" class="headerlink" title="故障现象"></a>故障现象</h3><p>我们阿里云上有一台BETA测试服务器自从上次将CPU配置从4核升级到8核,然后重启服务器以后..访问该服务器上的web网站经常出现卡顿的现象,大概是每隔几分钟出现一次,很快又恢复.</p><p>1.初步怀疑是BETA服务器性能不行,包括后端数据库拥挤导致</p><p>但是经过排查发现,故障发生时,服务器性能没有任何压力,后端数据库也正常.</p><p>2.在服务器上创建一个hello world 的静态网站,发现连静态网站都无法访问.</p><p>在访问网站的时候,长时间停留在TCP_NODELAY set阶段:</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$curl -vvv &quot;http://test.beta.haoshiqi.net&quot;</span><br><span class="line">* About to connect() to opadmin.beta.haoshiqi.net port 80 (#0)</span><br><span class="line">*   Trying 114.55.108.51...</span><br><span class="line">* TCP_NODELAY set</span><br></pre></td></tr></table></figure><p>通过telnet工具发现BETA服务器的80端口不通.</p><ol start="3"><li>转而怀疑是办公室网络问题.</li></ol><p>但是办公室访问其他阿里云服务器,访问线上环境,日常办公访问互联网又一切正常,在使用mtr,traceroute等工具排查路径节点时也一切正常,没有丢包线下.ping BETA服务器也没有任何丢包现象.</p><ol start="4"><li>转而怀疑是BETA服务器问题.</li></ol><p>但是在办公室网络访问出现故障时的同一时间,其他阿里云服务器访问BETA服务器上的网站又是一切正常,没有任何故障.用手机4G网络访问BETA也一切正常.</p><p>其他线索:</p><p>在晚上下班后,BETA服务器没有访问量时,从办公室访问BETA服务器一切正常,故障没有复现</p><p>5.经过抓包发现客户端发出了大量的TCP重传,但是服务器没有回应SYN报文.</p><p>BETA服务端tcpdump抓包命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -s 0 -i eth1 host 27.115.51.166 -w /tmp/beta_server.cap</span><br></pre></td></tr></table></figure><p>客户端本地tcpdump抓包命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo tcpdump -s 0 -i en4 host 114.55.108.51 -w ~/Desktop/beta.cap</span><br></pre></td></tr></table></figure><p>当故障出现时，服务器端其实是已经接送到TCP三次握手的SYN包，但不回应ACK给客户端，导致客户端一直处于等待状态.</p><hr><h3 id="原因分析"><a href="#原因分析" class="headerlink" title="原因分析"></a>原因分析</h3><p>后来发现是系统内核优化时,开启了net.ipv4.tcp_tw_recycle参数.这个参数用来优化快速回收TIME_WAIT的socket.但是默认tcp_timestamps也是开启的.当开启了<code>tcp_tw_recycle和timestamps选项后，当连接进入</code>TIME_WAIT`状态后，会记录对应远端主机最后到达分节的时间戳。如果同样的主机有新的分节到达，且时间戳小于之前记录的时间戳，即视为无效，相应的数据包会被丢弃;</p><p>我们的BETA服务器在上班时间使用比较频繁.这也导致了在上班时间内一个公网IP（经过NAT）大量地去反问服务器，不同客户端的时间可能不一致，所以就会出现时间戳错乱的现象，于是后面的数据包就被丢弃了，具体的表现通常是是客户端明明发送的SYN，但服务端就是不响应ACK.</p><hr><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>很多时候我们在做系统调优的情况时，都是直接在网上看一堆的内核参数，然后直接使用，却没有仔细研究过，很多时候，坑只有是自己拆过后才能记住，像这次这个<code>net.ipv4.tcp_tw_recycle</code>故障网上很多分享，看过和自己碰到过还真不一样，好记性不如烂笔头，慢慢记录，慢慢积累，坑应该会越来越少的；</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;p&gt;title:net.ipv4.tcp_tw_recycle踩的坑&lt;br&gt;date:2019-01-7 09:59:58&lt;br&gt;tags:experence&lt;br&gt;categories:experence&lt;br&gt;comments:true&lt;/p&gt;
&lt;h2 id=&quot;copyright-true&quot;&gt;&lt;a href=&quot;#copyright-true&quot; class=&quot;headerlink&quot; title=&quot;copyright:true&quot;&gt;&lt;/a&gt;copyright:true&lt;/h2&gt;&lt;h2 id=&quot;net-ipv4-tcp-tw-recycle踩的坑&quot;&gt;&lt;a href=&quot;#net-ipv4-tcp-tw-recycle踩的坑&quot; class=&quot;headerlink&quot; title=&quot;net.ipv4.tcp_tw_recycle踩的坑&quot;&gt;&lt;/a&gt;net.ipv4.tcp_tw_recycle踩的坑&lt;/h2&gt;&lt;p&gt;参考博文:&lt;a href=&quot;https://www.cnxct.com/coping-with-the-tcp-time_wait-state-on-busy-linux-servers-in-chinese-and-dont-enable-tcp_tw_recycle/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnxct.com/coping-with-the-tcp-time_wait-state-on-busy-linux-servers-in-chinese-and-dont-enable-tcp_tw_recycle/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在做系统调优的时候希望能加快&lt;code&gt;TIME_WAIT&lt;/code&gt;状态的回收，通常将&lt;code&gt;net.ipv4.tcp_tw_recycle&lt;/code&gt;选项开启，但是,请注意这里有个坑&lt;/p&gt;
&lt;h3 id=&quot;故障现象&quot;&gt;&lt;a href=&quot;#故障现象&quot; class=&quot;headerlink&quot; title=&quot;故障现象&quot;&gt;&lt;/a&gt;故障现象&lt;/h3&gt;&lt;p&gt;我们阿里云上有一台BETA测试服务器自从上次将CPU配置从4核升级到8核,然后重启服务器以后..访问该服务器上的web网站经常出现卡顿的现象,大概是每隔几分钟出现一次,很快又恢复.&lt;/p&gt;
&lt;p&gt;1.初步怀疑是BETA服务器性能不行,包括后端数据库拥挤导致&lt;/p&gt;
&lt;p&gt;但是经过排查发现,故障发生时,服务器性能没有任何压力,后端数据库也正常.&lt;/p&gt;
&lt;p&gt;2.在服务器上创建一个hello world 的静态网站,发现连静态网站都无法访问.&lt;/p&gt;
&lt;p&gt;在访问网站的时候,长时间停留在TCP_NODELAY set阶段:&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kong+casssandra集群环境部署</title>
    <link href="https://jesse.top/2020/06/26/Linux-Web/kong%20casssandra%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    <id>https://jesse.top/2020/06/26/Linux-Web/kong casssandra集群环境部署/</id>
    <published>2020-06-26T03:59:58.000Z</published>
    <updated>2020-06-26T03:07:42.986Z</updated>
    
    <content type="html"><![CDATA[<h2 id="kong-casssandra集群环境部署"><a href="#kong-casssandra集群环境部署" class="headerlink" title="kong+casssandra集群环境部署"></a>kong+casssandra集群环境部署</h2><h3 id="kong简介"><a href="#kong简介" class="headerlink" title="kong简介"></a>kong简介</h3><p>Kong是Mashape开源的一款API网关，起初是用来管理 Mashape 公司15000个微服务的，后来在2015年开源,现在已经在很多创业公司、大型企业和政府机构中广泛使用。基于nginx,Lua和Cassandra或PostgreSQL，支持分布式操作，有很强的可移植性和可扩展性。可以在任何一种基础设施上运行,作为应用和API之间的中间层，加上众多功能强大的插件，可以实现认证授权、访问控制等功能。并且提供易于使用的RESTful API来操作和配置系统。</p><p>有关kong的详细介绍请参考官网.</p><p>–</p><h3 id="cassandra简介"><a href="#cassandra简介" class="headerlink" title="cassandra简介"></a>cassandra简介</h3><p>Cassandra 是一个来自 Apache 的分布式数据库，具有高度可扩展性，可用于管理大量的结构化数据。它提供了高可用性，没有单点故障。kong支持PostgreSQL或者Cassandra两种数据库.这里我们选择了cassandra.</p><p>有关cassandra的详细介绍和使用方法.请参考官网</p><a id="more"></a><p>–</p><h3 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h3><ul><li><strong>kong cluster</strong></li></ul><p>kong 集群并不意味着客户端请求将会负载均衡到kong集群中的每个节点上，kong集群并不是开箱即用，仍然需要在kong集群多节点上层搭建负载均衡，以便分发请求。 一个kong集群只是意味着集群内的节点，都共享同样的配置。</p><p>有关Kong cluster集群的详细介绍请参考官网:<a href="https://docs.konghq.com/0.14.x/clustering/" target="_blank" rel="noopener">Kong cluser document</a></p><p>为了提高冗余性和健壮性.我们对kong的每个环节都进行了冗余设计.一个基本的kong集群架构大概如下图所示:</p><p><img src="http://pabkmteb4.bkt.clouddn.com/kong-flow.png" alt=""></p><p>–</p><h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3><p><strong>环境</strong>: </p><p>阿里云ECS Centos7.4操作系统<br>Kong: 0.14 最新版<br>Cassandra: 3.11 最新版</p><p>–</p><h4 id="安装Cassandra"><a href="#安装Cassandra" class="headerlink" title="安装Cassandra"></a>安装Cassandra</h4><p>安装方式官网参考: <a href="http://cassandra.apache.org/doc/latest/getting_started/installing.html#installation-from-binary-tarball-files" target="_blank" rel="noopener">Installing Cassandra</a></p><p><strong>安装前提条件</strong></p><p>1.安装JDK 8版本<br>2.安装2.7以上版本的Python.(cassandra管理工具:cqlsh 需要python2.7以上环境)</p><p><strong>安装步骤</strong></p><p>1.下载cassandra二进制文件.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirrors.tuna.tsinghua.edu.cn/apache/cassandra/3.11.3/apache-cassandra-3.11.3-bin.tar.gz</span><br></pre></td></tr></table></figure><p>2.将cassandra目录添加进环境变量.用work用户运行cassandra</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /usr/local/cassandra</span><br><span class="line">sudo chown -R work:work /usr/local/cassandra</span><br><span class="line">sudo tar -xvf apache-cassandra-3.11.3-bin.tar.gz -C /usr/local/cassandra</span><br><span class="line"></span><br><span class="line">cd /usr/local/cassandra</span><br><span class="line">sudo mv apache-cassandra-3.11.3/* .</span><br><span class="line">sudo rm apache-cassandra-3.11.3/ -rf</span><br></pre></td></tr></table></figure><p>添加进环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br><span class="line"></span><br><span class="line">export JAVA_HOME=/usr/local/java</span><br><span class="line">export CASSANDRA_HOME=/usr/local/cassandra</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$CASSANDRA_HOME/bin</span><br></pre></td></tr></table></figure><p>–</p><h4 id="配置Cassandra-以及cassandra集群"><a href="#配置Cassandra-以及cassandra集群" class="headerlink" title="配置Cassandra,以及cassandra集群"></a>配置Cassandra,以及cassandra集群</h4><p>1.编辑cassandra的cassandra.yml配置文件.修改下列配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 kong]$ vim /usr/local/cassandra/conf/cassandra.yaml</span><br><span class="line"></span><br><span class="line">#定义Cassandra集群名</span><br><span class="line">cluster_name: &apos;dwd_cassandra&apos;</span><br><span class="line">#定义hints路径.可以使用默认路径</span><br><span class="line">hints_directory: /data/cassandra/hints</span><br><span class="line"></span><br><span class="line">#采用密码方式连接数据库.默认情况下不需要任何用户密码就可以登录数据库</span><br><span class="line">authenticator: PasswordAuthenticator</span><br><span class="line"></span><br><span class="line">#定义数据库文件路径.可以使用默认/var/lib路径</span><br><span class="line">data_file_directories:</span><br><span class="line">      - /data/cassandra</span><br><span class="line"></span><br><span class="line">#定义commit日志路径.可以使用默认路径</span><br><span class="line">commitlog_directory: /data/cassandra/commitlog</span><br><span class="line"></span><br><span class="line">#缓存文件路径</span><br><span class="line">saved_caches_directory: /data/cassandra/saved_caches</span><br><span class="line"></span><br><span class="line">#关键配置,定义集群种子服务器地址.这里定义服务器的内网地址.不能使用0.0.0.0或者127的本机地址,可以加入多个集群节点的地址,IP地址之间用逗号分隔</span><br><span class="line">- seeds: &quot;10.25.87.159&quot;</span><br><span class="line"></span><br><span class="line">#listen地址</span><br><span class="line">listen_address: 10.25.87.159</span><br><span class="line"></span><br><span class="line">#rpc地址</span><br><span class="line">rpc_address: 10.25.87.159</span><br></pre></td></tr></table></figure><p>2.创建刚才定义的路径目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -pv /data/cassandra </span><br><span class="line">sudo chown -R work.work /data/</span><br></pre></td></tr></table></figure><p>3.启动cassandra.直接在命令行执行cassandra</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 kong]$ cassandra </span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">[work@kong-node1 kong]$ /usr/local/cassandra/bin/cassandra</span><br></pre></td></tr></table></figure><ol start="4"><li>使用cqlsh工具登陆cassandra数据库.创建cassandra用户密码,以及创建键空间</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#注意由于cassandra只侦听了内网的地址,因此要指定IP地址.</span><br><span class="line">#默认账号密码都是cassandra</span><br><span class="line">[work@kong-node1 kong]$ cqlsh 10.25.87.159  -ucassandra -pcassandra </span><br><span class="line"></span><br><span class="line">#创建一个kong用户.并且为超级用户</span><br><span class="line">cassandra@cqlsh&gt; create user kong with password &apos;kong&apos; superuser;</span><br><span class="line"></span><br><span class="line">#创建一个keyspace.命名为kong</span><br><span class="line">cassandra@cqlsh&gt; CREATE KEYSPACE kong WITH REPLICATION = &#123; &apos;class&apos; : &apos;SimpleStrategy&apos;, &apos;replication_factor&apos; : 1&#125;;</span><br><span class="line"></span><br><span class="line">cassandra@cqlsh&gt; exit</span><br></pre></td></tr></table></figure><p>5.删除自带的cassandra用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 cassandra]$ cqlsh 10.25.87.159  -ukong -pkong</span><br><span class="line">kong@cqlsh&gt; desc kong;</span><br><span class="line"></span><br><span class="line">CREATE KEYSPACE kong WITH replication = &#123;&apos;class&apos;: &apos;SimpleStrategy&apos;, &apos;replication_factor&apos;: &apos;1&apos;&#125;  AND durable_writes = true;</span><br><span class="line"></span><br><span class="line">kong@cqlsh&gt; drop user cassandra;</span><br></pre></td></tr></table></figure><p>–</p><h4 id="安装Kong"><a href="#安装Kong" class="headerlink" title="安装Kong"></a>安装Kong</h4><p>安装方法可以参考官网:<a href="https://docs.konghq.com/install/centos/?_ga=2.110797315.728319704.1539597667-917309945.1539077269#packages" target="_blank" rel="noopener">Install Kong</a></p><p>1.下载,安装rpm安装包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget -O kong-community-edition-0.14.1.el7.noarch.rpm  https://bintray.com/kong/kong-community-edition-rpm/download_file?file_path=centos/7/kong-community-edition-0.14.1.el7.noarch.rpm</span><br><span class="line"></span><br><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install kong-community-edition-0.14.1.el7.noarch.rpm</span><br></pre></td></tr></table></figure><p>2.修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/kong</span><br><span class="line">sudo cp kong.conf.default kong.conf</span><br><span class="line"></span><br><span class="line">sudo vim kong.conf</span><br><span class="line"></span><br><span class="line">#修改日志文件路径</span><br><span class="line">prefix = /data/kong/</span><br><span class="line"></span><br><span class="line">#由于磁盘空间有限,关闭kong的代理日志.后端真实服务器会记录nginx访问日志</span><br><span class="line">proxy_access_log = off</span><br><span class="line">proxy_error_log = off</span><br><span class="line"></span><br><span class="line">#在所有地址侦听管理端口,当然只侦听127地址会更安全.</span><br><span class="line">admin_listen = 0.0.0.0:8001, 0.0.0.0:8444 ssl</span><br><span class="line"></span><br><span class="line">#指定使用cassandra数据库</span><br><span class="line">database = cassandra</span><br><span class="line">#数据库地址,端口</span><br><span class="line">cassandra_contact_points = 10.25.87.159</span><br><span class="line">cassandra_port = 9042</span><br><span class="line"></span><br><span class="line">#上文定义的cassandra数据库的用户密码和键空间</span><br><span class="line">cassandra_keyspace = kong</span><br><span class="line">cassandra_username = kong</span><br><span class="line">cassandra_password = kong</span><br><span class="line"></span><br><span class="line">#kong官方建议的cassandra一致性机制</span><br><span class="line">cassandra_consistency = QUORUM</span><br><span class="line"></span><br><span class="line">#以下是集群的数据库和缓存方面的配置.详细介绍请参考官网</span><br><span class="line">db_update_frequency = 5</span><br><span class="line">db_update_propagation = 2</span><br></pre></td></tr></table></figure><p>3.创建kong目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/kong</span><br></pre></td></tr></table></figure><p>4.准备启动工作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kong migrations up -c /etc/kong/kong.conf</span><br></pre></td></tr></table></figure><p>5.启动kong</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kong start -c /etc/kong/kong.conf</span><br></pre></td></tr></table></figure><p>查看端口.可以看到cassandra和kong的侦听端口都已经成功启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">work@kong-node1 kong]$ netstat -tulnp</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class="line">tcp        0      0 0.0.0.0:8443            0.0.0.0:*               LISTEN      29342/nginx: master</span><br><span class="line">tcp        0      0 0.0.0.0:8444            0.0.0.0:*               LISTEN      29342/nginx: master</span><br><span class="line">tcp        0      0 127.0.0.1:7199          0.0.0.0:*               LISTEN      28598/java</span><br><span class="line">tcp        0      0 0.0.0.0:8000            0.0.0.0:*               LISTEN      29342/nginx: master</span><br><span class="line">tcp        0      0 0.0.0.0:8001            0.0.0.0:*               LISTEN      29342/nginx: master</span><br><span class="line">tcp        0      0 127.0.0.1:35503         0.0.0.0:*               LISTEN      28598/java</span><br><span class="line">tcp        0      0 10.25.87.159:9042       0.0.0.0:*               LISTEN      28598/java</span><br><span class="line">tcp        0      0 10.25.87.159:7000       0.0.0.0:*               LISTEN      28598/java</span><br></pre></td></tr></table></figure><hr><h3 id="部署另外一台kong和cassandra"><a href="#部署另外一台kong和cassandra" class="headerlink" title="部署另外一台kong和cassandra"></a>部署另外一台kong和cassandra</h3><p>今天在阿里云镜像了kong-node1的服务器.新的服务器名字为kong-node2.<br>软件已经安装,只需要修改部分配置</p><h5 id="修改node1和node2上的cassandra配置"><a href="#修改node1和node2上的cassandra配置" class="headerlink" title="修改node1和node2上的cassandra配置"></a>修改node1和node2上的cassandra配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在node1和node2上:</span><br><span class="line">[work@kong-node2 ~]$ vim /usr/local/cassandra/conf/cassandra.yaml</span><br><span class="line">#修改seeds配置.添加2台服务器的内网IP地址</span><br><span class="line">- seeds: &quot;10.25.87.159, 10.80.229.244&quot; </span><br><span class="line"></span><br><span class="line">在node2上修改侦听地址</span><br><span class="line">[work@kong-node2 ~]$ vim /usr/local/cassandra/conf/cassandra.yaml</span><br><span class="line">#将下列地址改成node2内网地址</span><br><span class="line">listen_address: 10.80.229.244</span><br><span class="line">rpc_address: 10.80.229.244</span><br></pre></td></tr></table></figure><h5 id="在node2上修改kong的配置文件"><a href="#在node2上修改kong的配置文件" class="headerlink" title="在node2上修改kong的配置文件:"></a>在node2上修改kong的配置文件:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">work@kong-node2 ~]$ vim /etc/kong/kong.conf</span><br><span class="line">#连接本机的cassandra数据库地址</span><br><span class="line">cassandra_contact_points = 10.80.229.244</span><br></pre></td></tr></table></figure><blockquote><p>note:千万不要启动node2上的cassandra.因为node2是从node1镜像过去的.所以数据库的token是一模一样的.</p></blockquote><h5 id="在node2上删除cassandra的数据库-这一步非常重要-因为这是从node1镜像过来的-所以node2上的数据库是node1的数据"><a href="#在node2上删除cassandra的数据库-这一步非常重要-因为这是从node1镜像过来的-所以node2上的数据库是node1的数据" class="headerlink" title="在node2上删除cassandra的数据库.这一步非常重要.因为这是从node1镜像过来的.所以node2上的数据库是node1的数据"></a>在node2上删除cassandra的数据库.这一步非常重要.因为这是从node1镜像过来的.所以node2上的数据库是node1的数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /data/cassandra/*</span><br></pre></td></tr></table></figure><h5 id="启动node2上的数据库"><a href="#启动node2上的数据库" class="headerlink" title="启动node2上的数据库"></a>启动node2上的数据库</h5><p>直接在命令行执行:cassandra</p><h5 id="查看cassandra的单台服务器状态"><a href="#查看cassandra的单台服务器状态" class="headerlink" title="查看cassandra的单台服务器状态"></a>查看cassandra的单台服务器状态</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 bin]$ nodetool info</span><br><span class="line">ID                     : 4fe1df37-e69e-4a25-acdc-4b2d73a92225</span><br><span class="line">Gossip active          : true</span><br><span class="line">Thrift active          : false</span><br><span class="line">Native Transport active: true</span><br><span class="line">Load                   : 522.87 KiB</span><br><span class="line">Generation No          : 1540372001</span><br><span class="line">Uptime (seconds)       : 63895</span><br><span class="line">Heap Memory (MB)       : 404.89 / 1004.00</span><br><span class="line">Off Heap Memory (MB)   : 0.00</span><br><span class="line">Data Center            : datacenter1</span><br><span class="line">Rack                   : rack1</span><br><span class="line">Exceptions             : 0</span><br><span class="line">Key Cache              : entries 59, size 5.03 KiB, capacity 50 MiB, 7540 hits, 7911 requests, 0.953 recent hit rate, 14400 save period in seconds</span><br><span class="line">Row Cache              : entries 0, size 0 bytes, capacity 0 bytes, 0 hits, 0 requests, NaN recent hit rate, 0 save period in seconds</span><br><span class="line">Counter Cache          : entries 0, size 0 bytes, capacity 25 MiB, 0 hits, 0 requests, NaN recent hit rate, 7200 save period in seconds</span><br><span class="line">Chunk Cache            : entries 28, size 1.75 MiB, capacity 219 MiB, 1237 misses, 26133 requests, 0.953 recent hit rate, NaN microseconds miss latency</span><br><span class="line">Percent Repaired       : 100.0%</span><br><span class="line">Token                  : (invoke with -T/--tokens to see all 256 tokens)</span><br></pre></td></tr></table></figure><h5 id="查看cassandra集群状态-可以看到集群中2台服务器"><a href="#查看cassandra集群状态-可以看到集群中2台服务器" class="headerlink" title="查看cassandra集群状态.可以看到集群中2台服务器"></a>查看cassandra集群状态.可以看到集群中2台服务器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 bin]$ nodetool status</span><br><span class="line">Datacenter: datacenter1</span><br><span class="line">=======================</span><br><span class="line">Status=Up/Down</span><br><span class="line">|/ State=Normal/Leaving/Joining/Moving</span><br><span class="line">--  Address        Load       Tokens       Owns (effective)  Host ID                               Rack</span><br><span class="line">UN  10.80.229.244  339.93 KiB  256          51.3%             04a75f63-be99-4f3e-93ff-937bbe9656d8  rack1</span><br><span class="line">UN  10.25.87.159   522.87 KiB  256          48.7%             4fe1df37-e69e-4a25-acdc-4b2d73a92225  rack1</span><br></pre></td></tr></table></figure><hr><h4 id="以下是我踩过的坑-在没有删除node2上的数据库文件情况下-直接启动cassnadra"><a href="#以下是我踩过的坑-在没有删除node2上的数据库文件情况下-直接启动cassnadra" class="headerlink" title="以下是我踩过的坑.在没有删除node2上的数据库文件情况下,直接启动cassnadra."></a>以下是我踩过的坑.在没有删除node2上的数据库文件情况下,直接启动cassnadra.</h4><p>启动node2的cassandra后.发现集群无法正常启动.使用cassandra自带的nodetool工具可以查看集群状态.这里只有自己一台服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node2 ~]$ nodetool status</span><br><span class="line">Datacenter: datacenter1</span><br><span class="line">=======================</span><br><span class="line">Status=Up/Down</span><br><span class="line">|/ State=Normal/Leaving/Joining/Moving</span><br><span class="line">--  Address        Load       Tokens       Owns (effective)  Host ID                               Rack</span><br><span class="line">UN  10.80.229.244  600.05 KiB  256          100.0%            4fe1df37-e69e-4a25-acdc-4b2d73a92225  rack1</span><br></pre></td></tr></table></figure><p>查看cassandra启动日志,发现日志提示和node1有一样的token:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">less /usr/local/cassandra/logs/system.log</span><br><span class="line"></span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,874 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token -9066137612411979055.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,874 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token -912539082610246005.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,874 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token -9125687604150710607.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,874 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token -9186325188411815558.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,874 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token -934168442605847346.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,874 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token -937629522304513228.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,874 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token -983284835358960159.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,875 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token 1111859401021864246.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,875 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token 1185525604491731552.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,875 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token 1209704333924286496.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,875 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token 1243859262038298713.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,875 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token 1284321765579584761.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,875 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token 1472069791929520463.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,875 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token 1479257042759500258.  Ignoring /10.25.87.159</span><br></pre></td></tr></table></figure><p>不仅如此,在node1上启动kong,提示cassandra数据库验证失败.以及提示kong需要migrations up(只需要在第一次启动kong时才需要migratios up):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 bin]$ kong restart -c /etc/kong/kong.conf</span><br><span class="line">Error: /usr/local/share/lua/5.1/kong/cmd/start.lua:37: [cassandra error] the current database schema does not match this version of Kong. Please run `kong migrations up` to update/initialize the database schema. Be aware that Kong migrations should only run from a single node, and that nodes running migrations concurrently will conflict with each other and might corrupt your database schema!</span><br></pre></td></tr></table></figure><p>kong migrations失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> work@kong-node1 bin]$ kong migrations up -c /etc/kong/kong.conf</span><br><span class="line">migrating core for keyspace kong</span><br><span class="line">core migrated up to: 2015-01-12-175310_skeleton</span><br><span class="line">Error: [cassandra error] Error during migration 2015-01-12-175310_init_schema: [Invalid] Undefined column name request_host</span><br></pre></td></tr></table></figure><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>启动node1和node2的cassandra</p><p>1.在node1和node2上drop kong的键空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 bin]$ cqlsh 10.25.87.159 -ukong -pkong</span><br><span class="line">Connected to dwd_cassandra at 10.25.87.159:9042.</span><br><span class="line">[cqlsh 5.0.1 | Cassandra 3.11.3 | CQL spec 3.4.4 | Native protocol v4]</span><br><span class="line">Use HELP for help.</span><br><span class="line">kong@cqlsh&gt; drop keyspace kong;</span><br><span class="line">kong@cqlsh&gt; exit</span><br><span class="line"></span><br><span class="line">[work@kong-node2 ~]$ cqlsh 10.80.229.244 -ukong -pkong</span><br><span class="line">Connected to dwd_cassandra at 10.80.229.244:9042.</span><br><span class="line">[cqlsh 5.0.1 | Cassandra 3.11.3 | CQL spec 3.4.4 | Native protocol v4]</span><br><span class="line">Use HELP for help.</span><br><span class="line">kong@cqlsh&gt; drop KEYSPACE kong;</span><br><span class="line">ConfigurationException: Cannot drop non existing keyspace &apos;kong&apos;.</span><br><span class="line">kong@cqlsh&gt; exit</span><br></pre></td></tr></table></figure><p>2.删除kong的键空间目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[work@kong-node1 bin]$ rm -rf  /data/cassandra/kong/</span><br><span class="line">[work@kong-node1 bin]$ ll /data/cassandra/kong/</span><br><span class="line">ls: cannot access /data/cassandra/kong/: No such file or directory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[work@kong-node2 ~]$ rm -rf /data/cassandra/kong/</span><br><span class="line">[work@kong-node2 ~]$ ll /data/cassandra/kong/</span><br><span class="line">ls: cannot access /data/cassandra/kong/: No such file or directory</span><br></pre></td></tr></table></figure><p>3.在node1上创建kong键空间.创建完毕后,应该会同步到node2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 bin]$ cqlsh 10.25.87.159 -ukong -pkong</span><br><span class="line">Connected to dwd_cassandra at 10.25.87.159:9042.</span><br><span class="line">[cqlsh 5.0.1 | Cassandra 3.11.3 | CQL spec 3.4.4 | Native protocol v4]</span><br><span class="line">Use HELP for help.</span><br><span class="line">kong@cqlsh&gt; CREATE KEYSPACE kong WITH REPLICATION = &#123; &apos;class&apos; : &apos;SimpleStrategy&apos;, &apos;replication_factor&apos; : 1&#125;;</span><br><span class="line">kong@cqlsh&gt; exit</span><br></pre></td></tr></table></figure><p>4.在node1上执行 kong migrations up ,执行完后同样会同步到node2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">work@kong-node1 bin]$ kong migrations up -c /etc/kong/kong.conf</span><br><span class="line">migrating core for keyspace kong</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">66 migrations ran</span><br><span class="line">waiting for Cassandra schema consensus (10000ms timeout)...</span><br><span class="line">Cassandra schema consensus: reached</span><br></pre></td></tr></table></figure><p>5.在node1和node2上启动kong</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 bin]$ kong restart -c /etc/kong/kong.conf</span><br><span class="line"></span><br><span class="line">[work@kong-node2 ~]$ kong start -c /etc/kong/kong.conf</span><br><span class="line">Kong started</span><br></pre></td></tr></table></figure><hr><h3 id="搭建kong-dashboard"><a href="#搭建kong-dashboard" class="headerlink" title="搭建kong-dashboard"></a>搭建kong-dashboard</h3><p>kong-dashboard是管理kong各个组件(serveice,route,plugin,upstream,consumer)的可视化UI管理工具.在增删改查各个组件的配置时非常方便.</p><p>现在kong-dashboard也支持到了最新版的kong和kong的最新组件.</p><p>kong-dashboard的github参考:<a href="https://github.com/PGBI/kong-dashboard" target="_blank" rel="noopener">kong-dashboar</a></p><hr><p>1.确保需要有node.js环境.如果没有npm工具,必须先安装nodejs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@DWD-BETA kong]$ npm -v</span><br><span class="line">5.6.0</span><br><span class="line">[work@DWD-BETA kong]$ node -v</span><br><span class="line">v8.10.0</span><br></pre></td></tr></table></figure><p>2.root用户执行下列安装命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@DWD-BETA ~]# npm install -g kong-dashboard</span><br><span class="line">/usr/local/src/nodejs/bin/kong-dashboard -&gt; /usr/local/src/nodejs/lib/node_modules/kong-dashboard/bin/kong-dashboard.js</span><br><span class="line">+ kong-dashboard@3.5.0</span><br><span class="line">added 184 packages in 28.8s</span><br></pre></td></tr></table></figure><p>3.启动kong-dashboard.启动方式有以下几种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Start Kong Dashboard</span><br><span class="line">kong-dashboard start --kong-url http://kong:8001</span><br><span class="line"></span><br><span class="line"># Start Kong Dashboard on a custom port</span><br><span class="line">kong-dashboard start \</span><br><span class="line">  --kong-url http://kong:8001 \</span><br><span class="line">  --port [port]</span><br><span class="line"></span><br><span class="line"># Start Kong Dashboard with basic auth</span><br><span class="line">kong-dashboard start \</span><br><span class="line">  --kong-url http://kong:8001 \</span><br><span class="line">  --basic-auth user1=password1 user2=password2</span><br><span class="line"></span><br><span class="line"># See full list of start options</span><br><span class="line">kong-dashboard start --help</span><br></pre></td></tr></table></figure><p>但是kong-dashboard是前台启动,没有deamnize模式.所以将kong-dashboard加入到supervisor进程管理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@DWD-BETA ~]# vim /etc/supervisor/conf.d/kong-dashboard.conf</span><br><span class="line"></span><br><span class="line">[program:kong-dashboard]</span><br><span class="line">command=/usr/local/src/nodejs/bin/kong-dashboard start --kong-url http://localhost:8001</span><br><span class="line">numprocs=1</span><br><span class="line">user=work</span><br><span class="line">stdout_logfile = /data/logs/kong/kong-dashboard.log</span><br><span class="line">redirect_stderr = true</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br></pre></td></tr></table></figure><p>修改权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@DWD-BETA ~]# chown -R work.work /etc/supervisor/conf.d/</span><br></pre></td></tr></table></figure><p>更新supervisor配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@DWD-BETA ~]# supervisorctl update kong-dashboard</span><br><span class="line">kong-dashboard: added process group</span><br></pre></td></tr></table></figure><p>但是由于我这台服务器上8080端口已经被使用,所以启动kong-dashboard报错:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">work@DWD-BETA kong]$ /usr/local/src/nodejs/bin/kong-dashboard start --kong-url http://localhost:8001</span><br><span class="line">Connecting to Kong on http://localhost:8001 ...</span><br><span class="line">Connected to Kong on http://localhost:8001.</span><br><span class="line">Kong version is 0.14.1</span><br><span class="line">Starting Kong Dashboard on port 8080</span><br><span class="line">events.js:183</span><br><span class="line">      throw er; // Unhandled &apos;error&apos; event</span><br><span class="line">      ^</span><br><span class="line"></span><br><span class="line">Error: listen EADDRINUSE :::8080</span><br><span class="line">    at Object._errnoException (util.js:1022:11)</span><br><span class="line">    at _exceptionWithHostPort (util.js:1044:20)</span><br><span class="line">    at Server.setupListenHandle [as _listen2] (net.js:1367:14)</span><br><span class="line">    at listenInCluster (net.js:1408:12)</span><br><span class="line">    at Server.listen (net.js:1492:7)</span><br><span class="line">    at Application.listen (/usr/local/src/nodejs/lib/node_modules/kong-dashboard/node_modules/koa/lib/application.js:65:19)</span><br><span class="line">    at Server.start (/usr/local/src/nodejs/lib/node_modules/kong-dashboard/lib/server.js:32:9)</span><br><span class="line">    at startKongDashboard (/usr/local/src/nodejs/lib/node_modules/kong-dashboard/bin/kong-dashboard.js:189:10)</span><br><span class="line">    at request.get.then.then (/usr/local/src/nodejs/lib/node_modules/kong-dashboard/bin/kong-dashboard.js:178:5)</span><br><span class="line">    at &lt;anonymous&gt;</span><br></pre></td></tr></table></figure><p>8080端口被jenkins占用了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@DWD-BETA kong]$ netstat -tulnp | grep 8080</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      17955/java</span><br></pre></td></tr></table></figure><p>更换kong-dashboard端口为8081</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[program:kong-dashboard]</span><br><span class="line">command=/usr/local/src/nodejs/bin/kong-dashboard  start --kong-url http://localhost:8001 --port 8081</span><br><span class="line">numprocs=1</span><br><span class="line">user=work</span><br><span class="line">stdout_logfile = /data/logs/kong/kong-dashboard.log</span><br><span class="line">redirect_stderr = true</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br></pre></td></tr></table></figure><p>更新supervisor后,仍然无法启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[work@DWD-BETA kong]$ supervisorctl update kong-dashboard</span><br><span class="line">kong-dashboard: stopped</span><br><span class="line">kong-dashboard: updated process group</span><br><span class="line">[work@DWD-BETA kong]$ supervisorctl status kong-dashboard</span><br><span class="line">kong-dashboard                   BACKOFF   Exited too quickly (process log may have details)</span><br></pre></td></tr></table></figure><p>手动启动正常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[work@DWD-BETA kong]$ /usr/local/src/nodejs/bin/kong-dashboard  start --kong-url http://localhost:8001 --port 8081</span><br><span class="line">Connecting to Kong on http://localhost:8001 ...</span><br><span class="line">Connected to Kong on http://localhost:8001.</span><br><span class="line">Kong version is 0.14.1</span><br><span class="line">Starting Kong Dashboard on port 8081</span><br><span class="line">Kong Dashboard has started on port 8081</span><br><span class="line">^C</span><br></pre></td></tr></table></figure><p>查看supervisor启动日志文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[work@DWD-BETA kong]$ less /data/logs/kong/kong-dashboard.log</span><br><span class="line">/usr/bin/env: node: No such file or directory</span><br><span class="line">/usr/bin/env: node: No such file or directory</span><br><span class="line">/usr/bin/env: node: No such file or directory</span><br><span class="line">/usr/bin/env: node: No such file or directory</span><br></pre></td></tr></table></figure><p>网上查找解决方案.说是要链接以下文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/bin/nodejs /usr/bin/node</span><br></pre></td></tr></table></figure><p>但是这台服务器上nodejs路径不同,所以执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[work@DWD-BETA kong]$ sudo ln -s /usr/local/src/nodejs /usr/bin/node</span><br></pre></td></tr></table></figure><p>仍然无法启动,提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/env: node: Permission denied</span><br><span class="line">/usr/bin/env: node: Permission denied</span><br><span class="line">/usr/bin/env: node: Permission denied</span><br><span class="line">/usr/bin/env: node: Permission denied</span><br><span class="line">/usr/bin/env: node: Permission denied</span><br><span class="line">/usr/bin/env: node: Permission denied</span><br></pre></td></tr></table></figure><p>修改kong-dashboard启动用户为root.仍然无法启动.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[program:kong-dashboard]</span><br><span class="line">command=/usr/local/src/nodejs/bin/kong-dashboard  start --kong-url http://127.0.0.1:8001 --port 8081</span><br><span class="line">numprocs=1</span><br><span class="line">user=root</span><br><span class="line">stdout_logfile = /data/logs/kong/kong-dashboard.log</span><br><span class="line">redirect_stderr = true</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br></pre></td></tr></table></figure><hr><p>操作失误在创建软件的时候,删除了nodejs源目录.重新安装了npm和kong-dashboard</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">解压nodejs包到:/usr/local/node/</span><br><span class="line"></span><br><span class="line">#设置环境变量: </span><br><span class="line">[root@DWD-BETA ~]# cat /etc/profile | tail -2</span><br><span class="line">export NODEJS_HOME=/usr/local/node/</span><br><span class="line">export PATH=$PATH:$NODEJS_HOME/bin</span><br><span class="line"></span><br><span class="line">[root@DWD-BETA ~]# node -v</span><br><span class="line">v8.10.0</span><br><span class="line">[root@DWD-BETA ~]# npm -v</span><br><span class="line">5.6.0</span><br></pre></td></tr></table></figure><p>创建链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@DWD-BETA ~]# ln -s /usr/local/node/bin/node /usr/bin/node</span><br><span class="line">root@DWD-BETA ~]# ll /usr/bin/node -d</span><br><span class="line">lrwxrwxrwx 1 root root 24 Nov  3 11:25 /usr/bin/node -&gt; /usr/local/node/bin/node</span><br></pre></td></tr></table></figure><p>修改supervisor配置文件中的命令路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[program:kong-dashboard]</span><br><span class="line">command=/usr/local/node/bin/kong-dashboard  start --kong-url http://127.0.0.1:8001 --port 8081</span><br><span class="line">numprocs=1</span><br><span class="line">priority=3</span><br><span class="line">user=root</span><br><span class="line">stdout_logfile = /data/logs/kong/kong-dashboard.log</span><br><span class="line">redirect_stderr = true</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br></pre></td></tr></table></figure><p>启动kong-dashboard</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@DWD-BETA ~]# supervisorctl update kong-dashboard</span><br><span class="line">kong-dashboard: stopped</span><br><span class="line">kong-dashboard: updated process group</span><br><span class="line"></span><br><span class="line">[root@DWD-BETA ~]# supervisorctl status kong-dashboard</span><br><span class="line">kong-dashboard                   RUNNING   pid 16635, uptime 0:05:02</span><br></pre></td></tr></table></figure><p>启动完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@DWD-BETA ~]# netstat -tulnp | grep 8081</span><br><span class="line">tcp6       0      0 :::8081                 :::*                    LISTEN      16635/node</span><br></pre></td></tr></table></figure><hr><h3 id="将cassandra加入到supervisor进程管理"><a href="#将cassandra加入到supervisor进程管理" class="headerlink" title="将cassandra加入到supervisor进程管理"></a>将cassandra加入到supervisor进程管理</h3><p>cassandra加入supervisor进程托管遇到不少问题.踩过以下2个坑:</p><p>1.启动报错,提示需要更高级版本的java.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cassandra 3.0 and later require Java 8u40 or later.</span><br><span class="line">Cassandra 3.0 and later require Java 8u40 or later.</span><br><span class="line">Cassandra 3.0 and later require Java 8u40 or later.</span><br><span class="line">Cassandra 3.0 and later require Java 8u40 or later.</span><br><span class="line">Cassandra 3.0 and later require Java 8u40 or later.</span><br><span class="line">Cassandra 3.0 and later require Java 8u40 or later.</span><br><span class="line">Cassandra 3.0 and later require Java 8u40 or later.</span><br></pre></td></tr></table></figure><p>我的解决方案:</p><ul><li>在cassandra的supervisor配置文件中加入环境变量:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">environment=JAVA_HOME=&quot;/usr/local/java&quot;  #这样cassandra会识别用户自定义安装的Java.</span><br></pre></td></tr></table></figure><ul><li>配置软链</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/local/java/bin/java /usr/bin/java</span><br></pre></td></tr></table></figure><p>2.仍然无法启动,因为命令行是以daemon方式启动.在cassandra的supervisor配置文件中的启动参数加入-f选项.</p><p>最终的cassandra配置文件如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[program:cassandra]</span><br><span class="line">command=/usr/local/cassandra/bin/cassandra -f</span><br><span class="line">directory=/usr/local/cassandra/</span><br><span class="line">environment=JAVA_HOME=&quot;/usr/local/java&quot;</span><br><span class="line">enviroment=PATH=&quot;$JAVA_HOME/bin:$PATH&quot;</span><br><span class="line">priority=0</span><br><span class="line">numprocs=1</span><br><span class="line">user=work</span><br><span class="line">stdout_logfile = /data/logs/cassandra/cassandra_supervisor.log</span><br><span class="line">redirect_stderr = true</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br></pre></td></tr></table></figure><hr><h3 id="将kong加入到supervisor"><a href="#将kong加入到supervisor" class="headerlink" title="将kong加入到supervisor"></a>将kong加入到supervisor</h3><p>1.由于默认kong启动是以daemon方式启动.所以修改/etc/kong/kong.conf配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#将下列行修改为off,且取消注释</span><br><span class="line">nginx_daemon = off</span><br></pre></td></tr></table></figure><p>2.编辑kong的supervisor配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[program:kong]</span><br><span class="line">command=/usr/local/bin/kong start -c /etc/kong/kong.conf</span><br><span class="line">numprocs=1</span><br><span class="line">priority=0</span><br><span class="line">user=work</span><br><span class="line">stdout_logfile = /data/logs/kong/kong_supervisor.log</span><br><span class="line">redirect_stderr = true</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br></pre></td></tr></table></figure><blockquote><p>注意由于kong启动的时候会连接后端的cassandra数据库,所以需要先启动cassandra,再启动kong.这就是为什么supervisor里要加入priority参数.优先级越小,启动顺序越优先.停止顺序越靠后.     </p></blockquote><p><strong>但是经过我的验证,发现priority参数没什么鸟用.当我start all,stop all时.永远是cassandra进程首先启动和关闭,无论priority优先级是大还是小.而不是supervisor官网介绍的那样效果</strong></p><p>启动没问题:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node2 ~]$ supervisorctl status</span><br><span class="line">cassandra                        RUNNING   pid 13531, uptime 0:10:09</span><br><span class="line">kong                             RUNNING   pid 14460, uptime 0:00:35</span><br><span class="line">kong-dashboard                   RUNNING   pid 14496, uptime 0:00:17</span><br></pre></td></tr></table></figure><p>但是发现supervisor管理kong进程有很严重的问题.</p><p>因为kong启动后包括2个进程:kong和nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">work@kong-node1 conf.d]$ ps aux | grep kong</span><br><span class="line">work      3198  0.2  0.0 130104  2700 ?        S    17:12   0:00 perl /usr/local/openresty/bin/resty /usr/local/bin/kong start -c /etc/kong/kong.conf</span><br><span class="line">work      3215  6.3  0.1 259600 11800 ?        S    17:12   0:00 nginx: master process /usr/local/openresty/nginx/sbin/nginx -p /data/kong -c nginx.conf</span><br></pre></td></tr></table></figure><p>.这个时候如果用supervisorctl restart kong进程会出现无法启动的情况.这是因为supervisor kill掉了kong进程.但是没有kill Ningx进程.所以重新启动kong的时候,由于nginx进程仍然存在,故无法启动.例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 conf.d]$ ps aux | grep kong</span><br><span class="line">work      2917  0.0  0.1 259600 11820 ?        S    17:05   0:00 nginx: master process /usr/local/openresty/nginx/sbin/nginx -p /data/kong -c nginx.conf</span><br><span class="line">work      3191  0.0  0.0 112704   976 pts/0    S+   17:11   0:00 grep --color=auto kong</span><br><span class="line">[work@kong-node1 conf.d]$ kill 2917</span><br><span class="line">[work@kong-node1 conf.d]$ ps aux | grep kong</span><br><span class="line">work      3193  0.0  0.0 112704   976 pts/0    S+   17:11   0:00 grep --color=auto kong</span><br><span class="line">[work@kong-node1 conf.d]$ supervisorctl start kong</span><br><span class="line">kong: started</span><br><span class="line"></span><br><span class="line">#kong启动后包含2个进程</span><br><span class="line">[work@kong-node1 conf.d]$ ps aux | grep kong</span><br><span class="line">work      3198  0.2  0.0 130104  2700 ?        S    17:12   0:00 perl /usr/local/openresty/bin/resty /usr/local/bin/kong start -c /etc/kong/kong.conf</span><br><span class="line">work      3215  6.3  0.1 259600 11800 ?        S    17:12   0:00 nginx: master process /usr/local/openresty/nginx/sbin/nginx -p /data/kong -c nginx.conf</span><br><span class="line">work      3228  0.0  0.0 112704   976 pts/0    R+   17:12   0:00 grep --color=auto kong</span><br><span class="line"></span><br><span class="line">#supervisor关闭了Kong进程后,无法启动.</span><br><span class="line">[work@kong-node1 conf.d]$ supervisorctl restart kong</span><br><span class="line">kong: stopped</span><br><span class="line">kong: ERROR (spawn error)</span><br><span class="line"></span><br><span class="line">#因为虽然kong进程杀死了.但是nginx进程还在.所以kong的8000端口仍然被占用</span><br><span class="line">[work@kong-node1 conf.d]$ ps aux | grep kong</span><br><span class="line">work      3215  0.1  0.1 259600 11800 ?        S    17:12   0:00 nginx: master process /usr/local/openresty/nginx/sbin/nginx -p /data/kong -c nginx.conf</span><br><span class="line">work      3307  0.0  0.0 112704   976 pts/0    S+   17:15   0:00 grep --color=auto kong</span><br><span class="line"></span><br><span class="line">#查看启动日志,提示kong进程已经启动了.</span><br><span class="line">Error: Kong is already running in /data/kong</span><br><span class="line"></span><br><span class="line">  Run with --v (verbose) or --vv (debug) for more details</span><br></pre></td></tr></table></figure><p><strong>暂时就不用supervisor管理了,采用命令行直接启动方式</strong></p><hr><p><strong>命令行启动kong.只有一个Nginx进程.没有Perl进程.不知道何故</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node2 conf.d]$kong start -c /etc/kong/kong.conf</span><br><span class="line">Kong started</span><br><span class="line">[work@kong-node2 conf.d]$ps aux | grep kong</span><br><span class="line">work     15558  0.0  0.0 259600  6540 ?        Ss   17:29   0:00 nginx: master process /usr/local/openresty/nginx/sbin/nginx -p /data/kong -c nginx.conf</span><br></pre></td></tr></table></figure><hr><h3 id="将kong-Cassandra加入到systemctl管理工具"><a href="#将kong-Cassandra加入到systemctl管理工具" class="headerlink" title="将kong,Cassandra加入到systemctl管理工具"></a>将kong,Cassandra加入到systemctl管理工具</h3><ul><li><strong>cassandra</strong></li></ul><p>systemctl文件如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 ~]$cd /usr/lib/systemd/system</span><br><span class="line">[work@kong-node1 system]$vim cassandra.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Cassandra</span><br><span class="line">After=network.target</span><br><span class="line">Before=kong.target </span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=work</span><br><span class="line">Group=work</span><br><span class="line">ExecStart=/usr/local/cassandra/bin/cassandra -f</span><br><span class="line">ExecStop=kill $(pgrep -f cassandra)</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><blockquote><p>注意.如果java是二进制包,则需要将Bin文件链接到系统环境变量目录下.因为systemctl不会读取profile环境,所以不能识别到java.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 system]$which java</span><br><span class="line">/usr/bin/java</span><br><span class="line">[work@kong-node1 system]$ll /usr/bin/java</span><br><span class="line">lrwxrwxrwx 1 root root 24 Nov 14 17:46 /usr/bin/java -&gt; /usr/local/java/bin/java</span><br></pre></td></tr></table></figure><p>第二种方法是在systemctl中指定环境变量.指定environment参数(这种方法理论可行,但是没有论证)</p><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Cassandra</span><br><span class="line">After=network.target</span><br><span class="line">Before=kong.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=work</span><br><span class="line">Group=work</span><br><span class="line">environment=JAVA_HOME=/usr/local/java</span><br><span class="line">environment=PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">ExecStart=/usr/local/cassandra/bin/cassandra -f</span><br><span class="line">ExecStop=kill $(pgrep -f cassandra)</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><hr><ul><li><strong>kong</strong></li></ul><p>在同目录下编辑kong服务配置.</p><blockquote><p>注意,需要在cassandra后端数据库启动后,才能启动kong服务</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 system]$vim kong.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description= kong service</span><br><span class="line">After=syslog.target network.target cassandra.target</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=work</span><br><span class="line">Group=work</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/kong start -c /etc/kong/kong.conf</span><br><span class="line">ExecReload=/usr/local/bin/kong reload -c /etc/kong/kong.conf</span><br><span class="line">ExecStop=/usr/local/bin/kong stop</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><ul><li><strong>在kong-node2上启动kong-dashbaord</strong></li></ul><blockquote><p>dashbaord服务启动需要在cassandra,kong服务启动之后</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node2 system]$vim kong-dashboard.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=kong-dashboard</span><br><span class="line">After=network.target cassandra.target kong.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=work</span><br><span class="line">Group=work</span><br><span class="line">ExecStart=/usr/local/bin/kong-dashboard start --kong-url http://10.111.30.158:8001</span><br><span class="line">ExecStop=kill $(pgrep -f kong-dashboard)</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><ul><li>加入到开启自启动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable cassandra</span><br><span class="line">systemctl enable kong</span><br><span class="line">systemctl enable kong-dashboard</span><br></pre></td></tr></table></figure><p>经过反复论证,systemctl可以管理以上服务.</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;kong-casssandra集群环境部署&quot;&gt;&lt;a href=&quot;#kong-casssandra集群环境部署&quot; class=&quot;headerlink&quot; title=&quot;kong+casssandra集群环境部署&quot;&gt;&lt;/a&gt;kong+casssandra集群环境部署&lt;/h2&gt;&lt;h3 id=&quot;kong简介&quot;&gt;&lt;a href=&quot;#kong简介&quot; class=&quot;headerlink&quot; title=&quot;kong简介&quot;&gt;&lt;/a&gt;kong简介&lt;/h3&gt;&lt;p&gt;Kong是Mashape开源的一款API网关，起初是用来管理 Mashape 公司15000个微服务的，后来在2015年开源,现在已经在很多创业公司、大型企业和政府机构中广泛使用。基于nginx,Lua和Cassandra或PostgreSQL，支持分布式操作，有很强的可移植性和可扩展性。可以在任何一种基础设施上运行,作为应用和API之间的中间层，加上众多功能强大的插件，可以实现认证授权、访问控制等功能。并且提供易于使用的RESTful API来操作和配置系统。&lt;/p&gt;
&lt;p&gt;有关kong的详细介绍请参考官网.&lt;/p&gt;
&lt;p&gt;–&lt;/p&gt;
&lt;h3 id=&quot;cassandra简介&quot;&gt;&lt;a href=&quot;#cassandra简介&quot; class=&quot;headerlink&quot; title=&quot;cassandra简介&quot;&gt;&lt;/a&gt;cassandra简介&lt;/h3&gt;&lt;p&gt;Cassandra 是一个来自 Apache 的分布式数据库，具有高度可扩展性，可用于管理大量的结构化数据。它提供了高可用性，没有单点故障。kong支持PostgreSQL或者Cassandra两种数据库.这里我们选择了cassandra.&lt;/p&gt;
&lt;p&gt;有关cassandra的详细介绍和使用方法.请参考官网&lt;/p&gt;
    
    </summary>
    
      <category term="Linux-Web" scheme="https://jesse.top/categories/Linux-Web/"/>
    
      <category term="kong" scheme="https://jesse.top/categories/Linux-Web/kong/"/>
    
    
      <category term="kong" scheme="https://jesse.top/tags/kong/"/>
    
  </entry>
  
  <entry>
    <title>k8s挂载NFS网络磁盘</title>
    <link href="https://jesse.top/2020/06/26/kubernetes/k8s%E6%8C%82%E8%BD%BDNFS%E7%BD%91%E7%BB%9C%E7%A3%81%E7%9B%98/"/>
    <id>https://jesse.top/2020/06/26/kubernetes/k8s挂载NFS网络磁盘/</id>
    <published>2020-06-26T03:59:58.000Z</published>
    <updated>2020-06-26T03:04:46.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="k8s挂载NFS网络磁盘"><a href="#k8s挂载NFS网络磁盘" class="headerlink" title="k8s挂载NFS网络磁盘"></a>k8s挂载NFS网络磁盘</h2><p>按照<kubernetes in="" action="">这本书NFS做持久化存储的例子,发现了一个坑.,启动pod失败,报如下错误</kubernetes></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown: changing ownership of &apos;/data/db&apos;: Operation not permitted</span><br></pre></td></tr></table></figure><p>网上也有人遇到这个问题.可以参考这篇文档: <a href="https://blog.csdn.net/herhun_chen/article/details/90247123" target="_blank" rel="noopener">Kubernetes 集群挂载NFS Volume</a></p><a id="more"></a><p>以下是pod的yaml文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-m01 ~]# cat mongodb-pod-nfs.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: mongodb</span><br><span class="line">spec:</span><br><span class="line">  volumes:</span><br><span class="line">     - name: mongodb-data</span><br><span class="line">       nfs:</span><br><span class="line">         server: 10.111.5.184</span><br><span class="line">         path: /data/k8s/</span><br><span class="line"></span><br><span class="line">  containers:</span><br><span class="line">     - image: mongo</span><br><span class="line">       name: mongodb</span><br><span class="line">       volumeMounts:</span><br><span class="line">         - name: mongodb-data</span><br><span class="line">           mountPath: /data/db</span><br><span class="line">       ports:</span><br><span class="line">         - containerPort: 27017</span><br><span class="line">           protocol: TCP</span><br></pre></td></tr></table></figure><p>出现这种<figure class="highlight plain"><figcaption><span>not permitted```的权限类问题,肯定是NFS的挂载有问题.但是在所有k8s的节点上往NFS共享磁盘写文件,又是正常的.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">解决这个问题需要在NFS服务器的```/etx/exports```配置文件修改成如下配置</span><br></pre></td></tr></table></figure></p><p>[work@hsq-beta-rpc ~]$cat /etc/exports<br>/data/k8s/ 10.111.0.0/16(rw,fsid=0,async,no_subtree_check,no_auth_nlm,insecure,no_root_squash)<br><code>`</code></p><blockquote><p>注意,以上配置其实是一行.没有换行</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;k8s挂载NFS网络磁盘&quot;&gt;&lt;a href=&quot;#k8s挂载NFS网络磁盘&quot; class=&quot;headerlink&quot; title=&quot;k8s挂载NFS网络磁盘&quot;&gt;&lt;/a&gt;k8s挂载NFS网络磁盘&lt;/h2&gt;&lt;p&gt;按照&lt;kubernetes in=&quot;&quot; action=&quot;&quot;&gt;这本书NFS做持久化存储的例子,发现了一个坑.,启动pod失败,报如下错误&lt;/kubernetes&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;chown: changing ownership of &amp;apos;/data/db&amp;apos;: Operation not permitted&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;网上也有人遇到这个问题.可以参考这篇文档: &lt;a href=&quot;https://blog.csdn.net/herhun_chen/article/details/90247123&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kubernetes 集群挂载NFS Volume&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="kubernetes" scheme="https://jesse.top/categories/kubernetes/"/>
    
    
      <category term="k8s" scheme="https://jesse.top/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>docker安装最新版Kong(v1.0)+konga</title>
    <link href="https://jesse.top/2020/06/26/Linux-Web/docker%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88Kong(v1.0)%20konga/"/>
    <id>https://jesse.top/2020/06/26/Linux-Web/docker安装最新版Kong(v1.0) konga/</id>
    <published>2020-06-26T03:59:58.000Z</published>
    <updated>2020-06-26T02:58:34.379Z</updated>
    
    <content type="html"><![CDATA[<h3 id="docker安装最新版Kong-v1-0-konga"><a href="#docker安装最新版Kong-v1-0-konga" class="headerlink" title="docker安装最新版Kong(v1.0)+konga"></a>docker安装最新版Kong(v1.0)+konga</h3><p>参考以下文档:</p><p><a href="https://docs.konghq.com/install/docker/?_ga=2.167535422.1288669860.1553147426-917309945.1539077269" target="_blank" rel="noopener">Kong installation</a></p><p><a href="https://github.com/pantsel/konga#installation" target="_blank" rel="noopener">konga github</a></p><hr><h4 id="docker安装kong-postgresql"><a href="#docker安装kong-postgresql" class="headerlink" title="docker安装kong+postgresql"></a>docker安装kong+postgresql</h4><p>1.创建一个docker网络用于docker,postgresql和konga容器间通信</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create kong-net</span><br></pre></td></tr></table></figure><p>2.启动posgtresql容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name kong-database \</span><br><span class="line">               --network=kong-net \</span><br><span class="line">               -p 5432:5432 \</span><br><span class="line">               -e &quot;POSTGRES_USER=kong&quot; \</span><br><span class="line">               -e &quot;POSTGRES_DB=kong&quot; \</span><br><span class="line">               postgres:9.6</span><br></pre></td></tr></table></figure><p>3.初始化postgresql数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm \</span><br><span class="line">    --network=kong-net \</span><br><span class="line">    -e &quot;KONG_DATABASE=postgres&quot; \</span><br><span class="line">    -e &quot;KONG_PG_HOST=kong-database&quot; \</span><br><span class="line">    -e &quot;KONG_CASSANDRA_CONTACT_POINTS=kong-database&quot; \</span><br><span class="line">    kong:latest kong migrations bootstrap</span><br></pre></td></tr></table></figure><blockquote><p>注意两点:</p><p>1.最好是先删除本地的kong镜像.因为本地的Kong:lastest镜像不一定就是最新版</p><p>2.如果本地的kong:latest镜像地域0.15版本,则不支持bootstrap命令.可以将bootstrap命令替换成up</p></blockquote><a id="more"></a><p>4.启动kong容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name kong \</span><br><span class="line">     --network=kong-net \</span><br><span class="line">     -v /data/logs/kong:/var/log/kong \</span><br><span class="line">     -v /data/apps/kong/plugins/:/usr/local/share/lua/5.1/kong/plugins/ \</span><br><span class="line">     -e &quot;KONG_DATABASE=postgres&quot; \</span><br><span class="line">     -e &quot;KONG_PG_HOST=kong-database&quot; \</span><br><span class="line">     -e &quot;KONG_CASSANDRA_CONTACT_POINTS=kong-database&quot; \</span><br><span class="line">     -e &quot;KONG_PROXY_ACCESS_LOG=/var/log/kong/access.log&quot; \</span><br><span class="line">     -e &quot;KONG_ADMIN_ACCESS_LOG=/var/log/kong/admin_access.log&quot; \</span><br><span class="line">     -e &quot;KONG_PROXY_ERROR_LOG=/var/log/kong/error.log&quot; \</span><br><span class="line">     -e &quot;KONG_ADMIN_ERROR_LOG=/var/log/kong/admin_error.log&quot; \</span><br><span class="line">     -e &quot;KONG_ADMIN_LISTEN=0.0.0.0:8001, 0.0.0.0:8444 ssl&quot; \</span><br><span class="line">     -p 8000:8000 \</span><br><span class="line">     -p 8443:8443 \</span><br><span class="line">     -p 8001:8001 \</span><br><span class="line">     -p 8444:8444 \</span><br><span class="line">     kong:latest</span><br></pre></td></tr></table></figure><blockquote><p>这里我映射了kong的插件目录和日志目录. </p></blockquote><ul><li>注意:要先吧kong容器里的/usr/local/share/lua/5.1/kong/plugins/目录下内容复制到宿主机的/data/apps/kong/plugins/目录下.否则宿主机的空目录会覆盖容器的插件目录,导致容器无法启动.</li></ul><p>kong容器目录拷贝到宿主机方法如下:</p><p>1.先不挂载目录启动kong容器</p><p>2.执行命令拷贝kong容器的/usr/local/share/lua/5.1/kong/plugins/ 目录到宿主机/data/apps/kong/plugins/目录下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[work@docker ~]$docker cp kong:/usr/local/share/lua/5.1/kong/plugins/  /data/apps/kong/plugins/</span><br></pre></td></tr></table></figure><blockquote><p>如果不需要将容器的kong插件目录映射到宿主机的话,这一步可以不需要做</p></blockquote><p>容器已经成功启动:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@docker conf.d]$docker ps | grep -E &quot;kong|postgre&quot;</span><br><span class="line">10fc881cca4b        kong:latest                                 &quot;/docker-entrypoin...&quot;   About an hour ago   Up About an hour    0.0.0.0:8000-8001-&gt;8000-8001/tcp, 0.0.0.0:8443-8444-&gt;8443-8444/tcp                                             kong</span><br><span class="line"></span><br><span class="line">afd1487e29a0        postgres:9.6                                &quot;docker-entrypoint...&quot;   3 hours ago         Up 3 hours          0.0.0.0:5432-&gt;5432/tcp                                                                                         kong-database</span><br></pre></td></tr></table></figure><hr><h4 id="安装konga"><a href="#安装konga" class="headerlink" title="安装konga"></a>安装konga</h4><p>konga是管理kong的一个dashboard界面.</p><p>1.先初始化数据库.这里也是用后端的postgresql数据库.官方命令如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm pantsel/konga:latest -c prepare -a &#123;&#123;adapter&#125;&#125; -u &#123;&#123;connection-uri&#125;&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>argument</th><th>description</th><th>default</th></tr></thead><tbody><tr><td>-c</td><td>command</td><td>-</td></tr><tr><td>-a</td><td>adapter (can be <code>postgres</code> or <code>mysql</code>)</td><td>-</td></tr><tr><td>-u</td><td>full database connection url</td></tr></tbody></table><p>执行以下命令,初始化数据库:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm pantsel/konga:latest -c prepare -a postgres -u  postgres://kong@10.0.0.250:5432/konga</span><br></pre></td></tr></table></figure><blockquote><p>这里稍微有点疑问的是数据库的connection url ..完整的connection url地址是: postgres://user:password@host:port/konga</p><p> postgres:<a href="mailto://kong@10.0.0.250" target="_blank" rel="noopener">//kong@10.0.0.250</a>:5432/konga —— 这里kong代表用户名,由于没有密码所以没有指定密码.10.0.0.250是postgresql的host主机名.konga表示初始化一个数据库</p></blockquote><p>执行结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[work@docker ~]$docker run --rm pantsel/konga:latest -c prepare -a postgres -u  postgres://kong@10.0.0.250:5432/konga</span><br><span class="line">debug: Preparing database...</span><br><span class="line">Using postgres DB Adapter.</span><br><span class="line">Database `konga` does not exist. Creating...</span><br><span class="line">Database `konga` created! Continue...</span><br><span class="line">debug: Hook:api_health_checks:process() called</span><br><span class="line">debug: Hook:health_checks:process() called</span><br><span class="line">debug: Hook:start-scheduled-snapshots:process() called</span><br><span class="line">debug: Hook:upstream_health_checks:process() called</span><br><span class="line">debug: Hook:user_events_hook:process() called</span><br><span class="line">debug: Seeding User...</span><br><span class="line">debug: User seed planted</span><br><span class="line">debug: Seeding Kongnode...</span><br><span class="line">debug: Kongnode seed planted</span><br><span class="line">debug: Seeding Emailtransport...</span><br><span class="line">debug: Emailtransport seed planted</span><br><span class="line">debug: Database migrations completed!</span><br></pre></td></tr></table></figure><ol start="2"><li>启动konga</li></ol><p>命令格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 1337:1337 </span><br><span class="line">             --network &#123;&#123;kong-network&#125;&#125; \ // optional</span><br><span class="line">             -e &quot;TOKEN_SECRET=&#123;&#123;somerandomstring&#125;&#125;&quot; \</span><br><span class="line">             -e &quot;DB_ADAPTER=the-name-of-the-adapter&quot; \ // &apos;mongo&apos;,&apos;postgres&apos;,&apos;sqlserver&apos;  or &apos;mysql&apos;</span><br><span class="line">             -e &quot;DB_HOST=your-db-hostname&quot; \</span><br><span class="line">             -e &quot;DB_PORT=your-db-port&quot; \ // Defaults to the default db port</span><br><span class="line">             -e &quot;DB_USER=your-db-user&quot; \ // Omit if not relevant</span><br><span class="line">             -e &quot;DB_PASSWORD=your-db-password&quot; \ // Omit if not relevant</span><br><span class="line">             -e &quot;DB_DATABASE=your-db-name&quot; \ // Defaults to &apos;konga_database&apos;</span><br><span class="line">             -e &quot;DB_PG_SCHEMA=my-schema&quot;\ // Optionally define a schema when integrating with prostgres</span><br><span class="line">             -e &quot;NODE_ENV=production&quot; \ // or &apos;development&apos; | defaults to &apos;development&apos;</span><br><span class="line">             --name konga \</span><br><span class="line">             pantsel/konga</span><br></pre></td></tr></table></figure><p>执行如下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 1337:1337 -d \</span><br><span class="line">             --network=kong-net \</span><br><span class="line">             -e &quot;DB_ADAPTER=postgres&quot; \</span><br><span class="line">             -e &quot;DB_HOST=10.0.0.250&quot; \</span><br><span class="line">             -e &quot;DB_PORT=5432&quot; \</span><br><span class="line">             -e &quot;DB_USER=kong&quot; \</span><br><span class="line">             -e &quot;DB_DATABASE=konga&quot; \</span><br><span class="line">             -e &quot;NODE_ENV=production&quot; \</span><br><span class="line">             --name konga \</span><br><span class="line">             pantsel/konga</span><br></pre></td></tr></table></figure><p>容器成功启动:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beb70407b417        pantsel/konga                               &quot;/app/start.sh&quot;          2 hours ago         Up 2 hours          0.0.0.0:1337-&gt;1337/tcp                                                                                         konga</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;docker安装最新版Kong-v1-0-konga&quot;&gt;&lt;a href=&quot;#docker安装最新版Kong-v1-0-konga&quot; class=&quot;headerlink&quot; title=&quot;docker安装最新版Kong(v1.0)+konga&quot;&gt;&lt;/a&gt;docker安装最新版Kong(v1.0)+konga&lt;/h3&gt;&lt;p&gt;参考以下文档:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.konghq.com/install/docker/?_ga=2.167535422.1288669860.1553147426-917309945.1539077269&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kong installation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/pantsel/konga#installation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;konga github&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;docker安装kong-postgresql&quot;&gt;&lt;a href=&quot;#docker安装kong-postgresql&quot; class=&quot;headerlink&quot; title=&quot;docker安装kong+postgresql&quot;&gt;&lt;/a&gt;docker安装kong+postgresql&lt;/h4&gt;&lt;p&gt;1.创建一个docker网络用于docker,postgresql和konga容器间通信&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker network create kong-net&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2.启动posgtresql容器&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker run -d --name kong-database \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               --network=kong-net \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               -p 5432:5432 \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               -e &amp;quot;POSTGRES_USER=kong&amp;quot; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               -e &amp;quot;POSTGRES_DB=kong&amp;quot; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               postgres:9.6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3.初始化postgresql数据库&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker run --rm \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    --network=kong-net \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -e &amp;quot;KONG_DATABASE=postgres&amp;quot; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -e &amp;quot;KONG_PG_HOST=kong-database&amp;quot; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -e &amp;quot;KONG_CASSANDRA_CONTACT_POINTS=kong-database&amp;quot; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    kong:latest kong migrations bootstrap&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;注意两点:&lt;/p&gt;
&lt;p&gt;1.最好是先删除本地的kong镜像.因为本地的Kong:lastest镜像不一定就是最新版&lt;/p&gt;
&lt;p&gt;2.如果本地的kong:latest镜像地域0.15版本,则不支持bootstrap命令.可以将bootstrap命令替换成up&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux-Web" scheme="https://jesse.top/categories/Linux-Web/"/>
    
    
      <category term="nginx" scheme="https://jesse.top/tags/nginx/"/>
    
      <category term="web" scheme="https://jesse.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>harbor私有仓库部署</title>
    <link href="https://jesse.top/2020/06/26/docker/harbor%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E9%83%A8%E7%BD%B2/"/>
    <id>https://jesse.top/2020/06/26/docker/harbor私有仓库部署/</id>
    <published>2020-06-26T03:59:58.000Z</published>
    <updated>2020-06-26T03:03:12.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="harbor私有仓库部署"><a href="#harbor私有仓库部署" class="headerlink" title="harbor私有仓库部署"></a>harbor私有仓库部署</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>harbor是docker的私有仓库,可以部署在局域网服务器上,用来管理docker镜像.虽然docker官方也提供公共镜像仓库,但是由于是境外网站,拉取镜像速度非常慢,而且有被墙的可能.部署私有仓库非常有必要</p><p>harbor是vmware公司开源的企业级的docker registry管理项目.</p><blockquote><p>处于数据脱敏需要,以下内容中隐藏了真实域名.而使用hub.xxxxxx.com替代</p></blockquote><hr><h3 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h3><p>harbor github: <a href="https://github.com/goharbor/harbor" target="_blank" rel="noopener">goharbor/harbor</a></p><p>官网文档介绍: <a href="https://goharbor.io/docs/1.10/" target="_blank" rel="noopener">harbor doc</a></p><p>在部署中遇到的各种坑,都可以通过查阅文档,或者搜索github的issue解决</p><hr><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>harbor是docker-compose部署的.包括一系列组件:nginx.core,log,register等等.</p><p>但是由于本机已经存在一个Nginx镜像.所以用Nginx代理到harbor的Nginx.<strong>如果是独立的服务器部署Harbor的话,则不会存在这个问题,可以直接跳过这一章节.</strong></p><p>nginx代理框架大概是:</p><p><strong>nginx—-&gt;harbor-nginx—–&gt;habor</strong></p><p>由于docker提交镜像需要Https协议,所以:</p><p><strong>nginx—301跳转到nginx https—–&gt;harbor-nginx http—-&gt; habor</strong></p><p>但是这样的部署方式,有一个问题:</p><p>私有仓库可以正常login但是push镜像的时候,又提示未验证.</p><p>该问题尝试过很多解决方案,但是均无法解决</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@idc-function-docker ~]# docker login --username=admin -pHarbor12345 hub.xxxxxx.com</span><br><span class="line">WARNING! Using --password via the CLI is insecure. Use --password-stdin.</span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br><span class="line">[root@idc-function-docker ~]# docker push hub.xxxxxx.com/master/nginx:latest</span><br><span class="line">The push refers to repository [hub.xxxxxx.com/master/nginx]</span><br><span class="line">d37eecb5b769: Pushing [==================================================&gt;]  3.584kB</span><br><span class="line">99134ec7f247: Preparing</span><br><span class="line">c3a984abe8a8: Preparing</span><br><span class="line">unauthorized: authentication required</span><br></pre></td></tr></table></figure><p>所以现在的架构是</p><p><strong>nginx—301跳转到Nginx https——&gt; harbor-nginx https——&gt;harbor</strong></p><hr><h3 id="harbor部署前提条件"><a href="#harbor部署前提条件" class="headerlink" title="harbor部署前提条件"></a>harbor部署前提条件</h3><ul><li>安装docker-ce</li><li>安装docker-composer</li><li>准备一个空目录.比如/data.或者/data/harbor (注意,最好是空目录,不要和其他项目混杂一起)</li><li>安装好https域名证书</li></ul><hr><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>docker和docker-compose的安装就略过了.这里提一句,我用的是acme.sh部署letsencrypt的证书</p><p>接下来开始部署harbor</p><ul><li>1.去github下载离线安装包.离线安装包虽然比较大,但是安装过程快速,且不会中断</li></ul><p>这里安装的是最新版,v1.10.1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在github下载 harbor-offline-installer-v1.10.1.tgz</span><br><span class="line">tar xvf 解压</span><br></pre></td></tr></table></figure><ul><li>2.解压后,进入harbor文件,编辑harbor.yaml配置文件.需要改动以下几个地方</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">hostname hub.xxxxxx.com  #定义主机名,可以使用IP,也可以用域名</span><br><span class="line"></span><br><span class="line">#定义https的服务器证书和秘钥的文件路径</span><br><span class="line">https:</span><br><span class="line">  # https port for harbor, default is 443</span><br><span class="line">  port: 443</span><br><span class="line">  # The path of cert and key files for nginx</span><br><span class="line">  certificate: /data/letsencrypt/hub.xxxxxx.com/fullchain.cer</span><br><span class="line">  private_key: /data/letsencrypt/hub.xxxxxx.com/hub.xxxxxx.com.key</span><br><span class="line">  </span><br><span class="line">#这是harbor命令行和浏览器登陆的初始密码..用户名是admin</span><br><span class="line">harbor_admin_password: Harbor12345</span><br><span class="line"></span><br><span class="line">#这是数据目录,最好是一个空目录</span><br><span class="line">data_volume: /data/apps/harbor</span><br><span class="line"></span><br><span class="line">#日志文件保存路径</span><br><span class="line">log:</span><br><span class="line">    location: /data/logs/harbor</span><br></pre></td></tr></table></figure><ul><li>3.执行install.sh文件.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#该脚本会检查主机的环境,拉取相关镜像.以及根据配置文件生成docker-compose文件.</span><br><span class="line">[root@idc-function-docker harbor]#./install.sh</span><br></pre></td></tr></table></figure><blockquote><p> 这个脚本执行到最后会报错,提示80端口和nginx容器已经被占用了.但是没关系.</p></blockquote><ul><li>4.修改docker-composer文件.(如果本机上没有nginx或者80端口没有被占用,这一步可以不做)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#将Nginx容器名改成hub-nginx</span><br><span class="line">#将80和443的端口映射修改一下,比如我这里</span><br><span class="line">proxy:</span><br><span class="line">    image: goharbor/nginx-photon:v1.10.1</span><br><span class="line">    container_name: hub-nginx</span><br><span class="line">ports:</span><br><span class="line">      - 8081:8080</span><br><span class="line">      - 4443:8443</span><br></pre></td></tr></table></figure><ul><li><ol start="5"><li>启动docker-compose</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@idc-function-docker harbor]#docker-compose up -d</span><br></pre></td></tr></table></figure><ul><li><ol start="6"><li>宿主机的nginx开启代理. (如果不是采用nginx代理的话,可以忽略这一步)</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#我这里是有一个独立的Nginx容器</span><br><span class="line">[root@idc-function-docker harbor]# cat/data/conf/nginx/conf.d/dwd-docker-hub.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">  server_name hub.xxxxxx.com;</span><br><span class="line">  listen 443 ssl http2;</span><br><span class="line">  ssl_certificate  /data/letsencrypt/hub.xxxxxx.com/fullchain.cer;</span><br><span class="line">  ssl_certificate_key /data/letsencrypt/hub.xxxxxx.com/hub.xxxxxx.com.key;</span><br><span class="line">  include /data/letsencrypt/options-ssl-nginx.conf; # managed by Certbot</span><br><span class="line">  ssl_dhparam /data/letsencrypt/ssl-dhparams.pem; # managed by Certbot</span><br><span class="line"></span><br><span class="line">  add_header      Strict-Transport-Security &quot;max-age=31536000&quot; always;</span><br><span class="line">  location / &#123;</span><br><span class="line"></span><br><span class="line">    proxy_pass https://172.16.20.30:4443; #代理到宿主机的4443端口,宿主机会将4443代理到hub-docer容器的443端口</span><br><span class="line">    client_max_body_size 2000m; #这里要定义大一点,否则提交镜像的时候,会提示 413 Request Entity Too Large</span><br><span class="line">                proxy_buffering off;</span><br><span class="line">                proxy_ssl_verify off;</span><br><span class="line">                proxy_set_header Host $http_host;</span><br><span class="line">                proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">                proxy_set_header Connection &quot;Upgrade&quot;;</span><br><span class="line">                proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    if ($host = hub.xxxxxx.com)&#123;</span><br><span class="line">        return 301 https://$host$request_uri;</span><br><span class="line">    &#125; # managed by Certbot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  listen 80;</span><br><span class="line">    server_name hub.xxxxxx.com;</span><br><span class="line">    return 404; # managed by Certbot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此,部署就完成了.</p><p>我之前在部署的过程中遇到无数的坑,,可能都是由于harbor没有使用Https引起的</p><hr><p>浏览器访问<a href="https://hub.xxxxxx.com,用初始的账号密码登陆,可以新建项目,创建用户等" target="_blank" rel="noopener">https://hub.xxxxxx.com,用初始的账号密码登陆,可以新建项目,创建用户等</a>.</p><p>我这里创建了一个master的公开项目</p><hr><p>登陆和push镜像没有任何问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@idc-function-docker ~]# docker login --username=admin -pHarbor12345 hub.xxxxxx.com</span><br><span class="line">WARNING! Using --password via the CLI is insecure. Use --password-stdin.</span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br><span class="line">[root@idc-function-docker ~]# docker push hub.xxxxxx.com/master/nginx:latest</span><br><span class="line">The push refers to repository [hub.xxxxxx.com/master/nginx]</span><br><span class="line">d37eecb5b769: Layer already exists</span><br><span class="line">99134ec7f247: Layer already exists</span><br><span class="line">c3a984abe8a8: Layer already exists</span><br><span class="line">latest: digest: sha256:7ac7819e1523911399b798309025935a9968b277d86d50e5255465d6592c0266 size: 948</span><br><span class="line">[root@idc-function-docker ~]#</span><br></pre></td></tr></table></figure><p>在另外一台客户端上,尝试pull镜像不需要密码.如果需要密码pull镜像,可以将项目设置为私有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$docker pull  hub.xxxxxx.com/master/nginx:latest</span><br><span class="line">latest: Pulling from master/nginx</span><br><span class="line">Digest: sha256:7ac7819e1523911399b798309025935a9968b277d86d50e5255465d6592c0266</span><br><span class="line">Status: Downloaded newer image for hub.xxxxxx.com/master/nginx:latest</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;harbor私有仓库部署&quot;&gt;&lt;a href=&quot;#harbor私有仓库部署&quot; class=&quot;headerlink&quot; title=&quot;harbor私有仓库部署&quot;&gt;&lt;/a&gt;harbor私有仓库部署&lt;/h2&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;harbor是docker的私有仓库,可以部署在局域网服务器上,用来管理docker镜像.虽然docker官方也提供公共镜像仓库,但是由于是境外网站,拉取镜像速度非常慢,而且有被墙的可能.部署私有仓库非常有必要&lt;/p&gt;
&lt;p&gt;harbor是vmware公司开源的企业级的docker registry管理项目.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;处于数据脱敏需要,以下内容中隐藏了真实域名.而使用hub.xxxxxx.com替代&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;社区&quot;&gt;&lt;a href=&quot;#社区&quot; class=&quot;headerlink&quot; title=&quot;社区&quot;&gt;&lt;/a&gt;社区&lt;/h3&gt;&lt;p&gt;harbor github: &lt;a href=&quot;https://github.com/goharbor/harbor&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;goharbor/harbor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官网文档介绍: &lt;a href=&quot;https://goharbor.io/docs/1.10/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;harbor doc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在部署中遇到的各种坑,都可以通过查阅文档,或者搜索github的issue解决&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;框架&quot;&gt;&lt;a href=&quot;#框架&quot; class=&quot;headerlink&quot; title=&quot;框架&quot;&gt;&lt;/a&gt;框架&lt;/h3&gt;&lt;p&gt;harbor是docker-compose部署的.包括一系列组件:nginx.core,log,register等等.&lt;/p&gt;
&lt;p&gt;但是由于本机已经存在一个Nginx镜像.所以用Nginx代理到harbor的Nginx.&lt;strong&gt;如果是独立的服务器部署Harbor的话,则不会存在这个问题,可以直接跳过这一章节.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;nginx代理框架大概是:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;nginx—-&amp;gt;harbor-nginx—–&amp;gt;habor&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于docker提交镜像需要Https协议,所以:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;nginx—301跳转到nginx https—–&amp;gt;harbor-nginx http—-&amp;gt; habor&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是这样的部署方式,有一个问题:&lt;/p&gt;
&lt;p&gt;私有仓库可以正常login但是push镜像的时候,又提示未验证.&lt;/p&gt;
&lt;p&gt;该问题尝试过很多解决方案,但是均无法解决&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="https://jesse.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://jesse.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>kong+postgresql+konga集群环境部署</title>
    <link href="https://jesse.top/2020/06/26/Linux-Web/kong%20postgresql%20konga/"/>
    <id>https://jesse.top/2020/06/26/Linux-Web/kong postgresql konga/</id>
    <published>2020-06-26T03:59:58.000Z</published>
    <updated>2020-06-26T03:09:18.121Z</updated>
    
    <content type="html"><![CDATA[<h2 id="kong-postgresql-konga集群环境部署"><a href="#kong-postgresql-konga集群环境部署" class="headerlink" title="kong+postgresql+konga集群环境部署"></a>kong+postgresql+konga集群环境部署</h2><h3 id="kong简介"><a href="#kong简介" class="headerlink" title="kong简介"></a>kong简介</h3><p>Kong是Mashape开源的一款API网关，起初是用来管理 Mashape 公司15000个微服务的，后来在2015年开源,现在已经在很多创业公司、大型企业和政府机构中广泛使用。基于nginx,Lua和Cassandra或PostgreSQL，支持分布式操作，有很强的可移植性和可扩展性。可以在任何一种基础设施上运行,作为应用和API之间的中间层，加上众多功能强大的插件，可以实现认证授权、访问控制等功能。并且提供易于使用的RESTful API来操作和配置系统。</p><p>有关kong的详细介绍请参考官网.</p><p>–</p><h3 id="postgreSQL简介"><a href="#postgreSQL简介" class="headerlink" title="postgreSQL简介"></a>postgreSQL简介</h3><p><a href="https://baike.baidu.com/item/PostgreSQL/530240" target="_blank" rel="noopener">PostgreSQL</a> 是一个免费的对象-关系数据库服务器(数据库管理系统)，它在灵活的 BSD-风格许可证下发行。它提供了相对其他开放源代码数据库系统(比如 MySQL 和 Firebird)，和专有系统(比如 Oracle、Sybase、IBM 的 DB2 和 Microsoft SQL Server)之外的另一种选择。</p><p>–</p><h3 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h3><ul><li><strong>kong cluster</strong></li></ul><p>kong 集群并不意味着客户端请求将会负载均衡到kong集群中的每个节点上，kong集群并不是开箱即用，仍然需要在kong集群多节点上层搭建负载均衡，以便分发请求。 一个kong集群只是意味着集群内的节点，都共享同样的配置。</p><p>有关Kong cluster集群的详细介绍请参考官网:<a href="https://docs.konghq.com/0.14.x/clustering/" target="_blank" rel="noopener">Kong cluser document</a></p><p>为了提高冗余性和健壮性.我们对kong的每个环节都进行了冗余设计.一个基本的kong集群架构大概如下图所示:</p><p><img src="https://img1.jesse.top/kong-flow.png" alt=""></p><a id="more"></a><p>–</p><h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3><p><strong>环境</strong>: </p><p>阿里云ECS Centos7.4操作系统<br>Kong: 1.0最新版<br>postgresql 9.6</p><p>konga 最新版</p><p><strong>集群架构说明:</strong></p><p>dwd-kong-node1节点服务器部署postgresql master主库</p><p>dwd-kong-node2节点服务器部署postgresql slave从库</p><p>在两个Kong节点服务器上都部署konga,但是konga指向postgresql master主库</p><p>–</p><h4 id="安装postgresql"><a href="#安装postgresql" class="headerlink" title="安装postgresql"></a>安装postgresql</h4><p>安装方式官网参考: <a href="https://www.postgresql.org/" target="_blank" rel="noopener">Installing Postgresql</a></p><p><strong>安装步骤</strong></p><p>1.安装Postgre9.6版本的Yum源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install https://download.postgresql.org/pub/repos/yum/9.6/redhat/rhel-7-x86_64/pgdg-centos96-9.6-3.noarch.rpm</span><br></pre></td></tr></table></figure><p>2.安装postgresql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install postgresql96 postgresql96-server -y</span><br></pre></td></tr></table></figure><p>3.切换到root用户下,初始化数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/pgsql-9.6/bin/postgresql96-setup initdb</span><br></pre></td></tr></table></figure><p>4.修改数据库的配置文件,监听所有接口</p><p>postgresql的配置文件默认路径在:/var/lib/pgsql/9.6/data/postgresql.conf</p><p>修改下列配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">listen_addresses = &apos;*&apos; #监听所有接口.由于我服务器只有内网地址,所有可以侦听在所有接口,(如果有公网地址,最好不要只样做)</span><br><span class="line">log_directory = &apos;/data/logs/postgre&apos; #指定日志文件的父目录</span><br></pre></td></tr></table></figure><p>5.修改数据库远程访问配置文件.开启远程访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /var/lib/pgsql/9.6/data/postgresql.conf/pg_hba.conf</span><br><span class="line"></span><br><span class="line">修改下列两项:</span><br><span class="line">#修改为md5认证,下列10.0.0.0/8是内网地址段</span><br><span class="line">host    all             all             127.0.0.1/32            md5</span><br><span class="line">host    all             all             10.0.0.0/8           md5</span><br></pre></td></tr></table></figure><p>6.创建日志目录,并且赋权给postgres用户(安装postgresql后默认会创建这个用户)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@dwd-kong-node1 data]# mkdir /data/logs/postgre</span><br><span class="line">[root@dwd-kong-node1 data]# chown -R postgre.postgre /data/logs/postgre</span><br></pre></td></tr></table></figure><p>7.启动postgresql数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable postgresql-9.6</span><br><span class="line">systemctl start postgresql-9.6</span><br></pre></td></tr></table></figure><hr><h3 id="创建数据库用户密码"><a href="#创建数据库用户密码" class="headerlink" title="创建数据库用户密码"></a>创建数据库用户密码</h3><p>1.切换到postgres用户,输入psql登陆数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@dwd-kong-node1 data]# su - postgres</span><br><span class="line">Last login: Mon Apr  8 09:27:12 CST 2019 on pts/0</span><br><span class="line">-bash-4.2$</span><br><span class="line">-bash-4.2$ psql</span><br><span class="line">psql (11.2, server 9.6.12)</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">postgres=#</span><br></pre></td></tr></table></figure><p>2.创建kong用户和kong数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER kong; </span><br><span class="line">CREATE DATABASE kong OWNER kong;</span><br></pre></td></tr></table></figure><p>3.创建konga的数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE konga OWNER kong;</span><br></pre></td></tr></table></figure><p>4.为kong用户创建一个密码,密码也是kong</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter user kong with password &apos;kong&apos;;</span><br></pre></td></tr></table></figure><p>5.输入\l,可以看到当前的数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">postgres=# \l</span><br><span class="line">                                  List of databases</span><br><span class="line">   Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges</span><br><span class="line">-----------+----------+----------+-------------+-------------+-----------------------</span><br><span class="line"> kong      | kong     | UTF8     | en_US.UTF-8 | en_US.UTF-8 |</span><br><span class="line"> konga     | kong     | UTF8     | en_US.UTF-8 | en_US.UTF-8 |</span><br><span class="line"> postgres  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |</span><br><span class="line"> template0 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +</span><br><span class="line">           |          |          |             |             | postgres=CTc/postgres</span><br><span class="line"> template1 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +</span><br><span class="line">           |          |          |             |             | postgres=CTc/postgres</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure><p>6.查看当前数据库有哪些用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">postgres=# select * from pg_roles;</span><br><span class="line">      rolname      | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolconnlimit | rolpassword | rolvaliduntil | rolbypassrls | rolconfig |  oid</span><br><span class="line">-------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+-------------+---------------+--------------+-----------+-------</span><br><span class="line"> postgres          | t        | t          | t             | t           | t           | t              |           -1 | ********    |               | t            |           |    10</span><br><span class="line"> pg_signal_backend | f        | t          | f             | f           | f           | f              |           -1 | ********    |               | f            |           |  4200</span><br><span class="line"> kong              | f        | t          | f             | f           | t           | f              |           -1 | ********    |               | f            |           | 16384</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure><hr><h4 id="安装Kong"><a href="#安装Kong" class="headerlink" title="安装Kong"></a>安装Kong</h4><p>安装方法可以参考官网:<a href="https://docs.konghq.com/install/centos/?_ga=2.110797315.728319704.1539597667-917309945.1539077269#packages" target="_blank" rel="noopener">Install Kong</a></p><p>1.下载,安装rpm安装包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget -O kong-community-edition-1.0.0.el7.noarch.rpm  https://kong.bintray.com/kong-community-edition-rpm/centos/7/:kong-community-edition-1.0.0.el7.noarch.rpm</span><br><span class="line"></span><br><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install kong-community-edition-1.0.0.el7.noarch.rpm</span><br></pre></td></tr></table></figure><p>2.dwd-kong-node1修改kong配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/kong</span><br><span class="line">sudo cp kong.conf.default kong.conf</span><br><span class="line"></span><br><span class="line">[root@dwd-kong-node1 data]#  sed -r &apos;/^[[:space:]]+#*/d&apos; /etc/kong/kong.conf | sed &apos;/^#/d&apos; | sed &apos;/^$/d&apos;</span><br><span class="line"></span><br><span class="line">prefix = /data/logs/kong/       # Working directory. Equivalent to Nginx&apos;s</span><br><span class="line">proxy_access_log = access.log       # Path for proxy port request access</span><br><span class="line">proxy_error_log = error.log         # Path for proxy port request error</span><br><span class="line">admin_listen = 0.0.0.0:8001     # Address and port on which Kong will expose</span><br><span class="line">database = postgres             # Determines which of PostgreSQL or Cassandra</span><br><span class="line">pg_host = 127.0.0.1             # The PostgreSQL host to connect to.</span><br><span class="line">pg_port = 5432                  # The port to connect to.</span><br><span class="line">pg_user = kong                  # The username to authenticate if required.</span><br><span class="line">pg_password = kong                 # The password to authenticate if required.</span><br><span class="line">pg_database = kong              # The database name to connect to.</span><br><span class="line">cluster_listen = 0.0.0.0:7946   # Address and port used to communicate with</span><br><span class="line">cluster_listen_rpc = 127.0.0.1:7373  # Address and port used to communicate</span><br></pre></td></tr></table></figure><p>3.dwd-kong-node2修改kong配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@dwd-kong-node2 system]# clear</span><br><span class="line">[root@dwd-kong-node2 system]# sed -r &apos;/^[[:space:]]+#*/d&apos; /etc/kong/kong.conf | sed &apos;/^#/d&apos; | sed &apos;/^$/d&apos;</span><br><span class="line">prefix = /data/logs/kong/       # Working directory. Equivalent to Nginx&apos;s</span><br><span class="line">proxy_access_log = access.log       # Path for proxy port request access</span><br><span class="line">proxy_error_log = error.log         # Path for proxy port request error</span><br><span class="line">database = postgres             # Determines which of PostgreSQL or Cassandra</span><br><span class="line">pg_host = 10.111.30.174             # The PostgreSQL host to connect to.</span><br><span class="line">pg_port = 5432                  # The port to connect to.</span><br><span class="line">pg_user = kong                  # The username to authenticate if required.</span><br><span class="line">pg_password = kong                 # The password to authenticate if required.</span><br><span class="line">pg_database = kong              # The database name to connect to.</span><br><span class="line">pg_ssl = off                    # Toggles client-server TLS connections</span><br><span class="line">pg_ssl_verify = off             # Toggles server certificate verification if</span><br><span class="line">cluster_listen = 0.0.0.0:7946   # Address and port used to communicate with</span><br><span class="line">cluster_listen_rpc = 127.0.0.1:7373  # Address and port used to communicate</span><br></pre></td></tr></table></figure><blockquote><p>唯一区别就是这里的数据库指向dwd-kong-node1上的postgresql(IP:10.111.30.174),而非本机.</p></blockquote><p>3.创建kong目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/logs/kong/</span><br></pre></td></tr></table></figure><p>4.在dwd-kong-node1上准备数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kong migrations bootstrap -c /etc/kong/kong.conf</span><br></pre></td></tr></table></figure><blockquote><p>由于dwd-kong-node2上指向了node1的数据库,所以在node2上不需要执行这个命令</p></blockquote><p>5.启动kong</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kong start -c /etc/kong/kong.conf</span><br></pre></td></tr></table></figure><p>查看端口.可以看到postgresql和kong的侦听端口都已经成功启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@dwd-kong-node1 data]# netstat -tulpn</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class="line">tcp        0      0 0.0.0.0:5432            0.0.0.0:*               LISTEN      26580/postmaster</span><br><span class="line">tcp        0      0 0.0.0.0:8443            0.0.0.0:*               LISTEN      24746/nginx: master</span><br><span class="line">tcp        0      0 0.0.0.0:5822            0.0.0.0:*               LISTEN      29688/sshd</span><br><span class="line">tcp        0      0 0.0.0.0:8000            0.0.0.0:*               LISTEN      24746/nginx: master</span><br><span class="line">tcp        0      0 0.0.0.0:8001            0.0.0.0:*               LISTEN      24746/nginx: master</span><br><span class="line">tcp6       0      0 :::5432                 :::*                    LISTEN      26580/postmaster</span><br><span class="line">udp        0      0 0.0.0.0:68              0.0.0.0:*                           748/dhclient</span><br><span class="line">udp        0      0 10.111.30.174:123       0.0.0.0:*                           6290/ntpd</span><br><span class="line">udp        0      0 127.0.0.1:123           0.0.0.0:*                           6290/ntpd</span><br><span class="line">udp        0      0 0.0.0.0:123             0.0.0.0:*                           6290/ntpd</span><br><span class="line">udp        0      0 0.0.0.0:34019           0.0.0.0:*                           748/dhclient</span><br><span class="line">udp6       0      0 :::31421                :::*                                748/dhclient</span><br><span class="line">udp6       0      0 :::123                  :::*                                6290/ntpd</span><br></pre></td></tr></table></figure><hr><h3 id="搭建konga"><a href="#搭建konga" class="headerlink" title="搭建konga"></a>搭建konga</h3><p>konga是管理kong各个组件(serveice,route,plugin,upstream,consumer)的可视化UI管理工具.在增删改查各个组件的配置时非常方便.</p><p>个人觉得UI界面比kong-dashboard要漂亮</p><p>konga的github参考:<a href="https://github.com/pantsel/konga" target="_blank" rel="noopener">konga</a></p><hr><p>1.确保需要有node.js环境.如果没有npm工具,必须先安装nodejs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@DWD-BETA kong]$ npm -v</span><br><span class="line">6.4.1</span><br><span class="line">[work@DWD-BETA kong]$ node -v</span><br><span class="line">v10.15.3</span><br></pre></td></tr></table></figure><p>2.安装bower,gulp包.安装git软件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install bower</span><br><span class="line">npm install gulp</span><br><span class="line">yum install git</span><br></pre></td></tr></table></figure><p>3.work用户下安装konga</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/pantsel/konga.git</span><br><span class="line">$ cd konga</span><br><span class="line">$ npm i</span><br></pre></td></tr></table></figure><p>4.编辑.env环境文件(dwd-kong-node2的文件内容中将下列的localhost修改为node1服务器的IP:10.111.30.174)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">work@dwd-kong-node1 konga]$ cat .env_example</span><br><span class="line">PORT=1337</span><br><span class="line">NODE_ENV=production</span><br><span class="line">KONGA_HOOK_TIMEOUT=120000</span><br><span class="line">DB_ADAPTER=postgres</span><br><span class="line">DB_URI=postgresql://localhost:5432/konga</span><br><span class="line">KONGA_LOG_LEVEL=warn</span><br><span class="line">TOKEN_SECRET=some_secret_token</span><br><span class="line">DB_USER=kong</span><br><span class="line">DB_PASSWORD=kong</span><br><span class="line">DB_DATABASE=konga</span><br></pre></td></tr></table></figure><p>5.启动konga</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">work@dwd-kong-node1 konga]$ npm start</span><br></pre></td></tr></table></figure><p>6.如果启动报错,则安装依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">work@dwd-kong-node1 konga]$ npm run bower-deps</span><br></pre></td></tr></table></figure><p>这个程序默认是前台启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[work@dwd-kong-node1 konga]$ npm start</span><br><span class="line"></span><br><span class="line">&gt; kongadmin@0.14.3 start /home/work/konga</span><br><span class="line">&gt; node --harmony app.js</span><br><span class="line"></span><br><span class="line">No DB Adapter defined. Using localDB...</span><br><span class="line">debug: Hook:api_health_checks:process() called</span><br><span class="line">debug: Hook:health_checks:process() called</span><br><span class="line">debug: Hook:start-scheduled-snapshots:process() called</span><br><span class="line">debug: Hook:upstream_health_checks:process() called</span><br><span class="line">debug: Hook:user_events_hook:process() called</span><br><span class="line">debug: User had models, so no seed needed</span><br><span class="line">debug: Kongnode had models, so no seed needed</span><br><span class="line">debug: Emailtransport seeds updated</span><br><span class="line">debug: -------------------------------------------------------</span><br><span class="line">debug: :: Mon Apr 08 2019 18:34:31 GMT+0800 (China Standard Time)</span><br><span class="line">debug: Environment : development</span><br><span class="line">debug: Port        : 1337</span><br><span class="line">debug: -------------------------------------------------------</span><br></pre></td></tr></table></figure><p>此时在浏览器输入:<a href="http://10.111.30.174:1337" target="_blank" rel="noopener">http://10.111.30.174:1337</a> 就能访问konga了.</p><hr><h3 id="systemctl管理kong和konga进程"><a href="#systemctl管理kong和konga进程" class="headerlink" title="systemctl管理kong和konga进程"></a>systemctl管理kong和konga进程</h3><ul><li>kong</li></ul><p>在/usr/lib/systemd/system路径下编辑kong.service文件.内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">work@dwd-kong-node1 system]$ pwd</span><br><span class="line">/usr/lib/systemd/system</span><br><span class="line">[work@dwd-kong-node1 system]$ cat kong.service</span><br><span class="line">[Unit]</span><br><span class="line">Description= kong service</span><br><span class="line">After=syslog.target network.target postgresql-9.6.target</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=work</span><br><span class="line">Group=work</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/kong start -c /etc/kong/kong.conf</span><br><span class="line">ExecReload=/usr/local/bin/kong reload -c /etc/kong/kong.conf</span><br><span class="line">ExecStop=/usr/local/bin/kong stop</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><ul><li>konga</li></ul><p>在/usr/lib/systemd/system路径下编辑konga.service文件.内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[work@dwd-kong-node1 system]$ cat konga.service</span><br><span class="line">[Unit]</span><br><span class="line">Description= konga service</span><br><span class="line">After=syslog.target network.target postgresql-9.6.target  kong.target</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=work</span><br><span class="line">Group=work</span><br><span class="line">Type=forking</span><br><span class="line">#需要指定工作目录,因为npm命令要在konga的目录下执行</span><br><span class="line">WorkingDirectory=/home/work/konga</span><br><span class="line">ExecStart=/usr/local/bin/npm start</span><br><span class="line">ExecStop=kill $(netstat -tlnp |grep 1337|  awk &apos;&#123;print $NF&#125;&apos; | awk -F &quot;/&quot; &apos;&#123;print $1&#125;&apos;)</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><ul><li>启动进程,且设置开机启动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[work@dwd-kong-node2 ~]$ sudo systemctl enable kong</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/kong.service to /usr/lib/systemd/system/kong.service.</span><br><span class="line">[work@dwd-kong-node2 ~]$ sudo systemctl enable konga.service</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/konga.service to /usr/lib/systemd/system/konga.service.</span><br><span class="line">[work@dwd-kong-node2 ~]$ sudo systemctl start kong.service</span><br><span class="line">[work@dwd-kong-node2 ~]$ sudo systemctl start konga.service</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;kong-postgresql-konga集群环境部署&quot;&gt;&lt;a href=&quot;#kong-postgresql-konga集群环境部署&quot; class=&quot;headerlink&quot; title=&quot;kong+postgresql+konga集群环境部署&quot;&gt;&lt;/a&gt;kong+postgresql+konga集群环境部署&lt;/h2&gt;&lt;h3 id=&quot;kong简介&quot;&gt;&lt;a href=&quot;#kong简介&quot; class=&quot;headerlink&quot; title=&quot;kong简介&quot;&gt;&lt;/a&gt;kong简介&lt;/h3&gt;&lt;p&gt;Kong是Mashape开源的一款API网关，起初是用来管理 Mashape 公司15000个微服务的，后来在2015年开源,现在已经在很多创业公司、大型企业和政府机构中广泛使用。基于nginx,Lua和Cassandra或PostgreSQL，支持分布式操作，有很强的可移植性和可扩展性。可以在任何一种基础设施上运行,作为应用和API之间的中间层，加上众多功能强大的插件，可以实现认证授权、访问控制等功能。并且提供易于使用的RESTful API来操作和配置系统。&lt;/p&gt;
&lt;p&gt;有关kong的详细介绍请参考官网.&lt;/p&gt;
&lt;p&gt;–&lt;/p&gt;
&lt;h3 id=&quot;postgreSQL简介&quot;&gt;&lt;a href=&quot;#postgreSQL简介&quot; class=&quot;headerlink&quot; title=&quot;postgreSQL简介&quot;&gt;&lt;/a&gt;postgreSQL简介&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/PostgreSQL/530240&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PostgreSQL&lt;/a&gt; 是一个免费的对象-关系数据库服务器(数据库管理系统)，它在灵活的 BSD-风格许可证下发行。它提供了相对其他开放源代码数据库系统(比如 MySQL 和 Firebird)，和专有系统(比如 Oracle、Sybase、IBM 的 DB2 和 Microsoft SQL Server)之外的另一种选择。&lt;/p&gt;
&lt;p&gt;–&lt;/p&gt;
&lt;h3 id=&quot;集群架构&quot;&gt;&lt;a href=&quot;#集群架构&quot; class=&quot;headerlink&quot; title=&quot;集群架构&quot;&gt;&lt;/a&gt;集群架构&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;kong cluster&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;kong 集群并不意味着客户端请求将会负载均衡到kong集群中的每个节点上，kong集群并不是开箱即用，仍然需要在kong集群多节点上层搭建负载均衡，以便分发请求。 一个kong集群只是意味着集群内的节点，都共享同样的配置。&lt;/p&gt;
&lt;p&gt;有关Kong cluster集群的详细介绍请参考官网:&lt;a href=&quot;https://docs.konghq.com/0.14.x/clustering/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kong cluser document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为了提高冗余性和健壮性.我们对kong的每个环节都进行了冗余设计.一个基本的kong集群架构大概如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img1.jesse.top/kong-flow.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux-Web" scheme="https://jesse.top/categories/Linux-Web/"/>
    
      <category term="kong" scheme="https://jesse.top/categories/Linux-Web/kong/"/>
    
    
      <category term="kong" scheme="https://jesse.top/tags/kong/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jesse.top/2020/06/26/Linux-Web/kong%20API%E7%BD%91%E5%85%B3%E4%BB%8B%E7%BB%8D%E5%8F%8AAPI%E6%8E%A5%E5%8F%A3%E9%85%8D%E7%BD%AE/"/>
    <id>https://jesse.top/2020/06/26/Linux-Web/kong API网关介绍及API接口配置/</id>
    <published>2020-06-26T03:05:39.216Z</published>
    <updated>2020-06-26T02:51:43.681Z</updated>
    
    <content type="html"><![CDATA[<h2 id="kong-API网关介绍及API接口配置"><a href="#kong-API网关介绍及API接口配置" class="headerlink" title="kong API网关介绍及API接口配置"></a>kong API网关介绍及API接口配置</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;kong-API网关介绍及API接口配置&quot;&gt;&lt;a href=&quot;#kong-API网关介绍及API接口配置&quot; class=&quot;headerlink&quot; title=&quot;kong API网关介绍及API接口配置&quot;&gt;&lt;/a&gt;kong API网关介绍及API接口配置&lt;/h2&gt;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Linux 使用parted+LVM分区</title>
    <link href="https://jesse.top/2020/06/26/Linux-Basic/Skills/Linux%20%E4%BD%BF%E7%94%A8parted%20LVM%E5%88%86%E5%8C%BA/"/>
    <id>https://jesse.top/2020/06/26/Linux-Basic/Skills/Linux 使用parted LVM分区/</id>
    <published>2020-06-26T02:59:58.000Z</published>
    <updated>2020-06-26T03:10:46.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux-使用parted-LVM分区"><a href="#Linux-使用parted-LVM分区" class="headerlink" title="Linux 使用parted+LVM分区"></a>Linux 使用parted+LVM分区</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>fdisk使用MBR分区硬盘,但是最大只能识别到2T的磁盘,如果单块磁盘超过2T则需要使用GPT分区格式</p><hr><h4 id="分区步骤"><a href="#分区步骤" class="headerlink" title="分区步骤"></a>分区步骤</h4><p>分区方法和fdisk大同小异</p><ul><li>1.parted 磁盘名 .进入交互式界面</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@archiver-mysql ~]# parted /dev/vdb</span><br><span class="line">GNU Parted 3.1</span><br><span class="line">Using /dev/vdb</span><br><span class="line">Welcome to GNU Parted! Type &apos;help&apos; to view a list of commands.</span><br></pre></td></tr></table></figure><ul><li>2.mklabel gpt 转换为gpt分区</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parted) mklabel gpt</span><br><span class="line">Warning: The existing disk label on /dev/vdb will be destroyed and all data on this disk will be lost. Do you want to continue?</span><br><span class="line">Yes/No? yes</span><br></pre></td></tr></table></figure><p>3.mkpart分区</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(parted) mkpart</span><br><span class="line">Partition name?  []? data  </span><br><span class="line">File system type?  [ext2]? ext4</span><br><span class="line">Start?</span><br><span class="line">Start?</span><br><span class="line">Start? 0% #起始和结束为止要用百分比格式,使4K对齐</span><br><span class="line">End? 100%</span><br><span class="line"></span><br><span class="line">#也可以直接在一条命令上输入</span><br><span class="line">mkpart data ext4 0% 100%</span><br></pre></td></tr></table></figure><p>至此,gpt分区就完成了.可以看到单块磁盘有5T空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(parted) print</span><br><span class="line">Model: Virtio Block Device (virtblk)</span><br><span class="line">Disk /dev/vdb: 5498GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags:</span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    File system  Name  Flags</span><br><span class="line"> 1      1049kB  5498GB  5498GB               data</span><br></pre></td></tr></table></figure><hr><h3 id="二-LVM分区"><a href="#二-LVM分区" class="headerlink" title="二 LVM分区"></a>二 LVM分区</h3><p>步骤一样</p><ul><li>1.pvcreate /dev/vdb1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@archiver-mysql ~]# pvcreate /dev/vdb1</span><br><span class="line">WARNING: ext4 signature detected on /dev/vdb1 at offset 1080. Wipe it? [y/n]: y</span><br><span class="line">  Wiping ext4 signature on /dev/vdb1.</span><br><span class="line">  Physical volume &quot;/dev/vdb1&quot; successfully created.</span><br><span class="line">  </span><br><span class="line">  [root@archiver-mysql ~]# pvdisplay</span><br><span class="line">  &quot;/dev/vdb1&quot; is a new physical volume of &quot;&lt;5.00 TiB&quot;</span><br><span class="line">  --- NEW Physical volume ---</span><br><span class="line">  PV Name               /dev/vdb1</span><br><span class="line">  VG Name</span><br><span class="line">  PV Size               &lt;5.00 TiB</span><br><span class="line">  Allocatable           NO</span><br><span class="line">  PE Size               0</span><br><span class="line">  Total PE              0</span><br><span class="line">  Free PE               0</span><br><span class="line">  Allocated PE          0</span><br><span class="line">  PV UUID               0SKSgB-TBHZ-PKU8-La1Q-dG00-23Df-4ZXoy4</span><br></pre></td></tr></table></figure><ul><li>2.vgextend vg名 pv名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@archiver-mysql ~]# vgdisplay</span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               mysql_log_vggroup  #这个是vg名字</span><br><span class="line">  System ID</span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        1</span><br><span class="line">  Metadata Sequence No  2</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                1</span><br><span class="line">  Open LV               1</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                1</span><br><span class="line">  Act PV                1</span><br><span class="line">  VG Size               &lt;100.00 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              25599</span><br><span class="line">  Alloc PE / Size       25599 / &lt;100.00 GiB</span><br><span class="line">  Free  PE / Size       0 / 0</span><br><span class="line">  VG UUID               JERXbu-vnc0-X2Kz-1PRH-2Q4v-kIc3-bRjNkE</span><br><span class="line">  </span><br><span class="line">  [root@archiver-mysql ~]# vgcreate mysql_data_vggroup /dev/vdb1 #这是vgcreate命令</span><br><span class="line">  Volume group &quot;mysql_data_vggroup&quot; successfully created</span><br></pre></td></tr></table></figure><ul><li>3.lvcreate -n lv卷名字  -l +100%free vg卷名字</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@archiver-mysql ~]# lvcreate -n mysql_data_lvgroup -l +100%free mysql_data_vggroup</span><br></pre></td></tr></table></figure><ul><li>4.格式化卷</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@archiver-mysql ~]# mkfs.ext4 /dev/mysql_data_vggroup/mysql_data_lvgroup</span><br></pre></td></tr></table></figure><ul><li><ol start="5"><li>挂载</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@archiver-mysql ~]# mount /dev/mysql_data_vggroup/mysql_data_lvgroup /data</span><br></pre></td></tr></table></figure><ul><li>6.别忘记写入/etc/fstab开启自启文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;/dev/mapper/mysql_data_vggroup-mysql_data_lvgroup /data ext4 defaults 0 0&quot; &gt;&gt; /etc/fstab</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Linux-使用parted-LVM分区&quot;&gt;&lt;a href=&quot;#Linux-使用parted-LVM分区&quot; class=&quot;headerlink&quot; title=&quot;Linux 使用parted+LVM分区&quot;&gt;&lt;/a&gt;Linux 使用parted+LVM分区&lt;/h2&gt;&lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;&lt;p&gt;fdisk使用MBR分区硬盘,但是最大只能识别到2T的磁盘,如果单块磁盘超过2T则需要使用GPT分区格式&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;分区步骤&quot;&gt;&lt;a href=&quot;#分区步骤&quot; class=&quot;headerlink&quot; title=&quot;分区步骤&quot;&gt;&lt;/a&gt;分区步骤&lt;/h4&gt;&lt;p&gt;分区方法和fdisk大同小异&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.parted 磁盘名 .进入交互式界面&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@archiver-mysql ~]# parted /dev/vdb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;GNU Parted 3.1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Using /dev/vdb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Welcome to GNU Parted! Type &amp;apos;help&amp;apos; to view a list of commands.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;2.mklabel gpt 转换为gpt分区&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(parted) mklabel gpt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Warning: The existing disk label on /dev/vdb will be destroyed and all data on this disk will be lost. Do you want to continue?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Yes/No? yes&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3.mkpart分区&lt;/p&gt;
    
    </summary>
    
      <category term="Linux-Basic" scheme="https://jesse.top/categories/Linux-Basic/"/>
    
      <category term="Skills" scheme="https://jesse.top/categories/Linux-Basic/Skills/"/>
    
    
      <category term="LVM" scheme="https://jesse.top/tags/LVM/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://jesse.top/2020/06/26/Linux-Basic/SSL/gitlab%E6%9B%B4%E6%96%B0SSL%E8%AF%81%E4%B9%A6/"/>
    <id>https://jesse.top/2020/06/26/Linux-Basic/SSL/gitlab更新SSL证书/</id>
    <published>2020-06-26T02:59:37.826Z</published>
    <updated>2020-06-26T02:51:43.987Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>由于letsencrypt证书有效期太短.gitlab不是很方便自动续约.所以在阿里云上购买证书,然后下载到到服务器.(由于gitlab底层是基于nginx,所以下载证书也是选择Nginx格式)</p><hr><p>找出gitlab证书存放位置:</p><p>1.在gitlab配置文件下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@gitlab:~# cd /etc/gitlab</span><br><span class="line">root@gitlab:/etc/gitlab# ls</span><br><span class="line">gitlab.rb  gitlab.rb.bak  gitlab.rb.bak2  gitlab-secrets.json  trusted-certs</span><br></pre></td></tr></table></figure><p>2.打开gitlab.rb配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@gitlab:/etc/gitlab# vim gitlab.rb</span><br><span class="line"></span><br><span class="line">#可以找到下列两行配置.这个就是gitlab的ssl证书存放路径</span><br><span class="line">nginx[&apos;ssl_certificate&apos;] = &quot;/etc/ssl/private/gitlab.pem&quot;</span><br><span class="line">nginx[&apos;ssl_certificate_key&apos;] = &quot;/etc/ssl/private/gitlab.key&quot;</span><br></pre></td></tr></table></figure><p>在gitlab的nginx配置文件下也可以找到相关配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@gitlab:/etc/gitlab# cd /var/opt/gitlab/nginx/conf/</span><br><span class="line">root@gitlab:/var/opt/gitlab/nginx/conf# ls</span><br><span class="line">gitlab-http.conf  gitlab-http.conf.bak  nginx.conf  nginx-status.conf</span><br><span class="line"></span><br><span class="line">#在gitlab-http.conf的nginx配置文件中也定义了ssl路径:</span><br><span class="line"></span><br><span class="line">root@gitlab:/var/opt/gitlab/nginx/conf# cat gitlab-http.conf | grep ssl_certificate</span><br><span class="line">  ssl_certificate /etc/ssl/private/gitlab.pem;</span><br><span class="line">  ssl_certificate_key /etc/ssl/private/gitlab.key;</span><br></pre></td></tr></table></figure><p>3.将阿里云下载下来的证书上传到gitlab的/etc/ssl/private目录中</p><p>4.重命名目前的证书文件为*.bak 将新的证书文件(.pem和.key)命名为gitlab.key和gitlab.pem</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">root@gitlab:/etc/ssl/private# ll</span><br><span class="line">total 28</span><br><span class="line">drwx--x--- 2 root ssl-cert 4096 Dec 18 18:30 ./</span><br><span class="line">drwxr-xr-x 4 root root     4096 Jan 17  2018 ../</span><br><span class="line">-rwxr-xr-x 1 root root     1679 Dec 18 18:29 gitlab.key*</span><br><span class="line">-rwxr-xr-x 1 work work     1675 Dec 25  2017 gitlab.key.bak*</span><br><span class="line">-rwxr-xr-x 1 root root     3663 Dec 18 18:29 gitlab.pem*</span><br><span class="line">-rwxr-xr-x 1 work work     3313 Dec 25  2017 gitlab.pem.bak*</span><br><span class="line">-rw-r----- 1 root ssl-cert 1704 Jun  9  2017 ssl-cert-snakeoil.key</span><br></pre></td></tr></table></figure><p>5.重启gitlab程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root@gitlab:/etc/ssl/private# gitlab-ctl restart</span><br><span class="line">ok: run: gitaly: (pid 1442) 1s</span><br><span class="line">ok: run: gitlab-monitor: (pid 1449) 1s</span><br><span class="line">ok: run: gitlab-workhorse: (pid 1452) 0s</span><br><span class="line">ok: run: logrotate: (pid 1463) 1s</span><br><span class="line">ok: run: nginx: (pid 1469) 0s</span><br><span class="line">ok: run: node-exporter: (pid 1478) 0s</span><br><span class="line">ok: run: postgres-exporter: (pid 1484) 1s</span><br><span class="line">ok: run: postgresql: (pid 1494) 0s</span><br><span class="line">ok: run: prometheus: (pid 1503) 1s</span><br><span class="line">ok: run: redis: (pid 1517) 1s</span><br><span class="line">ok: run: redis-exporter: (pid 1521) 0s</span><br><span class="line">ok: run: sidekiq: (pid 1532) 0s</span><br><span class="line">ok: run: unicorn: (pid 1537) 1s</span><br><span class="line">root@gitlab:/etc/ssl/private#</span><br></pre></td></tr></table></figure><p>重新登录gitlab发现新的证书已经生效</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;由于letsencrypt证书有效期太短.gitlab不是很方便自动续约.所以在阿里云上购买证书,然后下载到到服务器.(由于gitlab底层
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>41.Python之路 - 多线程编程</title>
    <link href="https://jesse.top/2020/06/26/python/06-Concurrent/02-Python%E4%B9%8B%E8%B7%AF%20-%20%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B9%8B%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://jesse.top/2020/06/26/python/06-Concurrent/02-Python之路 - 并发编程之多线程/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:39:04.408Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-多线程编程"><a href="#Python之路-多线程编程" class="headerlink" title="Python之路 - 多线程编程"></a>Python之路 - 多线程编程</h1><h2 id="前言-🍀"><a href="#前言-🍀" class="headerlink" title="前言  🍀"></a>前言  🍀</h2><p>在上一篇中说了一大堆理论 , 那么现在就开始实践了 </p><p>先说线程再说进程 , 为什么 ?  因为在Python中有一个<code>Python GIL</code>全局解释器锁 , 这是个什么东西? 最后来说</p><p>总之线程和进程都是与操作系统有关的知识 , 所以操作系统基础 , 对于这两节内容的理解会有很大的帮助</p><h2 id="Threading-🍀"><a href="#Threading-🍀" class="headerlink" title="Threading  🍀"></a>Threading  🍀</h2><p>Python通过两个标准库<code>_thread</code> (built-in) 和<code>threading</code>提供对线程的支持 , threading对_thread进行了封装</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">_thread.py</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">This module provides primitive operations to write multi-threaded programs.</span></span><br><span class="line"><span class="string">The 'threading' module provides a more convenient interface.</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>So , 明显我们一般直接使用threading</p><p>threading模块中提供了Thread , Lock , RLock , Semaphore , Event , Condition , Timer等组件</p><a id="more"></a><h2 id="Thread-🍀"><a href="#Thread-🍀" class="headerlink" title="Thread  🍀"></a>Thread  🍀</h2><p>参数说明</p><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>group</td><td>未使用 , 值始终</td></tr><tr><td>target</td><td>表示调用对象 , 即子线程要执行的任务</td></tr><tr><td>name</td><td>子线程的名称</td></tr><tr><td>args</td><td>传入target函数中的位置参数 , 是一个元组 , 参数后必须加逗号</td></tr><tr><td>kwargs</td><td>表示调用对象的字典</td></tr></tbody></table><p>方法说明</p><table><thead><tr><th>方法</th><th>说明</th></tr></thead><tbody><tr><td>Thread.run (self)</td><td>进程启动时运行的方法 , 由该方法调用target参数所指定的函数 , 在子类中可以进行重构 , 与线程中一样</td></tr><tr><td>Thread.start (self)</td><td>启动进程 , start方法就是去帮你调用run方法</td></tr><tr><td>Thread.terminate (self)</td><td>强制终止线程 , 不会进行任何清理操作 , 使用时需小心其子进程与锁的问题</td></tr><tr><td>Thread.join (self, timeout=None)</td><td>阻塞调用 , 主线程进行等待 , timeout为超时时间</td></tr><tr><td>Thread.is_alive (self)</td><td>这个方法在run()方法开始之前返回True , 在run()方法结束之后 , 返回所有活动线程的列表</td></tr><tr><td>Thread.isDaemon(self)</td><td>判断是否为守护线程 , 返回bool值</td></tr><tr><td>Thread.setDaemon(self,daemonic)</td><td>将子线程设置为守护线程 , daemonic = daemon</td></tr><tr><td>Thread.getName(self,name)</td><td>获取线程名称</td></tr><tr><td>Thread.setName(self,name)</td><td>设置线程名称</td></tr></tbody></table><p>实例属性说明</p><table><thead><tr><th>属性</th><th>说明</th></tr></thead><tbody><tr><td>Thread.daemon</td><td>默认值为False , True则为守护线程</td></tr><tr><td>Thread.name</td><td>线程的名称</td></tr><tr><td>Thread.isAlive</td><td>即为is_alive的返回值</td></tr><tr><td>Thread.ident</td><td>线程标识符 , 没启动则为None</td></tr></tbody></table><p><strong>创建线程</strong>  </p><p>Python中使用线程有两种方式 : 函数或者用类来包装线程对象</p><p>函数调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 定义线程要运行的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"I am %s"</span> % name)</span><br><span class="line">    <span class="comment"># 为了便于观察,让它睡上2秒</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 防止被导入执行两次</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建一个线程实例,args参数是一个元组,必须加逗号</span></span><br><span class="line">    t1 = threading.Thread(target=func, args=(<span class="string">"Lyon"</span>,))</span><br><span class="line">    <span class="comment"># 再创建一个线程实例</span></span><br><span class="line">    t2 = threading.Thread(target=func, args=(<span class="string">"Kenneth"</span>,))</span><br><span class="line">    <span class="comment"># 启动线程</span></span><br><span class="line">    t1.start()</span><br><span class="line">    <span class="comment"># 启动另一个线程</span></span><br><span class="line">    t2.start()</span><br><span class="line">    <span class="comment"># 打印线程名</span></span><br><span class="line">    print(t1.getName())</span><br><span class="line">    <span class="comment"># 打印线程名</span></span><br><span class="line">    print(t2.getName())</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">I am Lyon</span></span><br><span class="line"><span class="string">I am Kenneth</span></span><br><span class="line"><span class="string">Thread-1</span></span><br><span class="line"><span class="string">Thread-2</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>类继承调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 继承threading中的Thread类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="comment"># 线程中所需要的参数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="comment"># threading.Thread.__init__(self)</span></span><br><span class="line">        super().__init__()</span><br><span class="line">        self.name = name</span><br><span class="line"><span class="comment"># 重构run方法,注意这个是表示线程活动的方法,必须有</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am %s"</span> % self.name)</span><br><span class="line">        time.sleep(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 防止被导入执行两次</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建一个线程实例</span></span><br><span class="line">    t1 = MyThread(<span class="string">'Lyon'</span>)</span><br><span class="line">    <span class="comment"># 创建另一个线程实例</span></span><br><span class="line">    t2 = MyThread(<span class="string">'Kenneth'</span>)</span><br><span class="line">    <span class="comment"># 启动线程,调用了类中的run方法</span></span><br><span class="line">    t1.start()</span><br><span class="line">    <span class="comment"># 启动另一个线程</span></span><br><span class="line">    t2.start()</span><br><span class="line">    <span class="comment"># 获取线程名</span></span><br><span class="line">    print(t1.getName())</span><br><span class="line">    <span class="comment"># 获取线程名</span></span><br><span class="line">    print(t2.getName())</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果: </span></span><br><span class="line"><span class="string">I am Lyon</span></span><br><span class="line"><span class="string">I am Kenneth</span></span><br><span class="line"><span class="string">Lyon</span></span><br><span class="line"><span class="string">Kenneth</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Thread实例对象的方法</span><br><span class="line">  # isAlive(): 返回线程是否活动的。</span><br><span class="line">  # getName(): 返回线程名。</span><br><span class="line">  # setName(): 设置线程名。</span><br><span class="line">threading模块提供的一些方法：</span><br><span class="line">  # threading.currentThread(): 返回当前的线程变量。</span><br><span class="line">  # threading.enumerate(): 返回一个包含正在运行的线程的list。正在运行指线程启动后、结束前，不包括启动前和终止后的线程。</span><br><span class="line">  # threading.activeCount(): 返回正在运行的线程数量，与len(threading.enumerate())有相同的结果。</span><br></pre></td></tr></table></figure><h2 id="Join-amp-setDaemon-🍀"><a href="#Join-amp-setDaemon-🍀" class="headerlink" title="Join &amp; setDaemon  🍀"></a>Join &amp; setDaemon  🍀</h2><p>在说这两个方法之前 , 需要知道主线程与子线程的概念</p><p>主线程 : 当一个程序启动时 , 就有一个进程被操作系统创建 , 与此同时一个线程也立刻运行 , 该线程通常叫做程序的主线程</p><p>子线程 : 因为程序是开始时就执行的 , 如果你需要再创建线程 , 那么创建的线程就是这个主线程的子线程</p><p><code>主线程的重要性体现在两方面 : 1. 是产生其他子线程的线程 ; 2. 通常它必须最后完成执行比如执行各种关闭作</code> </p><p><code>在Python中线程的一些机制与C/C++不同 , 在C/C++中 , 主线程结束后 , 其子线程会默认被主线程kill掉 . 而在Python中 , 主线程结束后 , 会默认等待子线程结束后 , 主线程才退出</code> </p><blockquote><p><strong>Join</strong></p></blockquote><p>在上面的线程的创建时 , 获取线程名并不是在最后执行的 , 而是遇到sleep阻塞自动切换执行的 , 而sleep(2)则是在最后执行的 , 如果还不明白在看下面一个例子</p><p>遇到阻塞自动切换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 定义线程要执行的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="comment"># 打印内容</span></span><br><span class="line">    print(<span class="string">"I am %s"</span> % name)</span><br><span class="line">    <span class="comment"># 睡两秒</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 睡完继续起来干活</span></span><br><span class="line">    print(<span class="string">"When I'm done, I'm going to keep talking..."</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建一个线程实例</span></span><br><span class="line">    lyon = threading.Thread(target=run, args=(<span class="string">'Lyon'</span>,))</span><br><span class="line">    <span class="comment"># 创建另一个线程实例</span></span><br><span class="line">    kenneth = threading.Thread(target=run, args=(<span class="string">'Kenneth'</span>,))</span><br><span class="line">    <span class="comment"># 启动线程</span></span><br><span class="line">    lyon.start()</span><br><span class="line">    <span class="comment"># 启动另一个线程</span></span><br><span class="line">    kenneth.start()</span><br><span class="line">    <span class="comment"># 我是主线程,我应该最后执行的</span></span><br><span class="line">    print(<span class="string">"I was the main thread, and I ended up executing"</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">I am Lyon</span></span><br><span class="line"><span class="string">I am Kenneth</span></span><br><span class="line"><span class="string">I was the main thread, and I ended up executing</span></span><br><span class="line"><span class="string">When I'm done, I'm going to keep talking...</span></span><br><span class="line"><span class="string">When I'm done, I'm going to keep talking...</span></span><br><span class="line"><span class="string">结果分析:</span></span><br><span class="line"><span class="string">第一行打印了 I am Lyon,这没问题第一个线程启动了</span></span><br><span class="line"><span class="string">第二行打印了 I am Kenneth,这就有问题了,这明明是第二个线程中的事情,我擦我的第一个线程都没执行完</span></span><br><span class="line"><span class="string">第三行打印了 I was the main thread, and I ended up executing,你牛逼把我主线程的事都打印了</span></span><br><span class="line"><span class="string">睡了两秒,看来是遇到阻塞自动切换了</span></span><br><span class="line"><span class="string">最后打印了两个线程中的 When I'm done, I'm going to keep talking...</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>在很多情况下 , 我们需要的是让各个线程执行完毕后 , 才接着往下执行 , 也就是不跳过阻塞 , 就让它等下去 , 这个时候就需要用join了</p><p>join : 阻塞调用程序 , 知道join () 方法的线程调用终止 , 才会继续往下执行</p><p>上面加上join后</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"I am %s"</span> % name)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"When I'm done, I'm going to keep talking..."</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lyon = threading.Thread(target=run, args=(<span class="string">'Lyon'</span>,))</span><br><span class="line">    kenneth = threading.Thread(target=run, args=(<span class="string">'Kenneth'</span>,))</span><br><span class="line">    lyon.start()</span><br><span class="line">    lyon.join()</span><br><span class="line">    kenneth.start()</span><br><span class="line">    kenneth.join()</span><br><span class="line">    print(<span class="string">"I was the main thread, and I ended up executing"</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">I am Lyon</span></span><br><span class="line"><span class="string"># sleep 2 seconds</span></span><br><span class="line"><span class="string">When I'm done, I'm going to keep talking...</span></span><br><span class="line"><span class="string">I am Kenneth</span></span><br><span class="line"><span class="string"># sleep 2 seconds</span></span><br><span class="line"><span class="string">When I'm done, I'm going to keep talking...</span></span><br><span class="line"><span class="string">I was the main thread, and I ended up executing</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>程序按照我们的意愿按顺序执行了</p><blockquote><p><strong>setDaemon</strong> </p></blockquote><p>无论进程还是线程 , 都遵循 : 守护进程 (线程) 会等待主进程 (线程) 运行完毕后被销毁</p><p>对于主进程来说 , 运行完毕指的是主进程代码运行完毕</p><p>对于主线程来说 , 运行完毕指的是主线程所在的进程内所有非守护线程统统运行完毕</p><p>setDaemon() 与 join() 基本上是相对的 , join会等子线程执行完毕 ; 而setDaemon则不会等 , 只要主线程执行完了 ,  我才不管你子线程执没执行完毕 , 统统给我回收 , 这样才能保证进程能正常结束</p><p>setDaemon设置守护线程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"I am %s"</span> % name)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"When I'm done, I'm going to keep talking..."</span>)</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    lyon = threading.Thread(target=run, args=(<span class="string">'Lyon'</span>,))</span><br><span class="line">    kenneth = threading.Thread(target=run, args=(<span class="string">'Kenneth'</span>,))</span><br><span class="line">    <span class="comment"># 设置守护线程,必须在启动前设置</span></span><br><span class="line">    lyon.setDaemon(<span class="keyword">True</span>)</span><br><span class="line">    <span class="comment"># 启动线程</span></span><br><span class="line">    lyon.start()</span><br><span class="line">    <span class="comment"># 设置守护线程</span></span><br><span class="line">    kenneth.setDaemon(<span class="keyword">True</span>)</span><br><span class="line">    kenneth.start()</span><br><span class="line">    print(<span class="string">"I was the main thread, and I ended up executing"</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">I am Lyon</span></span><br><span class="line"><span class="string">I am Kenneth</span></span><br><span class="line"><span class="string">I was the main thread, and I ended up executing</span></span><br><span class="line"><span class="string">结果说明:</span></span><br><span class="line"><span class="string">主线程一旦执行完毕,那么守护线程就一并退出,不管被守护线程是否执行完毕</span></span><br><span class="line"><span class="string">所以lyon和kenneth两个子线程并没有执行完毕,如果在主线程中在加上sleep(5),</span></span><br><span class="line"><span class="string">即超过子线程阻塞,那么这两个子线程就能执行完毕了</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>将主线程设置为守护线程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(num)</span>:</span></span><br><span class="line">    print(<span class="string">"I like num %d"</span> % num)</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    print(<span class="string">"When I'm done, I'm going to keep talking..."</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">6</span>):</span><br><span class="line">        <span class="comment"># 创建线程实例</span></span><br><span class="line">        t = threading.Thread(target=run, args=(i,))</span><br><span class="line">        <span class="comment"># 启动线程</span></span><br><span class="line">        t.start()</span><br><span class="line">        <span class="comment"># 阻塞调用</span></span><br><span class="line">        t.join()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 创建一个主线程</span></span><br><span class="line">    m = threading.Thread(target=main, args=[])</span><br><span class="line">    <span class="comment"># 设置为守护线程</span></span><br><span class="line">    m.setDaemon(<span class="keyword">True</span>)</span><br><span class="line">    <span class="comment"># 启动线程</span></span><br><span class="line">    m.start()</span><br><span class="line">    <span class="comment"># 等待其子线程执行完毕后,再8秒退出</span></span><br><span class="line">    m.join(timeout=<span class="number">8</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">I like num 1</span></span><br><span class="line"><span class="string">When I'm done, I'm going to keep talking...</span></span><br><span class="line"><span class="string">I like num 2</span></span><br><span class="line"><span class="string">When I'm done, I'm going to keep talking...</span></span><br><span class="line"><span class="string">I like num 3</span></span><br><span class="line"><span class="string">When I'm done, I'm going to keep talking...</span></span><br><span class="line"><span class="string">I like num 4</span></span><br><span class="line"><span class="string">结果说明:</span></span><br><span class="line"><span class="string">子线程并没有执行完毕,主线程退出,守护线程一并退出</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="Python-GIL-🍀"><a href="#Python-GIL-🍀" class="headerlink" title="Python GIL  🍀"></a>Python GIL  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">In CPython, the global interpreter lock, or GIL, is a mutex that prevents multiple </span></span><br><span class="line"><span class="string">native threads from executing Python bytecodes at once. This lock is necessary mainly </span></span><br><span class="line"><span class="string">because CPython’s memory management is not thread-safe. (However, since the GIL </span></span><br><span class="line"><span class="string">exists, other features have grown to depend on the guarantees that it enforces.)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>基本意思是说 , 在CPython解释器中 , 同一个进程下开启的多线程 , 同一时刻只能有一个线程执行 , 无法利用多核优势</p><p>GIL并不是Python的一种特性 , 它是在实现Python解释器(CPhthon)时引入的一个概念 , 就比如同一段代码可以通过CPython , PyPy , Psyco等不同的Python执行环境来执行 , 像JPython中就没有GIL . 由于CPython是大部分环境下默认的Python执行环境 , 所以在很多人的概念里CPython就是Python , 但是要记住 , GIL并不是Python的特性 , Python完全可以不依赖GIL</p><blockquote><p><strong>GIL</strong> </p></blockquote><p>GIL本质就是一把互斥锁 , 即会将并发运行变成串行 , 以此来控制同一时间内共享数据只能被一个任务进行修改 , 从而保证数据的安全性</p><p><code>保护不同的数据时 , 应该加不同的锁</code>  , GIL是解释器级别的锁 , 又叫做全局解释器锁</p><p>CPython加入GIL主要的原因是为了降低程序的开发复杂度 , 让你不需要关心内存回收的问题 , 你可以理解为Python解释器里有一个独立的线程 , 每过一段时间它起wake up做一次全局轮询看看哪些内存数据是可以被清空的 , 此时你自己的程序 里的线程和Python解释器自己的线程是并发运行的 , 假设你的线程删除了一个变量 , py解释器的垃圾回收线程在清空这个变量的过程中的clearing时刻 , 可能一个其它线程正好又重新给这个还没来及得清空的内存空间赋值了 , 结果就有可能新赋值的数据被删除了 , 为了解决类似的问题 , Python解释器简单粗暴的加了锁 , 即当一个线程运行时 , 其它人都不能动 , 这样就解决了上述的问题 , 这可以说是Python早期版本的遗留问题 . 毕竟Python出来的时候 , 多核处理还没出来呢 , 所以并没有考虑多核问题</p><p>以上就可以说明 , Python多线程不适合CPU密集型应用 , 但适用于IO密集型应用</p><p>##Lock  🍀</p><p>多线程与多进程最大的不同在于 , 多进程中 , 同一个变量 , 各自有一份拷贝存在于每个进程中 , 互不影响 , 但是在多线程中 , 所有变量对于所有线程都是共享的 , 因此 , 线程之间共享数据最大的危险在于多个线程同时修改一个变量 , 那就乱套了 , 所以我们需要GIL一样 , 来锁住数据</p><p>上面说了 , 保护不同的数据 , 要加不同的锁 , GIL是为了保护解释器的数据 , 明显我们还需要保护用户数据的锁</p><p>所以为了保证用户数据的安全 , 我们需要另一个锁 , 互斥锁(Mutex)</p><p>无锁版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 线程的调度是由操作系统决定的,一旦线程交替执行,并且次数足够多,那么就可能出问题了</span></span><br><span class="line"><span class="comment"># 直接用廖大大的例子,地址:www.liaoxuefeng.com</span></span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="comment"># 假定这是你的银行存款:</span></span><br><span class="line">balance = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_it</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="comment"># 先存后取，结果应该为0:</span></span><br><span class="line">    <span class="keyword">global</span> balance</span><br><span class="line">    balance = balance + n</span><br><span class="line">    balance = balance - n</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_thread</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000</span>):</span><br><span class="line">        change_it(n)</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">    t1 = threading.Thread(target=run_thread, args=(<span class="number">5</span>,))</span><br><span class="line">    t2 = threading.Thread(target=run_thread, args=(<span class="number">8</span>,))</span><br><span class="line">    <span class="comment"># 这里跟join的位置有关系,因为join也是可以实现锁的功能的,下面说</span></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    print(balance,end=<span class="string">""</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string"># 这里我就只给出5次的结果,因为5次就已经出现错误了</span></span><br><span class="line"><span class="string"># 正常情况下数据不混乱,结果应该一直为0</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>加锁版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="comment"># 假定这是你的银行存款:</span></span><br><span class="line">balance = <span class="number">0</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">change_it</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="comment"># 先存后取，结果应该为0:</span></span><br><span class="line">    <span class="keyword">global</span> balance</span><br><span class="line">    balance = balance + n</span><br><span class="line">    balance = balance - n</span><br><span class="line"><span class="comment"># 创建一把锁</span></span><br><span class="line">lock = threading.Lock()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run_thread</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100000</span>):</span><br><span class="line">        <span class="comment"># 先要获取锁:</span></span><br><span class="line">        lock.acquire()</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="comment"># 放心地改吧:</span></span><br><span class="line">            change_it(n)</span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            <span class="comment"># 改完了一定要释放锁:</span></span><br><span class="line">            lock.release()</span><br><span class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">10000</span>):</span><br><span class="line">    t1 = threading.Thread(target=run_thread, args=(<span class="number">5</span>,))</span><br><span class="line">    t2 = threading.Thread(target=run_thread, args=(<span class="number">8</span>,))</span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br><span class="line">    t1.join()</span><br><span class="line">    t2.join()</span><br><span class="line">    print(balance)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">0</span></span><br><span class="line"><span class="string"># 这里的结果一直都是0,So我就只写出一个结果了 </span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p><strong>join vs lock</strong> </p><p>上面第一个无锁版本的例子中 , 其实join()就可以实现我们想要的功能 , 只需要各个线程后面不加多余的东西直接接join()就行 , 因为我们知道join()的功能是进行阻塞 , 一加join() , 肯定其他就没有线程能动了 , 上面例子中故意将<code>t1.join()</code> 加在了<code>t2.start()</code>的后面 , 就是为了能让t2”有机可趁” , 既然<code>join()</code> 就可以实现 , 那我们还要锁干嘛?</p><p>我们应该想想 , join实现的原理 , join会使线程进行阻塞 , 也就是说会让真个线程变成完全串行的 , 既然只有一个线程在进行操作 , 那么它肯定就不会乱 , 但是使用join影响了执行效率 , 所以我们想能不能只让线程中的一部分串行? 答案是能的 , 就是利用互斥锁 , 想让哪里串行就让哪里串行</p><p>PS : <code>Python3.x</code>好像会自动加锁 , 但是<code>Python2.x</code>是不会的 , 写的时候还是都加上把 , 保证安全性</p><h2 id="RLock-🍀"><a href="#RLock-🍀" class="headerlink" title="RLock  🍀"></a>RLock  🍀</h2><p>RLock叫做递归锁 , 在说之前先说一个死锁问题</p><p>进程也有死锁和递归锁 , 所谓死锁 : 是指两个或两个以上的进程或线程在执行过程中 , 因争夺资源而造成的一种互相等待的现象 , 若无外力作用 , 他们都将无法推进下去 . 此时称系统处于死锁状态或系统产生了死锁 , 这些永远在互相等待的进程称为死锁进程 , 如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 创建两个锁</span></span><br><span class="line">mutexA = threading.Lock()</span><br><span class="line">mutexB = threading.Lock()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="comment"># 重构run方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.func1()</span><br><span class="line">        self.func2()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func1</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 获取锁A</span></span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        print(<span class="string">"\033[31m%s get mutexA...\033[0m"</span> % self.name)</span><br><span class="line">        <span class="comment"># 获取锁B</span></span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        print(<span class="string">"\033[33m%s get mutexB...\033[0m"</span> % self.name)</span><br><span class="line">        <span class="comment"># 释放锁B</span></span><br><span class="line">        mutexB.release()</span><br><span class="line">        <span class="comment"># 释放锁A</span></span><br><span class="line">        mutexA.release()</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">(self)</span>:</span></span><br><span class="line">        mutexB.acquire()</span><br><span class="line">        print(<span class="string">"\033[35m%s get mutexB...\033[0m"</span> % self.name)</span><br><span class="line">        <span class="comment"># 睡1秒</span></span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">        mutexA.acquire()</span><br><span class="line">        print(<span class="string">"\033[37m%s get mutexA...\033[0m"</span> % self.name)</span><br><span class="line">        mutexA.release()</span><br><span class="line">        mutexB.release()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        t = MyThread()</span><br><span class="line">        t.start()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">Thread-1 get mutexA...</span></span><br><span class="line"><span class="string">Thread-1 get mutexB...</span></span><br><span class="line"><span class="string">Thread-1 get mutexB...</span></span><br><span class="line"><span class="string">Thread-2 get mutexA...</span></span><br><span class="line"><span class="string"># 到这里整个程序就永远等着了</span></span><br><span class="line"><span class="string">结果说明: </span></span><br><span class="line"><span class="string">首先执行了func1,没有阻塞,顺利执行完毕</span></span><br><span class="line"><span class="string">然后执行func2,获取了锁B后就开始睡1一秒,也就是阻塞开始</span></span><br><span class="line"><span class="string">于是系统自动切换,再次执行了func1,而B的锁在阻塞前没释放</span></span><br><span class="line"><span class="string">最后func1中的mutexB.acquire()就一直等前面一个线程把锁给释放了</span></span><br><span class="line"><span class="string">等到天荒地老,海枯石烂,也等不到了</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>为了解决这样的问题 , 于是就有了递归锁 , 在Python中为了支持在同一线程中多次请求同一资源 , Python提供了可重入锁RLock</p><p>这个RLock内部维护着一个Lock和一个counter变量 , counter记录了acquire的次数 , 从而使得资源可以被多次require . 直到一个线程所有的acquire都被release , 其他的线程才能获得资源</p><p>RLock版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 仅仅只需如下修改</span></span><br><span class="line">mutexA = threading.Lock()</span><br><span class="line">mutexB = threading.Lock()</span><br><span class="line"><span class="comment"># 以上两行修改为</span></span><br><span class="line">mutexA = mutexB = threading.RLock()</span><br><span class="line"><span class="comment"># 注意如果仅仅修改后部分,即将Lock() -&gt; RLock()是不行的,那样等于创建了两把递归锁</span></span><br></pre></td></tr></table></figure><h2 id="queue-🍀"><a href="#queue-🍀" class="headerlink" title="queue  🍀"></a>queue  🍀</h2><p>我们可以使用队列处理线程编程中多个线程之间交换的安全问题</p><p>在queue中有三种模式 , Queue (先进先出 , FIFO) , LifoQueue (后进先出 , LIFO) , 还有一个可以设置优先级的队列PriorityQueue</p><p>Queue</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line">q = Queue.Queue()</span><br><span class="line">q.put(<span class="string">'First'</span>)</span><br><span class="line">q.put(<span class="string">'Second'</span>)</span><br><span class="line">q.put(<span class="string">'Third'</span>)</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">First</span></span><br><span class="line"><span class="string">Second</span></span><br><span class="line"><span class="string">Third</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>LifoQueue</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line">q = Queue.LifoQueue()</span><br><span class="line">q.put(<span class="string">'First'</span>)</span><br><span class="line">q.put(<span class="string">'Second'</span>)</span><br><span class="line">q.put(<span class="string">'Third'</span>)</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">Third</span></span><br><span class="line"><span class="string">Second</span></span><br><span class="line"><span class="string">First</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>PriorityQueue</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line">q = Queue.PriorityQueue()</span><br><span class="line"><span class="comment"># put进入一个元组,元组的第一个元素是优先级,越小优先级越高</span></span><br><span class="line">q.put((<span class="number">20</span>, <span class="string">'A'</span>))</span><br><span class="line">q.put((<span class="number">10</span>, <span class="string">'B'</span>))</span><br><span class="line">q.put((<span class="number">30</span>, <span class="string">'C'</span>))</span><br><span class="line"></span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line">print(q.get())</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">(10, 'B')</span></span><br><span class="line"><span class="string">(20, 'A')</span></span><br><span class="line"><span class="string">(30, 'C')</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>更多请阅读Python标准库目录下的queue模块内容</p><h2 id="Producer-Consumer-🍀"><a href="#Producer-Consumer-🍀" class="headerlink" title="Producer-Consumer  🍀"></a>Producer-Consumer  🍀</h2><p><strong>生产者 - 消费者问题</strong>  </p><p>又称有界缓冲区问题 , 在进程中 , 两个进程共享一个公共的固定大小的缓冲区 , 其中一个是生产者 , 将信息放入缓冲区 ; 另一个是消费者 , 从缓冲区取出信息 . 问题在于当缓冲区满时 , 而此时生产者还想向其中放入一个新的数据项的情况 ; 相反 , 当缓冲区为空时 , 消费者视图从缓冲区中取数据 , 该如何去解决? </p><p>为了解决这个问题于是引入了生产者和消费者模式 , 基本思路也是如进程中睡眠和唤醒</p><p><strong>生产者消费模式</strong> </p><p>通过一个容器来解决生产者和消费者的强耦合问题 . 生产者与消费者彼此之间不直接通讯 , 而通过阻塞队列来进行通讯 , 所以生产者生产完数据之后不用等待消费者处理 , 直接扔给阻塞队列 , 消费者不找生产者要数据 , 而是直接从阻塞队列里取 , 阻塞队列就相当于一个缓冲区 , 平衡了生产者和消费者的处理能力</p><p>在并发编程中使用生产者和消费者模式能解决绝大多数并发问题 , 在线程世界里 , 生产者就是生产数据的线程 , 消费者就是消费数据的线程 . 以下有两个生产者消费者问题的例子</p><p>基础版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">producer</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        <span class="comment"># 进行生产,放入队列</span></span><br><span class="line">        q.put(<span class="string">"%d bottle of milk"</span> % i)</span><br><span class="line">    print(<span class="string">"Start waiting for all the milk to be taken..."</span>)</span><br><span class="line">    q.join()</span><br><span class="line">    print(<span class="string">"All the milk was taken out..."</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">consumer</span><span class="params">(name)</span>:</span></span><br><span class="line">    <span class="comment"># 队列中有就取</span></span><br><span class="line">    <span class="keyword">while</span> q.qsize() &gt; <span class="number">0</span>:</span><br><span class="line">        print(<span class="string">"%s got %s"</span> % (name, q.get()))</span><br><span class="line">        q.task_done()</span><br><span class="line"><span class="comment"># 创建一个队列对象</span></span><br><span class="line">q = queue.Queue()</span><br><span class="line">p = threading.Thread(target=producer,)</span><br><span class="line">p.start()</span><br><span class="line">c1 = consumer(<span class="string">"Lyon"</span>)</span><br></pre></td></tr></table></figure><p>生产与消费同时进行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line">q = queue.Queue()</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Producer</span><span class="params">(name)</span>:</span></span><br><span class="line">  count = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> count &lt; <span class="number">20</span>:</span><br><span class="line">    time.sleep(random.randrange(<span class="number">3</span>))</span><br><span class="line">    <span class="comment"># 将数据放入队列</span></span><br><span class="line">    q.put(count)</span><br><span class="line">    print(<span class="string">'Producer %s has produced %s bun...'</span> % (name, count))</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Consumer</span><span class="params">(name)</span>:</span></span><br><span class="line">  count = <span class="number">1</span></span><br><span class="line">  <span class="keyword">while</span> count &lt; <span class="number">20</span>:</span><br><span class="line">    time.sleep(random.randrange(<span class="number">4</span>))</span><br><span class="line">    <span class="comment"># 不为空就取,为空就提示</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">        <span class="comment"># 从队列中取出信息</span></span><br><span class="line">        data = q.get()</span><br><span class="line">        print(data)</span><br><span class="line">        print(<span class="string">'\033[32;1mConsumer %s has eat %s bun...\033[0m'</span> % (name, data))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"No bun anymore..."</span>)</span><br><span class="line">    count += <span class="number">1</span></span><br><span class="line">p1 = threading.Thread(target=Producer, args=(<span class="string">'Lyon'</span>,))</span><br><span class="line">c1 = threading.Thread(target=Consumer, args=(<span class="string">'Kenneth'</span>,))</span><br><span class="line">p1.start()</span><br><span class="line">c1.start()</span><br></pre></td></tr></table></figure><h2 id="Semaphore-🍀"><a href="#Semaphore-🍀" class="headerlink" title="Semaphore  🍀"></a>Semaphore  🍀</h2><p>信号量(Semaphore) , 引入一个整型变量来累计线程的唤醒次数 , threading模块中 , 有一个Semaphore类管理一个内置的计数器 , 每当调用acquire()时内置计数器 -1 ;调用release()时内置计数器 +1;计数器不能小于0 ; 当计数器等于0时 , acquire()将阻塞线程知道其他线程调用release()</p><p>一次最多连接5个线程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 内置计数器 -1</span></span><br><span class="line">    sm.acquire()</span><br><span class="line">    print(<span class="string">'%s get semaphores'</span> % threading.current_thread().getName())</span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line">    <span class="comment"># 内置计数器 +1</span></span><br><span class="line">    sm.release()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="comment"># 一次最多只能有5个线程获取信号量</span></span><br><span class="line">    sm = threading.Semaphore(<span class="number">5</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        t = threading.Thread(target=func)</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure><p>利用信号量可以解决生产者与消费者问题 , 《现代操作系统中》一书中进行了简单的实现</p><h2 id="Event-🍀"><a href="#Event-🍀" class="headerlink" title="Event  🍀"></a>Event  🍀</h2><p>在多线程中 , 每个线程都是互相独立的 , 互不影响 , 如果我们需要通过某个线程的状态来控制程序的执行过程 , 是非常难的 . 为了解决这些问题 , 我们就可以使用threading中的Event对象来实现我们的目的</p><p>Event对象中包含一个可由线程设置的信号标志 , 它允许线程等待某些事件的发生 . 在初始情况下 , Event对象中的信号标志被设置为假 ; 如果有线程等待一个Event对象 , 而这个Event对象的标志为假 , 那么这个线程将会被一直阻塞直至该标志为真 . 一个线程如果将一个Event对象的信号标志设置为真 , 它将唤醒所有等待这个Event对象的线程 . 如果一个线程等待一个已经被设置为真的Event对象 , 那么它将忽略这个事件 , 继续执行</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>Event.isSet()</td><td>返回Event的状态 , isSet == is_set</td></tr><tr><td>Event.wait()</td><td>如果Event.isSet() == False将阻塞线程</td></tr><tr><td>Event.set()</td><td>设置Event的状态值为True , 所有阻塞池中的线程激活进入就绪状态 , 等待操作系统调度</td></tr><tr><td>Event.clear()</td><td>回复Event的状态值为False</td></tr></tbody></table><p>解决重复连接问题</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">conn_mysql</span><span class="params">()</span>:</span></span><br><span class="line">    count = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> event.is_set():</span><br><span class="line">        <span class="comment"># 大于3次主动触发TimeoutError</span></span><br><span class="line">        <span class="keyword">if</span> count &gt; <span class="number">3</span>:</span><br><span class="line">            <span class="keyword">raise</span> TimeoutError(<span class="string">'Connection timeout...'</span>)</span><br><span class="line">        print(<span class="string">'%s %sth attempt to connect'</span> % (threading.current_thread().getName(), count))</span><br><span class="line">        <span class="comment"># 阻塞0.5秒</span></span><br><span class="line">        event.wait(<span class="number">0.5</span>)</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    print(<span class="string">'%s connect successfully'</span> % threading.current_thread().getName())</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check_mysql</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'%s is checking mysql'</span> % threading.current_thread().getName())</span><br><span class="line">    time.sleep(random.randint(<span class="number">2</span>, <span class="number">4</span>))</span><br><span class="line">    <span class="comment"># 激活线程</span></span><br><span class="line">    event.set()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    event = threading.Event()</span><br><span class="line">    conn1 = threading.Thread(target=conn_mysql)</span><br><span class="line">    conn2 = threading.Thread(target=conn_mysql)</span><br><span class="line">    check = threading.Thread(target=check_mysql)</span><br><span class="line">    conn1.start()</span><br><span class="line">    conn2.start()</span><br><span class="line">    check.start()</span><br></pre></td></tr></table></figure><h2 id="Condition-🍀"><a href="#Condition-🍀" class="headerlink" title="Condition  🍀"></a>Condition  🍀</h2><p>使线程等待 , 只有满足条件时 , 才释放线程</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">condition_func</span><span class="params">()</span>:</span></span><br><span class="line">    ret = <span class="keyword">False</span></span><br><span class="line">    inp = input(<span class="string">'&gt;&gt;&gt;'</span>)</span><br><span class="line">    <span class="comment"># 只有当inp等于1时才会执行</span></span><br><span class="line">    <span class="keyword">if</span> inp == <span class="string">'1'</span>:</span><br><span class="line">        ret = <span class="keyword">True</span></span><br><span class="line">    <span class="keyword">return</span> ret</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(n)</span>:</span></span><br><span class="line">    con.acquire()</span><br><span class="line">    con.wait_for(condition_func)</span><br><span class="line">    print(<span class="string">"run the thread: %s"</span> %n)</span><br><span class="line">    con.release()</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    con = threading.Condition()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        t = threading.Thread(target=run, args=(i,))</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure><h2 id="Timer-🍀"><a href="#Timer-🍀" class="headerlink" title="Timer  🍀"></a>Timer  🍀</h2><p>threading模块中还有一个Timer类 , 可以指定时间后执行某操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello1</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I am Lyon"</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello2</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Hello, future"</span>)</span><br><span class="line"><span class="comment"># 1秒后执行</span></span><br><span class="line">t1 = threading.Timer(<span class="number">1</span>, hello1)</span><br><span class="line"><span class="comment"># 两秒后执行</span></span><br><span class="line">t2 = threading.Timer(<span class="number">2</span>,hello2)</span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-多线程编程&quot;&gt;&lt;a href=&quot;#Python之路-多线程编程&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 多线程编程&quot;&gt;&lt;/a&gt;Python之路 - 多线程编程&lt;/h1&gt;&lt;h2 id=&quot;前言-🍀&quot;&gt;&lt;a href=&quot;#前言-🍀&quot; class=&quot;headerlink&quot; title=&quot;前言  🍀&quot;&gt;&lt;/a&gt;前言  🍀&lt;/h2&gt;&lt;p&gt;在上一篇中说了一大堆理论 , 那么现在就开始实践了 &lt;/p&gt;
&lt;p&gt;先说线程再说进程 , 为什么 ?  因为在Python中有一个&lt;code&gt;Python GIL&lt;/code&gt;全局解释器锁 , 这是个什么东西? 最后来说&lt;/p&gt;
&lt;p&gt;总之线程和进程都是与操作系统有关的知识 , 所以操作系统基础 , 对于这两节内容的理解会有很大的帮助&lt;/p&gt;
&lt;h2 id=&quot;Threading-🍀&quot;&gt;&lt;a href=&quot;#Threading-🍀&quot; class=&quot;headerlink&quot; title=&quot;Threading  🍀&quot;&gt;&lt;/a&gt;Threading  🍀&lt;/h2&gt;&lt;p&gt;Python通过两个标准库&lt;code&gt;_thread&lt;/code&gt; (built-in) 和&lt;code&gt;threading&lt;/code&gt;提供对线程的支持 , threading对_thread进行了封装&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;_thread.py&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;This module provides primitive operations to write multi-threaded programs.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;The &#39;threading&#39; module provides a more convenient interface.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;So , 明显我们一般直接使用threading&lt;/p&gt;
&lt;p&gt;threading模块中提供了Thread , Lock , RLock , Semaphore , Event , Condition , Timer等组件&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Concurrent" scheme="https://jesse.top/categories/python/Concurrent/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>31.Python之路 - 反射</title>
    <link href="https://jesse.top/2020/06/26/python/04-Object-Oriented/07-Python%E4%B9%8B%E8%B7%AF%20-%20%E5%8F%8D%E5%B0%84/"/>
    <id>https://jesse.top/2020/06/26/python/04-Object-Oriented/07-Python之路 - 反射/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:31:56.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-反射"><a href="#Python之路-反射" class="headerlink" title="Python之路 - 反射"></a>Python之路 - 反射</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力 </p><p>Python面向对象中的反射是通过字符串的形式来操作对象相关的属性 , 在Python中一切皆对象 , 并且只要是对象就可以使用反射</p><h2 id="hasattr-🍀"><a href="#hasattr-🍀" class="headerlink" title="hasattr  🍀"></a>hasattr  🍀</h2><p>判断对象中是否具有给定名称的属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasattr</span><span class="params">(*args, **kwargs)</span>:</span> <span class="comment"># real signature unknown</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Return whether the object has an attribute with the given name.  </span></span><br><span class="line"><span class="string">    This is done by calling getattr(obj, name) and catching AttributeError.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>实例1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个字符串</span></span><br><span class="line">name = <span class="string">'lyon'</span></span><br><span class="line"><span class="comment"># 查看是否具有给定名称的属性</span></span><br><span class="line">bool = hasattr(name,<span class="string">'__len__'</span>)</span><br><span class="line"><span class="comment"># 打印bool</span></span><br><span class="line">print(bool)</span><br><span class="line"><span class="comment"># 执行结果:True</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">说明:很多初学者可能一直不理解为什么说Python里一切皆对象,因为没有意识到,在Python中str、list、int ...等这些数据类型,其实就是用class写出来的一个模型,那么既然是类就会有属性这一说,就可以利用反射来操作对象了</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">s1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">s2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">this_modules = sys.modules[__name__]</span><br><span class="line">print(type(this_modules),hasattr(this_modules,<span class="string">'s1'</span>))</span><br><span class="line">module1</span><br></pre></td></tr></table></figure><h2 id="getattr-🍀"><a href="#getattr-🍀" class="headerlink" title="getattr  🍀"></a>getattr  🍀</h2><p>从一个对象中获取属性名称</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getattr</span><span class="params">(object, name, default=None)</span>:</span> <span class="comment"># known special case of getattr</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Get a named attribute from an object; getattr(x, 'y') is equivalent to x.y.</span></span><br><span class="line"><span class="string">    When a default argument is given, it is returned when the attribute doesn't</span></span><br><span class="line"><span class="string">    exist; without it, an exception is raised in that case.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'hello &#123;&#125;'</span>.format(self.name))</span><br><span class="line"><span class="comment"># 创建一个实例a        </span></span><br><span class="line">a = A(<span class="string">'Lyon'</span>,<span class="number">18</span>)</span><br><span class="line"><span class="comment"># 获取静态属性age</span></span><br><span class="line">age = getattr(a,<span class="string">'age'</span>)</span><br><span class="line"><span class="comment"># 打印age</span></span><br><span class="line">print(age)</span><br><span class="line"><span class="comment"># 获取动态属性hello,即方法</span></span><br><span class="line">hello = getattr(a,<span class="string">'hello'</span>)</span><br><span class="line"><span class="comment"># 执行hello</span></span><br><span class="line">hello()</span><br><span class="line"><span class="comment"># 如果不存在就需要设置default参数,否则就报错</span></span><br><span class="line">birthday = getattr(a,<span class="string">'birthday'</span>,<span class="string">'today'</span>)</span><br><span class="line"><span class="comment"># 打印birthday,即为default参数</span></span><br><span class="line">print(birthday)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">18</span></span><br><span class="line"><span class="string">hello Lyon</span></span><br><span class="line"><span class="string">today</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="setattr-🍀"><a href="#setattr-🍀" class="headerlink" title="setattr  🍀"></a>setattr  🍀</h2><p>定义属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setattr</span><span class="params">(x, y, v)</span>:</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Sets the named attribute on the given object to the specified value.   </span></span><br><span class="line"><span class="string">    setattr(x, 'y', v) is equivalent to ``x.y = v''</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line">b = B()</span><br><span class="line"><span class="comment"># 新增属性,如果存在即为修改</span></span><br><span class="line">setattr(b, <span class="string">'age'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="comment"># 打印age属性</span></span><br><span class="line">print(b.age)</span><br><span class="line"><span class="comment"># 新增add方法</span></span><br><span class="line">setattr(b, <span class="string">'add'</span>, <span class="keyword">lambda</span> age: age + <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 修改age属性</span></span><br><span class="line">b.age = b.add(b.age)</span><br><span class="line"><span class="comment"># 打印age属性</span></span><br><span class="line">print(b.age)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">18</span></span><br><span class="line"><span class="string">19</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="delattr-🍀"><a href="#delattr-🍀" class="headerlink" title="delattr  🍀"></a>delattr  🍀</h2><p>删除对象中的属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delattr</span><span class="params">(x, y)</span>:</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Deletes the named attribute from the given object.</span></span><br><span class="line"><span class="string">    delattr(x, 'y') is equivalent to ``del x.y''</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.age = self.age + <span class="number">1</span></span><br><span class="line">c = C(<span class="string">'Lyon'</span>,<span class="number">18</span>)</span><br><span class="line"><span class="comment"># 删除c中的</span></span><br><span class="line">delattr(c,<span class="string">'name'</span>)</span><br><span class="line"><span class="comment"># print(c.name)   报错</span></span><br><span class="line">delattr(c,<span class="string">'add'</span>)</span><br><span class="line"><span class="comment"># c.add()   报错</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-反射&quot;&gt;&lt;a href=&quot;#Python之路-反射&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 反射&quot;&gt;&lt;/a&gt;Python之路 - 反射&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力 &lt;/p&gt;
&lt;p&gt;Python面向对象中的反射是通过字符串的形式来操作对象相关的属性 , 在Python中一切皆对象 , 并且只要是对象就可以使用反射&lt;/p&gt;
&lt;h2 id=&quot;hasattr-🍀&quot;&gt;&lt;a href=&quot;#hasattr-🍀&quot; class=&quot;headerlink&quot; title=&quot;hasattr  🍀&quot;&gt;&lt;/a&gt;hasattr  🍀&lt;/h2&gt;&lt;p&gt;判断对象中是否具有给定名称的属性&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hasattr&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(*args, **kwargs)&lt;/span&gt;:&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# real signature unknown&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    Return whether the object has an attribute with the given name.  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    This is done by calling getattr(obj, name) and catching AttributeError.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    &quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实例1&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 定义一个字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;name = &lt;span class=&quot;string&quot;&gt;&#39;lyon&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 查看是否具有给定名称的属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bool = hasattr(name,&lt;span class=&quot;string&quot;&gt;&#39;__len__&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 打印bool&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(bool)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 执行结果:True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;说明:很多初学者可能一直不理解为什么说Python里一切皆对象,因为没有意识到,在Python中str、list、int ...等这些数据类型,其实就是用class写出来的一个模型,那么既然是类就会有属性这一说,就可以利用反射来操作对象了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实例2&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; sys&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;this_modules = sys.modules[__name__]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(type(this_modules),hasattr(this_modules,&lt;span class=&quot;string&quot;&gt;&#39;s1&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;module1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;getattr-🍀&quot;&gt;&lt;a href=&quot;#getattr-🍀&quot; class=&quot;headerlink&quot; title=&quot;getattr  🍀&quot;&gt;&lt;/a&gt;getattr  🍀&lt;/h2&gt;&lt;p&gt;从一个对象中获取属性名称&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Object-Oriented" scheme="https://jesse.top/categories/python/Object-Oriented/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>35.Python之路 - 网络编程之Socket</title>
    <link href="https://jesse.top/2020/06/26/python/05-Network/02-Python%E4%B9%8B%E8%B7%AF%20-%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E4%B9%8BSocket/"/>
    <id>https://jesse.top/2020/06/26/python/05-Network/02-Python之路 - 网络编程之Socket/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:35:29.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-网络编程之Socket"><a href="#Python之路-网络编程之Socket" class="headerlink" title="Python之路 - 网络编程之Socket"></a>Python之路 - 网络编程之Socket</h1><h2 id="C-S架构-🍀"><a href="#C-S架构-🍀" class="headerlink" title="C/S架构  🍀"></a>C/S架构  🍀</h2><p>在网络通信中 , 一般是一方求一方应 , 求的一方就是客户端即 <code>Client</code>  , 应的一方就是服务端即<code>Server</code> , 这就是C/S架构 , 在互联网中处处是C/S架构 , 比如我们访问百度 ,  百度就是一个服务端 , 而我们的浏览器就是一个客户端</p><h2 id="Socket-🍀"><a href="#Socket-🍀" class="headerlink" title="Socket  🍀"></a>Socket  🍀</h2><p>Socket是应用层与TCP/IP协议族通信的中间软件抽象层 , 它是一组接口 , 是从顶上三层 (osi七层协议的应用层) 进入传输层的接口 ; 顶上三层通常构成所谓的用户进程 , 底下四层却通常作为操作系统内核的一个部分提供</p><p>Socket又叫做套接字 , Python中socket为我们封装好了TCP/UDP协议 , 所以我们无需深入理解 , 只要遵循socket的规定去编程就可以了</p><p><strong>创建socket对象</strong> </p><p>创建socket对象就是一个建立TCP的过程 , 即三次握手 , 断开当然就是四次挥手了<br><a id="more"></a></p><p><img src="https://ss0.baidu.com/6ONWsjip0QIZ8tyhnq/it/u=3233953725,3136815440&amp;fm=173&amp;app=25&amp;f=JPEG?w=580&amp;h=708&amp;s=FD843C720B1A764D52D554DA0000E0B1" alt="TCP communication"></p><p>代码实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入socket模块</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="comment"># 调用socket模块中的socket类实例化出对象</span></span><br><span class="line">sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM,<span class="number">0</span>)</span><br><span class="line"><span class="string">'''或者可以使用 from module import * ,可以大幅度减少代码,仅仅提一下,毕竟有弊端'''</span></span><br><span class="line"><span class="comment"># 导入socket模块中的所有内容</span></span><br><span class="line"><span class="keyword">from</span> socket <span class="keyword">import</span> *</span><br><span class="line"><span class="comment"># 实例化socket类</span></span><br><span class="line">sock = socket(AF_INET,SOCK_STREAM,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p><strong>socket类参数说明</strong> </p><p>其构造函数源码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, family=AF_INET, type=SOCK_STREAM, proto=<span class="number">0</span>, fileno=None)</span>:</span></span><br><span class="line">    <span class="comment"># 下面内容就不摘了</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><blockquote><p><em>family</em> : 地址簇</p></blockquote><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>AF_INET</td><td>IPv4 , 即默认为IPv4</td></tr><tr><td>AF_INET6</td><td>IPv6</td></tr><tr><td>AF_UNIX</td><td>针对Unix系统进程间通信</td></tr></tbody></table><blockquote><p><em>type</em> : 类型</p></blockquote><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>SOCK_STREAM</td><td>面向流 , 即TCP</td></tr><tr><td>SOCK_DGRAM</td><td>面向数据报 , 即UDP</td></tr><tr><td>SOCK_RAW</td><td>原始套接字 , 可处理ICMP,IGMP等网络报文 ; 可以处理特殊的IPv4报文 ; 利用原始套接字 , 可以通过IP_HDRINCL套接字选项由用户构造IP头</td></tr><tr><td>SOCK_RDM</td><td>一种可靠的UDP形式 . SOCK_RAM用来提供对原始协议的低级访问 , 在需要执行某些特殊操作时使用 , 如发送ICMP报文 , SOCK_RAW通常仅限于高级用户或管理员运行的程序使用</td></tr><tr><td>SOCK_SEQPACKET</td><td>可靠的连续数据包服务</td></tr></tbody></table><blockquote><p><em>proto</em> : 协议</p></blockquote><table><thead><tr><th>参数</th><th>说明</th></tr></thead><tbody><tr><td>0</td><td>与特定的地址家族相关的协议 , 如果是0 , 则系统就会根据地址格式和套接类别 , 自动选择一个合适的协议</td></tr></tbody></table><p>还有一个<em>fileno</em>参数是无需理会的</p><h2 id="基于TCP-🍀"><a href="#基于TCP-🍀" class="headerlink" title="基于TCP  🍀"></a>基于TCP  🍀</h2><p>TCP协议是有链接的 , 面向流的 , 数据传输可靠 , 必须先启动服务端</p><p><strong>TCP服务端</strong> </p><ol><li>创建套接字对象                            <em>创建socket对象</em> </li><li>绑定IP和端口                                         <em>绑定 bind()</em> </li><li>开始监听链接                                        <em>监听 listen()</em> </li><li>阻塞 , 等待客户端成功连接                  <em>阻塞 accept()</em> </li><li>接收请求数据                                        <em>接收 recv()</em> </li><li>处理并发送请求数据                            <em>发送 send()</em> </li><li>通信完毕 , 关闭链接 , 关闭套接字       <em>关闭 close()</em>                    </li></ol><p><strong>TCP客户端</strong> </p><ol><li>创建套接字对象                                     <em>创建socket对象</em> </li><li>连接服务端 , 按照IP和端口连接           <em>连接 connet()</em> </li><li>发送请求数据                                        <em>发送 send()</em> </li><li>接收请求数据                                        <em>接收 recv()</em> </li><li>通信完毕 , 关闭套接字                        <em>关闭 close()</em> </li></ol><p>简单实例</p><p>tcp_server.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入socket模块</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="comment"># 创建socket对象,默认参数就不填了</span></span><br><span class="line">sock = socket.socket()</span><br><span class="line"><span class="comment"># 绑定IP和端口,参数是一个元组(ip,port)</span></span><br><span class="line">sock.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 开始监听,最大监听数为5</span></span><br><span class="line">sock.listen(<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 阻塞,等待连接,返回一个链接通道和一个地址</span></span><br><span class="line">conn,addr = sock.accept()</span><br><span class="line"><span class="comment"># 接收请求数据,接收大小为1024字节</span></span><br><span class="line">content = conn.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="comment"># 打印结果(bytes转成str显示)</span></span><br><span class="line">print(content.decode())</span><br><span class="line"><span class="comment"># 发送请求结果,必须以bytes类型</span></span><br><span class="line">conn.send(<span class="string">b'Hello Lyon'</span>)</span><br><span class="line"><span class="comment"># 关闭链接</span></span><br><span class="line">conn.close()</span><br><span class="line"><span class="comment"># 关闭套接字</span></span><br><span class="line">sock.close()</span><br></pre></td></tr></table></figure><p>tcp_client.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入socket模块</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="comment"># 创建socket对象</span></span><br><span class="line">sock = socket.socket()</span><br><span class="line"><span class="comment"># 建立链接</span></span><br><span class="line">sock.connect((<span class="string">'127.0.0.1'</span>, <span class="number">8080</span>))</span><br><span class="line"><span class="comment"># 发送请求数据,必须以bytes类型</span></span><br><span class="line">sock.send(<span class="string">b"I'm Lyon"</span>)</span><br><span class="line"><span class="comment"># 接收请求结果</span></span><br><span class="line">content = sock.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line">print(content.decode())</span><br><span class="line"><span class="comment"># 关闭套接字</span></span><br><span class="line">sock.close()</span><br></pre></td></tr></table></figure><h2 id="基于UDP-🍀"><a href="#基于UDP-🍀" class="headerlink" title="基于UDP  🍀"></a>基于UDP  🍀</h2><p>UDP协议是无链接的 , 面向数据报的 , 数据传输全靠吼 , 不可靠 , 先启动哪一端都不会报错</p><p><strong>UDP服务端</strong> </p><ol><li>创建套接字对象                            <em>创建socket对象</em> </li><li>绑定IP和端口                                         <em>绑定 bind()</em> </li><li>接收请求数据                                        <em>接收 recvfrom()</em> </li><li>通信完毕 , 关闭套接字       <em>关闭 close()</em>                    </li></ol><p><strong>UDP客户端</strong> </p><ol><li>创建套接字对象                                     <em>创建socket对象</em> </li><li>发送请求数据                                        <em>发送 sendto()</em> </li><li>通信完毕 , 关闭套接字                        <em>关闭 close()</em> </li></ol><p>简单实例</p><p>udp_server.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入socket模块</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="comment"># 创建socket对象</span></span><br><span class="line">sock = socket.socket(type=socket.SOCK_DGRAM)</span><br><span class="line"><span class="comment"># 绑定ip和端口</span></span><br><span class="line">sock.bind((<span class="string">'127.0.0.1'</span>, <span class="number">8090</span>))</span><br><span class="line"><span class="comment"># 接收请求,返回数据和地址</span></span><br><span class="line">data,addr = sock.recvfrom(<span class="number">1024</span>)</span><br><span class="line"><span class="comment"># 打印请求</span></span><br><span class="line">print(data.decode())</span><br><span class="line"><span class="comment"># 关闭套接字</span></span><br><span class="line">sock.close()</span><br></pre></td></tr></table></figure><p>udp_client.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入socket模块</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="comment"># 创建socket对象</span></span><br><span class="line">sock = socket.socket(type=socket.SOCK_DGRAM)</span><br><span class="line"><span class="comment"># 发送请求到指定地址</span></span><br><span class="line">sock.sendto(<span class="string">b"I'm Lyon"</span>, (<span class="string">'127.0.0.1'</span>, <span class="number">8090</span>))</span><br><span class="line"><span class="comment"># 关闭套接字</span></span><br><span class="line">sock.close()</span><br></pre></td></tr></table></figure><h2 id="Socket对象方法-🍀"><a href="#Socket对象方法-🍀" class="headerlink" title="Socket对象方法  🍀"></a>Socket对象方法  🍀</h2><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>s.bind()</td><td>绑定地址（host,port）到套接字， 在AF_INET下,以元组（host,port）的形式表示地址。</td></tr><tr><td>s.listen()</td><td>开始TCP监听。backlog指定在拒绝连接之前，操作系统可以挂起的最大连接数量。该值至少为1，大部分应用程序设为5就可以了。</td></tr><tr><td>s.accept()</td><td>被动接受TCP客户端连接,(阻塞式)等待连接的到来</td></tr><tr><td>s.connect()</td><td>主动初始化TCP服务器连接，。一般address的格式为元组（hostname,port），如果连接出错，返回socket.error错误。</td></tr><tr><td>s.connect_ex()</td><td>connect()函数的扩展版本,出错时返回出错码,而不是抛出异常</td></tr><tr><td>s.recv()</td><td>接收TCP数据，数据以字符串形式返回，bufsize指定要接收的最大数据量。flag提供有关消息的其他信息，通常可以忽略。</td></tr><tr><td>s.send()</td><td>发送TCP数据，将string中的数据发送到连接的套接字。返回值是要发送的字节数量，该数量可能小于string的字节大小。</td></tr><tr><td>s.sendall()</td><td>完整发送TCP数据，完整发送TCP数据。将string中的数据发送到连接的套接字，但在返回之前会尝试发送所有数据。成功返回None，失败则抛出异常。</td></tr><tr><td>s.recvfrom()</td><td>接收UDP数据，与recv()类似，但返回值是（data,address）。其中data是包含接收数据的字符串，address是发送数据的套接字地址。</td></tr><tr><td>s.sendto()</td><td>发送UDP数据，将数据发送到套接字，address是形式为（ipaddr，port）的元组，指定远程地址。返回值是发送的字节数。</td></tr><tr><td>s.close()</td><td>关闭套接字</td></tr><tr><td>s.getpeername()</td><td>返回连接套接字的远程地址。返回值通常是元组（ipaddr,port）。</td></tr><tr><td>s.getsockname()</td><td>返回套接字自己的地址。通常是一个元组(ipaddr,port)</td></tr><tr><td>s.setsockopt(level,optname,value)</td><td>设置给定套接字选项的值。</td></tr><tr><td>s.getsockopt(level,optname[.buflen])</td><td>返回套接字选项的值。</td></tr><tr><td>s.settimeout(timeout)</td><td>设置套接字操作的超时期，timeout是一个浮点数，单位是秒。值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect()）</td></tr><tr><td>s.gettimeout()</td><td>返回当前超时期的值，单位是秒，如果没有设置超时期，则返回None。</td></tr><tr><td>s.fileno()</td><td>返回套接字的文件描述符。</td></tr><tr><td>s.setblocking(flag)</td><td>如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值）。非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常。</td></tr><tr><td>s.makefile()</td><td>创建一个与该套接字相关连的文件</td></tr></tbody></table><p>解决<code>OSError: [Errno 48] Address already in use</code> 问题</p><p>添加一条socket配置 , 重用ip和端口</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">sock = socket.socket()</span><br><span class="line"><span class="comment"># 添加在bind前</span></span><br><span class="line">sock.setsockopt(socket.SOL_SOCKET,SO_REUSEADDR,<span class="number">1</span>)</span><br><span class="line">sock.bind(address)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-网络编程之Socket&quot;&gt;&lt;a href=&quot;#Python之路-网络编程之Socket&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 网络编程之Socket&quot;&gt;&lt;/a&gt;Python之路 - 网络编程之Socket&lt;/h1&gt;&lt;h2 id=&quot;C-S架构-🍀&quot;&gt;&lt;a href=&quot;#C-S架构-🍀&quot; class=&quot;headerlink&quot; title=&quot;C/S架构  🍀&quot;&gt;&lt;/a&gt;C/S架构  🍀&lt;/h2&gt;&lt;p&gt;在网络通信中 , 一般是一方求一方应 , 求的一方就是客户端即 &lt;code&gt;Client&lt;/code&gt;  , 应的一方就是服务端即&lt;code&gt;Server&lt;/code&gt; , 这就是C/S架构 , 在互联网中处处是C/S架构 , 比如我们访问百度 ,  百度就是一个服务端 , 而我们的浏览器就是一个客户端&lt;/p&gt;
&lt;h2 id=&quot;Socket-🍀&quot;&gt;&lt;a href=&quot;#Socket-🍀&quot; class=&quot;headerlink&quot; title=&quot;Socket  🍀&quot;&gt;&lt;/a&gt;Socket  🍀&lt;/h2&gt;&lt;p&gt;Socket是应用层与TCP/IP协议族通信的中间软件抽象层 , 它是一组接口 , 是从顶上三层 (osi七层协议的应用层) 进入传输层的接口 ; 顶上三层通常构成所谓的用户进程 , 底下四层却通常作为操作系统内核的一个部分提供&lt;/p&gt;
&lt;p&gt;Socket又叫做套接字 , Python中socket为我们封装好了TCP/UDP协议 , 所以我们无需深入理解 , 只要遵循socket的规定去编程就可以了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;创建socket对象&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;创建socket对象就是一个建立TCP的过程 , 即三次握手 , 断开当然就是四次挥手了&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Network" scheme="https://jesse.top/categories/python/Network/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>28.Python之路 - 面向对象特性之封装</title>
    <link href="https://jesse.top/2020/06/26/python/04-Object-Oriented/04-Python%E4%B9%8B%E8%B7%AF%20-%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%B0%81%E8%A3%85/"/>
    <id>https://jesse.top/2020/06/26/python/04-Object-Oriented/04-Python之路 - 面向对象之封装/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:30:31.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-面向对象特性之封装"><a href="#Python之路-面向对象特性之封装" class="headerlink" title="Python之路 - 面向对象特性之封装"></a>Python之路 - 面向对象特性之封装</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>封装就是把客观事物封装成抽象的类 , 并且类可以把自己的数据和方法只让可信的类或者对象操作 , 对不可信的进行信息隐藏</p><h2 id="私有问题-🍀"><a href="#私有问题-🍀" class="headerlink" title="私有问题  🍀"></a>私有问题  🍀</h2><p>当我们类中的一些属性或者方法想要对不可信的类或者对象隐藏时 , 我们就可以将这些属性或者方法 , 定义成私有属性或者私有方法</p><p>在Python中用双下划线开头的方式将属性隐藏起来 , 即带双下划线就为私有属性或者私有方法</p><ul><li>私有属性</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        <span class="comment"># 定义私有属性</span></span><br><span class="line">        self.__name = name</span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">a = A(<span class="string">"Lyon"</span>)</span><br><span class="line"><span class="comment"># 访问a中的__name属性</span></span><br><span class="line">print(a.__name)</span><br><span class="line"><span class="comment"># 执行结果 : AttributeError: 'A' object has no attribute '__name'</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">结果报错,意思是对象A中没有__name这个属性</span></span><br><span class="line"><span class="string">也就是说,外部已经不能直接利用 .__name 来访问这个属性了</span></span><br><span class="line"><span class="string">因为此时它是一个私有属性</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>将属性定义成私有属性其实是一种变形操作 , 即类中所有以双下划线开头的名称都会自动变形成:_类名+名称 如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="comment"># 定义私有属性</span></span><br><span class="line">        self.__name = name</span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">a = A(<span class="string">"Lyon"</span>)</span><br><span class="line"><span class="comment"># 访问a中的__name属性</span></span><br><span class="line">print(a._A__name)      </span><br><span class="line"><span class="comment"># 执行结果: Lyon</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">__name自动变形为 _A__name</span></span><br><span class="line"><span class="string">所以使用a._A__name是可以访问到的</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>由上可知变形的特点如下:</p><ol><li>类中定义的__name只能在内部使用 , 并且内部使用是引用的变形的结果,即( self._A__name)</li><li>这种变形其实是针对外部的变形 , 在外部是无法通过__name访问的</li></ol><p><strong><em>PS : 这种变形机制其实并没有真正意义上限制我们从外部直接访问属性 , 知道了类名和属性名就可以拼出名字 : _类名__属性 , 然后就可以访问了 , 如 a._A__name . 并且变形的过程只在类的定义时发生一次</em></strong> </p><ul><li>私有方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__func</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"In the A"</span>)</span><br><span class="line">a = A()</span><br><span class="line">a.__func()</span><br><span class="line"><span class="comment"># 执行结果: AttributeError: 'A' object has no attribute '__func'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a._A__func()</span><br><span class="line"><span class="comment"># 执行结果: In the A</span></span><br></pre></td></tr></table></figure><h2 id="当私有遇到继承-🍀"><a href="#当私有遇到继承-🍀" class="headerlink" title="当私有遇到继承  🍀"></a>当私有遇到继承  🍀</h2><p>当我们在继承中使用私有属性或者方法时 , 因为变形机制 , 我们已经不能将私有属性或者方法 , 来与普通属性或者方法那样看待了</p><ul><li>私有属性继承</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ame)</span>:</span></span><br><span class="line">        self.__name = ame</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, ame)</span>:</span></span><br><span class="line">        self.__name = name</span><br><span class="line">        <span class="comment"># 继承父类中的属性</span></span><br><span class="line">        super().__init__(ame)</span><br><span class="line">a = B(<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line">print(a._A__name)</span><br><span class="line">print(a._B__name)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">b</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>例子说明 : 在上节中已经知道变形操作这回事了 , 当遇到继承时需要注意的就是 , 我们表面上看到的是两个类中都只有一个__name属性 , 但是由于变形 , 使其在定义完成后就分别变成了_A__name 和 _B__name  , 所以继承时已经是两个不同的属性了 , 所以两个属性都存在 , 只是我们表面上还是看不到</p><ul><li>私有方法继承</li></ul><p>与私有属性继承一样 , 需要注意私有方法名变形的问题</p><p>我们可以利用这一特点 , 来实现继承时达到子类不会覆盖父类方法的效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__func</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'from A'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__func()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__func</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'from B'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__func()</span><br><span class="line">b=B()</span><br><span class="line">b.test1()</span><br><span class="line">b.test2()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">from A</span></span><br><span class="line"><span class="string">from B</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="封装与扩展性-🍀"><a href="#封装与扩展性-🍀" class="headerlink" title="封装与扩展性  🍀"></a>封装与扩展性  🍀</h2><p>封装在于明确区分内外 , 使得类实现者可以修改封装内的东西而不影响外部调用者的代码 ; 而外部使用者只知道一个接口(函数) , 只要接口(函数)名 , 参数不变 , 使用者的代码永远无需改变 . 这就提供了一个良好的合作基础 , 相当于只要接口这个基础约定不变 , 则代码改变也不足为虑</p><p>原始类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Room</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, owner, width, length, high)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.owner = owner</span><br><span class="line">        self.__width = width</span><br><span class="line">        self.__length = length</span><br><span class="line">        self.__high = high</span><br><span class="line">    <span class="comment"># 对外提供的求面积接口,隐藏内部实现详解</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tell_area</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__width * self.__length</span><br><span class="line">r1 = Room(<span class="string">'卧室'</span>,<span class="string">'Lyon'</span>,<span class="string">'0.3'</span>,<span class="string">'2'</span>,<span class="string">'2'</span>)</span><br><span class="line">r1.tell_area()</span><br></pre></td></tr></table></figure><p>修改类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Room</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, owner, width, length, high)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.owner = owner</span><br><span class="line">        self.__width = width</span><br><span class="line">        self.__length = length</span><br><span class="line">        self.__high = high</span><br><span class="line">    <span class="comment"># 对外提供的求体积接口,隐藏内部实现详解</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tell_area</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__width * self.__length * self.__high</span><br><span class="line">r1 = Room(<span class="string">'卧室'</span>,<span class="string">'Lyon'</span>,<span class="string">'0.3'</span>,<span class="string">'2'</span>,<span class="string">'2'</span>)</span><br><span class="line">r1.tell_area()</span><br></pre></td></tr></table></figure><p>我们发现我们将类的功能作出了修改 , 但是对于使用类功能的人来说 , 接口并没有发生变化 , 他们依然可以用原来的接口使用新功能</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-面向对象特性之封装&quot;&gt;&lt;a href=&quot;#Python之路-面向对象特性之封装&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 面向对象特性之封装&quot;&gt;&lt;/a&gt;Python之路 - 面向对象特性之封装&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;封装就是把客观事物封装成抽象的类 , 并且类可以把自己的数据和方法只让可信的类或者对象操作 , 对不可信的进行信息隐藏&lt;/p&gt;
&lt;h2 id=&quot;私有问题-🍀&quot;&gt;&lt;a href=&quot;#私有问题-🍀&quot; class=&quot;headerlink&quot; title=&quot;私有问题  🍀&quot;&gt;&lt;/a&gt;私有问题  🍀&lt;/h2&gt;&lt;p&gt;当我们类中的一些属性或者方法想要对不可信的类或者对象隐藏时 , 我们就可以将这些属性或者方法 , 定义成私有属性或者私有方法&lt;/p&gt;
&lt;p&gt;在Python中用双下划线开头的方式将属性隐藏起来 , 即带双下划线就为私有属性或者私有方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;私有属性&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self,name)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;# 定义私有属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.__name = name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 实例化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a = A(&lt;span class=&quot;string&quot;&gt;&quot;Lyon&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 访问a中的__name属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(a.__name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 执行结果 : AttributeError: &#39;A&#39; object has no attribute &#39;__name&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;结果报错,意思是对象A中没有__name这个属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;也就是说,外部已经不能直接利用 .__name 来访问这个属性了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;因为此时它是一个私有属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Object-Oriented" scheme="https://jesse.top/categories/python/Object-Oriented/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>27.Python之路 - 面向对象多态</title>
    <link href="https://jesse.top/2020/06/26/python/04-Object-Oriented/03-Python%E4%B9%8B%E8%B7%AF%20-%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%A4%9A%E6%80%81/"/>
    <id>https://jesse.top/2020/06/26/python/04-Object-Oriented/03-Python之路 - 面向对象之多态/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:30:06.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-面向对象多态"><a href="#Python之路-面向对象多态" class="headerlink" title="Python之路 - 面向对象多态"></a>Python之路 - 面向对象多态</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>上一篇中已经得知 , 继承可以扩展已存在的代码模块(类) , 其目的是为了解决<strong><em>代码重用</em></strong> 问题</p><p>多态则是为了实现另一个目的 : 接口重用</p><h2 id="多态-🍀"><a href="#多态-🍀" class="headerlink" title="多态  🍀"></a>多态  🍀</h2><p>多态 (Polymorphism) 按字面的意思就是”多种状态” , 比如动物有多种形态 , 人 , 猫 , 狗 ; 文件也有多种格式 exe , txt , md(MarkDown格式) , 这就是多态</p><p> 在面向对象语言中 , 接口的多种不同的实现方式即为多态 </p><blockquote><p>多态性是允许你将父对象设置成为一个或多个他的子对象相等的技术 , 赋值之后 , 父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作</p></blockquote><p>静态多态性</p><a id="more"></a><p>必须在编译时就能确定其处理方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">n1 = <span class="number">12</span></span><br><span class="line">n2 = <span class="number">34</span></span><br><span class="line"><span class="comment"># int类型相加</span></span><br><span class="line">print(n1 + n2)</span><br><span class="line">s1 = <span class="string">'hello '</span></span><br><span class="line">s2 = <span class="string">'word'</span></span><br><span class="line"><span class="comment"># str类型相加</span></span><br><span class="line">print(s1 + s2)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">46</span></span><br><span class="line"><span class="string">hello word</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>如上述例子我们利用运算符 “+”,  完成了两种情况下的运算 , 并且Python解释器在执行前就已确定处理方式 , 即编译过程中就已经知道了调用哪个函数 </p><p>动态多态性</p><p>编译时无法立即确定其处理方式 , 只有在执行时才确定处理方式 , 注意一定要同名 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta,abstractclassmethod</span><br><span class="line"><span class="comment"># 接口继承</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">    @abstractclassmethod</span></span><br><span class="line">    <span class="comment"># 约束派生类必须有talk方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"喵喵喵"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"汪汪汪"</span>)</span><br><span class="line">c = Cat()</span><br><span class="line">d = Dog()</span><br><span class="line"><span class="comment"># 因为接口的缘故,我们无需考虑实例化后的对象具体是什么类型,因为动物都有talk方法,所以我们可以直接使用</span></span><br><span class="line">c.talk()</span><br><span class="line">d.talk()</span><br><span class="line"><span class="comment"># 我们进行接口统一</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">talk</span><span class="params">(obj)</span>:</span></span><br><span class="line">    obj.talk()</span><br><span class="line">talk(c)</span><br><span class="line">talk(d)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">喵喵喵</span></span><br><span class="line"><span class="string">汪汪汪</span></span><br><span class="line"><span class="string">喵喵喵</span></span><br><span class="line"><span class="string">汪汪汪</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>上栗中, Python解释器在解释时是无法确定处理方式的 , 因为存在几个同名的方法 , 编译时并不能确定是哪一个 , 只有在执行时 , 才能确定使用哪个类中的talk() 方法 , 这就是动态多态性</p><p>小结:</p><ol><li>静态多态性与动态多态性的区别在于 , 编译时是否能确定其处理方式</li><li>通过多态可以实现用一个函数名调用不同内容的函数</li></ol><h2 id="多态性的好处-🍀"><a href="#多态性的好处-🍀" class="headerlink" title="多态性的好处  🍀"></a>多态性的好处  🍀</h2><p>多态性是面向对象的三大特性之一 , 有很多人说Python不支持多态 , 事实上Python处处是多态 , 比如内置函数len() 就是多态的一种体现 </p><p>多态的作用: </p><ol><li><p>增加了程序的灵活性</p><p>以不变应万变 , 不论对象有多少中形态 , 使用者都是同一种形式去调用 , 如 talk(obj)</p></li><li><p>增加了程序的可扩展性</p><p>通过继承Animal类派生了一个新的类 , 使用者无需更改自己的代码 , 依旧利用 talk(obj) 进行调用</p></li></ol><p>对于多态 , 可能会觉得比较模糊 , 这是因为 , 我们在写程序时不知不觉就用上了 , 哈哈所以还是说处处是多态</p><h2 id="鸭子类型-🍀"><a href="#鸭子类型-🍀" class="headerlink" title="鸭子类型  🍀"></a>鸭子类型  🍀</h2><p>Python崇尚鸭子类型</p><p>以下是维基百科中对鸭子类型得论述 :</p><p>在程序设计中 , 鸭子类型 (英语 : duck typing) 是动态类型的一种风格。在这种风格中 , 一个对象有效的语义 , 不是由继承自特定的类或实现特定的接口 , 而是由当前方法和属性的集合决定 . 这个概念的名字来源于由James Whitcomb Riley提出的鸭子测试 , “ 鸭子测试 “可以这样表述：</p><p>“ 如果走起来像鸭子 , 游泳起来像鸭子 , 叫起来也像鸭子 , 那么它就是鸭子 “</p><p><strong>在鸭子类型中 , 关注的不是对象的类型本身 , 而是它是如何使用的</strong> . 例如 , 在不使用鸭子类型的语言中 , 我们可以编写一个函数 , 它接受一个类型为鸭的对象 , 并调用它的走和叫方法 . 在使用鸭子类型的语言中 , 这样的一个函数可以接受一个任意类型的对象 , 并调用它的走和叫方法 . 如果这些需要被调用的方法不存在 , 那么将引发一个运行时错误 . 任何拥有这样的正确的走和叫方法的对象都可被函数接受的这种行为引出了以上表述 , 这种决定类型的方式因此得名。</p><p>鸭子类型通常得益于不测试方法和函数中参数的类型 , 而是依赖文档 , 清晰的代码和测试来确保正确使用 . 从静态类型语言转向动态类型语言的用户通常试图添加一些静态的 ( 在运行之前的 ) 类型检查 , 从而影响了鸭子类型的益处和可伸缩性 , 并约束了语言的动态特性</p><p>例1 : 利用标准库中定义的各种 ‘ 与文件类似的对象 ‘ , 尽管这些对象的工作方式像文件 , 但他们没有继承内置对象的方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 文本文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TxtFile</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 磁盘文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DiskFile</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>二者都像鸭子, 二者看起来都像文件,因而就可以当文件一样去用</p><p>例2 : 序列类型有多种形态 : 字符串 , 列表 , 元组 , 但他们没有直接的继承关系</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 三者都是序列类型</span></span><br><span class="line">name = <span class="string">'Lyon'</span></span><br><span class="line">namel = [<span class="string">'Lyon'</span>]</span><br><span class="line">namet = (<span class="string">'Lyon'</span>,)</span><br><span class="line"><span class="comment"># 字符串,列表,元组并没有直接关系,都可以调用len(),并且我们无需考虑类型</span></span><br><span class="line">print(len(name))</span><br><span class="line">print(len(namel))</span><br><span class="line">print(len(namet))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-面向对象多态&quot;&gt;&lt;a href=&quot;#Python之路-面向对象多态&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 面向对象多态&quot;&gt;&lt;/a&gt;Python之路 - 面向对象多态&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;上一篇中已经得知 , 继承可以扩展已存在的代码模块(类) , 其目的是为了解决&lt;strong&gt;&lt;em&gt;代码重用&lt;/em&gt;&lt;/strong&gt; 问题&lt;/p&gt;
&lt;p&gt;多态则是为了实现另一个目的 : 接口重用&lt;/p&gt;
&lt;h2 id=&quot;多态-🍀&quot;&gt;&lt;a href=&quot;#多态-🍀&quot; class=&quot;headerlink&quot; title=&quot;多态  🍀&quot;&gt;&lt;/a&gt;多态  🍀&lt;/h2&gt;&lt;p&gt;多态 (Polymorphism) 按字面的意思就是”多种状态” , 比如动物有多种形态 , 人 , 猫 , 狗 ; 文件也有多种格式 exe , txt , md(MarkDown格式) , 这就是多态&lt;/p&gt;
&lt;p&gt; 在面向对象语言中 , 接口的多种不同的实现方式即为多态 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;多态性是允许你将父对象设置成为一个或多个他的子对象相等的技术 , 赋值之后 , 父对象就可以根据当前赋值给它的子对象的特性以不同的方式运作&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;静态多态性&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Object-Oriented" scheme="https://jesse.top/categories/python/Object-Oriented/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>46.Python之路 - 实现线程池</title>
    <link href="https://jesse.top/2020/06/26/python/06-Concurrent/Python%E4%B9%8B%E8%B7%AF%20-%20%E5%AE%9E%E7%8E%B0%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>https://jesse.top/2020/06/26/python/06-Concurrent/Python之路 - 实现线程池/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:40:53.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-实现线程池-🍀"><a href="#Python之路-实现线程池-🍀" class="headerlink" title="Python之路 - 实现线程池  🍀"></a>Python之路 - 实现线程池  🍀</h1><h2 id="方式一-🍀"><a href="#方式一-🍀" class="headerlink" title="方式一  🍀"></a>方式一  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max_num=<span class="number">20</span>)</span>:</span></span><br><span class="line">        self.queue = Queue.Queue(max_num)</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> xrange(max_num):</span><br><span class="line">            self.queue.put(threading.Thread)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_thread</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.queue.get()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_thread</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.queue.put(threading.Thread)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">使用:</span></span><br><span class="line"><span class="string">pool = ThreadPool(10)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def func(arg, p):</span></span><br><span class="line"><span class="string">    import time</span></span><br><span class="line"><span class="string">    time.sleep(2)</span></span><br><span class="line"><span class="string">    p.add_thread()</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">for i in range(30):</span></span><br><span class="line"><span class="string">    thread = pool.get_thread()</span></span><br><span class="line"><span class="string">    t = thread(target=func, args=(i, pool))</span></span><br><span class="line"><span class="string">    t.start()</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="方式二-🍀"><a href="#方式二-🍀" class="headerlink" title="方式二  🍀"></a>方式二  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> queue</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> contextlib</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">StopEvent = object()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ThreadPool</span><span class="params">(object)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, max_num, max_task_num = None)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> max_task_num:</span><br><span class="line">            self.q = queue.Queue(max_task_num)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.q = queue.Queue()</span><br><span class="line">        self.max_num = max_num</span><br><span class="line">        self.cancel = <span class="keyword">False</span></span><br><span class="line">        self.terminal = <span class="keyword">False</span></span><br><span class="line">        self.generate_list = []</span><br><span class="line">        self.free_list = []</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self, func, args, callback=None)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        线程池执行一个任务</span></span><br><span class="line"><span class="string">        :param func: 任务函数</span></span><br><span class="line"><span class="string">        :param args: 任务函数所需参数</span></span><br><span class="line"><span class="string">        :param callback: 任务执行失败或成功后执行的回调函数，回调函数有两个参数1、任务函数执行状态；2、任务函数返回值（默认为None，即：不执行回调函数）</span></span><br><span class="line"><span class="string">        :return: 如果线程池已经终止，则返回True否则None</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> self.cancel:</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">        <span class="keyword">if</span> len(self.free_list) == <span class="number">0</span> <span class="keyword">and</span> len(self.generate_list) &lt; self.max_num:</span><br><span class="line">            self.generate_thread()</span><br><span class="line">        w = (func, args, callback,)</span><br><span class="line">        self.q.put(w)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">generate_thread</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        创建一个线程</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        t = threading.Thread(target=self.call)</span><br><span class="line">        t.start()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        循环去获取任务函数并执行任务函数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        current_thread = threading.currentThread()</span><br><span class="line">        self.generate_list.append(current_thread)</span><br><span class="line"></span><br><span class="line">        event = self.q.get()</span><br><span class="line">        <span class="keyword">while</span> event != StopEvent:</span><br><span class="line"></span><br><span class="line">            func, arguments, callback = event</span><br><span class="line">            <span class="keyword">try</span>:</span><br><span class="line">                result = func(*arguments)</span><br><span class="line">                success = <span class="keyword">True</span></span><br><span class="line">            <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                success = <span class="keyword">False</span></span><br><span class="line">                result = <span class="keyword">None</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> callback <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span>:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    callback(success, result)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">with</span> self.worker_state(self.free_list, current_thread):</span><br><span class="line">                <span class="keyword">if</span> self.terminal:</span><br><span class="line">                    event = StopEvent</span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    event = self.q.get()</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line">            self.generate_list.remove(current_thread)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">close</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        执行完所有的任务后，所有线程停止</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.cancel = <span class="keyword">True</span></span><br><span class="line">        full_size = len(self.generate_list)</span><br><span class="line">        <span class="keyword">while</span> full_size:</span><br><span class="line">            self.q.put(StopEvent)</span><br><span class="line">            full_size -= <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">terminate</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        无论是否还有任务，终止线程</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        self.terminal = <span class="keyword">True</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> self.generate_list:</span><br><span class="line">            self.q.put(StopEvent)</span><br><span class="line"></span><br><span class="line">        self.q.queue.clear()</span><br><span class="line"></span><br><span class="line"><span class="meta">    @contextlib.contextmanager</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">worker_state</span><span class="params">(self, state_list, worker_thread)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        用于记录线程中正在等待的线程数</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        state_list.append(worker_thread)</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            <span class="keyword">yield</span></span><br><span class="line">        <span class="keyword">finally</span>:</span><br><span class="line">            state_list.remove(worker_thread)</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">pool = ThreadPool(5)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def callback(status, result):</span></span><br><span class="line"><span class="string">    # status, execute action status</span></span><br><span class="line"><span class="string">    # result, execute action return value</span></span><br><span class="line"><span class="string">    pass</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">def action(i):</span></span><br><span class="line"><span class="string">    print(i)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">for i in range(30):</span></span><br><span class="line"><span class="string">    ret = pool.run(action, (i,), callback)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">time.sleep(5)</span></span><br><span class="line"><span class="string">print(len(pool.generate_list), len(pool.free_list))</span></span><br><span class="line"><span class="string">print(len(pool.generate_list), len(pool.free_list))</span></span><br><span class="line"><span class="string">pool.close()</span></span><br><span class="line"><span class="string">pool.terminate()</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-实现线程池-🍀&quot;&gt;&lt;a href=&quot;#Python之路-实现线程池-🍀&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 实现线程池  🍀&quot;&gt;&lt;/a&gt;Python之路 - 实现线程池  🍀&lt;/h1&gt;&lt;h2 id=&quot;方式一-🍀&quot;&gt;&lt;a href=&quot;#方式一-🍀&quot; class=&quot;headerlink&quot; title=&quot;方式一  🍀&quot;&gt;&lt;/a&gt;方式一  🍀&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;32&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Queue&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; threading&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ThreadPool&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(object)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, max_num=&lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.queue = Queue.Queue(max_num)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; i &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; xrange(max_num):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            self.queue.put(threading.Thread)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;get_thread&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; self.queue.get()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;add_thread&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.queue.put(threading.Thread)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;使用:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;pool = ThreadPool(10)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;def func(arg, p):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    import time&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    time.sleep(2)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    p.add_thread()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;for i in range(30):&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    thread = pool.get_thread()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    t = thread(target=func, args=(i, pool))&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    t.start()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Concurrent" scheme="https://jesse.top/categories/python/Concurrent/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>18.Python之路 - 模块导入详解</title>
    <link href="https://jesse.top/2020/06/26/python/03-Modules/02-Python%E4%B9%8B%E8%B7%AF%20-%20%E6%A8%A1%E5%9D%97%E5%AF%BC%E5%85%A5%E8%AF%A6%E8%A7%A3/"/>
    <id>https://jesse.top/2020/06/26/python/03-Modules/02-Python之路 - 模块导入详解/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:27:24.724Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-模块导入详解"><a href="#Python之路-模块导入详解" class="headerlink" title="Python之路 - 模块导入详解"></a>Python之路 - 模块导入详解</h1><h2 id="import-🍀"><a href="#import-🍀" class="headerlink" title="import 🍀"></a>import 🍀</h2><p>我们知道一个模块就是一个py文件 , 当我们执行py文件时 , python解释器会先加载内置命名空间 , 其次是加载全局命名空间( 学习函数就已知道 )  , 还有个局部命名空间就不说了</p><p>当python解释器遇到我们的import语句时 , import会将模块进行初始化 , 即会将模块中的内容执行一遍 , 既然执行 , 那么被import的模块的全局命名空间就创建成功了 , 并且会将这个创建成功的命名空间加载到使用import语句的本地的全局命名空间 . 于是我们就可以在本地使用被导入模块了</p><p>自定义模块my_module.py , 文件名my_module.py , 模块名my_module</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">在模块my_module.py下</span><br><span class="line">---------------文件内容----------------</span><br><span class="line">|  print(<span class="string">'from the my_module.py'</span>)    |</span><br><span class="line">|  <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">()</span>:</span>                       |</span><br><span class="line">|    print(module1)  | </span><br><span class="line">--------------------------------------</span><br><span class="line">在当前文件test.py下</span><br><span class="line">---------------文件内容----------------</span><br><span class="line">|  <span class="keyword">import</span> my_module                  |</span><br><span class="line">|  my_module.read()                  |</span><br><span class="line">--------------------------------------</span><br><span class="line"><span class="comment"># 执行test.py文件,打印结果</span></span><br><span class="line">module1</span><br></pre></td></tr></table></figure><p>import语句是可以在程序中的任意位置使用的 , 且针对同一个模块import多次时 , 为了防止你重复导入 , python进行了如下优化 : 第一次导入后就将模块名加载到内存了 , 后续的import语句仅是对已经加载大内存中的模块对象增加一次引用 , 不会重新执行模块内的语句 </p><p>import多次同以模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">在模块my_module.py下</span><br><span class="line">---------------文件内容----------------</span><br><span class="line">|  print(<span class="string">'from the my_module.py'</span>)    |</span><br><span class="line">|  <span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">()</span>:</span>                       |</span><br><span class="line">|    print(module1)  | </span><br><span class="line">--------------------------------------</span><br><span class="line">在当前test.py文件下</span><br><span class="line">---------------文件内容----------------</span><br><span class="line">|  <span class="keyword">import</span> my_module                  |</span><br><span class="line">|  <span class="keyword">import</span> my_module                  |</span><br><span class="line">|  <span class="keyword">import</span> my_module                  |</span><br><span class="line">|  my_module.read()                  |</span><br><span class="line">--------------------------------------</span><br><span class="line"><span class="comment"># 执行test.py文件,打印结果</span></span><br><span class="line">module1</span><br></pre></td></tr></table></figure><p>我们可以从sys.modules中找到当前已经加载的模块 , sys.modules是一个字典 , 内部包含模块名与模块对象的映射 ,该字典决定了导入模块时是否需要重新导入 </p><p>每个模块的命名空间都是相互独立的 , 这样我们在编写自己的模块时 , 就不用担心我们定义在自己模块中全局变量在被导入时 , 与使用者的同名全局变量冲突</p><p><strong><em>ps:模块中的内容使用 :<code>模块名 .函数或者变量或者类</code>来进行调用</em></strong></p><p>总结</p><p>首次导入模块时python会做三件事</p><ol><li>为源文件(如my_module模块) 创建新的命名空间 , 在my_module中定义的函数和方法若是使用到了globals() 时访问的就是这个命名空间</li><li>在新创建的命名空间执行模块中包含的代码 , 如上例中执行了模块中的print语句 , 并加载了函数</li><li>创建名字my_module 来引用该命名空间 , 使用my_module.名字的方式访问my_module.py文件中定义的名字 , 且名字与test.py文件中的名字来自两个完全不同的地方</li></ol><h2 id="import-…-as-…-🍀"><a href="#import-…-as-…-🍀" class="headerlink" title="import … as … 🍀"></a>import … as … 🍀</h2><p>为模块取名</p><p>根据用户需求选择额不同的sql(数据库)功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在mysql.py中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqlparse</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'from mysql sqlparse'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在oracle.py中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sqlparse</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'from oracle sqlparse'</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在test.py中</span></span><br><span class="line">db_type = input(<span class="string">'Please choice the database &gt;&gt;'</span>).strip()</span><br><span class="line"><span class="keyword">if</span> db_type == <span class="string">'mysql'</span>:</span><br><span class="line">    <span class="keyword">import</span> mysql <span class="keyword">as</span> db</span><br><span class="line"><span class="keyword">elif</span> db_type == <span class="string">'oracle'</span>:</span><br><span class="line">    <span class="keyword">import</span> oracle <span class="keyword">as</span> db</span><br></pre></td></tr></table></figure><p>一行导入多个模块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys,os,re</span><br></pre></td></tr></table></figure><h2 id="from-…-import-…-🍀"><a href="#from-…-import-…-🍀" class="headerlink" title="from … import … 🍀"></a>from … import … 🍀</h2><p>相当于import , 同样会执行一遍my_module文件 , 同样也会创建命名空间 , 但是from .. . import … 是将my_module中的名字直接导入到当前的命名空间 , 也就意味着可以直接调用 , 而不用像import那样 , 利用 my_module <em>.</em> 名字 来进行调用</p><p>两种方式对比</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># import方式</span></span><br><span class="line"><span class="keyword">import</span> my_module</span><br><span class="line"><span class="comment"># 模块名 + '.' + 函数名进行调用</span></span><br><span class="line">my_module.read()</span><br><span class="line"><span class="comment"># from...import...方式</span></span><br><span class="line"><span class="keyword">from</span> my_module <span class="keyword">import</span> read</span><br><span class="line"><span class="comment"># 直接用函数名调用</span></span><br><span class="line">read()</span><br></pre></td></tr></table></figure><p>PS : 利用from…import…方式进行导入 , 一般用来指定导入模块中的某一部分 , 或者方便使用 , 还有一个特殊的导入 from … import * (作用是导入模块中的所有内容 , 但是有弊端) </p><p>as</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> my_module <span class="keyword">import</span> read <span class="keyword">as</span> r</span><br></pre></td></tr></table></figure><p>多行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> my_module <span class="keyword">import</span> (read1,</span><br><span class="line">                      read2,</span><br><span class="line">                      read3)</span><br></pre></td></tr></table></figure><h2 id="from-…-import-🍀"><a href="#from-…-import-🍀" class="headerlink" title="from … import * 🍀"></a>from … import * 🍀</h2><p>from my_module import * 会将my_module 中的所有的不是以下划线 ‘ _ ‘ 开头的名字都导入到当前位置 , 在大部分情况下我们python程序不应该使用这种导入方式 , 因为你无法知道 * 导入了什么名字 , 很有可能会覆盖掉你已经定义过的名字 , 而且可读性极其的差</p><p>在my_module.py中新增一行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这样在另外一个文件中用from my_module import * 就能导入列表中规定的两个名字</span></span><br><span class="line">__all__ = [<span class="string">'money'</span> , <span class="string">'read1'</span>]</span><br></pre></td></tr></table></figure><h2 id="if-name-‘-main-‘-🍀"><a href="#if-name-‘-main-‘-🍀" class="headerlink" title="if __name__ == ‘__main__‘ 🍀"></a>if __name__ == ‘__main__‘ 🍀</h2><p>所有的模块都有一个内置属性 __name__ , 可以用来查看模块名</p><p>在当前文件执行时会返回’ __main__ ‘, 如果不在当前文件执行那么就会返回所执行的模块名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># my_module.py中</span></span><br><span class="line">print(__name__)</span><br><span class="line"><span class="comment"># 执行my_module.py</span></span><br><span class="line">执行结果: __main__</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py中</span></span><br><span class="line"><span class="keyword">import</span> my_modlue</span><br><span class="line"><span class="comment"># 执行 test.py </span></span><br><span class="line">执行结果: my_module</span><br></pre></td></tr></table></figure><p>所以利用__name__ 属性 , 我们就可以实现 , 模块可以自己执行 , 也可以导入到别的模块中执行 , 并且他不会执行 <strong>两次</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># my_module.py中</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'we are in %s'</span> % __name__)</span><br><span class="line"><span class="comment"># 如果在当前文件下就会执行</span></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># test.py中 , 执行test.py</span></span><br><span class="line"><span class="comment"># 解释from语句时 , 并不会执行my_module中的main()</span></span><br><span class="line"><span class="keyword">from</span> my_module <span class="keyword">import</span> main</span><br><span class="line"><span class="comment"># 执行main()</span></span><br><span class="line">main()</span><br><span class="line">执行结果：we are <span class="keyword">in</span> my_module</span><br><span class="line"><span class="comment"># 结果显示只执行了一次main()</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-模块导入详解&quot;&gt;&lt;a href=&quot;#Python之路-模块导入详解&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 模块导入详解&quot;&gt;&lt;/a&gt;Python之路 - 模块导入详解&lt;/h1&gt;&lt;h2 id=&quot;import-🍀&quot;&gt;&lt;a href=&quot;#import-🍀&quot; class=&quot;headerlink&quot; title=&quot;import 🍀&quot;&gt;&lt;/a&gt;import 🍀&lt;/h2&gt;&lt;p&gt;我们知道一个模块就是一个py文件 , 当我们执行py文件时 , python解释器会先加载内置命名空间 , 其次是加载全局命名空间( 学习函数就已知道 )  , 还有个局部命名空间就不说了&lt;/p&gt;
&lt;p&gt;当python解释器遇到我们的import语句时 , import会将模块进行初始化 , 即会将模块中的内容执行一遍 , 既然执行 , 那么被import的模块的全局命名空间就创建成功了 , 并且会将这个创建成功的命名空间加载到使用import语句的本地的全局命名空间 . 于是我们就可以在本地使用被导入模块了&lt;/p&gt;
&lt;p&gt;自定义模块my_module.py , 文件名my_module.py , 模块名my_module&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Modules" scheme="https://jesse.top/categories/python/Modules/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
</feed>
