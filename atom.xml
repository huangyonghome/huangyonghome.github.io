<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jesse&#39;s home</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jesse.top/"/>
  <updated>2020-06-30T13:01:53.371Z</updated>
  <id>https://jesse.top/</id>
  
  <author>
    <name>Jesse</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>acme.sh自动申请SSL证书脚本</title>
    <link href="https://jesse.top/2020/06/30/Linux-Basic/shell&amp;shell%E8%84%9A%E6%9C%AC/acme.sh%E8%87%AA%E5%8A%A8%E7%94%B3%E8%AF%B7SSL%E8%AF%81%E4%B9%A6%E8%84%9A%E6%9C%AC/"/>
    <id>https://jesse.top/2020/06/30/Linux-Basic/shell&amp;shell脚本/acme.sh自动申请SSL证书脚本/</id>
    <published>2020-06-29T16:44:48.000Z</published>
    <updated>2020-06-30T13:01:53.371Z</updated>
    
    <content type="html"><![CDATA[<h2 id="acme-sh自动申请SSL证书脚本"><a href="#acme-sh自动申请SSL证书脚本" class="headerlink" title="acme.sh自动申请SSL证书脚本"></a>acme.sh自动申请SSL证书脚本</h2><p>acme.sh是GitHub上的一个项目.有关这个工具的介绍可以参考github,或者查看Linux-证书目录下的相关笔记</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#description: 使用acme.sh工具通过自动DNS验证方式申请SSL证书.</span><br><span class="line">#date: 20190620</span><br><span class="line"></span><br><span class="line">#判断是否有指定域名,以及域名</span><br><span class="line">if [ $# != 2 ];then</span><br><span class="line">   echo &quot;usage: $0 domain_name ssl_install_dir&quot;</span><br><span class="line">   exit 1</span><br><span class="line">fi</span><br><span class="line">#接收要申请SSL证书的域名参数</span><br><span class="line">ssl_domain=$1</span><br><span class="line">#接收证书安装目标路径的参数</span><br><span class="line">ssl_install_dir=$2</span><br><span class="line"></span><br><span class="line">#判断申请的是否是通配符证书</span><br><span class="line">if `echo $ssl_domain | grep &quot;^\*&quot; &gt; /dev/null 2&gt;&amp;1`;then</span><br><span class="line"></span><br><span class="line">    #如果是通配符证书,那么替换到域名前面的&quot;*.&quot;</span><br><span class="line">    ssl_name=$(echo $ssl_domain | sed &apos;s@\*\.@@&apos;)</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line"></span><br><span class="line">    ssl_name=$ssl_domain</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#检查证书安装目录,判断该域名是否已经申请过证书.如果已经申请过,则直接退出</span><br><span class="line"></span><br><span class="line">#新建ssl_dir证书路径变量</span><br><span class="line">ssl_dir=$&#123;ssl_install_dir&#125;/$&#123;ssl_name&#125;</span><br><span class="line"></span><br><span class="line">if [ -d $ssl_dir ];then</span><br><span class="line"></span><br><span class="line">    echo &quot;$ssl_domain certificate has already installed&quot; &amp;&amp; exit 0</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#导入环境变量</span><br><span class="line">export DP_Id=DNS服务器的AccessKeyID</span><br><span class="line">export DP_Key=DNS服务器的Secret</span><br><span class="line"></span><br><span class="line">#申请证书</span><br><span class="line">cd /home/work/.acme.sh/</span><br><span class="line"></span><br><span class="line"># 判断申请的是通配符证书,还是单域名证书</span><br><span class="line">if [ $ssl_domain == $ssl_name ];then</span><br><span class="line"></span><br><span class="line">./acme.sh --issue --dns dns_dp  -d $ssl_name</span><br><span class="line"></span><br><span class="line">else</span><br><span class="line">./acme.sh --issue --dns dns_dp  -d $ssl_name -d $ssl_domain</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#判断证书申请是否成功</span><br><span class="line">if [ $? != 0 ];then</span><br><span class="line">     echo &quot;$ssl_domain certificate applied failed&quot; &amp;&amp; exit 1</span><br><span class="line">else</span><br><span class="line">    echo &quot;$ssl_domain certificate applied successfully&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#新建证书目标路径</span><br><span class="line">mkdir -p $ssl_dir</span><br><span class="line"></span><br><span class="line">#安装证书</span><br><span class="line">./acme.sh  --installcert  -d  $ssl_name  \</span><br><span class="line">       --key-file $&#123;ssl_dir&#125;/$&#123;ssl_name&#125;.key  \</span><br><span class="line">       --fullchain-file $&#123;ssl_dir&#125;/fullchain.cer     \</span><br><span class="line">       --reloadcmd  &quot;supervisorctl -c /etc/supervisord/supervisord.conf restart nginx&quot;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;acme-sh自动申请SSL证书脚本&quot;&gt;&lt;a href=&quot;#acme-sh自动申请SSL证书脚本&quot; class=&quot;headerlink&quot; title=&quot;acme.sh自动申请SSL证书脚本&quot;&gt;&lt;/a&gt;acme.sh自动申请SSL证书脚本&lt;/h2&gt;&lt;p&gt;acme.s
      
    
    </summary>
    
      <category term="Linux-Basic" scheme="https://jesse.top/categories/Linux-Basic/"/>
    
      <category term="shell&amp;shell脚本" scheme="https://jesse.top/categories/Linux-Basic/shell-shell%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="scripts" scheme="https://jesse.top/tags/scripts/"/>
    
  </entry>
  
  <entry>
    <title>mysql数据库使用xtrabackup全量,增量备份</title>
    <link href="https://jesse.top/2020/06/30/Linux-Basic/shell&amp;shell%E8%84%9A%E6%9C%AC/mysql%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BD%BF%E7%94%A8xtrabackup%E5%85%A8%E9%87%8F,%E5%A2%9E%E9%87%8F%E5%A4%87%E4%BB%BD/"/>
    <id>https://jesse.top/2020/06/30/Linux-Basic/shell&amp;shell脚本/mysql数据库使用xtrabackup全量,增量备份/</id>
    <published>2020-06-29T16:44:48.000Z</published>
    <updated>2020-06-30T12:59:00.486Z</updated>
    
    <content type="html"><![CDATA[<h2 id="mysql数据库使用xtrabackup全量-增量备份"><a href="#mysql数据库使用xtrabackup全量-增量备份" class="headerlink" title="mysql数据库使用xtrabackup全量,增量备份"></a>mysql数据库使用xtrabackup全量,增量备份</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">##############################################################</span><br><span class="line"># File Name: backup.sh</span><br><span class="line"># Version: V1.0</span><br><span class="line"># Author: huangyong</span><br><span class="line"># Created Time : 2018-3-1 18:42:00</span><br><span class="line"># Description: 数据库全量,增量备份脚本</span><br><span class="line"></span><br><span class="line">#备份策略:每周一进行全备,其他日期备份当周的增量备份.每次全备前删除2周前的备份</span><br><span class="line">#可扩展功能:打包备份文件.备份文件传输到远程服务器</span><br><span class="line"></span><br><span class="line">#date:2018-04-15</span><br><span class="line">#update:由于数据库/data磁盘已快满.所以备份只保留一周.</span><br><span class="line"></span><br><span class="line">#date:2018-04-23</span><br><span class="line">#update:增加如果备份失败则发邮件通知功能</span><br><span class="line">#       增加自动删除备份日志功能</span><br><span class="line"></span><br><span class="line">#data:2018-04-24</span><br><span class="line">#update:1.增加xtrabackup自带的的备份压缩功能,且压缩线程数4.</span><br><span class="line">#       2.全备完成后,打包整个全备的备份文件(暂时先不打包)</span><br><span class="line">#       3.全备完成后,同步备份文件到BETA服务器</span><br><span class="line">#       4.保留2份备份文件,也就是保留2周</span><br><span class="line">#       5.将脚本的执行用户从root改到work.</span><br><span class="line"></span><br><span class="line">#date:2018-05-03</span><br><span class="line">#update:修改N_变量的抓取inc增量备份目录的命令.之前用的是sort命令,经常会抓取到错误的inc增量备份目录</span><br><span class="line">#        脚本执行用户改成root,因为work用户没有权限访问mysql的数据文件目录</span><br><span class="line">##############################################################</span><br><span class="line"></span><br><span class="line">#获取脚本所存放目录</span><br><span class="line">cd `dirname $0`</span><br><span class="line">bash_path=`pwd`</span><br><span class="line">#脚本名</span><br><span class="line">me=$(basename $0)</span><br><span class="line"></span><br><span class="line">#设置要备份的innodb数据库，用空格格开，空为备份所有库</span><br><span class="line">databases=&apos;&apos;</span><br><span class="line"></span><br><span class="line">#定义变量</span><br><span class="line">DATE=$(date +%W) #全年的第几周,一个星期为一个备份周期.备份根目录，其子目录：base为全量，inc1、inc2...为增量</span><br><span class="line">TWO_WEEKS_AGO=$(echo $&#123;DATE&#125;-2|bc) #前两周前的备份</span><br><span class="line">FULL_DATE=$(date +%F) #存储日志日期</span><br><span class="line">DAY_DATE=$(date +%w) #判断一周的第几天</span><br><span class="line">#MYSQL=&quot;mysql&quot;  # mysql命令绝对路径或在PATH中</span><br><span class="line">MYSQL_DATA_DIR=&quot;/data/mysql/data&quot;  # 数据库目录</span><br><span class="line">BACKUP_USER=&quot;tongji&quot;  # 备份用户</span><br><span class="line">PASSWD=$(cat /data/xtrabackup/password)  # 备份密码保存文件</span><br><span class="line">BACK_FILE_DIR=&quot;/data/backups/$&#123;DATE&#125;&quot;  # 备份频率目录，此目录变化频率为备份一周期</span><br><span class="line">LOG_P_DIR=&quot;/data/backup_logs&quot; #备份日志根目录</span><br><span class="line">LOG_DIR=&quot;/data/backup_logs/$&#123;FULL_DATE&#125;&quot;  # 备份过程日志目录</span><br><span class="line">#LOG_ERR=&quot;$&#123;LOG_DIR&#125;/mysql_backup_fail.log&quot; #备份错误日志文件</span><br><span class="line">LOG_FILE=&quot;$&#123;LOG_DIR&#125;/mysql_backup.log&quot;  #备份过程日志文件</span><br><span class="line">email_user=&quot;huangyong@doweidu.com&quot;</span><br><span class="line">ssh_server=&quot;10.25.2.85&quot;  # 远程备份服务器IP</span><br><span class="line">ssh_server_dir=&quot;/data/tongjidb-mysqlbackup&quot;  # 远程备份服务器目录</span><br><span class="line">ssh_port=&quot;5822&quot;  # ssh端口</span><br><span class="line">ssh_parameters=&quot;-o StrictHostKeyChecking=no -o ConnectTimeout=60&quot;</span><br><span class="line">ssh_user=&quot;work&quot;</span><br><span class="line">ssh_command=&quot;ssh $&#123;ssh_parameters&#125; -p $&#123;ssh_port&#125;&quot;</span><br><span class="line">#scp_command=&quot;scp $&#123;ssh_parameters&#125; -P $&#123;ssh_port&#125;&quot;</span><br><span class="line"></span><br><span class="line">#定义保存日志函数</span><br><span class="line">function save_log () &#123;</span><br><span class="line">        </span><br><span class="line">echo -e &quot;#################[`date +%F\ %T`]$* ####################&quot; &gt;&gt; $LOG_FILE</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#定义发送邮件函数</span><br><span class="line">function send_mail () &#123;</span><br><span class="line">        echo $1 | mail -s $1  $email_user</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#创建目录</span><br><span class="line">[ ! -d &quot;$&#123;BACK_FILE_DIR&#125;&quot; ] &amp;&amp; mkdir -p $&#123;BACK_FILE_DIR&#125;</span><br><span class="line">[ ! -d &quot;$&#123;LOG_DIR&#125;&quot; ] &amp;&amp; mkdir -p $&#123;LOG_DIR&#125;</span><br><span class="line"></span><br><span class="line">function full_backup () &#123;</span><br><span class="line"># 全量备份函数</span><br><span class="line">[ ! -z &quot;$databases&quot; ] &amp;&amp; option=&quot;--databases=$&#123;databases&#125;&quot; || option=&quot;&quot; </span><br><span class="line"></span><br><span class="line">##############################MYSQL全库备份#########################</span><br><span class="line">/usr/bin/xtrabackup  --user=$BACKUP_USER --password=$PASSWD --compress --compress-threads=4 --backup --target-dir=$&#123;BACK_FILE_DIR&#125;/base --datadir=$&#123;MYSQL_DATA_DIR&#125; $option &gt; $LOG_FILE 2&gt;&amp;1</span><br><span class="line"></span><br><span class="line">        if [ $? -eq 0 ];then</span><br><span class="line">             save_log &quot;mysql full_backup succeed&quot;</span><br><span class="line">             chown -R mysql:mysql $&#123;BACK_FILE_DIR&#125;/base</span><br><span class="line">        </span><br><span class="line">        else</span><br><span class="line">             save_log &quot;mysql full_backup failed&quot;</span><br><span class="line">             #send_mail &quot;mysql full_backup failed&quot;</span><br><span class="line">             exit 1   </span><br><span class="line">        </span><br><span class="line">        fi                </span><br><span class="line">###################################################################</span><br><span class="line"></span><br><span class="line">          </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function incremental_backup () &#123;</span><br><span class="line">    [ ! -z &quot;$databases&quot; ] &amp;&amp; option=&quot;--databases=$&#123;databases&#125;&quot; || option=&quot;&quot;</span><br><span class="line"></span><br><span class="line">    cd  $BACK_FILE_DIR</span><br><span class="line">    # 判断是否存在第一次增量备份目录inc1</span><br><span class="line">    # 存在则获取最后一次增量备份目录incN，然后基于最后一次增量备份，做增量备份</span><br><span class="line">    # 不存在则基于全量备份目录base做增量备份</span><br><span class="line">    if [ -d &quot;inc1&quot; ];then</span><br><span class="line">        N_=$(ls -l | awk -F &apos;inc&apos; &apos;/^d+.+inc[0-9]+$/&#123;a[NR]=$NF;len=asort(a,sa)&#125;END&#123;print sa[len]&#125;&apos;)</span><br><span class="line">        N=$(echo $N_+1|bc)</span><br><span class="line">        #增量备份 </span><br><span class="line">        /usr/bin/xtrabackup --user=$BACKUP_USER --password=$PASSWD --backup --compress --target-dir=$BACK_FILE_DIR/inc$N \</span><br><span class="line">        --incremental-basedir=$BACK_FILE_DIR/inc$N_ --datadir=$MYSQL_DATA_DIR $option &gt; $LOG_FILE 2&gt;&amp;1</span><br><span class="line">    else</span><br><span class="line">        N=&quot;1&quot;</span><br><span class="line">        #增量备份 </span><br><span class="line">        [ ! -d $BACK_FILE_DIR/base ] &amp;&amp; save_log &quot;incremental backup failed,no full_backup&quot; &amp;&amp; exit 1</span><br><span class="line">        /usr/bin/xtrabackup --user=$BACKUP_USER --password=$PASSWD --backup --compress --target-dir=$BACK_FILE_DIR/inc$N \</span><br><span class="line">        --incremental-basedir=$BACK_FILE_DIR/base --datadir=$MYSQL_DATA_DIR $option &gt; $LOG_FILE 2&gt;&amp;1</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    if [ $? -eq 0 ];then</span><br><span class="line">             save_log &quot;mysql inc$&#123;N&#125;-backup successed&quot;</span><br><span class="line">             chown -R mysql:mysql $&#123;BACK_FILE_DIR&#125;/inc$N</span><br><span class="line">        </span><br><span class="line">        else</span><br><span class="line">             save_log &quot;mysql inc$&#123;N&#125;-backup failed&quot; </span><br><span class="line">            #send_mail &quot;mysql inc$&#123;N&#125;-backup failed&quot;</span><br><span class="line">             exit 1   </span><br><span class="line">                        </span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function rsync_backup_files () &#123;</span><br><span class="line">#传输到远程服务器备份, 需要配置免密ssh认证</span><br><span class="line">        </span><br><span class="line">        #使用rsync将本地的/data/backups目录同步到BETA服务器.同时删除BETA服务器上2周前的备份目录</span><br><span class="line">rsync -az --delete /data/backups -e &quot;$&#123;ssh_command&#125;&quot; $ssh_user@$&#123;ssh_server&#125;:$ssh_server_dir</span><br><span class="line">[ $? -eq 0 ] &amp;&amp; save_log &quot;full-backuped rsync successed&quot; || \</span><br><span class="line">&#123; save_log &quot;backup rsync failed&quot; ; send_mail &quot;mysql backup rsync failed&quot; ; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#每周1进行全备.其他日期对本周一的全备做增量备份</span><br><span class="line">if [ $DAY_DATE -eq 1 ];then</span><br><span class="line">    </span><br><span class="line">   </span><br><span class="line">   #删除2周前的备份文件</span><br><span class="line">   if [ 1 -le $TWO_WEEKS_AGO -a $TWO_WEEKS_AGO -lt 10 ];then #如果本周和2周前的数相减小于10,并且大于等于1,则相差的结果前加个0.比如07</span><br><span class="line">        FILE_NAME=$(dirname $BACK_FILE_DIR)/0$TWO_WEEKS_AGO</span><br><span class="line">        [ -d $FILE_NAME ] &amp;&amp; rm -rf $FILE_NAME</span><br><span class="line"></span><br><span class="line">   elif [ $TWO_WEEKS_AGO -ge 10 ];then  #如果两数相减等于两位数,直接删除文件</span><br><span class="line">           FILE_NAME=$(dirname $BACK_FILE_DIR)/$TWO_WEEKS_AGO</span><br><span class="line">           [ -d $FILE_NAME ] &amp;&amp; rm -rf $FILE_NAME</span><br><span class="line"></span><br><span class="line">   fi</span><br><span class="line"></span><br><span class="line">   full_backup #调用全备</span><br><span class="line">  </span><br><span class="line">else</span><br><span class="line">     incremental_backup #调用增备</span><br><span class="line"></span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#删除7天前日志文件</span><br><span class="line">find $LOG_P_DIR -type d -mtime +7 -exec rm -rf &#123;&#125; \;</span><br><span class="line"></span><br><span class="line">rsync_backup_files</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;mysql数据库使用xtrabackup全量-增量备份&quot;&gt;&lt;a href=&quot;#mysql数据库使用xtrabackup全量-增量备份&quot; class=&quot;headerlink&quot; title=&quot;mysql数据库使用xtrabackup全量,增量备份&quot;&gt;&lt;/a&gt;mysql
      
    
    </summary>
    
      <category term="Linux-Basic" scheme="https://jesse.top/categories/Linux-Basic/"/>
    
      <category term="shell&amp;shell脚本" scheme="https://jesse.top/categories/Linux-Basic/shell-shell%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="scripts" scheme="https://jesse.top/tags/scripts/"/>
    
  </entry>
  
  <entry>
    <title>分析统计Nginx日志的响应时间</title>
    <link href="https://jesse.top/2020/06/30/Linux-Basic/shell&amp;shell%E8%84%9A%E6%9C%AC/%E5%88%86%E6%9E%90Nginx%E6%97%A5%E5%BF%97%E7%9A%84%E5%93%8D%E5%BA%94%E6%97%B6%E9%97%B4/"/>
    <id>https://jesse.top/2020/06/30/Linux-Basic/shell&amp;shell脚本/分析Nginx日志的响应时间/</id>
    <published>2020-06-29T16:44:48.000Z</published>
    <updated>2020-06-30T13:03:22.173Z</updated>
    
    <content type="html"><![CDATA[<h2 id="分析统计Nginx日志的响应时间"><a href="#分析统计Nginx日志的响应时间" class="headerlink" title="分析统计Nginx日志的响应时间"></a>分析统计Nginx日志的响应时间</h2><p>Nginx日志格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">log_format main &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;</span><br><span class="line">                &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;</span><br><span class="line">                &apos;&quot;$http_user_agent&quot; $http_x_forwarded_for &quot;$request_time&quot;&apos;;</span><br></pre></td></tr></table></figure><p>实际日志如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[work@iqg-yyq2 ~]$ head  /data/logs/nginx/iqg_api_v5.access.log</span><br><span class="line">100.97.74.45 - - [11/Mar/2019:03:46:01 +0800] &quot;HEAD / HTTP/1.0&quot; 200 0 &quot;-&quot; &quot;-&quot; - &quot;0.001&quot;</span><br><span class="line">100.117.85.154 - - [11/Mar/2019:03:46:01 +0800] &quot;HEAD / HTTP/1.0&quot; 200 0 &quot;-&quot; &quot;-&quot; - &quot;0.001&quot;</span><br><span class="line">100.97.74.22 - - [11/Mar/2019:03:46:02 +0800] &quot;HEAD / HTTP/1.0&quot; 200 0 &quot;-&quot; &quot;-&quot; - &quot;0.002&quot;</span><br><span class="line">100.117.85.96 - - [11/Mar/2019:03:46:02 +0800] &quot;HEAD / HTTP/1.0&quot; 200 0 &quot;-&quot; &quot;-&quot; - &quot;0.001&quot;</span><br><span class="line">100.117.85.133 - - [11/Mar/2019:03:46:02 +0800] &quot;HEAD / HTTP/1.0&quot; 200 0 &quot;-&quot; &quot;-&quot; - &quot;0.001&quot;</span><br><span class="line">100.117.85.172 - - [11/Mar/2019:03:46:02 +0800] &quot;HEAD / HTTP/1.0&quot; 200 0 &quot;-&quot; &quot;-&quot; - &quot;0.002&quot;</span><br><span class="line">100.97.74.0 - - [11/Mar/2019:03:46:02 +0800] &quot;HEAD / HTTP/1.0&quot; 200 0 &quot;-&quot; &quot;-&quot; - &quot;0.001&quot;</span><br><span class="line">100.97.73.184 - - [11/Mar/2019:03:46:02 +0800] &quot;HEAD / HTTP/1.0&quot; 200 0 &quot;-&quot; &quot;-&quot; - &quot;0.001&quot;</span><br><span class="line">100.117.85.85 - - [11/Mar/2019:03:46:02 +0800] &quot;HEAD / HTTP/1.0&quot; 200 0 &quot;-&quot; &quot;-&quot; - &quot;0.001&quot;</span><br><span class="line">100.97.74.62 - - [11/Mar/2019:03:46:02 +0800] &quot;HEAD / HTTP/1.0&quot; 200 0 &quot;-&quot; &quot;-&quot; - &quot;0.001&quot;</span><br></pre></td></tr></table></figure><p>最后一行为响应时间.但是是个字符串,还不能直接用awk来统计</p><p>下面这个脚本用来统计响应时间:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">[ $# -ne 2 ] &amp;&amp; echo &quot;Usage: ./loganalysis.sh two parameters: logfile path  and cost time&quot; &amp;&amp; exit 0</span><br><span class="line"></span><br><span class="line">[ ! -f &quot;$1&quot; ] &amp;&amp; echo &quot;the file doesn&apos;t exsit,please check again&quot; &amp;&amp; exit 0</span><br><span class="line">logfile=$(basename $1)</span><br><span class="line"></span><br><span class="line">[ &quot;$2&quot; -lt 0 ] &amp;&amp; echo &quot; the second parameter is not a digit&quot; &amp;&amp; exit 0</span><br><span class="line">cost_time=$2</span><br><span class="line"></span><br><span class="line">cat $1 | awk &apos;&#123;print $NF&#125;&apos;  | awk -F &quot;\&quot;&quot; &apos;&#123;print $2&#125;&apos;  &gt;  time.txt</span><br><span class="line">echo &quot;split request_time over!!!&quot;</span><br><span class="line"></span><br><span class="line">paste  -d &quot; &quot; $1 time.txt &gt; new.log</span><br><span class="line">echo &quot;build new logfile over!!!&quot;</span><br><span class="line"></span><br><span class="line">awk &apos;($NF&gt;&apos;$cost_time&apos;)&#123;print $0&#125;&apos; new.log &gt; slow-$&#123;logfile&#125;</span><br><span class="line">echo &quot;please see slowtime in slow-$&#123;logfile&#125;&quot;</span><br><span class="line"></span><br><span class="line">rm -f time.txt</span><br><span class="line">rm -f new.log</span><br><span class="line"></span><br><span class="line"># analyze the access frequence of API</span><br><span class="line"></span><br><span class="line">echo &quot;#############the access frequence of API ##################&quot;</span><br><span class="line">awk &apos;&#123;++S[$4]&#125; END &#123; for (i in S) print &quot;URL:&quot;i &quot;\t&quot; &quot;access times:&quot;S[i]&#125;&apos; slow-$&#123;logfile&#125;</span><br></pre></td></tr></table></figure><p>下面是统计iqg_api_v5.access.log这个日志响应时间超过1秒的记录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[work@iqg-yyq2 ~]$ ./loganalysis.sh /data/logs/nginx/iqg_api_v5.access.log 1</span><br><span class="line">split request_time over!!!</span><br><span class="line">build new logfile over!!!</span><br><span class="line">please see slowtime in slowtime.txt!!!</span><br><span class="line">[work@iqg-yyq2 ~]$</span><br></pre></td></tr></table></figure><p>查看最终结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">work@iqg-yyq2 ~]$ head slowtime.txt</span><br><span class="line">100.117.85.64 [11/Mar/2019:14:14:15 &quot;HEAD / 1.223</span><br><span class="line">100.97.74.41 [11/Mar/2019:14:14:16 &quot;HEAD / 1.984</span><br><span class="line">100.97.74.104 [11/Mar/2019:14:14:16 &quot;HEAD / 1.880</span><br><span class="line">100.97.74.5 [11/Mar/2019:14:14:16 &quot;HEAD / 1.758</span><br><span class="line">100.117.85.100 [11/Mar/2019:14:14:16 &quot;HEAD / 1.757</span><br><span class="line">100.97.73.213 [11/Mar/2019:14:14:16 &quot;HEAD / 1.767</span><br><span class="line">100.117.85.160 [11/Mar/2019:14:14:16 &quot;HEAD / 1.662</span><br><span class="line">100.97.74.118 [11/Mar/2019:14:14:16 &quot;HEAD / 1.566</span><br><span class="line">100.97.73.141 [11/Mar/2019:14:14:16 &quot;HEAD / 1.215</span><br><span class="line">100.117.56.238 [11/Mar/2019:14:14:16 &quot;HEAD / 1.132</span><br><span class="line">[work@iqg-yyq2 ~]$</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;分析统计Nginx日志的响应时间&quot;&gt;&lt;a href=&quot;#分析统计Nginx日志的响应时间&quot; class=&quot;headerlink&quot; title=&quot;分析统计Nginx日志的响应时间&quot;&gt;&lt;/a&gt;分析统计Nginx日志的响应时间&lt;/h2&gt;&lt;p&gt;Nginx日志格式如下:&lt;/
      
    
    </summary>
    
      <category term="Linux-Basic" scheme="https://jesse.top/categories/Linux-Basic/"/>
    
      <category term="shell&amp;shell脚本" scheme="https://jesse.top/categories/Linux-Basic/shell-shell%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="scripts" scheme="https://jesse.top/tags/scripts/"/>
    
  </entry>
  
  <entry>
    <title>将服务器日志归档到阿里云OSS的脚本</title>
    <link href="https://jesse.top/2020/06/30/Linux-Basic/shell&amp;shell%E8%84%9A%E6%9C%AC/%E5%B0%86%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%97%A5%E5%BF%97%E5%BD%92%E6%A1%A3%E5%88%B0%E9%98%BF%E9%87%8C%E4%BA%91OSS%E7%9A%84%E8%84%9A%E6%9C%AC/"/>
    <id>https://jesse.top/2020/06/30/Linux-Basic/shell&amp;shell脚本/将服务器日志归档到阿里云OSS的脚本/</id>
    <published>2020-06-29T16:44:48.000Z</published>
    <updated>2020-06-30T13:02:31.723Z</updated>
    
    <content type="html"><![CDATA[<h2 id="将服务器日志归档到阿里云OSS的脚本"><a href="#将服务器日志归档到阿里云OSS的脚本" class="headerlink" title="将服务器日志归档到阿里云OSS的脚本"></a>将服务器日志归档到阿里云OSS的脚本</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line">#Descripion: upload trade center logs file to Aliyun OSS</span><br><span class="line">#Author: HuangYong</span><br><span class="line">#date: 2019-04-29 </span><br><span class="line"></span><br><span class="line">buket=mg-tradecenter-log-archived #OSS Buket name</span><br><span class="line">year=$(date +%Y) #年份</span><br><span class="line">year_dir=log-archived-$&#123;year&#125; #OSS年份目录</span><br><span class="line">month=$(date +%m) #月份</span><br><span class="line">ossutil64_dir=/home/work</span><br><span class="line"></span><br><span class="line">yesterday_logtime=$(date +%Y%m%d --date=&quot;-1 day&quot;) #upload yeasterday logfile</span><br><span class="line">log_dir=/data/logs/apps/trade-center/trade-center # tradecenter log file parent dir</span><br><span class="line">log_prefix=&quot;trade-center.log&quot; #logfile prefix</span><br><span class="line">hostname=api1 #tradecenter server</span><br><span class="line"></span><br><span class="line">#判断是否安装ossutil64工具</span><br><span class="line">[ ! -f &quot;/home/work/ossutil64&quot; ] &amp;&amp; echo &quot;请安装ossutil64软件&quot; &amp;&amp; exit 1</span><br><span class="line"></span><br><span class="line">#判断年份目录是否存在,不存在则创建</span><br><span class="line">if ! `$&#123;ossutil64_dir&#125;/ossutil64 ls oss://$&#123;buket&#125;/$&#123;year_dir&#125;/ &gt; /dev/null 2&gt;&amp;1`;then</span><br><span class="line">   $&#123;ossutil64_dir&#125;/ossutil64 mkdir oss://$&#123;buket&#125;/$&#123;year_dir&#125;/</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">#判断月份目录是否存在,不存在则创建</span><br><span class="line">if ! `$&#123;ossutil64_dir&#125;/ossutil64 ls oss://$&#123;buket&#125;/$&#123;year_dir&#125;/$&#123;month&#125; &gt; /dev/null 2&gt;&amp;1`;then</span><br><span class="line">   $&#123;ossutil64_dir&#125;/ossutil64 mkdir oss://$&#123;buket&#125;/$&#123;year_dir&#125;/$&#123;month&#125;/</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 打包昨天的日志文件</span><br><span class="line"></span><br><span class="line">cd $log_dir</span><br><span class="line"></span><br><span class="line">for log_type in &quot;debug&quot; &quot;error&quot; &quot;netrcd-admin&quot; &quot;netrcd-callback&quot; &quot;netrcd-gateway&quot; &quot;netrcd-notify&quot; &quot;script&quot;;do</span><br><span class="line"></span><br><span class="line">    log_name=&quot;$&#123;log_prefix&#125;.$&#123;log_type&#125;.$yesterday_logtime&quot;</span><br><span class="line">    if [ -f $log_name ];then</span><br><span class="line">        tar -zc -f $&#123;hostname&#125;.$&#123;log_name&#125;.tar.gz  $log_name</span><br><span class="line">    fi</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line"># 上传文件到OSS</span><br><span class="line"></span><br><span class="line">$&#123;ossutil64_dir&#125;/ossutil64 cp $log_dir --include=&quot;$&#123;hostname&#125;*.tar.gz&quot; -r -f oss://$&#123;buket&#125;/$&#123;year_dir&#125;/$&#123;month&#125;/</span><br><span class="line"></span><br><span class="line">#上传完成后,删除打包的日志</span><br><span class="line">[ $? == 0 ] &amp;&amp; rm -f $log_dir/$&#123;hostname&#125;*</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;将服务器日志归档到阿里云OSS的脚本&quot;&gt;&lt;a href=&quot;#将服务器日志归档到阿里云OSS的脚本&quot; class=&quot;headerlink&quot; title=&quot;将服务器日志归档到阿里云OSS的脚本&quot;&gt;&lt;/a&gt;将服务器日志归档到阿里云OSS的脚本&lt;/h2&gt;&lt;figure c
      
    
    </summary>
    
      <category term="Linux-Basic" scheme="https://jesse.top/categories/Linux-Basic/"/>
    
      <category term="shell&amp;shell脚本" scheme="https://jesse.top/categories/Linux-Basic/shell-shell%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="scripts" scheme="https://jesse.top/tags/scripts/"/>
    
  </entry>
  
  <entry>
    <title>kvm自动创建虚拟机,自定义IP地址</title>
    <link href="https://jesse.top/2020/06/30/Linux-Basic/shell&amp;shell%E8%84%9A%E6%9C%AC/kvm%E9%80%9A%E8%BF%87%E6%A8%A1%E6%9D%BF%E8%87%AA%E5%8A%A8%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA,%E9%85%8D%E7%BD%AEIP%E7%BD%91%E7%BB%9C/"/>
    <id>https://jesse.top/2020/06/30/Linux-Basic/shell&amp;shell脚本/kvm通过模板自动创建虚拟机,配置IP网络/</id>
    <published>2020-06-29T16:44:48.000Z</published>
    <updated>2020-06-30T13:00:33.613Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">通过KVM模板自动化创建虚拟机（需要电脑中存在模板）.以及创建完虚拟机后,自动修改IP地址</span></span><br><span class="line"><span class="meta">#</span><span class="bash">该脚本需要以root身份执行</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta"> #</span><span class="bash">镜像和模板源文件</span></span><br><span class="line">src_img_path=/opt/vmx/linux/hadoop.dev.base.img</span><br><span class="line">src_xml_path=/etc/libvirt/qemu/hadoop.dev.base.xml</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">镜像和模板源文件父目录</span></span><br><span class="line">prefix_img_path=/opt/vmx/linux</span><br><span class="line">prefix_xml_path=/etc/libvirt/qemu</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">获取新虚拟机名称</span></span><br><span class="line">get_newname()&#123;</span><br><span class="line">while true</span><br><span class="line">        do</span><br><span class="line">                read -p "请输入新虚拟机名称(主机名)：" newname</span><br><span class="line">                if [ $newname ];then</span><br><span class="line">                    if `virsh list --all | grep "\b$&#123;newname&#125;\b"`;then</span><br><span class="line">                        echo "该虚拟机已经存在.请检查系统当前虚拟机"</span><br><span class="line">                    else</span><br><span class="line"></span><br><span class="line">                        #设置新虚拟机镜像和模板路径</span><br><span class="line">                        new_img_path=$&#123;prefix_img_path&#125;/$&#123;newname&#125;.qcow2</span><br><span class="line">                        new_xml_path=$&#123;prefix_xml_path&#125;/$&#123;newname&#125;.xml</span><br><span class="line">                        break</span><br><span class="line">                    fi</span><br><span class="line">                else</span><br><span class="line">                        echo "************"</span><br><span class="line">                        echo "请输入虚拟机主机名！"</span><br><span class="line">                        echo "************"</span><br><span class="line">                fi</span><br><span class="line">        done</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">设置新虚拟机内存</span></span><br><span class="line">get_newmemary()&#123;</span><br><span class="line">while true</span><br><span class="line">        do</span><br><span class="line">                current_free_mem=`free -g|awk '/^Mem/&#123;print $4&#125;'`</span><br><span class="line">                mem_total=`free -g|awk '/^Mem/&#123;print $2&#125;'`</span><br><span class="line">                echo "目前本机内存总大小：$&#123;mem_total&#125;g"</span><br><span class="line">                echo "当前空闲内存大小为：$&#123;current_free_mem&#125;g"</span><br><span class="line">                read -p "请输入新虚拟机内存大小(单位G)：" newmemary</span><br><span class="line">                if [ $newmemary ];then</span><br><span class="line">                        if [[ $newmemary &lt; $mem_total ]];then</span><br><span class="line">                                break</span><br><span class="line">                        else</span><br><span class="line">                                echo "**********************************"</span><br><span class="line">                                echo "输入的数值必须小于当前内存总大小！"</span><br><span class="line">                                echo "**********************************"</span><br><span class="line">                        fi</span><br><span class="line">                else</span><br><span class="line">                        echo "********************"</span><br><span class="line">                        echo "请输入新虚拟机内存！"</span><br><span class="line">                        echo "********************"</span><br><span class="line">                fi</span><br><span class="line">        done</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">设置新虚拟机CPU</span></span><br><span class="line">get_newcpu()&#123;</span><br><span class="line">while true</span><br><span class="line">        do</span><br><span class="line">                core=`cat /proc/cpuinfo| grep "processor"| wc -l`</span><br><span class="line">                echo "可用core个数：$&#123;core&#125;"</span><br><span class="line">                read -p "请输入新虚拟机处理器核数：" newcpu</span><br><span class="line">                if [ $newcpu ];then</span><br><span class="line">                        if [ $newcpu -le $core ];then</span><br><span class="line">                                break</span><br><span class="line">                        else</span><br><span class="line">                                echo "******************************"</span><br><span class="line">                                echo "不能超过可用个数或者输入错误！"</span><br><span class="line">                                echo "******************************"</span><br><span class="line">                        fi</span><br><span class="line">                else</span><br><span class="line">                        echo "**************"</span><br><span class="line">                        echo "输入不能为空！"</span><br><span class="line">                        echo "**************"</span><br><span class="line">                fi</span><br><span class="line">        done</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">设置IP</span></span><br><span class="line">get_ip()&#123;</span><br><span class="line"></span><br><span class="line">    while true</span><br><span class="line">        do </span><br><span class="line">            read -p "请输入新虚拟机的IP地址(格式:172.16.10.[2-240]):" ip</span><br><span class="line">            if `echo $ip| grep -E "172.16.10.[0-9]&#123;1,3&#125;$" &gt; /dev/null 2&gt;&amp;1`;then</span><br><span class="line">                ipaddr=$(echo $ip | awk -F "." '&#123;print $4&#125;')</span><br><span class="line">                #valid_check=$(echo $ip | awk -F "." '2&lt;$4 &amp;&amp; $4&lt;241 &#123;print "yes"&#125;')</span><br><span class="line">                #if [ "$valid_check" == "yes" ];then</span><br><span class="line">                if [ $ipaddr -gt 2 -a $ipaddr -lt 241 ];then</span><br><span class="line">                    if ! `ping -W 3 -c 1 $ip &gt; /dev/null 2&gt;&amp;1`;then</span><br><span class="line">                       break</span><br><span class="line">                    </span><br><span class="line">                    else</span><br><span class="line">                       echo "当前IP已经被占用,请重新输入"</span><br><span class="line">                    </span><br><span class="line">                    fi</span><br><span class="line">                </span><br><span class="line">                else</span><br><span class="line">                    echo "IP地址必须要在2-240之间"</span><br><span class="line"></span><br><span class="line">                fi</span><br><span class="line">            </span><br><span class="line">            else</span><br><span class="line">                echo "IP地址格式不对,请重新输入"</span><br><span class="line">            </span><br><span class="line">            fi</span><br><span class="line">    done</span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">复制模板、xml</span></span><br><span class="line">copy_model_xml()&#123;</span><br><span class="line">cp $src_img_path $new_img_path</span><br><span class="line">        cp $src_xml_path $new_xml_path</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">修改xml文件</span></span><br><span class="line">modification_xml()&#123;</span><br><span class="line">    uuid=`uuidgen`</span><br><span class="line">sed -ri "s/(&lt;name&gt;).*(&lt;\/name&gt;)/\1$&#123;newname&#125;\2/" $new_xml_path  </span><br><span class="line">        sed -ri "s/(&lt;uuid&gt;).*(&lt;\/uuid&gt;)/\1$&#123;uuid&#125;\2/" $new_xml_path </span><br><span class="line">        mem_kb=$(($&#123;newmemary&#125;*1024*1024)) </span><br><span class="line"> </span><br><span class="line">        sed -ri "s/(&lt;memory.*&gt;).*(&lt;\/memory&gt;)/\1$&#123;mem_kb&#125;\2/" $new_xml_path </span><br><span class="line">        sed -ri "s/(&lt;currentMemory.*&gt;).*(&lt;\/currentMemory&gt;)/\1$&#123;mem_kb&#125;\2/" $new_xml_path</span><br><span class="line">        sed -ri "s/(&lt;vcpu.*&gt;).*(&lt;\/vcpu&gt;)/\1$&#123;newcpu&#125;\2/" $new_xml_path</span><br><span class="line">        sed -ri "s@(&lt;source file=').*('\/&gt;)@\1$&#123;new_img_path&#125;\2@" $new_xml_path  #定义新虚拟机的xml文件路径</span><br><span class="line"></span><br><span class="line">        sed -i "s@port='5930'@port='"59$&#123;ipaddr&#125;"'@" $new_xml_path #配置VNC端口号.格式59+ip地址最后一位</span><br><span class="line">        mac_addr=`openssl rand -hex 3 | sed -r 's/..\B/&amp;:/g'` #生成一个随机的MAC地址</span><br><span class="line"> </span><br><span class="line">        sed -ri "s/(&lt;mac address='..:..:..:).*('\/&gt;)/\1$&#123;mac_addr&#125;\2/" $new_xml_path #配置MAC地址</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">define</span></span><br><span class="line">define_vm()&#123;</span><br><span class="line">virsh define $new_xml_path #从xml文件中生成新虚拟机</span><br><span class="line">echo "**********"</span><br><span class="line">echo "$&#123;newname&#125;建完成！"</span><br><span class="line">echo "**********"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">network_setting()&#123;</span><br><span class="line"></span><br><span class="line">    #该脚本使用guestmount工具，Centos7中安装libguestfs-tools-c可以获得guestmount工具</span><br><span class="line">    #脚本在不登陆虚拟机的情况下，修改虚拟机的IP地址信息</span><br><span class="line"></span><br><span class="line">    mountpath="/tmp/$&#123;newname&#125;"</span><br><span class="line">    [ ! -d $mountpath ] &amp;&amp; mkdir $mountpath</span><br><span class="line"></span><br><span class="line">    guestmount  -d $&#123;newname&#125; -i $mountpath</span><br><span class="line"></span><br><span class="line">    #修改IP地址: 注意这里要通过这种方式才能修改IP..不能使用sed命令直接修改原文件,否则虚拟机启动后无法识别ifcfg-eth0文件</span><br><span class="line">    cat &gt; $&#123;mountpath&#125;/etc/sysconfig/network-scripts/ifcfg-eth0 &lt;&lt; EOF</span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEFROUTE=yes</span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=yes</span><br><span class="line">IPV6_AUTOCONF=yes</span><br><span class="line">IPV6_DEFROUTE=yes</span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">IPV6_ADDR_GEN_MODE=stable-privacy</span><br><span class="line">NAME=eth0</span><br><span class="line">DEVICE=eth0</span><br><span class="line">ONBOOT=yes</span><br><span class="line">IPADDR=$ip</span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line">GATEWAY=172.16.10.254</span><br><span class="line">DNS1=114.114.114.114</span><br><span class="line">EOF</span><br><span class="line">    #sed -i "/IPADDR/s@.*@IPADDR=$&#123;ip&#125;@" $&#123;mountpath&#125;/etc/sysconfig/network-scripts/ifcfg-eth0</span><br><span class="line">    #修改主机名</span><br><span class="line">    echo "$&#123;newname&#125;" &gt; $&#123;mountpath&#125;/etc/hostname</span><br><span class="line"></span><br><span class="line">    echo "虚拟主机IP地址和主机名配置完成"</span><br><span class="line"></span><br><span class="line">    #卸载临时挂载目录</span><br><span class="line">    umount /tmp/$&#123;newname&#125;</span><br><span class="line">    </span><br><span class="line">    #删除临时挂载目录</span><br><span class="line">    rm -rf /tmp/$&#123;newname&#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash">------------运行分界线------------------------------------</span></span><br><span class="line"></span><br><span class="line">get_newname</span><br><span class="line">get_newmemary</span><br><span class="line">get_newcpu</span><br><span class="line">get_ip</span><br><span class="line">copy_model_xml</span><br><span class="line">modification_xml</span><br><span class="line">define_vm</span><br><span class="line">network_setting</span><br></pre></td></tr></table></figure><p>参考 <a href="https://blog.csdn.net/qq_41814635/article/details/82256970" target="_blank" rel="noopener">https://blog.csdn.net/qq_41814635/article/details/82256970</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight shell&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
      <category term="Linux-Basic" scheme="https://jesse.top/categories/Linux-Basic/"/>
    
      <category term="shell&amp;shell脚本" scheme="https://jesse.top/categories/Linux-Basic/shell-shell%E8%84%9A%E6%9C%AC/"/>
    
    
      <category term="scripts" scheme="https://jesse.top/tags/scripts/"/>
    
  </entry>
  
  <entry>
    <title>使用goreplay收集线上真实http流量</title>
    <link href="https://jesse.top/2020/06/29/Linux-Web/%E4%BD%BF%E7%94%A8goreplay%E6%94%B6%E9%9B%86%E7%BA%BF%E4%B8%8A%E7%9C%9F%E5%AE%9Ehttp%E6%B5%81%E9%87%8F/"/>
    <id>https://jesse.top/2020/06/29/Linux-Web/使用goreplay收集线上真实http流量/</id>
    <published>2020-06-29T03:59:58.000Z</published>
    <updated>2020-06-29T13:45:33.890Z</updated>
    
    <content type="html"><![CDATA[<h2 id="使用goreplay收集线上真实http流量"><a href="#使用goreplay收集线上真实http流量" class="headerlink" title="使用goreplay收集线上真实http流量"></a>使用goreplay收集线上真实http流量</h2><h3 id="背景介绍"><a href="#背景介绍" class="headerlink" title="背景介绍"></a>背景介绍</h3><p>在很多场景中,我们需要将线上服务器的真实Http请求复制转发到某台服务器中(或者测试环境中),并且前提是不影响线上生产业务进行.</p><p>例如:</p><ol><li>通常可能会通过ab等压测工具来对单一http接口进行压测。但如果是需要http服务整体压测，使用ab来压测工作量大且不方便，通过线上流量复制引流，通过将真实请求流量放大N倍来进行压测，能对服务有一个较为全面的检验.</li><li>将线上流量引入到测试环境中,测试某个中间件或者数据库的压力</li><li>上线前在预发布环境，使用线上真实的请求，检查是否准备发布的版本，是否具备发布标准</li><li>用线上的流量转发到预发，检查相同流量下一些指标的反馈情况，检查核心数据是否有改善、优化.</li></ol><a id="more"></a><hr><h3 id="goreplay介绍"><a href="#goreplay介绍" class="headerlink" title="goreplay介绍"></a>goreplay介绍</h3><p>goreplay项目请参考github:<a href="https://github.com/buger/goreplay" target="_blank" rel="noopener">goreplay介绍</a></p><p>goreplay是一款开源网络监控工具,可以在不影响业务的情况下,记录服务器真实流量,将该流量用来做镜像,压力测试,监控和分析等用途.</p><p>简单来说就是goreplay抓取线上真实的流量，并将捕捉到的流量转发到测试服务器上(或者保存到本地文件中)</p><p>goreplay大致工作流程如下:</p><p><img src="https://img2.jesse.top/20200629110035.png" alt=""></p><hr><h3 id="goreplay常见使用方式"><a href="#goreplay常见使用方式" class="headerlink" title="goreplay常见使用方式"></a>goreplay常见使用方式</h3><p>goreplay使用文档参考:<a href="https://github.com/buger/goreplay/wiki" target="_blank" rel="noopener">goreplay文档</a></p><p>常用的一些命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">-input-raw 抓取指定端口的流量 gor --input-raw :8080</span><br><span class="line">-output-stdout 打印到控制台</span><br><span class="line">-output-file 将请求写到文件中 gor --input-raw :80 --output-file ./requests.gor</span><br><span class="line">-input-file 从文件中读取请求，与上一条命令呼应 gor --input-file ./requests.gor</span><br><span class="line">-exit-after 5s 持续时间</span><br><span class="line">-http-allow-url url白名单，其他请求将会被丢弃</span><br><span class="line">-http-allow-method 根据请求方式过滤</span><br><span class="line">-http-disallow-url 遇上一个url相反，黑名单，其他的请求会被捕获到</span><br></pre></td></tr></table></figure><blockquote><p>更多命令可以使用 ./gor –help查看</p></blockquote><hr><h3 id="goreplay安装"><a href="#goreplay安装" class="headerlink" title="goreplay安装"></a>goreplay安装</h3><p>在github上下载Linux的二进制文件: <a href="https://github.com/buger/goreplay/releases" target="_blank" rel="noopener">goreplay安装</a></p><blockquote><p>注意.虽然在github上提供了rpm安装包,但是实际安装发现无法安装:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@dwd-tongji-3 ~]# rpm -ivh gor-1.0.0-1.x86_64.rpm</span><br><span class="line">Preparing...                          ################################# [100%]</span><br><span class="line">package goreplay-1.0.0-1.x86_64 is intended for a different operating system</span><br></pre></td></tr></table></figure><p>下载github上的二进制文件,解压后是一个gor的二进制可执行文件.复制到PATH变量路径下即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@dwd-tongji-3 ~]# wget https://github.com/buger/goreplay/releases/download/v1.0.0/gor_1.0.0_x64.tar.gz</span><br><span class="line">[root@dwd-tongji-3 ~]# ls</span><br><span class="line"> gor_1.0.0_x64.tar.gz</span><br><span class="line">[root@dwd-tongji-3 ~]# tar -xf gor_1.0.0_x64.tar.gz</span><br><span class="line">[root@dwd-tongji-3 ~]# ls</span><br><span class="line">gor </span><br><span class="line">[root@dwd-tongji-3 ~]# ll gor</span><br><span class="line">-rwxr-xr-x 1 501 games 17779040 Mar 30  2019 gor</span><br><span class="line">[root@dwd-tongji-3 ~]# cp gor /usr/local/bin/</span><br></pre></td></tr></table></figure><hr><h3 id="goreplay简单实践"><a href="#goreplay简单实践" class="headerlink" title="goreplay简单实践"></a>goreplay简单实践</h3><h4 id="1-将本地http的流量保存到本地文件中"><a href="#1-将本地http的流量保存到本地文件中" class="headerlink" title="1.将本地http的流量保存到本地文件中."></a>1.将本地http的流量保存到本地文件中.</h4><p>为了简便起见,以下命令都在root用户下执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## 1.开启一个screen窗口</span><br><span class="line">[root@dwd-tongji-3 ~]# screen -S GOR</span><br><span class="line">## 2.将80流量保存到本地的文件</span><br><span class="line">[root@dwd-tongji-3 ~]# gor --input-raw :80 --output-file /data/requests.gor</span><br><span class="line">Version: 1.0.0</span><br></pre></td></tr></table></figure><p>默认情况下goreplay会以块文件存储,将流量保存为多个块文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@dwd-tongji-3 ~]# ls /data/requests_* | more</span><br><span class="line">/data/requests_0.gor</span><br><span class="line">/data/requests_100.gor</span><br><span class="line">/data/requests_101.gor</span><br><span class="line">/data/requests_102.gor</span><br><span class="line">/data/requests_103.gor</span><br><span class="line">/data/requests_104.gor</span><br><span class="line">/data/requests_105.gor</span><br><span class="line">/data/requests_106.gor</span><br><span class="line">/data/requests_107.gor</span><br><span class="line">/data/requests_108.gor</span><br><span class="line">/data/requests_109.gor</span><br><span class="line">/data/requests_10.gor</span><br></pre></td></tr></table></figure><p>使用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>[root@dwd-tongji-3 ~]#./gor –input-raw :80 –output-file /data/gor.gor –output-file-append</p><p>[root@dwd-tongji-3 ~]# ll /data -h<br>total 1.4M<br>-rw-r—– 1 root root 1.4M Jun 29 15:13 gor.gor<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 2.将http的请求打印到终端</span><br></pre></td></tr></table></figure></p><p>[root@dwd-tongji-3 ~]#gor –input-raw :8000 –output-stdout<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 3.将http的请求转发到测试环境</span><br></pre></td></tr></table></figure></p><p>gor –input-raw :80 –output-http=”<a href="http://beta:80&quot;" target="_blank" rel="noopener">http://beta:80&quot;</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">在测试服务器上的nginx查看日志,.发现流量已经进来了</span><br></pre></td></tr></table></figure></p><p>10.111.51.243 - - [29/Jun/2020:14:56:55 +0800] “POST /piwik.php HTTP/1.1” 200 5 “<a href="https://2021001151691008.hybrid.alipay-eco.com/2021001151691008/0.2.2006111453.18/index.html#pages/index/index?appid=2021001151691008&amp;taskId=415&quot;" target="_blank" rel="noopener">https://2021001151691008.hybrid.alipay-eco.com/2021001151691008/0.2.2006111453.18/index.html#pages/index/index?appid=2021001151691008&amp;taskId=415&quot;</a> “Mozilla/5.0 (iPhone; CPU iPhone OS 13_3_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/17D50 Ariver/1.0.12 AliApp(AP/10.1.95.7030) Nebula WK RVKType(0) AlipayDefined(nt:4G,ws:375|667|2.0) AlipayClient/10.1.95.7030 Language/zh-Hans Region/CN NebulaX/1.0.0” “112.96.179.238”<br>10.111.51.243 - - [29/Jun/2020:14:56:55 +0800] “POST /piwik.php HTTP/1.1” 200 5 “<a href="https://servicewechat.com/wxa090d3923fde0d4b/132/page-frame.html&quot;" target="_blank" rel="noopener">https://servicewechat.com/wxa090d3923fde0d4b/132/page-frame.html&quot;</a> “Mozilla/5.0 (iPhone; CPU iPhone OS 13_5_1 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Mobile/15E148 MicroMessenger/7.0.13(0x17000d29) NetType/4G Language/zh_CN” “14.106.171.11”<br>10.111.51.243 - - [29/Jun/2020:14:56:55 +0800] “POST /piwik_new.php?actionname=zt-template HTTP/1.1” 400 249 “-“ “-“ “118.31.36.251”<br>10.111.51.243 - - [29/Jun/2020:14:56:55 +0800] “POST /piwik_new.php?actionname=zt-template HTTP/1.1” 400 249 “-“ “-“ “118.31.36.251”<br>10.111.51.243 - - [29/Jun/2020:14:56:55 +0800] “POST /piwik_new.php?actionname=zt-template HTTP/1.1” 400 249 “-“ “-“ “118.31.36.251”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">####  也可以将流量输出到多个终端</span><br><span class="line"></span><br><span class="line">* 输出到多个http服务器</span><br></pre></td></tr></table></figure></p><p>gor –input-tcp :28020 –output-http “<a href="http://staging.com&quot;" target="_blank" rel="noopener">http://staging.com&quot;</a>  –output-http “<a href="http://dev.com&quot;" target="_blank" rel="noopener">http://dev.com&quot;</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 输出到文件或者Http服务器</span><br></pre></td></tr></table></figure></p><p>gor –input-raw :80 –output-file requests.log –output-http “<a href="http://staging.com&quot;" target="_blank" rel="noopener">http://staging.com&quot;</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">####  4.将流量从文件重放到http服务器</span><br><span class="line"></span><br><span class="line">1.首先将请求流量保存到本地文件</span><br></pre></td></tr></table></figure></p><p>sudo ./gor –input-raw :8000 –output-file=requests.gor<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">2.再开一个窗口,运行gor,将请求流量从文件中重放</span><br></pre></td></tr></table></figure></p><p>./gor –input-file requests.gor –output-http=”<a href="http://localhost:8001&quot;" target="_blank" rel="noopener">http://localhost:8001&quot;</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 压力测试</span><br><span class="line"></span><br><span class="line">goreplay支持将捕获到的生产实际请求流量减少或者放大重播以用于测试环境的压力测试.压力测试一般针对Input流量减少或者放大.例如下面的例子</span><br></pre></td></tr></table></figure></p><h1 id="Replay-from-file-on-2x-speed"><a href="#Replay-from-file-on-2x-speed" class="headerlink" title="Replay from file on 2x speed"></a>Replay from file on 2x speed</h1><p>#将请求流量以2倍的速度放大重播<br>gor –input-file “requests.gor|200%” –output-http “staging.com”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">当然也也支持10%,20%等缩小请求流量</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">### 限速</span><br><span class="line"></span><br><span class="line">如果受限于测试环境的服务器资源压力,只想重播一部分流量到测试环境中,而不需要所有的实际生产流量,那么就可以用限速功能.有两种策略可以实现限流</span><br><span class="line"></span><br><span class="line">1.随机丢弃请求流量</span><br><span class="line"></span><br><span class="line">2.基于Header或者URL丢弃一定的流量(百分比)</span><br><span class="line"></span><br><span class="line">#####  随机丢弃请求流量</span><br><span class="line"></span><br><span class="line">input和output两端都支持限速,有两种限速算法:**百分比**或者**绝对值**</span><br><span class="line"></span><br><span class="line">* 百分比: input端支持缩小或者放大请求流量,基于指定的策略随机丢弃请求流量</span><br><span class="line">* 绝对值: 如果单位时间(秒)内达到临界值,则丢弃剩余请求流量,下一秒临界值还原</span><br><span class="line"></span><br><span class="line">**用法**:</span><br><span class="line"></span><br><span class="line">在output终端使用&quot;|&quot;运算符指定限速阈值,例如:</span><br><span class="line"></span><br><span class="line">* 使用绝对值限速</span><br></pre></td></tr></table></figure></p><h1 id="staging-server-will-not-get-more-than-ten-requests-per-second"><a href="#staging-server-will-not-get-more-than-ten-requests-per-second" class="headerlink" title="staging.server will not get more than ten requests per second"></a>staging.server will not get more than ten requests per second</h1><p>#staging服务每秒只接收10个请求<br>gor –input-tcp :28020 –output-http “<a href="http://staging.com|10&quot;" target="_blank" rel="noopener">http://staging.com|10&quot;</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 使用百分比限速</span><br></pre></td></tr></table></figure></p><h1 id="replay-server-will-not-get-more-than-10-of-requests"><a href="#replay-server-will-not-get-more-than-10-of-requests" class="headerlink" title="replay server will not get more than 10% of requests"></a>replay server will not get more than 10% of requests</h1><h1 id="useful-for-high-load-environments"><a href="#useful-for-high-load-environments" class="headerlink" title="useful for high-load environments"></a>useful for high-load environments</h1><p>gor –input-raw :80 –output-tcp “replay.local:28020|10%”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##### 基于Header或者URL参数限速</span><br><span class="line"></span><br><span class="line">如果header或者URL参数中有唯一值,例如(API key),则可以转发指定百分比的流量到后端,例如:</span><br></pre></td></tr></table></figure></p><h1 id="Limit-based-on-header-value"><a href="#Limit-based-on-header-value" class="headerlink" title="Limit based on header value"></a>Limit based on header value</h1><p>gor –input-raw :80 –output-tcp “replay.local:28020|10%” –http-header-limiter “X-API-KEY: 10%”</p><h1 id="Limit-based-on-URL-param-value"><a href="#Limit-based-on-URL-param-value" class="headerlink" title="Limit based on URL param value"></a>Limit based on URL param value</h1><p>gor –input-raw :80 –output-tcp “replay.local:28020|10%” –http-param-limiter “api_key: 10%”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">###  过滤</span><br><span class="line"></span><br><span class="line">如果只想捕获指定的URL路径请求,或者http头部,或者Http方法,则可以使用过滤功能</span><br><span class="line"></span><br><span class="line">下面是几个例子</span><br><span class="line"></span><br><span class="line">* 只捕获某个URL</span><br></pre></td></tr></table></figure></p><h1 id="only-forward-requests-being-sent-to-the-api-endpoint"><a href="#only-forward-requests-being-sent-to-the-api-endpoint" class="headerlink" title="only forward requests being sent to the /api endpoint"></a>only forward requests being sent to the /api endpoint</h1><p>gor –input-raw :8080 –output-http staging.com –http-allow-url /api<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 拒绝某个URL</span><br></pre></td></tr></table></figure></p><h1 id="only-forward-requests-NOT-being-sent-to-the-api…-endpoint"><a href="#only-forward-requests-NOT-being-sent-to-the-api…-endpoint" class="headerlink" title="only forward requests NOT being sent to the /api… endpoint"></a>only forward requests NOT being sent to the /api… endpoint</h1><p>gor –input-raw :8080 –output-http staging.com –http-disallow-url /api<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 基于正则表达式过滤头部</span><br></pre></td></tr></table></figure></p><h1 id="only-forward-requests-with-an-api-version-of-1-0x"><a href="#only-forward-requests-with-an-api-version-of-1-0x" class="headerlink" title="only forward requests with an api version of 1.0x"></a>only forward requests with an api version of 1.0x</h1><p>gor –input-raw :8080 –output-http staging.com –http-allow-header api-version:^1.0\d</p><h1 id="only-forward-requests-NOT-containing-User-Agent-header-value-“Replayed-by-Gor”"><a href="#only-forward-requests-NOT-containing-User-Agent-header-value-“Replayed-by-Gor”" class="headerlink" title="only forward requests NOT containing User-Agent header value “Replayed by Gor”"></a>only forward requests NOT containing User-Agent header value “Replayed by Gor”</h1><p>gor –input-raw :8080 –output-http staging.com –http-disallow-header “User-Agent: Replayed by Gor”<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">* 过滤HTTP请求方法</span><br></pre></td></tr></table></figure></p><p>gor –input-raw :80 –output-http “<a href="http://staging.server&quot;" target="_blank" rel="noopener">http://staging.server&quot;</a> \<br>    –http-allow-method GET \<br>    –http-allow-method OPTIONS<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;使用goreplay收集线上真实http流量&quot;&gt;&lt;a href=&quot;#使用goreplay收集线上真实http流量&quot; class=&quot;headerlink&quot; title=&quot;使用goreplay收集线上真实http流量&quot;&gt;&lt;/a&gt;使用goreplay收集线上真实http流量&lt;/h2&gt;&lt;h3 id=&quot;背景介绍&quot;&gt;&lt;a href=&quot;#背景介绍&quot; class=&quot;headerlink&quot; title=&quot;背景介绍&quot;&gt;&lt;/a&gt;背景介绍&lt;/h3&gt;&lt;p&gt;在很多场景中,我们需要将线上服务器的真实Http请求复制转发到某台服务器中(或者测试环境中),并且前提是不影响线上生产业务进行.&lt;/p&gt;
&lt;p&gt;例如:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;通常可能会通过ab等压测工具来对单一http接口进行压测。但如果是需要http服务整体压测，使用ab来压测工作量大且不方便，通过线上流量复制引流，通过将真实请求流量放大N倍来进行压测，能对服务有一个较为全面的检验.&lt;/li&gt;
&lt;li&gt;将线上流量引入到测试环境中,测试某个中间件或者数据库的压力&lt;/li&gt;
&lt;li&gt;上线前在预发布环境，使用线上真实的请求，检查是否准备发布的版本，是否具备发布标准&lt;/li&gt;
&lt;li&gt;用线上的流量转发到预发，检查相同流量下一些指标的反馈情况，检查核心数据是否有改善、优化.&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="Linux-Web" scheme="https://jesse.top/categories/Linux-Web/"/>
    
    
      <category term="goreplay" scheme="https://jesse.top/tags/goreplay/"/>
    
  </entry>
  
  <entry>
    <title>docker学习笔记---Docker存储驱动篇</title>
    <link href="https://jesse.top/2020/06/29/docker/docker%E7%AC%94%E8%AE%B0%E2%80%94%E5%AD%98%E5%82%A8%E9%A9%B1%E5%8A%A8%E7%AF%87/"/>
    <id>https://jesse.top/2020/06/29/docker/docker笔记—存储驱动篇/</id>
    <published>2020-06-29T03:59:58.000Z</published>
    <updated>2020-06-29T13:42:46.456Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker笔记——存储驱动篇"><a href="#docker笔记——存储驱动篇" class="headerlink" title="docker笔记——存储驱动篇"></a>docker笔记——存储驱动篇</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>通过前一篇的镜像笔记,我们知道docker的镜像是只读的,而且通过同一个镜像启动的docker容器,他们共享同一份底层镜像文件.</p><p>这里主要说一说.这些分层的多个只读Image镜像是如何在磁盘中存储的.</p><hr><h3 id="docker存储驱动"><a href="#docker存储驱动" class="headerlink" title="docker存储驱动"></a>docker存储驱动</h3><p>docker提供了多种存储驱动来实现不同的方式存储镜像，下面是常用的几种存储驱动：</p><ul><li>AUFS</li><li>OverlayFS</li><li>Devicemapper</li><li>Btrfs</li><li>ZFS</li></ul><p>下面说一说AUFS、OberlayFS及Devicemapper，更多的存储驱动说明可参考：<a href="http://dockone.io/article/1513" target="_blank" rel="noopener">http://dockone.io/article/1513</a></p><a id="more"></a><h4 id="AUFS"><a href="#AUFS" class="headerlink" title="AUFS"></a>AUFS</h4><p>AUFS（AnotherUnionFS）是一种Union FS，是文件级的存储驱动。AUFS是一个能透明覆盖一个或多个现有文件系统的层状文件系统，把多层合并成文件系统的单层表示。简单来说就是支持将不同目录挂载到同一个虚拟文件系统下的文件系统。这种文件系统可以一层一层地叠加修改文件。无论底下有多少层都是只读的，只有最上层的文件系统是可写的。当需要修改一个文件时，AUFS创建该文件的一个副本，使用CoW(写时复制)将文件从只读层复制到可写层进行修改，结果也保存在可写层。</p><p>通常来说最上层是可读写层,下层是只读层.当需要读取一个文件A时,会从最顶层的读写层开始向下寻找.本层没有则根据层关系到下一层开始找.直到找到第一个文件A</p><p>当需要写入一个文件A时,如果这个文件不存在,则在读写层新建一个.否则会像上面的步骤一样从顶层开始寻找,找到A文件后,复制到读写层进行修改</p><p>当需要删除一个文件A时,如果这个文件仅仅存在读写层,则直接删除.否则就需要先在读写层删除,然后再在读写层创建一个whiteout文件来标志这个文件不存在,而不是真正删除底层文件.</p><p>当新建一个文件A.如果这个文件在读写层存在对应的whiteout文件,则先将whiteout文件删除再新建.否则直接读写层新建</p><p>在Docker中，底下的只读层就是image，可写层就是Container。结构如下图所示：</p><p><img src="https://img1.jesse.top/docker-aufs.jpg" alt=""></p><p>如果你正在使用aufs作为存储驱动,那么在Docker的工作目录(/var/lib/docker)和image下发现aufs目录:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">root@docker:~# tree /var/lib/docker -d -L 1</span><br><span class="line">/var/lib/docker</span><br><span class="line">├── aufs</span><br><span class="line">├── containers</span><br><span class="line">├── image</span><br><span class="line">├── network</span><br><span class="line">├── plugins</span><br><span class="line">├── swarm</span><br><span class="line">├── tmp</span><br><span class="line">├── trust</span><br><span class="line">└── volumes</span><br><span class="line"></span><br><span class="line">root@docker:~# tree /var/lib/docker/image -d -L 1</span><br><span class="line">/var/lib/docker/image</span><br><span class="line">└── aufs</span><br><span class="line"></span><br><span class="line">root@docker:~# tree /var/lib/docker/aufs/ -d -L 1</span><br><span class="line">/var/lib/docker/aufs/</span><br><span class="line">├── diff</span><br><span class="line">├── layers</span><br><span class="line">└── mnt</span><br></pre></td></tr></table></figure><p>在docker工作目录的aufs目录下有3个目录.其中mnt为aufs的挂载目录,diff为实际数据,包括只读层和读写层.layers为每层依赖有关的层描述文件</p><hr><h3 id="Device-mapper"><a href="#Device-mapper" class="headerlink" title="Device mapper"></a>Device mapper</h3><p>Device mapper是Linux内核2.6.9后支持的，提供的一种从逻辑设备到物理设备的映射框架机制，在该机制下，用户可以很方便的根据自己的需要制定实现存储资源的管理策略。前面讲的AUFS和OverlayFS都是文件级存储，而Device mapper是块级存储，所有的操作都是直接对块进行操作，而不是文件。</p><p>Device mapper驱动会先在块设备上创建一个资源池，然后在资源池上创建一个带有文件系统的基本设备，所有镜像都是这个基本设备的快照，而容器则是镜像的快照。所以在容器里看到文件系统是资源池上基本设备的文件系统的快照，并不有为容器分配空间。当要写入一个新文件时，在容器的镜像内为其分配新的块并写入数据，这个叫用时分配。</p><p>当要修改已有文件时，再使用CoW为容器快照分配块空间，将要修改的数据复制到在容器快照中新的块里再进行修改。Device mapper 驱动默认会创建一个100G的文件包含镜像和容器。每一个容器被限制在10G大小的卷内，可以自己配置调整。结构如下图所示：</p><p><img src="https://img1.jesse.top/docker-devicemapper.jpg" alt=""></p><p>在Centos 7发行版上最新版的docker中,默认的存储驱动就是device mapper.但是提示已经被弃用了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$docker info</span><br><span class="line">Containers: 3</span><br><span class="line"> Running: 3</span><br><span class="line"> Paused: 0</span><br><span class="line"> Stopped: 0</span><br><span class="line">Images: 138</span><br><span class="line">Server Version: 18.09.2</span><br><span class="line">Storage Driver: devicemapper #这一行</span><br><span class="line">......略......</span><br><span class="line">WARNING: the devicemapper storage-driver is deprecated, and will be removed in a future release. #最后这一行提示devicemapper已经被弃用</span><br></pre></td></tr></table></figure><p>和aufs一样,在docker的工作目录下也能看到device mapper目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$ll /var/lib/docker/devicemapper/</span><br><span class="line">总用量 32</span><br><span class="line">drwx------ 2 root root    32 2月  23 16:25 devicemapper</span><br><span class="line">drwx------ 2 root root 24576 5月  16 10:30 metadata</span><br><span class="line">drwxr-xr-x 5 root root  4096 5月  16 10:30 mnt</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;docker笔记——存储驱动篇&quot;&gt;&lt;a href=&quot;#docker笔记——存储驱动篇&quot; class=&quot;headerlink&quot; title=&quot;docker笔记——存储驱动篇&quot;&gt;&lt;/a&gt;docker笔记——存储驱动篇&lt;/h2&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;通过前一篇的镜像笔记,我们知道docker的镜像是只读的,而且通过同一个镜像启动的docker容器,他们共享同一份底层镜像文件.&lt;/p&gt;
&lt;p&gt;这里主要说一说.这些分层的多个只读Image镜像是如何在磁盘中存储的.&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;docker存储驱动&quot;&gt;&lt;a href=&quot;#docker存储驱动&quot; class=&quot;headerlink&quot; title=&quot;docker存储驱动&quot;&gt;&lt;/a&gt;docker存储驱动&lt;/h3&gt;&lt;p&gt;docker提供了多种存储驱动来实现不同的方式存储镜像，下面是常用的几种存储驱动：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;AUFS&lt;/li&gt;
&lt;li&gt;OverlayFS&lt;/li&gt;
&lt;li&gt;Devicemapper&lt;/li&gt;
&lt;li&gt;Btrfs&lt;/li&gt;
&lt;li&gt;ZFS&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面说一说AUFS、OberlayFS及Devicemapper，更多的存储驱动说明可参考：&lt;a href=&quot;http://dockone.io/article/1513&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://dockone.io/article/1513&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="https://jesse.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://jesse.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker学习笔记---docker-compose</title>
    <link href="https://jesse.top/2020/06/29/docker/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94docker-compose/"/>
    <id>https://jesse.top/2020/06/29/docker/docker学习笔记—docker-compose/</id>
    <published>2020-06-29T03:59:58.000Z</published>
    <updated>2020-06-30T12:32:51.209Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker学习笔记——docker-compose"><a href="#docker学习笔记——docker-compose" class="headerlink" title="docker学习笔记——docker-compose"></a>docker学习笔记——docker-compose</h2><p>docker compose 定义并且运行多个docker容器.使用YAML风格文件定义一个compose文件.利用compose文件创建和启动所有服务.</p><p>使用docker compose基本只需要3个步骤</p><ul><li>在Dockerfile文件定义app环境</li><li>在docker-compose.yml文件中定义组成app的各个服务</li><li>run docker-compose up 和compose 启动和运行app</li></ul><p>下面文档均可以在docker-compose官方找到详细资料:<a href="https://docs.docker.com/compose/" target="_blank" rel="noopener">docker-compose</a></p><h3 id="docker-compose安装"><a href="#docker-compose安装" class="headerlink" title="docker-compose安装"></a>docker-compose安装</h3><a id="more"></a><p>docker-compose的安装非常简单.下面是Linux上的安装方法.其他平台请自行参考官网</p><p>1.下载最近的1.24版本的二进制文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo curl -L &quot;https://github.com/docker/compose/releases/download/1.24.0/docker-compose-$(uname -s)-$(uname -m)&quot; -o /usr/local/bin/docker-compose</span><br></pre></td></tr></table></figure><p>2.给予执行权限.加入环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo chmod +x /usr/local/bin/docker-compose</span><br><span class="line">sudo ln -s /usr/local/bin/docker-compose /usr/bin/docker-compose</span><br></pre></td></tr></table></figure><p>3.安装完成.查看是否安装成功</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose --version</span><br><span class="line">docker-compose version 1.24.0, build 1110ad01</span><br></pre></td></tr></table></figure><hr><h2 id="compose例子"><a href="#compose例子" class="headerlink" title="compose例子"></a>compose例子</h2><p>在官网上,或者去github上下载一个例子.这里我参考<docker 深入浅出="">这本书的例子</docker></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/counter-app</span><br><span class="line">cd /data/counter-app</span><br><span class="line">git clone https://github.com/nigelpoulton/counter-app.git</span><br></pre></td></tr></table></figure><h3 id="docker-compose文件"><a href="#docker-compose文件" class="headerlink" title="docker-compose文件"></a>docker-compose文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost counter-app]$cat docker-compose.yml</span><br><span class="line"></span><br><span class="line">version: &quot; 3.5&quot;</span><br><span class="line">services:</span><br><span class="line">   web-fe:</span><br><span class="line">      build:</span><br><span class="line">         command: python app.py</span><br><span class="line">         ports:</span><br><span class="line">            - target: 5000</span><br><span class="line">              published: 5000</span><br><span class="line">         </span><br><span class="line">         networks:</span><br><span class="line">            - counter-net</span><br><span class="line">         </span><br><span class="line">         volumes:</span><br><span class="line">            - type: volume</span><br><span class="line">              source: counter-vol</span><br><span class="line">              target: /code</span><br><span class="line">    </span><br><span class="line">   redis:</span><br><span class="line">      image: &quot;redis:alpine&quot;</span><br><span class="line">      networks:</span><br><span class="line">         counter-net</span><br><span class="line">   </span><br><span class="line">networks:</span><br><span class="line">        counter-net:</span><br><span class="line">   </span><br><span class="line">volumes:</span><br><span class="line">       counter-vol:</span><br></pre></td></tr></table></figure><p><strong>compose文件结构</strong></p><p>包含4个一级key: version.services.network.volumes</p><ul><li>version: 必须指定,定义了compose文件格式版本.这里是3.5最新版</li><li>services: 用于定义不同的应用服务.这个例子中定义了2个服务.一个是web-fe的web前端.一个是redis的内存数据库.docker compose会将每个服务部署在各自的容器中</li><li>networks用于创建新的网络.默认情况下会创建bridge网络</li><li>volume用于创建新的卷</li></ul><p>上面的docker compose文件定义了2个服务.在web-fe的服务定义中.包含如下指令:</p><ul><li>build:  指定docker基于当前目录下的Dockerfile文件构建一个新镜像</li><li>command: 指定在容器中执行app.py脚本作为主程序 (这个指令可以忽略,因为dockerfile镜像中已经配置了CMD指令)</li><li>ports: 将容器(target)的5000端口映射到宿主机(published)5000端口</li><li>networks: docker将此容器连接到指定的网络上</li><li>volumes: 指定docker将宿主机counter-vol卷(source)挂载到容器内的/code(target)上.counter-vol卷是已经存在的,或者是在文件下方的volumes一级key中定义的</li></ul><p>redis服务比较简单,就不再赘述..</p><hr><h2 id="部署docker-compose"><a href="#部署docker-compose" class="headerlink" title="部署docker-compose"></a>部署docker-compose</h2><p>简要介绍counter-app目录内的几个文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost counter-app]$ll</span><br><span class="line">总用量 20</span><br><span class="line">-rw-r--r-- 1 root root 599 6月  18 17:34 app.py    #应用程序代码</span><br><span class="line">-rw-r--r-- 1 root root 475 6月  17 18:46 docker-compose.ymal  #compose文件,定义了如何部署容器</span><br><span class="line">-rw-r--r-- 1 root root 109 6月  18 17:34 Dockerfile  #构建web-fe服务镜像的dockerfile</span><br><span class="line">-rw-r--r-- 1 root root 128 6月  18 17:34 README.md   </span><br><span class="line">-rw-r--r-- 1 root root  11 6月  18 17:34 requirements.txt #列出app.py代码文件中python的依赖包</span><br></pre></td></tr></table></figure><h4 id="启动docker-compose"><a href="#启动docker-compose" class="headerlink" title="启动docker-compose"></a>启动docker-compose</h4><p>在当前目录下执行下列路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d #后台启动</span><br></pre></td></tr></table></figure><p>默认情况下<code>docker-compose</code>命令会寻找当前目录下名为docker-compose.yml或者docker-compose.yaml的Compose文件.如果Compose文件是其他文件名.则需要-f参数来指定具体文件名:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f compose_file up -d</span><br></pre></td></tr></table></figure><p>如果找不到文件则会报错:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ERROR:</span><br><span class="line">        Can&apos;t find a suitable configuration file in this directory or any</span><br><span class="line">        parent. Are you in the right directory?</span><br><span class="line"></span><br><span class="line">        Supported filenames: docker-compose.yml, docker-compose.yaml</span><br></pre></td></tr></table></figure><p>部署过程中创建或者拉取了3个镜像: counterapp_web-fe,python,redis</p><p>部署完成后,启动了如下2个容器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost counter-app]$docker ps</span><br><span class="line">CONTAINER ID        IMAGE                             COMMAND                  CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">474301996ccc        redis:alpine                      &quot;docker-entrypoint.s…&quot;   21 hours ago        Up 21 hours         6379/tcp                 counter-app_redis_1</span><br><span class="line">c7a1e28b5e28        counter-app_web-fe                &quot;python app.py&quot;          21 hours ago        Up 21 hours         0.0.0.0:5000-&gt;5000/tcp   counter-app_web-fe_1</span><br></pre></td></tr></table></figure><p>每个容器都以项目名为前缀(所在目录名称).此外,还用一个数字为后缀用于表示容器序列(因为docker-compose允许扩容和缩减服务器数量)</p><p>同时,docker-compose还创建了counter-app_counter-net网络:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost counter-app]$docker network ls</span><br><span class="line">NETWORK ID          NAME                      DRIVER              SCOPE</span><br><span class="line">6d40a81d76e7        bridge                    bridge              local</span><br><span class="line">ef71284e9acc        counter-app_counter-net   bridge              local</span><br></pre></td></tr></table></figure><p>应用部署成功后,可以查看容器的运行效果.每次访问,计数器就+1</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost counter-app]$curl http://localhost:5000</span><br><span class="line">What&apos;s up Docker Deep Divers! You&apos;ve visited me 1 times.</span><br><span class="line">[root@localhost counter-app]$curl http://localhost:5000</span><br><span class="line">What&apos;s up Docker Deep Divers! You&apos;ve visited me 2 times.</span><br><span class="line">[root@localhost counter-app]$curl http://localhost:5000</span><br><span class="line">What&apos;s up Docker Deep Divers! You&apos;ve visited me 3 times.</span><br></pre></td></tr></table></figure><hr><h2 id="docker-Compose管理"><a href="#docker-Compose管理" class="headerlink" title="docker Compose管理"></a>docker Compose管理</h2><p>上面讲到如何部署一个compose应用..接下来讲解一下compose的管理命令.需要注意的是所有的docker-compose命令都需要在相关目录下执行.不然仍然会提示找不到docker-compose.yml(yaml)文件</p><p>如果是停止应用.只需将up换成down即可.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost counter-app]$docker-compose down</span><br><span class="line">Stopping counter-app_redis_1  ... done</span><br><span class="line">Stopping counter-app_web-fe_1 ... done</span><br><span class="line">Removing counter-app_redis_1  ... done</span><br><span class="line">Removing counter-app_web-fe_1 ... done</span><br><span class="line">Removing network counter-app_counter-net</span><br></pre></td></tr></table></figure><p>停止compose经历了如下的过程:</p><ul><li>停止所有容器</li><li>移除容器</li><li>移除docker网络</li></ul><p>此时,无论是执行<code>docker ps</code>还是<code>docker ps -a</code>都看不到容器</p><h4 id="查看compose各个服务容器的运行的进程"><a href="#查看compose各个服务容器的运行的进程" class="headerlink" title="查看compose各个服务容器的运行的进程"></a>查看compose各个服务容器的运行的进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost counter-app]$docker-compose top</span><br><span class="line">counter-app_redis_1</span><br><span class="line">UID    PID    PPID    C   STIME   TTY     TIME         CMD</span><br><span class="line">---------------------------------------------------------------</span><br><span class="line">100   32558   32542   0   13:21   ?     00:00:00   redis-server</span><br><span class="line"></span><br><span class="line">counter-app_web-fe_1</span><br><span class="line">UID     PID    PPID    C   STIME   TTY     TIME                    CMD</span><br><span class="line">--------------------------------------------------------------------------------------</span><br><span class="line">root   32582   32564   6   13:21   ?     00:00:00   python app.py</span><br><span class="line">root   32703   32582   4   13:21   ?     00:00:00   /usr/local/bin/python /code/app.py</span><br><span class="line">[root@localhost counter-app]$</span><br></pre></td></tr></table></figure><blockquote><p>PID是docker宿主机的进程ID</p></blockquote><h4 id="停止应用容器-但是并不删除资源"><a href="#停止应用容器-但是并不删除资源" class="headerlink" title="停止应用容器.但是并不删除资源"></a>停止应用容器.但是并不删除资源</h4><p>执行完<code>docker-compose stop</code>命令后,容器还存在</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost counter-app]$docker-compose stop</span><br><span class="line">Stopping counter-app_web-fe_1 ... done</span><br><span class="line">Stopping counter-app_redis_1  ... done</span><br><span class="line"></span><br><span class="line">[root@localhost counter-app]$docker-compose ps</span><br><span class="line">        Name                      Command               State    Ports</span><br><span class="line">----------------------------------------------------------------------</span><br><span class="line">counter-app_redis_1    docker-entrypoint.sh redis ...   Exit 0</span><br><span class="line">counter-app_web-fe_1   python app.py                    Exit 0</span><br><span class="line">[root@localhost counter-app]$</span><br></pre></td></tr></table></figure><h4 id="删除-重启已停止的compose应用容器"><a href="#删除-重启已停止的compose应用容器" class="headerlink" title="删除,重启已停止的compose应用容器"></a>删除,重启已停止的compose应用容器</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker-compose rm #删除.删除应用相关的容器,但是不会删除卷和镜像和网络.</span><br><span class="line">docker-compose restart #重启</span><br></pre></td></tr></table></figure><p>#### </p><h4 id="拉取服务镜像"><a href="#拉取服务镜像" class="headerlink" title="拉取服务镜像"></a>拉取服务镜像</h4><p><code>docker-compose pull server_name</code>这个命令会先拉取服务镜像到本地.例如在本文的docker compose例子中有2个服务:web-fe和redis.如果执行下列命令,会仅仅拉取redis镜像到本地</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose pull redis</span><br></pre></td></tr></table></figure><h4 id="其他命令"><a href="#其他命令" class="headerlink" title="其他命令"></a>其他命令</h4><p>日常docker管理容器的命令都可以使用<code>docker-compose</code>替代.例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker-compose logs service_name #查看服务容器日志</span><br><span class="line">docker-compose exec service_name #开启终端登陆容器</span><br><span class="line">docker-compose kill -s SIGINT    #杀死docker-compose服务容器</span><br><span class="line">docker-compose ps                #列出容器</span><br></pre></td></tr></table></figure><hr><h3 id="docker-compose配置文件指令解析"><a href="#docker-compose配置文件指令解析" class="headerlink" title="docker-compose配置文件指令解析"></a>docker-compose配置文件指令解析</h3><p>以下配置文件以版本3.x为例.官网参考:<a href="https://docs.docker.com/compose/compose-file/" target="_blank" rel="noopener">https://docs.docker.com/compose/compose-file/</a></p><p>下面是个包含完整指令的样例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6379&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - frontend</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 2</span><br><span class="line">      update_config:</span><br><span class="line">        parallelism: 2</span><br><span class="line">        delay: 10s</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres:9.4</span><br><span class="line">    volumes:</span><br><span class="line">      - db-data:/var/lib/postgresql/data</span><br><span class="line">    networks:</span><br><span class="line">      - backend</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line"></span><br><span class="line">  vote:</span><br><span class="line">    image: dockersamples/examplevotingapp_vote:before</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;5000:80&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - frontend</span><br><span class="line">    depends_on:</span><br><span class="line">      - redis</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 2</span><br><span class="line">      update_config:</span><br><span class="line">        parallelism: 2</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line"></span><br><span class="line">  result:</span><br><span class="line">    image: dockersamples/examplevotingapp_result:before</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;5001:80&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - backend</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 1</span><br><span class="line">      update_config:</span><br><span class="line">        parallelism: 2</span><br><span class="line">        delay: 10s</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line"></span><br><span class="line">  worker:</span><br><span class="line">    image: dockersamples/examplevotingapp_worker</span><br><span class="line">    networks:</span><br><span class="line">      - frontend</span><br><span class="line">      - backend</span><br><span class="line">    deploy:</span><br><span class="line">      mode: replicated</span><br><span class="line">      replicas: 1</span><br><span class="line">      labels: [APP=VOTING]</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">        delay: 10s</span><br><span class="line">        max_attempts: 3</span><br><span class="line">        window: 120s</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line"></span><br><span class="line">  visualizer:</span><br><span class="line">    image: dockersamples/visualizer:stable</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    stop_grace_period: 1m30s</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  frontend:</span><br><span class="line">  backend:</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  db-data:</span><br></pre></td></tr></table></figure><h2 id="Service块级别的配置文件指令"><a href="#Service块级别的配置文件指令" class="headerlink" title="Service块级别的配置文件指令"></a>Service块级别的配置文件指令</h2><h4 id="build"><a href="#build" class="headerlink" title="build"></a>build</h4><p>build可以指定一个目录或者在build下还可以指定context上下文环境和docker-file文件名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  webapp:</span><br><span class="line">    build: ./dir</span><br><span class="line">    </span><br><span class="line">或者</span><br><span class="line">webapp:</span><br><span class="line">    build:</span><br><span class="line">      context: ./dir</span><br><span class="line">      dockerfile: Dockerfile-alternate #如果指定dockerfile,则必须要指定一个build路径,也就是context</span><br><span class="line">      args:</span><br><span class="line">        buildno: 1</span><br></pre></td></tr></table></figure><p>如果同时指定了Image关键字,那么会构建一个指定的镜像名:tag</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">build: ./dir</span><br><span class="line">image: webapp:tag  #构建webapp:tag的镜像名</span><br></pre></td></tr></table></figure><blockquote><p>build选项在swarm中部署stack时是无效的,因为docker stack命令只接受已经build好的镜像</p></blockquote><h4 id="CONTEXT"><a href="#CONTEXT" class="headerlink" title="CONTEXT"></a>CONTEXT</h4><p>定义上下文目录.如果是一个相对目录,那么是相对Compose file文件的目录.</p><h4 id="ARGS"><a href="#ARGS" class="headerlink" title="ARGS"></a>ARGS</h4><p>在build过程中可以允许使用ARGS变量传递给dockerfile.具体用法参考官网</p><h4 id="COMMAND"><a href="#COMMAND" class="headerlink" title="COMMAND"></a>COMMAND</h4><p>重写dockerfile或者镜像中的默认命令.和dockerfile一样可以是shell方式也可以是exec方式执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">command: bundle exec thin -p 3000</span><br><span class="line">command: [&quot;bundle&quot;, &quot;exec&quot;, &quot;thin&quot;, &quot;-p&quot;, &quot;3000&quot;]</span><br></pre></td></tr></table></figure><h4 id="configs"><a href="#configs" class="headerlink" title="configs"></a>configs</h4><p>授予每个service的配置文件访问.具体用法参考官网</p><h4 id="container-name"><a href="#container-name" class="headerlink" title="container_name"></a>container_name</h4><p>指定一个容器名,而不是使用默认名字</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">container_name: my-web-container</span><br></pre></td></tr></table></figure><blockquote><p>需要注意的是由于容器名必须唯一,所以当扩展多个容器副本时,指定一个具体的容器名会报错,所以这个指令在swarm模式下部署stack时会被忽略</p></blockquote><h4 id="depends-on"><a href="#depends-on" class="headerlink" title="depends_on"></a>depends_on</h4><p>用于在多个services之间指定依赖性.service dependencies会导致以下行为</p><ul><li><code>docker-compose up</code> 启动时会参考depndency顺序.在下面这个例子中.db和redis服务会先于web服务启动</li><li><code>docker-compose up SERVICE</code>会自动启动该SERVICE的依赖服务.在下面例子中<code>docker-compose up web</code>命令会自动创建和启动db和redis</li><li><code>docker-compose stop</code>会参考依赖顺序而停止服务.在下面例子中,web服务会先于db和redis服务停止</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    depends_on:</span><br><span class="line">      - db</span><br><span class="line">      - redis</span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br></pre></td></tr></table></figure><blockquote><p>使用depens_on需要注意以下几点:</p><p>1.denpds_on只会在web依赖的服务启动后就启动web服务,而不是等待db和redis服务启动并且处于ready状态才启动web.这有可能会带来一些问题,比如mysql启动较慢,数据库还没准备好等.如果你需要确定后端的db,redis数据库启动成功,并且可以连接时才启动web服务,可以参考<a href="https://docs.docker.com/compose/startup-order/" target="_blank" rel="noopener">https://docs.docker.com/compose/startup-order/</a></p><p>2.version3版本不再支持depends_on下的condition指令</p><p>3.version3版本的depends_on选项在swarm模式下部署stack时会被忽略</p></blockquote><p>depends_on选项的控制启动顺序参考:</p><p>编写一个shell脚本循环判断后端的数据库是否ready.如果ready则执行CMD命令.然后在command指令中指定脚本的后端db数据库服务名,以及CMD命令参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"># wait-for-postgres.sh</span><br><span class="line">#循环测试db服务($1参数)的状态.一旦可以连接了,执行cmd命令(python app.py)</span><br><span class="line">set -e</span><br><span class="line"></span><br><span class="line">host=&quot;$1&quot;</span><br><span class="line">shift</span><br><span class="line">cmd=&quot;$@&quot;</span><br><span class="line"></span><br><span class="line">until PGPASSWORD=$POSTGRES_PASSWORD psql -h &quot;$host&quot; -U &quot;postgres&quot; -c &apos;\q&apos;; do</span><br><span class="line">  &gt;&amp;2 echo &quot;Postgres is unavailable - sleeping&quot;</span><br><span class="line">  sleep 1</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">&gt;&amp;2 echo &quot;Postgres is up - executing command&quot;</span><br><span class="line">exec $cmd</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command: [&quot;./wait-for-postgres.sh&quot;, &quot;db&quot;, &quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure><h4 id="deploy指令"><a href="#deploy指令" class="headerlink" title="deploy指令"></a>deploy指令</h4><p>该指令用于配置服务相关的配置和部署方式.这个指令只在version3版本支持,而且只在swarm模式下才生效.单机<code>docker-compose up</code>方式执行会被忽略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 6</span><br><span class="line">      update_config:</span><br><span class="line">        parallelism: 2</span><br><span class="line">        delay: 10s</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br></pre></td></tr></table></figure><p>下面是有关deploy的几个子指令介绍</p><ul><li>ENDPOINT_MODE</li></ul><blockquote><p>version 3.3 only</p></blockquote><p><code>endpoint_mode: VIP</code>  Docker为service分配一个虚拟IP.作为用户的前端入口.docker路由用户请求到所有可用的worker节点..这也是默认模式</p><p><code>endpoint_mode: dnsrr</code> DNS轮询服务,Docker发起一个service name的DNS查询,并且返回一个包含多个IP地址的列表.客户端通过轮询方式链接其中一个IP地址.</p><ul><li>LABLES</li></ul><p>为service指定一个标签.只对service生效,无法为service的具体某个容器生效</p><ul><li>MODE</li></ul><p>mode定义了在swarm节点上的副本部署模式,有global和replicated两种模式,默认是replicated</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  worker:</span><br><span class="line">    image: dockersamples/examplevotingapp_worker</span><br><span class="line">    deploy:</span><br><span class="line">      mode: global</span><br></pre></td></tr></table></figure><p>关于两种模式的区别参考:<a href="https://docs.docker.com/engine/swarm/how-swarm-mode-works/services/#replicated-and-global-services" target="_blank" rel="noopener">https://docs.docker.com/engine/swarm/how-swarm-mode-works/services/#replicated-and-global-services</a></p><ul><li>REPLACEMENT</li></ul><p>定义了constrants(约束条件)和preferences.的参数.</p><p>下面是constrants指令的用法:</p><p>constrants指令可以限制某个task在哪些swarm节点上运行.多个constrants指令是逻辑AND的关系来匹配满足条件的nodes.constrants可以匹配swarm节点或者Docker引擎标签:</p><table><thead><tr><th style="text-align:left">node attribute</th><th style="text-align:left">matches</th><th style="text-align:left">example</th></tr></thead><tbody><tr><td style="text-align:left"><code>node.id</code></td><td style="text-align:left">Node ID</td><td style="text-align:left"><code>node.id==2ivku8v2gvtg4</code></td></tr><tr><td style="text-align:left"><code>node.hostname</code></td><td style="text-align:left">Node hostname</td><td style="text-align:left"><code>node.hostname!=node-2</code></td></tr><tr><td style="text-align:left"><code>node.role</code></td><td style="text-align:left">Node role</td><td style="text-align:left"><code>node.role==manager</code></td></tr><tr><td style="text-align:left"><code>node.labels</code></td><td style="text-align:left">user defined node labels</td><td style="text-align:left"><code>node.labels.security==high</code></td></tr><tr><td style="text-align:left"><code>engine.labels</code></td><td style="text-align:left">Docker Engine’s labels</td><td style="text-align:left"><code>engine.labels.operatingsystem==ubuntu 14.04</code></td></tr></tbody></table><p>例如下面这个例子中限制redis service的task运行在lable标签等于queue的swarm节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ docker service create \</span><br><span class="line">  --name redis_2 \</span><br><span class="line">  --constraint &apos;node.labels.type == queue&apos; \</span><br><span class="line">  redis:3.0.6</span><br></pre></td></tr></table></figure><p>回到刚才REPLACEMENT的例子,下面的例子中表示db service只运行在swarm manager节点,而且docker node节点的操作系统是Ubuntu 14.04</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints:</span><br><span class="line">          - node.role == manager</span><br><span class="line">          - engine.labels.operatingsystem == ubuntu 14.04</span><br><span class="line">        preferences:</span><br><span class="line">          - spread: node.labels.zone</span><br></pre></td></tr></table></figure><ul><li>REPLICAS</li></ul><p>如果service 是replicated模式(默认模式),定义容器的启动数量.在下面的例子中启动6个worker容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  worker:</span><br><span class="line">    image: dockersamples/examplevotingapp_worker</span><br><span class="line">    networks:</span><br><span class="line">      - frontend</span><br><span class="line">      - backend</span><br><span class="line">    deploy:</span><br><span class="line">      mode: replicated</span><br><span class="line">      replicas: 6</span><br></pre></td></tr></table></figure><ul><li>RESOURCES</li></ul><p>配置容器限定的使用资源</p><p>在下面这个例子中.redis service被限制只允许使用不超过50M内存,以及0.5的CPU处理器时间(单个CPU内核的50%).并且有20M内存和0.25的CPU处理器时间预留(也就是永远为redis service保留)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    deploy:</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &apos;0.50&apos;</span><br><span class="line">          memory: 50M</span><br><span class="line">        reservations:</span><br><span class="line">          cpus: &apos;0.25&apos;</span><br><span class="line">          memory: 20M</span><br></pre></td></tr></table></figure><p><strong>Out Of Memory Exceptions[OOME]</strong></p><p>如果service 或者容器使用了超过限制的资源.容器或者docker引擎就会出现OOME错误.docker进程可能会被内核OOM killer给kill掉.关于如何规避这种问题,请参考<a href="https://docs.docker.com/config/containers/resource_constraints/" target="_blank" rel="noopener">understand the risks of running out of memory</a></p><ul><li>RESTART_POLICY</li></ul><p>配置当容器停止时如何重新启动容器的策略.有以下几种子指令</p><p>1.<code>condition</code> 重启容器的约束条件.有: <code>none</code>,<code>on-failure</code>,和<code>any</code>(default:any)</p><p>2.<code>delay</code>: 尝试重启容器的时间间隔.默认是0</p><p>3.<code>max_attempts</code>:如果容器重启失败,重启最大尝试次数,默认是一直尝试</p><p>4.<code>window</code>:重启后等待多久认定重启成功.默认是immediately</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  redis:</span><br><span class="line">    image: redis:alpine</span><br><span class="line">    deploy:</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">        delay: 5s</span><br><span class="line">        max_attempts: 3</span><br><span class="line">        window: 120s</span><br></pre></td></tr></table></figure><h4 id="ROLLBACK-CONFIG"><a href="#ROLLBACK-CONFIG" class="headerlink" title="ROLLBACK_CONFIG"></a>ROLLBACK_CONFIG</h4><p>更新失败的回滚指令.</p><h4 id="UPDATE-CONFIG"><a href="#UPDATE-CONFIG" class="headerlink" title="UPDATE_CONFIG"></a>UPDATE_CONFIG</h4><p>配置service如何进行滚动更新.</p><h4 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h4><p>自定义DNS地址,可以是单个值或者一个列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dns: 8.8.8.8</span><br><span class="line"></span><br><span class="line">dns:</span><br><span class="line">  - 8.8.8.8</span><br><span class="line">  - 9.9.9.9</span><br></pre></td></tr></table></figure><h4 id="entrypoint"><a href="#entrypoint" class="headerlink" title="entrypoint"></a>entrypoint</h4><p>重写dockerfile或者镜像中的entrypoint指令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">entrypoint: /code/entrypoint.sh</span><br><span class="line"></span><br><span class="line">#也可以是一个列表格式:</span><br><span class="line"></span><br><span class="line">entrypoint:</span><br><span class="line">    - php</span><br><span class="line">    - -d</span><br><span class="line">    - zend_extension=/usr/local/lib/php/extensions/no-debug-non-zts-20100525/xdebug.so</span><br><span class="line">    - -d</span><br><span class="line">    - memory_limit=-1</span><br><span class="line">    - vendor/bin/phpunit</span><br></pre></td></tr></table></figure><h4 id="env-file"><a href="#env-file" class="headerlink" title="env_file"></a>env_file</h4><p>添加环境变量文件,可以是单个值,也可以是个列表.该文件最好是在当前docker-compose文件目录或者子目录下.</p><p>如果是指定多个变量文件,而且有重复的变量且赋值不同,那么以最后一个变量文件的变量为准</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">  some-service:</span><br><span class="line">    env_file:</span><br><span class="line">      - a.env</span><br><span class="line">      - b.env</span><br></pre></td></tr></table></figure><h4 id="environment"><a href="#environment" class="headerlink" title="environment"></a>environment</h4><p>添加环境变量.可以使用列表格式,或者字典格式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">environment:</span><br><span class="line">  RACK_ENV: development</span><br><span class="line">  SHOW: &apos;true&apos;</span><br><span class="line">  SESSION_SECRET:</span><br><span class="line"></span><br><span class="line">environment:</span><br><span class="line">  - RACK_ENV=development</span><br><span class="line">  - SHOW=true</span><br><span class="line">  - SESSION_SECRET</span><br></pre></td></tr></table></figure><h4 id="extra-hosts"><a href="#extra-hosts" class="headerlink" title="extra_hosts"></a>extra_hosts</h4><p>添加hostname和IP地址的绑定映射到hosts文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">extra_hosts:</span><br><span class="line"> - &quot;somehost:162.242.195.82&quot;</span><br><span class="line"> - &quot;otherhost:50.31.209.229&quot;</span><br><span class="line"> </span><br><span class="line"> #会在容器内的/etc/hosts文件生成如何内容</span><br><span class="line">162.242.195.82  somehost</span><br><span class="line">50.31.209.229   otherhost</span><br></pre></td></tr></table></figure><h4 id="healthcheck"><a href="#healthcheck" class="headerlink" title="healthcheck"></a>healthcheck</h4><p>检查service的各个容器是否处于”healthy”状态.例如下面的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">healthcheck:</span><br><span class="line">  test: [&quot;CMD&quot;, &quot;curl&quot;, &quot;-f&quot;, &quot;http://localhost&quot;]</span><br><span class="line">  interval: 1m30s</span><br><span class="line">  timeout: 10s</span><br><span class="line">  retries: 3</span><br><span class="line">  start_period: 40s</span><br></pre></td></tr></table></figure><p><code>test</code>指令必须为一个字符串或者一个列表.如果是个上例子中的列表格式.则第一个参数必须为<code>NONE</code>,<code>CMD</code>,或者<code>CMD-SHELL</code>.如果是字符串相当于指定了<code>CMD-SHELL</code>参数</p><p>下面2个写法和上文的例子效果一样</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test: [&quot;CMD-SHELL&quot;, &quot;curl -f http://localhost || exit 1&quot;]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test: curl -f https://localhost || exit 1</span><br></pre></td></tr></table></figure><p>要关闭健康检查,可以使用<code>disable:true</code>.等同于<code>test:[&quot;NONE&quot;]</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">healthcheck:</span><br><span class="line">  disable: true</span><br></pre></td></tr></table></figure><h4 id="image"><a href="#image" class="headerlink" title="image"></a>image</h4><p>指定容器的启动镜像.可以是指定的repository/tag 或者一个镜像ID.如果本地不存在该镜像,会尝试去pull镜像到本地.如果指定了<code>build</code>指定,会使用指定的命令来构建一个镜像</p><p>下面这几种写法均正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">image: redis</span><br><span class="line">image: ubuntu:14.04</span><br><span class="line">image: tutum/influxdb</span><br><span class="line">image: example-registry.com:4000/postgresql</span><br><span class="line">image: a4bc65fd</span><br></pre></td></tr></table></figure><h4 id="logging"><a href="#logging" class="headerlink" title="logging"></a>logging</h4><p>service的log配置.下面的例子中指定了一个syslog服务器的地址</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">logging:</span><br><span class="line">  driver: syslog</span><br><span class="line">  options:</span><br><span class="line">    syslog-address: &quot;tcp://192.168.0.42:123&quot;</span><br></pre></td></tr></table></figure><p><code>driver</code>为容器指定logging的驱动,一共以下3种驱动方式,默认是json-file</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">driver: &quot;json-file&quot;</span><br><span class="line">driver: &quot;syslog&quot;</span><br><span class="line">driver: &quot;none&quot;</span><br></pre></td></tr></table></figure><p>也可以限定json-file驱动的日志转出.例如下列指定了最大的日志文件大小和日志保留份数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">options:</span><br><span class="line">  max-size: &quot;200k&quot;</span><br><span class="line">  max-file: &quot;10&quot;</span><br></pre></td></tr></table></figure><h4 id="network-mode"><a href="#network-mode" class="headerlink" title="network_mode"></a>network_mode</h4><p>指定网络模式,有以下几种网络模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">network_mode: &quot;bridge&quot;</span><br><span class="line">network_mode: &quot;host&quot;</span><br><span class="line">network_mode: &quot;none&quot;</span><br><span class="line">network_mode: &quot;service:[service name]&quot;</span><br><span class="line">network_mode: &quot;container:[container name/id]&quot;</span><br></pre></td></tr></table></figure><h4 id="networks"><a href="#networks" class="headerlink" title="networks"></a>networks</h4><p>services加入的网络.这些网络名在顶级<code>network</code>指令中有指定</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">services:</span><br><span class="line">  some-service:</span><br><span class="line">    networks:</span><br><span class="line">     - some-network</span><br><span class="line">     - other-network</span><br></pre></td></tr></table></figure><h4 id="IPV4-ADDRESS-IPV6-ADDRESS"><a href="#IPV4-ADDRESS-IPV6-ADDRESS" class="headerlink" title="IPV4_ADDRESS,IPV6_ADDRESS"></a>IPV4_ADDRESS,IPV6_ADDRESS</h4><p>为容器指定一个静态的IP地址.但是对应的Network顶级指令中必须指定一个ipam块,定义该网络的IP子网范围.例如</p><p>app_net网络的ipam快中指定了172.16.238.0/24的子网.然后为app service指定一个静态IP</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  app:</span><br><span class="line">    image: nginx:alpine</span><br><span class="line">    networks:</span><br><span class="line">      app_net:</span><br><span class="line">        ipv4_address: 172.16.238.10</span><br><span class="line">        ipv6_address: 2001:3984:3989::10</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  app_net:</span><br><span class="line">    ipam:</span><br><span class="line">      driver: default</span><br><span class="line">      config:</span><br><span class="line">        - subnet: &quot;172.16.238.0/24&quot;</span><br><span class="line">        - subnet: &quot;2001:3984:3989::/64&quot;</span><br></pre></td></tr></table></figure><h4 id="ports"><a href="#ports" class="headerlink" title="ports"></a>ports</h4><p>暴露端口.下面是几种短格式写法.推荐将端口用双引号括起来</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ports:</span><br><span class="line"> - &quot;3000&quot;</span><br><span class="line"> - &quot;3000-3005&quot;</span><br><span class="line"> - &quot;8000:8000&quot;</span><br><span class="line"> - &quot;9090-9091:8080-8081&quot;</span><br><span class="line"> - &quot;49100:22&quot;</span><br><span class="line"> - &quot;127.0.0.1:8001:8001&quot;</span><br><span class="line"> - &quot;127.0.0.1:5000-5010:5000-5010&quot;</span><br><span class="line"> - &quot;6060:6060/udp&quot;</span><br></pre></td></tr></table></figure><blockquote><p>此外还有完整格式的写法.</p></blockquote><h4 id="restart"><a href="#restart" class="headerlink" title="restart"></a>restart</h4><p>默认的restart策略是<code>no</code>有以下四种重启策略</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">restart: &quot;no&quot;</span><br><span class="line">restart: always</span><br><span class="line">restart: on-failure</span><br><span class="line">restart: unless-stopped</span><br></pre></td></tr></table></figure><h3 id="sysctls"><a href="#sysctls" class="headerlink" title="sysctls"></a>sysctls</h3><p>配置容器的内核参数.可以是数组或者字典类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sysctls:</span><br><span class="line">  net.core.somaxconn: 1024</span><br><span class="line">  net.ipv4.tcp_syncookies: 0</span><br><span class="line">  </span><br><span class="line">sysctls:</span><br><span class="line">  - net.core.somaxconn=1024</span><br><span class="line">  - net.ipv4.tcp_syncookies=0</span><br></pre></td></tr></table></figure><h3 id="ulimits"><a href="#ulimits" class="headerlink" title="ulimits"></a>ulimits</h3><p>配置ulimits</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ulimits:</span><br><span class="line">  nproc: 65535</span><br><span class="line">  nofile:</span><br><span class="line">    soft: 20000</span><br><span class="line">    hard: 40000</span><br></pre></td></tr></table></figure><h3 id="volumes"><a href="#volumes" class="headerlink" title="volumes"></a>volumes</h3><p>挂载一个路径或者一个卷.</p><p>如果是在service层级挂载宿主机上的路径到容器,那么不需要在顶级指令中定义<code>volumes</code>key.但是如果是挂载一个卷到多个service,可以在顶级指令中定义个卷名.然后使用这个卷名去挂载</p><p>下面这个例子在顶级<code>volumes</code>指令中定义了2个卷名:mydata和dbdata. mydata被web service挂载.dbdata被db service挂载.下面2个挂载格式都可以.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    image: nginx:alpine</span><br><span class="line">    volumes:</span><br><span class="line">      - type: volume</span><br><span class="line">        source: mydata</span><br><span class="line">        target: /data</span><br><span class="line">        volume:</span><br><span class="line">          nocopy: true</span><br><span class="line">      - type: bind</span><br><span class="line">        source: ./static</span><br><span class="line">        target: /opt/app/static</span><br><span class="line"></span><br><span class="line">  db:</span><br><span class="line">    image: postgres:latest</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/var/run/postgres/postgres.sock:/var/run/postgres/postgres.sock&quot;</span><br><span class="line">      - &quot;dbdata:/var/lib/postgresql/data&quot;</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  mydata:</span><br><span class="line">  dbdata:</span><br></pre></td></tr></table></figure><p>简短格式写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">volumes:</span><br><span class="line">  # Just specify a path and let the Engine create a volume</span><br><span class="line">  - /var/lib/mysql</span><br><span class="line"></span><br><span class="line">  # Specify an absolute path mapping</span><br><span class="line">  - /opt/data:/var/lib/mysql</span><br><span class="line"></span><br><span class="line">  # Path on the host, relative to the Compose file</span><br><span class="line">  - ./cache:/tmp/cache</span><br><span class="line"></span><br><span class="line">  # User-relative path</span><br><span class="line">  - ~/configs:/etc/configs/:ro</span><br><span class="line"></span><br><span class="line">  # Named volume</span><br><span class="line">  - datavolume:/var/lib/mysql</span><br></pre></td></tr></table></figure><p>完整格式写法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3.7&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    image: nginx:alpine</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;80:80&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - type: volume</span><br><span class="line">        source: mydata</span><br><span class="line">        target: /data</span><br><span class="line">        volume:</span><br><span class="line">          nocopy: true</span><br><span class="line">      - type: bind</span><br><span class="line">        source: ./static</span><br><span class="line">        target: /opt/app/static</span><br><span class="line"></span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br><span class="line"></span><br><span class="line">volumes:</span><br><span class="line">  mydata:</span><br></pre></td></tr></table></figure><hr><h2 id="Volume块级别配置文件指令"><a href="#Volume块级别配置文件指令" class="headerlink" title="Volume块级别配置文件指令"></a>Volume块级别配置文件指令</h2><p>大部分volume的用法在上面都已经解释过了,Volume的顶级指令配置不多.</p><h4 id="driver"><a href="#driver" class="headerlink" title="driver"></a>driver</h4><p>指定volume卷的驱动,docker引擎默认指定的驱动是<code>local</code>.</p><hr><h2 id="Network块级别配置文件指令"><a href="#Network块级别配置文件指令" class="headerlink" title="Network块级别配置文件指令"></a>Network块级别配置文件指令</h2><p>详细的docker network特性以及所有network驱动请见:<a href="https://docs.docker.com/compose/networking/" target="_blank" rel="noopener">Network guide</a></p><p>默认情况下Compose启动单一网络,一个services的每个容器加入到默认的网络,并且该网络下的所有容器之间都能互相访问</p><p>假如下面的compose文件在<code>myapp</code>目录下.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    build: .</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8000:8000&quot;</span><br><span class="line">  db:</span><br><span class="line">    image: postgres</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8001:5432&quot;</span><br></pre></td></tr></table></figure><p>当执行<code>docker-compose up</code>命令启动时,会执行以下几个步骤</p><p>1.创建一个<code>myapp_default</code>的网络</p><p>2.使用web的配置文件启动一个容器,加入到<code>myapp_default</code>网络中</p><p>3.使用db的配置文件启动一个容器.加入到<code>myapp_default</code>的网络中</p><p>所有容器成功启动后,每个容器都能访问对方的<code>hostname</code>和对方的IP地址.</p><p>另外,需要理解<code>HOST_PORT</code>和<code>COMTAINER_PORT</code>的区别.在上面这个例子中,db的<code>host_port</code>是8001,容器的端口是5432,services之间的容器都是通过<code>CONTAINER_PORT</code>也就是容器的IP进行通信的.例如访问数据库地址应该是:<code>postgres://db:5432</code></p><h4 id="driver-1"><a href="#driver-1" class="headerlink" title="driver"></a>driver</h4><p>指定网络驱动.在单主机下Docker引擎默认使用<code>bridge</code>模式.在swarm集群环境中,默认使用<code>overlay</code>模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver: overlay</span><br></pre></td></tr></table></figure><hr><h2 id="configs和secrets块级别配置文件指令"><a href="#configs和secrets块级别配置文件指令" class="headerlink" title="configs和secrets块级别配置文件指令"></a>configs和secrets块级别配置文件指令</h2><p>还不是很懂这个怎么用的,以后有空再研究</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;docker学习笔记——docker-compose&quot;&gt;&lt;a href=&quot;#docker学习笔记——docker-compose&quot; class=&quot;headerlink&quot; title=&quot;docker学习笔记——docker-compose&quot;&gt;&lt;/a&gt;docker学习笔记——docker-compose&lt;/h2&gt;&lt;p&gt;docker compose 定义并且运行多个docker容器.使用YAML风格文件定义一个compose文件.利用compose文件创建和启动所有服务.&lt;/p&gt;
&lt;p&gt;使用docker compose基本只需要3个步骤&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在Dockerfile文件定义app环境&lt;/li&gt;
&lt;li&gt;在docker-compose.yml文件中定义组成app的各个服务&lt;/li&gt;
&lt;li&gt;run docker-compose up 和compose 启动和运行app&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;下面文档均可以在docker-compose官方找到详细资料:&lt;a href=&quot;https://docs.docker.com/compose/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;docker-compose&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;docker-compose安装&quot;&gt;&lt;a href=&quot;#docker-compose安装&quot; class=&quot;headerlink&quot; title=&quot;docker-compose安装&quot;&gt;&lt;/a&gt;docker-compose安装&lt;/h3&gt;
    
    </summary>
    
      <category term="docker" scheme="https://jesse.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://jesse.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker学习笔记---Docker镜像篇</title>
    <link href="https://jesse.top/2020/06/29/docker/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E9%95%9C%E5%83%8F%E7%AF%87/"/>
    <id>https://jesse.top/2020/06/29/docker/docker学习笔记——镜像篇/</id>
    <published>2020-06-29T03:59:58.000Z</published>
    <updated>2020-06-30T12:32:51.209Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker笔记——镜像篇"><a href="#docker笔记——镜像篇" class="headerlink" title="docker笔记——镜像篇"></a>docker笔记——镜像篇</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>docker镜像是一个只读的Docker容器模板.含有启动docker容器所需的文件系统结构以及内容.因此是启动一个容器的基础.docker镜像的文件内容以及一些运行docker容器的配置文件组成了docker容器的静态文件运行环境—rootfs.</p><p>可以这么理解,docker镜像是docker容器的静态视角.docker容器是docker镜像的运行状态</p><hr><p><strong>1.rootfs</strong></p><p>rootfs是docker容器的根目录.如:/dev,/proc,/bin,/etc …….传统的Linux容器操作系统内核启动时,首先挂载一个只读(read-only)的rootfs.当系统检测到完整性后,再将其切换到读写(read-write)模式.而在docker架构中.也沿用了Linux内核的启动方法.在docker为容器挂载rootfs时,将rootfs设置为只读模式,挂载完毕后,在已有的只读rootfs上再挂载一个读写层.</p><p>读写层位于docker容器文件系统的最顶层.下面可能挂载了多个只读层.</p><a id="more"></a><p><strong>2.docker镜像的特点</strong></p><ul><li><strong>分层</strong></li></ul><p>每个镜像都由一系列的”镜像层”组成.当需要修改容器镜像内的某个文件时,只对最上方的读写层进行修改,不覆盖下面的只读层文件系统.例如删除一个只读文件系统中的文件时,只会在读写层标记这个文件”已经被删除”,但是这个文件在只读层中仍然存在.只不过不被用户感知.</p><ul><li><strong>写时复制(copy-on-write)</strong></li></ul><p>每个容器在启动的时候并不需要单独复制一份镜像文件,而是将所有镜像层以只读的方式挂载到一个挂载点,在多个容器之间共享.在未更改镜像文件内容时,所有容器共享一份数据,只有在docker容器运行过程中修改过文件时,才会把变化的文件内容写到读写层.并隐藏只读层中的老版本文件.</p><p>写时复制机制减少了镜像对磁盘空间的占用和容器的启动时间</p><ul><li><strong>联合挂载</strong></li></ul><p>联合挂载技术可以在一个挂载点同时挂载多个文件系统.实现这种联合挂载技术的文件系统被称为联合文件系统(union filesystem).从内核的角度来看,docker容器的文件系统分为只读rootfs层和读写层.但是在用户的视角看来,整个文件系统都是rootfs底层.</p><p>下面这个图可以理解,镜像是由一堆的只读层堆叠起来的统一视角:</p><p><img src="![Docker镜像](https://img1.jesse.top/docker-image1.gif" alt=""></p><p>下面这个图理解了docker镜像和docker容器的区别</p><p><img src="https://img1.jesse.top/docker-container1.png" alt=""></p><hr><h3 id="docker镜像的相关概念"><a href="#docker镜像的相关概念" class="headerlink" title="docker镜像的相关概念"></a>docker镜像的相关概念</h3><p>1.<strong>registry</strong></p><p>registry用来保存docker镜像.可以将registry简单的想象成类似于git仓库之类的实体.当<figure class="highlight docker"><figcaption><span>run```命令启动一个容器时,如果宿主机上并不存在该镜像,那么docker将从registry中下载镜像并保存到宿主机</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">可以使用docker官方的公共registry服务(docker hub),可以可以使用阿里云私有的registry,甚至还可以自己搭建私有的registry</span><br><span class="line"></span><br><span class="line">**<span class="number">2</span>.repository**</span><br><span class="line"></span><br><span class="line">repository是由具有某个功能的docker镜像的所有迭代版本构成的镜像组.repository通常表示镜像所具有的功能,例如ansible/ubunbu14.<span class="number">4</span>-ansible.而顶层仓库则只包含repository名.例如,Ubuntu</span><br><span class="line"></span><br><span class="line">repository是一个镜像集合,包含了多个不同版本的镜像.使用标签进行版本区分,例如ubuntu:<span class="number">14.04</span>,ubuntu12.<span class="number">04</span>.他们均属于ubuntu这个repository</span><br><span class="line"></span><br><span class="line">**总而言之,registry是repository的集合,repository是镜像的集合**</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="comment">### docker镜像相关的命令</span></span><br><span class="line"></span><br><span class="line">* **拉取镜像**</span><br><span class="line"></span><br><span class="line">`docker pull [OPTIONS] NAME[:TAG|@DIGEST]`</span><br><span class="line"></span><br><span class="line">如果只指定了镜像名,则默认从docker hub官方拉取该镜像的最新latest版本</span><br></pre></td></tr></table></figure></p><p>[root@localhost ~]$docker pull nginx<br>Using default tag: latest<br>latest: Pulling from library/nginx<br>743f2d6c1f65: Pull complete<br>6bfc4ec4420a: Pull complete<br>688a776db95f: Pull complete<br>Digest: sha256:23b4dcdf0d34d4a129755fc6f52e1c6e23bb34ea011b315d87e193033bcd1b68<br>Status: Downloaded newer image for nginx:latest<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">如果指定了tag,则拉取指定的版本镜像</span><br></pre></td></tr></table></figure></p><p>[root@localhost ~]$docker pull nginx:1.15<br>1.15: Pulling from library/nginx<br>Digest: sha256:23b4dcdf0d34d4a129755fc6f52e1c6e23bb34ea011b315d87e193033bcd1b68<br>Status: Downloaded newer image for nginx:1.15<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">拉取我阿里云的私人registry下的镜像</span><br></pre></td></tr></table></figure></p><p>#registry.cn-hangzhou.aliyuncs.com/jesse_images为仓库地址</p><p>#php7.1.9为镜像版本<br>[root@localhost ~]$docker pull registry.cn-hangzhou.aliyuncs.com/jesse_images/jesse_images:php7.1.9</p><p>php7.1.9: Pulling from jesse_images/jesse_images<br>Digest: sha256:ed9b7326b539f47a81697e51ed8ec698bec49fb62959990c1277d068fc55ff94<br>Status: Downloaded newer image for registry.cn-hangzhou.aliyuncs.com/jesse_images/jesse_images:php7.1.9<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">* **删除镜像**</span><br><span class="line"></span><br><span class="line">命令格式:</span><br><span class="line"></span><br><span class="line">`docker rmi [OPTIONS] IMAGE [IMAGE…]`</span><br><span class="line"></span><br><span class="line">可以是docker rmi 镜像ID 或者 docker rmi 镜像名:tag</span><br></pre></td></tr></table></figure></p><p>docker images #查看当前宿主机上的镜像<br>[root@localhost ~]$docker images<br>REPOSITORY                                                    TAG                    IMAGE ID            CREATED             SIZE<br>busybox                                                       latest                 64f5d945efcc        6 days ago          1.2MB<br>nginx                                                         1.15                   53f3fd8007f7        7 days ago          109MB<br>nginx                                                         latest                 53f3fd8007f7        7 days ago          109MB<br>php-swoole                                                    7.1                    aa71c42a22ca        9 days ago          588MB</p><p><none>                                                        <none>                 01f5d7914e61        9 days ago          585MB</none></none></p><p>#删除镜像ID为01f5d7914e61的镜像</p><p>[root@localhost ~]$docker rmi 01f5d7914e61<br>Deleted: sha256:01f5d7914e615b0e2f7cc36a494c876dfc0c678963898374d9ef512d7a762aac<br>Deleted: sha256:b4dd4a057d2561647ff7bf6b299a143c99f66831c129618f49bca5e6ac82f99e<br>Deleted: sha256:c37c880338efd3d340bfa71b35b7653b6cec8eb4f5dfcfab8c7ad0045fef3ce6<br>Deleted: sha256:fb7d015f8921c1244134730b6c21f0bda6c7156ccd421d9e0069d5a1074b48dd<br>Deleted: sha256:ab74760ab0af7680fa9338100c92306392ffeb384b8976045a11dab9a4ebbc57<br>Deleted: sha256:8544a2552375c861955db9034e9c3c5a3e83530b84de9b9bb6d4a7d0d5e5b8ac<br>Deleted: sha256:4eebc2d39a0733b28992a064fc71852297927a3994b01a9d1123d71b042ab729</p><p>#删除nginx.tag为1.15的镜像<br>[root@localhost ~]$docker rmi nginx:1.15<br>Untagged: nginx:1.15<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">* **查看镜像**</span><br><span class="line"></span><br><span class="line">`docker history 镜像名`可以看到镜像的构建分层</span><br></pre></td></tr></table></figure></p><p>[root@localhost ~]$docker history nginx<br>IMAGE               CREATED             CREATED BY                                      SIZE                COMMENT<br>53f3fd8007f7        7 days ago          /bin/sh -c #(nop)  CMD [“nginx” “-g” “daemon…   0B</p><p><missing>           7 days ago          /bin/sh -c #(nop)  STOPSIGNAL SIGTERM           0B</missing></p><p><missing>           7 days ago          /bin/sh -c #(nop)  EXPOSE 80                    0B</missing></p><p><missing>           7 days ago          /bin/sh -c ln -sf /dev/stdout /var/log/nginx…   0B</missing></p><p><missing>           7 days ago          /bin/sh -c set -x  &amp;&amp; apt-get update  &amp;&amp; apt…   54.1MB</missing></p><p><missing>           7 days ago          /bin/sh -c #(nop)  ENV NJS_VERSION=1.15.12.0…   0B</missing></p><p><missing>           7 days ago          /bin/sh -c #(nop)  ENV NGINX_VERSION=1.15.12…   0B</missing></p><p><missing>           7 days ago          /bin/sh -c #(nop)  LABEL maintainer=NGINX Do…   0B</missing></p><p><missing>           8 days ago          /bin/sh -c #(nop)  CMD [“bash”]                 0B</missing></p><p><missing>           8 days ago          /bin/sh -c #(nop) ADD file:fcb9328ea4c115670…   55.3MB<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">`docker inspect 镜像名` 可以看到镜像的具体信息</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">* **创建镜像**</span><br><span class="line"></span><br><span class="line">`docker commit`命令可以基于现有的容器创建出一个镜像</span><br></pre></td></tr></table></figure></missing></p><p>#用法格式:<br>docker commit -m ‘镜像说明信息’   -a  作者  容器ID 镜像名:版本</p><p>[root@localhost ~]$docker commit -h</p><p>Usage:    docker commit [OPTIONS] CONTAINER [REPOSITORY[:TAG]]</p><p>Create a new image from a container’s changes</p><p>Options:<br>  -a, –author string    Author (e.g., “John Hannibal Smith <a href="mailto:&#104;&#97;&#110;&#x6e;&#105;&#x62;&#x61;&#108;&#x40;&#97;&#45;&#x74;&#101;&#97;&#109;&#46;&#99;&#111;&#x6d;" target="_blank" rel="noopener">&#104;&#97;&#110;&#x6e;&#105;&#x62;&#x61;&#108;&#x40;&#97;&#45;&#x74;&#101;&#97;&#109;&#46;&#99;&#111;&#x6d;</a>“)<br>  -c, –change list      Apply Dockerfile instruction to the created image<br>  -m, –message string   Commit message<br>  -p, –pause            Pause container during commit (default true)</p><p>  #例如.将正在运行中的Nginx容器提交为一个新的nginx:test镜像<br>[root@localhost ~]$docker commit -m ‘test’ -a ‘jesse’ nginx nginx:test<br>sha256:028f5e2b21a66a1bf5f70727f20cac04e8918f57d5584cc2aeb09f18791d9680<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">* 导入导出镜像</span><br><span class="line"></span><br><span class="line">命令: </span><br><span class="line"></span><br><span class="line">`docker save -o 保存文件名 镜像名:tag`  ————将某个镜像保存为一个文件</span><br><span class="line"></span><br><span class="line">`docker load &lt; 文件名` or `docker load —input 文件名`——将某个文件导入到本地镜像</span><br><span class="line"></span><br><span class="line">例如</span><br></pre></td></tr></table></figure></p><p>#将nginx:test这个镜像保存为Nginx_test.tar文件<br>[root@localhost ~]$docker save -o nginx_test.tar nginx:test<br>[root@localhost ~]$ll nginx_test.tar<br>-rw——- 1 root root 113036800 5月  16 10:29 nginx_test.tar</p><p>#删除ningx:test这个镜像.然后再从该文件恢复<br>[root@localhost ~]$docker load &lt; nginx_test.tar<br>67392954caf5: Loading layer [==================================================&gt;]  8.192kB/8.192kB<br>Loaded image: nginx:test</p><p>#镜像已经被导入<br>[root@localhost ~]$docker images | grep nginx<br>nginx                                                         test                   028f5e2b21a6        4 minutes ago       109MB<br><code>`</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;docker笔记——镜像篇&quot;&gt;&lt;a href=&quot;#docker笔记——镜像篇&quot; class=&quot;headerlink&quot; title=&quot;docker笔记——镜像篇&quot;&gt;&lt;/a&gt;docker笔记——镜像篇&lt;/h2&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;docker镜像是一个只读的Docker容器模板.含有启动docker容器所需的文件系统结构以及内容.因此是启动一个容器的基础.docker镜像的文件内容以及一些运行docker容器的配置文件组成了docker容器的静态文件运行环境—rootfs.&lt;/p&gt;
&lt;p&gt;可以这么理解,docker镜像是docker容器的静态视角.docker容器是docker镜像的运行状态&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;1.rootfs&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;rootfs是docker容器的根目录.如:/dev,/proc,/bin,/etc …….传统的Linux容器操作系统内核启动时,首先挂载一个只读(read-only)的rootfs.当系统检测到完整性后,再将其切换到读写(read-write)模式.而在docker架构中.也沿用了Linux内核的启动方法.在docker为容器挂载rootfs时,将rootfs设置为只读模式,挂载完毕后,在已有的只读rootfs上再挂载一个读写层.&lt;/p&gt;
&lt;p&gt;读写层位于docker容器文件系统的最顶层.下面可能挂载了多个只读层.&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="https://jesse.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://jesse.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker学习笔记---docker容器篇</title>
    <link href="https://jesse.top/2020/06/29/docker/docker%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E5%AE%B9%E5%99%A8%E7%AF%87/"/>
    <id>https://jesse.top/2020/06/29/docker/docker学习笔记—容器篇/</id>
    <published>2020-06-29T03:59:58.000Z</published>
    <updated>2020-06-29T14:28:34.926Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker学习笔记—-docker容器篇"><a href="#docker学习笔记—-docker容器篇" class="headerlink" title="docker学习笔记— docker容器篇"></a>docker学习笔记— docker容器篇</h2><p><strong>一.创建并启动容器</strong></p><ul><li><strong>创建容器</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker create -it 镜像名:tag</span><br></pre></td></tr></table></figure><ul><li><strong>查看所有容器</strong>(包括运行中,已退出,错误容器)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><ul><li>查看所有容器的ID</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -qa</span><br></pre></td></tr></table></figure><ul><li><strong>启动容器</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start container_id</span><br></pre></td></tr></table></figure><ul><li><strong>使用指定的镜像直接创建并启动容器</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">docker run -it 镜像名:标签 COMMAND</span><br><span class="line"></span><br><span class="line">jesse@jesse-virtual-machine:~$ docker run -it ubuntu:16.04 /bin/bash</span><br><span class="line">root@66a29f973548:/#   ----------此时已经进入到容器的bash环境</span><br></pre></td></tr></table></figure><a id="more"></a><p>当利用 docker run 来创建容器时，Docker 在后台运行的标准操作包括：</p><p>1.检查本地是否存在指定的镜像，不存在就从公有仓库下载</p><p>2.利用镜像创建并启动一个容器</p><p>3.分配一个文件系统，并在只读的镜像层外面挂载一层可读写层</p><p>4.从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去</p><p>5.从地址池配置一个 ip 地址给容器</p><p>6.执行用户指定的应用程序</p><p>7.执行完毕后容器被终止</p><ul><li><strong>以守护状态运行:</strong></li></ul><p>以守护态运行（加参数-d):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d registry.intra.weibo.com/yushuang3/centos:v1 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;</span><br></pre></td></tr></table></figure><ul><li><strong>容器终止:</strong></li></ul><p><strong>获取容器输出的信息</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs container_id</span><br></pre></td></tr></table></figure><p><strong>停止容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop container_Id</span><br></pre></td></tr></table></figure><blockquote><p>终止一个容器  加入-t=10 表示等待10秒(不加-t选项则默认就是10秒)再次发送SIGKILL信号终止容器</p></blockquote><p><strong>重启容器</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker restart container_id</span><br></pre></td></tr></table></figure><p><strong>容器状态:</strong></p><ul><li><strong>status表示容器的状态..</strong></li></ul><ul><li><strong>exited 表示容器已经退出</strong></li><li><strong>up 表示容器正在运行</strong></li></ul><p>docker run启动容器时还可以指定其他的配置参数:</p><ul><li>-h HOSTNAME 或者 –hostname=HOSTNAME.设置容器的主机名</li><li>–dns=IP_ADDRESS:设置容器的DNS.写在容器的/etc/resolv.conf文件中.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]$docker run -itd --name busybox1 -h dwd-busybox --dns=8.8.8.8 busybox</span><br><span class="line">c25dac9c641705e00f02aefe302987f39f853a1feb8c0d3f32dc1675747edd84</span><br><span class="line"></span><br><span class="line">[root@localhost test]$docker exec -it busybox1 hostname</span><br><span class="line">dwd-busybox</span><br><span class="line"></span><br><span class="line">[root@localhost test]$docker exec -it busybox1 cat /etc/resolv.conf</span><br><span class="line">nameserver 8.8.8.8</span><br></pre></td></tr></table></figure><p>但是需要注意的是.这些修改不会被 docker commit保存,也就是不会保存在镜像中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">#将busybox1容器保存为busybox1:test镜像</span><br><span class="line">[root@localhost test]$docker commit -m &apos;test&apos; -a &apos;jesse&apos; busybox1 busybox1:test</span><br><span class="line">sha256:3c8faee532f177cf8bb8736db89694c2c3ff5be1a30a15d604e450130909d123</span><br><span class="line"></span><br><span class="line">#用这个镜像,启动一个新的busybox1-test的容器</span><br><span class="line">[root@localhost test]$docker run --name busybox1-test -itd busybox1:test</span><br><span class="line">9326b615e9e3af64336683f7f82e048929de560d4ad0a5caf2485bbc4a62e18c</span><br><span class="line"></span><br><span class="line">#可以看到hostname和dns信息没有被保留</span><br><span class="line">[root@localhost test]$docker exec -it busybox1-test hostname</span><br><span class="line">9326b615e9e3</span><br><span class="line"></span><br><span class="line">[root@localhost test]$docker exec -it busybox1-test cat /etc/resolv.conf</span><br><span class="line">nameserver 114.114.114.114</span><br><span class="line">nameserver 114.114.115.115</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;docker学习笔记—-docker容器篇&quot;&gt;&lt;a href=&quot;#docker学习笔记—-docker容器篇&quot; class=&quot;headerlink&quot; title=&quot;docker学习笔记— docker容器篇&quot;&gt;&lt;/a&gt;docker学习笔记— docker容器篇&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;一.创建并启动容器&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;创建容器&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker create -it 镜像名:tag&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;查看所有容器&lt;/strong&gt;(包括运行中,已退出,错误容器)&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker ps -a&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;查看所有容器的ID&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker ps -qa&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;启动容器&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker start container_id&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;使用指定的镜像直接创建并启动容器&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker run -it 镜像名:标签 COMMAND&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;jesse@jesse-virtual-machine:~$ docker run -it ubuntu:16.04 /bin/bash&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;root@66a29f973548:/#   ----------此时已经进入到容器的bash环境&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="docker" scheme="https://jesse.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://jesse.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker学习笔记---docker网络之overlay</title>
    <link href="https://jesse.top/2020/06/29/docker/docker%E5%AE%98%E7%BD%91%E5%AD%A6%E4%B9%A0--docker%E7%BD%91%E7%BB%9C%E4%B9%8Boverlay/"/>
    <id>https://jesse.top/2020/06/29/docker/docker官网学习--docker网络之overlay/</id>
    <published>2020-06-29T03:59:58.000Z</published>
    <updated>2020-06-30T12:32:51.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker官网学习-7-docker网络之overlay"><a href="#docker官网学习-7-docker网络之overlay" class="headerlink" title="docker官网学习-7.docker网络之overlay"></a>docker官网学习-7.docker网络之overlay</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>overlay网卡在多个docker宿主机之间创建一个分布式的网络,允许多个容器安全通信.</p><p>当初始化一个swarm集群,或者加入docker宿主机到一个swarm集群中.Docker会在该宿主机上创建2个网络:</p><ul><li>ingress: 负责swarm集群的控制以及数据流量</li><li>docker_gwbridge:一个Bridge网络,负责连接swarm集群中的每个docker节点</li></ul><p>overlay网络的创建方式和bridge一样.也是<code>docker network create</code>命令</p><hr><h3 id="创建overlay网络"><a href="#创建overlay网络" class="headerlink" title="创建overlay网络"></a>创建overlay网络</h3><a id="more"></a><p><strong>创建overlay网络的前提条件</strong></p><p>1.防火墙开通以下端口</p><ul><li>TCP 2377——集群管理节点通信</li><li>TCP,UPD 7946—节点间通信</li><li>UDP 4789—overlay网络流量</li></ul><p>2.初始化docker宿主机为swarm集群的manager角色.命令为<code>docker swarm init</code>.或者使用<code>docker swarm join</code>命令加入到一个现有的swarm集群.</p><p>这两种方式都会创建默认的ingress overlay网络.</p><blockquote><p>即使你不打算使用swarm服务,但是也要这样做.然后才能创建自定义的overlay网络</p></blockquote><p><strong>创建overlay网络命令</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#创建个overlay网络.名字为my-overlay</span><br><span class="line">docker network create -d overlay my-overlay</span><br></pre></td></tr></table></figure><p>如果swarm服务或者独立容器需要和其他docker宿主机上的独立容器通信.需要加上<code>—attachable</code>参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#创建个overlay网络,名字为my-overlay.并且和其他docker宿主机的standalone容器通信.</span><br><span class="line">docker network create -d overlay --attachable my-overlay</span><br></pre></td></tr></table></figure><blockquote><p>可以自定义地址段,掩码,网关等信息.具体方法见docker network create –help</p></blockquote><hr><h3 id="自定义默认Ingress网络"><a href="#自定义默认Ingress网络" class="headerlink" title="自定义默认Ingress网络"></a>自定义默认Ingress网络</h3><p>大部分用户不需要配置ingress网络.但是docker17.05以上版本可以自定义ingress网络.如果默认的Ingress网络iP地址段和已经存在的网络有冲突,则自定义的配置可很有用.</p><p>配置Ingress网络需要先删除ingress,然后重新创建.所以最好是在创建容器服务之前先定义好ingress.如果已经有暴露出端口的服务.则需要先删除服务.</p><p><strong>自定义默认ingress网络步骤如下:</strong></p><p>1.查看当前ingress网络.<code>docker network inspect ingress</code>.删除所有连接到ingress的容器的服务.</p><p>2.移除现有的ingress网络.<code>docker network rm ingress</code></p><p>3.使用<code>--ingress</code>参数重新创建一个overlay网络.定义自定义参数.例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">docker network create \</span><br><span class="line"> --driver overlay \</span><br><span class="line"> --ingress \</span><br><span class="line"> --subnet=10.11.0.0/16 \</span><br><span class="line"> --gateway=10.11.0.2 \</span><br><span class="line"> --opt com.docker.network.driver.mtu=1200 \</span><br><span class="line"> my-ingress</span><br></pre></td></tr></table></figure><blockquote><p>可以用自定义名称(my-ingress)来定义ingress网络.但是只允许存在一个自定义Ingress.</p></blockquote><p>4.重启步骤1中的服务</p><hr><h3 id="自定义默认docker-gwbridge-接口"><a href="#自定义默认docker-gwbridge-接口" class="headerlink" title="自定义默认docker_gwbridge 接口"></a>自定义默认docker_gwbridge 接口</h3><p>docker_gwbridge是连接overlay网络和docker宿主机物理网卡之间的虚拟网桥.当初始化一个swarm集群,或者将docker宿主机加入到一个swarm集群时,docker会自动创建docker_gwbridge.但是docker_gwbridge不是一个docker服务,而是存在于docker宿主机的内核当中.</p><p>所以需要在加入到swarm集群前先配置好docker_gwbridge.</p><p><strong>自定义默认docker_gwbridge网络步骤如下:</strong></p><p>1.停止docker</p><p>2.删除当前<code>docker_gwbridge</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip link set docker_gwbridge down</span><br><span class="line"></span><br><span class="line">$ sudo ip link del dev docker_gwbridge</span><br></pre></td></tr></table></figure><p>3.开启docker.不要加入或者初始化swarm</p><p>4.手动创建<code>docker_gwbridge</code>.下面这个例子定义了网络iP地址范围</p><blockquote><p>关于docker_gwbridge的更多参数请参考<a href="https://docs.docker.com/engine/reference/commandline/network_create/#bridge-driver-options" target="_blank" rel="noopener">Bridg dirver options</a></p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker network create \</span><br><span class="line">--subnet 10.11.0.0/16 \</span><br><span class="line">--opt com.docker.network.bridge.name=docker_gwbridge \</span><br><span class="line">--opt com.docker.network.bridge.enable_icc=false \</span><br><span class="line">--opt com.docker.network.bridge.enable_ip_masquerade=true \</span><br><span class="line">docker_gwbridge</span><br></pre></td></tr></table></figure><p>5.初始化或者加入到swarm集群</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;docker官网学习-7-docker网络之overlay&quot;&gt;&lt;a href=&quot;#docker官网学习-7-docker网络之overlay&quot; class=&quot;headerlink&quot; title=&quot;docker官网学习-7.docker网络之overlay&quot;&gt;&lt;/a&gt;docker官网学习-7.docker网络之overlay&lt;/h2&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;overlay网卡在多个docker宿主机之间创建一个分布式的网络,允许多个容器安全通信.&lt;/p&gt;
&lt;p&gt;当初始化一个swarm集群,或者加入docker宿主机到一个swarm集群中.Docker会在该宿主机上创建2个网络:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ingress: 负责swarm集群的控制以及数据流量&lt;/li&gt;
&lt;li&gt;docker_gwbridge:一个Bridge网络,负责连接swarm集群中的每个docker节点&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;overlay网络的创建方式和bridge一样.也是&lt;code&gt;docker network create&lt;/code&gt;命令&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;创建overlay网络&quot;&gt;&lt;a href=&quot;#创建overlay网络&quot; class=&quot;headerlink&quot; title=&quot;创建overlay网络&quot;&gt;&lt;/a&gt;创建overlay网络&lt;/h3&gt;
    
    </summary>
    
      <category term="docker" scheme="https://jesse.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://jesse.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker学习笔记---理解swarm集群</title>
    <link href="https://jesse.top/2020/06/29/docker/docker%E5%AE%98%E7%BD%91%E5%AD%A6%E4%B9%A0-5.%E5%AD%A6%E4%B9%A0swarm%E9%9B%86%E7%BE%A4/"/>
    <id>https://jesse.top/2020/06/29/docker/docker官网学习-5.学习swarm集群/</id>
    <published>2020-06-29T03:59:58.000Z</published>
    <updated>2020-06-29T13:11:55.850Z</updated>
    
    <content type="html"><![CDATA[<h3 id="理解swarm集群"><a href="#理解swarm集群" class="headerlink" title="理解swarm集群"></a>理解swarm集群</h3><p>一个swarm是一组运行docker服务器的的集群,docker服务器可以是物理机也可以是虚拟机.</p><p>swarm manager可以使用多种策略来运行容器.比如”emptiest node”—部署容器到压力最小的服务器上,或者”global”—确保每台服务器都只允许一个容器实例.你可以在Compose文件中指示swarm manager去选择何种策略</p><p>swarm managers是swarm进群中唯一可以执行命令,或者授权其他服务器以”workers”身份加入swarm集群的服务器.</p><hr><h4 id="初始化swarm-加入节点"><a href="#初始化swarm-加入节点" class="headerlink" title="初始化swarm,加入节点"></a>初始化swarm,加入节点</h4><p>试验环境:</p><p>1.10.0.0.50 —swarm manager<br>2.10.0.0.12 —worker 节点</p><ul><li>初始化swarm,并且指定通告的IP</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$docker swarm init --advertise-addr 10.0.0.50</span><br><span class="line">Swarm initialized: current node (zlvl9l94blu3rfcaaptdvo9u1) is now a manager.</span><br><span class="line"></span><br><span class="line">To add a worker to this swarm, run the following command:</span><br><span class="line"></span><br><span class="line">    docker swarm join --token SWMTKN-1-2i5fyjf2niw81tudcvpw33yuni277vz45lt6tyi5bvcnhvuwea-bj091dpe6e69ph9kt3lmsthgp 10.0.0.50:2377</span><br><span class="line"></span><br><span class="line">To add a manager to this swarm, run &apos;docker swarm join-token manager&apos; and follow the instructions.</span><br></pre></td></tr></table></figure><p>根据上面提示,在第二台服务器上以worker身份加入swarm集群</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@php ~]$docker swarm join --token SWMTKN-1-2i5fyjf2niw81tudcvpw33yuni277vz45lt6tyi5bvcnhvuwea-bj091dpe6e69ph9kt3lmsthgp 10.0.0.50:2377</span><br><span class="line">This node joined a swarm as a worker.</span><br><span class="line">[root@php ~]$</span><br></pre></td></tr></table></figure><p>执行docker node ls命令可以管理和查看swarm集群的所有节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$docker node ls</span><br><span class="line">ID                            HOSTNAME                STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION</span><br><span class="line">zlvl9l94blu3rfcaaptdvo9u1 *   localhost.localdomain   Ready               Active              Leader              18.09.2</span><br><span class="line">ud5ztqzvvfwg3d3hwmts5y9ct     php                     Ready               Active                                  18.09.3</span><br><span class="line">[root@localhost ~]$</span><br></pre></td></tr></table></figure><p>执行docker swarm leave命令将某个节点退出swarm集群</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">[root@php ~]$docker swarm leave</span><br><span class="line">Node left the swarm.</span><br><span class="line">[root@php ~]$</span><br><span class="line"></span><br><span class="line">此时这个节点在swarm集群中状态为down</span><br><span class="line"></span><br><span class="line">[root@localhost ~]$docker node ls</span><br><span class="line">ID                            HOSTNAME                STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION</span><br><span class="line">zlvl9l94blu3rfcaaptdvo9u1 *   localhost.localdomain   Ready               Active              Leader              18.09.2</span><br><span class="line">ud5ztqzvvfwg3d3hwmts5y9ct     php                     Down                Active                                  18.09.3</span><br><span class="line">[root@localhost ~]$</span><br></pre></td></tr></table></figure><hr><h4 id="在swarm集群部署app"><a href="#在swarm集群部署app" class="headerlink" title="在swarm集群部署app"></a>在swarm集群部署app</h4><p>现在可以把上一小节的docker compose部署在swarm集群上了.执行命令和上一小节一样.但是需要注意的是只能在swarm manager节点服务器上执行命令.</p><p>在第一台服务器上执行如下命令:(确保docker compose文件和镜像文件在这台服务器上)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@localhost ~]$cd /data/compose</span><br><span class="line">[root@localhost compose]$ls</span><br><span class="line">docker-compose.yml</span><br><span class="line">[root@localhost compose]$docker stack deploy -c docker-compose.yml getstartedlab</span><br><span class="line">Creating network getstartedlab_webnet</span><br><span class="line">Creating service getstartedlab_web</span><br><span class="line">[root@localhost compose]$</span><br></pre></td></tr></table></figure><p>APP已经成功部署到swarm集群上,现在可以使用上一小节中的同样的命令来管理app集群,只不过这次services和容器已经部署到两台服务器上:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost compose]$docker stack ps getstartedlab</span><br><span class="line">ID                  NAME                      IMAGE                  NODE                    DESIRED STATE       CURRENT STATE              ERROR                              PORTS</span><br><span class="line">4borwslue8k5        getstartedlab_web.1       friendlyhello:latest   localhost.localdomain   Running             Preparing 6 seconds ago</span><br><span class="line">ixmkldh16otx        getstartedlab_web.2       friendlyhello:latest   php                     Ready               Preparing 22 seconds ago</span><br><span class="line">i2yhimkst4iq         \_ getstartedlab_web.2   friendlyhello:latest   php                     Shutdown            Rejected 23 seconds ago    &quot;No such image: friendlyhello:…&quot;</span><br><span class="line">gytqpcwnzvrm        getstartedlab_web.3       friendlyhello:latest   localhost.localdomain   Running             Preparing 6 seconds ago</span><br><span class="line">j94tblo4qjwa        getstartedlab_web.4       friendlyhello:latest   php                     Ready               Preparing 22 seconds ago</span><br><span class="line">b7r9xkf4glh6         \_ getstartedlab_web.4   friendlyhello:latest   php                     Shutdown            Rejected 22 seconds ago    &quot;No such image: friendlyhello:…&quot;</span><br><span class="line">i8sv4c293ata        getstartedlab_web.5       friendlyhello:latest   localhost.localdomain   Running             Preparing 6 seconds ago</span><br></pre></td></tr></table></figure><blockquote><p>需要在另外一台服务器上pull同样的镜像,否则容器无法启动</p></blockquote><ul><li><p>在第二台服务器上下载我阿里云私有仓库的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">docker login --username=jessehuang408 registry.cn-hangzhou.aliyuncs.com</span><br><span class="line">Password:</span><br><span class="line"></span><br><span class="line">[root@php ~]$docker pull registry.cn-hangzhou.aliyuncs.com/jesse_images/jesse_images:frendlyhello-v1.0</span><br><span class="line">frendlyhello-v1.0: Pulling from jesse_images/jesse_images</span><br><span class="line">f7e2b70d04ae: Pull complete</span><br><span class="line">1e9214730e83: Pull complete</span><br><span class="line">5bd4ec081f7b: Pull complete</span><br><span class="line">be26b369a1e7: Pull complete</span><br><span class="line">236be9d80905: Pull complete</span><br><span class="line">1bf8a3675b0b: Pull complete</span><br><span class="line">5752f9477f0c: Pull complete</span><br><span class="line">Digest: sha256:8e8b57ef6e22c8c04c1c80cfab9f336928cffabacaa4ae4e74ec57e54bcffdb2</span><br><span class="line">Status: Downloaded newer image for registry.cn-hangzhou.aliyuncs.com/jesse_images/jesse_images:frendlyhello-v1.0</span><br><span class="line"></span><br><span class="line">[root@php ~]$docker images</span><br><span class="line">REPOSITORY                                                    TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/jesse_images/jesse_images   frendlyhello-v1.0   f091d1bb803c        2 days ago          131MB</span><br><span class="line">[root@php ~]$*</span><br></pre></td></tr></table></figure></li><li><p>将镜像修改成和第一台服务器一样:frendlyhello:latest</p></li></ul><p>命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag 镜像ID REPOSITORY:TAG</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@php ~]$docker tag f091d1bb803c frendlyhello:latest</span><br><span class="line">[root@php ~]$docker images</span><br><span class="line">REPOSITORY                                                    TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">frendlyhello                                                  latest              f091d1bb803c        2 days ago          131MB</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/jesse_images/jesse_images   frendlyhello-v1.0   f091d1bb803c        2 days ago          131MB</span><br><span class="line">[root@php ~]$</span><br></pre></td></tr></table></figure><ul><li>将第一台服务器的docker-compose文件拷贝到同样的目录下</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@php ~]$mkdir /data/compose</span><br><span class="line">[root@php ~]$scp root@10.0.0.50:/data/compose/docker-compose.yml /data/compose/</span><br></pre></td></tr></table></figure><ul><li>回到第一台服务器上删除刚才创建的getstartedlab</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost compose]$docker stack rm getstartedlab</span><br><span class="line">Removing service getstartedlab_web</span><br><span class="line">Removing network getstartedlab_webnet</span><br><span class="line"></span><br><span class="line">[root@localhost compose]$docker stack ps getstartedlab</span><br><span class="line">nothing found in stack: getstartedlab</span><br></pre></td></tr></table></figure><ul><li>重新部署docker compose</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost compose]$docker stack deploy -c docker-compose.yml getstartedlab</span><br><span class="line">Creating network getstartedlab_webnet</span><br><span class="line">Creating service getstartedlab_web</span><br><span class="line">[root@localhost compose]$</span><br></pre></td></tr></table></figure><ul><li>成功部署</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost compose]$docker stack ps getstartedlab</span><br><span class="line">ID                  NAME                  IMAGE                  NODE                    DESIRED STATE       CURRENT STATE              ERROR               PORTS</span><br><span class="line">uqsj8mim0sac        getstartedlab_web.1   friendlyhello:latest   localhost.localdomain   Running             Preparing 3 seconds ago</span><br><span class="line">shjiwlnj12sp        getstartedlab_web.2   friendlyhello:latest   php                     Running             Preparing 24 seconds ago</span><br><span class="line">8sqllvgid8jp        getstartedlab_web.3   friendlyhello:latest   php                     Running             Preparing 24 seconds ago</span><br><span class="line">v7fsecgcg504        getstartedlab_web.4   friendlyhello:latest   php                     Running             Preparing 24 seconds ago</span><br><span class="line">np8utmyvk5px        getstartedlab_web.5   friendlyhello:latest   localhost.localdomain   Running             Preparing 3 seconds ago</span><br><span class="line">[root@localhost compose]$</span><br></pre></td></tr></table></figure><p>在第二台的worker节点上执行命令会提示失败:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@php compose]$docker stack ps getstartedlab</span><br><span class="line">Error response from daemon: This node is not a swarm manager. Worker nodes can&apos;t be used to view or modify cluster state. Please run this command on a manager node or promote the current node to a manager.</span><br><span class="line">[root@php compose]$</span><br></pre></td></tr></table></figure><p>现在,在两台服务器上都能访问刚才部署的app</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> huangyong@huangyong-Macbook-Pro  ~  curl http://10.0.0.12:4000</span><br><span class="line">&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; 926f433b3896&lt;br/&gt;&lt;b&gt;Visits:&lt;/b&gt; &lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;% </span><br><span class="line"></span><br><span class="line">huangyong@huangyong-Macbook-Pro  ~  curl http://10.0.0.50:4000</span><br><span class="line">&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; 1535f17586ea&lt;br/&gt;&lt;b&gt;Visits:&lt;/b&gt; &lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;%                                                            huangyong@huangyong-Macbook-Pro  ~ </span><br></pre></td></tr></table></figure><h4 id="扩展app"><a href="#扩展app" class="headerlink" title="扩展app"></a>扩展app</h4><p>扩展app还是直接编辑docker-compose.yml文件.然后重新docker stack deploy部署即可.</p><p>如果是需要将其他虚拟机或者物理服务器加入进swarm集群,就像第二台服务器一样使用docker swarm join命令加入即可,</p><h4 id="停止swarm"><a href="#停止swarm" class="headerlink" title="停止swarm"></a>停止swarm</h4><p>命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stack rm getstartedlab</span><br></pre></td></tr></table></figure><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 初始化一个swarm集群</span><br><span class="line"></span><br><span class="line">docker swarm init --advertise-addr IP</span><br><span class="line"></span><br><span class="line">#加入到swarm集群</span><br><span class="line">docker swarm join --token &lt;token&gt; &lt;swarm manager IP&gt;:&lt;port&gt;</span><br><span class="line"></span><br><span class="line">#部署app</span><br><span class="line">docker stack deploy -c docker-compose.yml &lt;services name&gt;</span><br><span class="line">&gt; note:在所有docker服务器节点上都需要有docker-compose.yml文件和相关镜像</span><br><span class="line"></span><br><span class="line"># 查看services </span><br><span class="line">docker stack ps &lt;services name&gt;</span><br><span class="line">docker services ls</span><br><span class="line">docker stack ls</span><br><span class="line"></span><br><span class="line"># 从swarm集群中删除 services</span><br><span class="line"></span><br><span class="line">docker stack rm &lt;service name&gt;</span><br><span class="line"></span><br><span class="line"># 删除swarm集群节点</span><br><span class="line"></span><br><span class="line">docker swarm leave #worker节点</span><br><span class="line">docker swarm leave --force #manager节点</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;理解swarm集群&quot;&gt;&lt;a href=&quot;#理解swarm集群&quot; class=&quot;headerlink&quot; title=&quot;理解swarm集群&quot;&gt;&lt;/a&gt;理解swarm集群&lt;/h3&gt;&lt;p&gt;一个swarm是一组运行docker服务器的的集群,docker服务器可以是物理机也可以是虚拟机.&lt;/p&gt;
&lt;p&gt;swarm manager可以使用多种策略来运行容器.比如”emptiest node”—部署容器到压力最小的服务器上,或者”global”—确保每台服务器都只允许一个容器实例.你可以在Compose文件中指示swarm manager去选择何种策略&lt;/p&gt;
&lt;p&gt;swarm managers是swarm进群中唯一可以执行命令,或者授权其他服务器以”workers”身份加入swarm集群的服务器.&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;初始化swarm-加入节点&quot;&gt;&lt;a href=&quot;#初始化swarm-加入节点&quot; class=&quot;headerlink&quot; title=&quot;初始化swarm,加入节点&quot;&gt;&lt;/a&gt;初始化swarm,加入节点&lt;/h4&gt;&lt;p&gt;试验环境:&lt;/p&gt;
&lt;p&gt;1.10.0.0.50 —swarm manager&lt;br&gt;2.10.0.0.12 —worker 节点&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;初始化swarm,并且指定通告的IP&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="docker" scheme="https://jesse.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://jesse.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker学习笔记---学习Docker Stack</title>
    <link href="https://jesse.top/2020/06/29/docker/docker%E5%AE%98%E7%BD%91%E5%AD%A6%E4%B9%A0-6.%E5%AD%A6%E4%B9%A0stack/"/>
    <id>https://jesse.top/2020/06/29/docker/docker官网学习-6.学习stack/</id>
    <published>2020-06-29T03:59:58.000Z</published>
    <updated>2020-06-29T13:12:58.803Z</updated>
    
    <content type="html"><![CDATA[<h2 id="学习Docker-Stack"><a href="#学习Docker-Stack" class="headerlink" title="学习Docker Stack"></a>学习Docker Stack</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>一个stack是一组共享依赖包的多个相关的services,并且可以编排和扩展.其实从第4小节开始,在利用compose文件部署app时,就已经开始一直使用stack.但是还只是运行在一个单一服务器的单一service.<br>现在,你可以学习在多个服务器上,运行多个相关的services.</p><hr><ul><li>使用下面的docker-compose.yml文件替换第4小节中的docker-compose.yml</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    # replace username/repo:tag with your name and image details</span><br><span class="line">    image: ianch/friendlyhello:v1</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 5</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &quot;0.1&quot;</span><br><span class="line">          memory: 50M</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;4000:80&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">  Visualizer:</span><br><span class="line">    image: dockersamples/visualizer:stable</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br></pre></td></tr></table></figure><a id="more"></a><p>docker-compose文件稍微做了点改动.添加一个Visualizer服务,placement指令确保这个Visualizer服务仅仅运行在swarm manager节点.</p><hr><h4 id="部署compose文件"><a href="#部署compose文件" class="headerlink" title="部署compose文件"></a>部署compose文件</h4><ul><li>初始化swarm</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker swarm init</span><br></pre></td></tr></table></figure><ul><li>第二台服务器加入swarm集群</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@php compose]$docker swarm join --token SWMTKN-1-5qr6e90o52h5licxatuvmft65kji5qf1roujebf16auoe5xgam-3d0fuzr8818r6330n88dm1fcu 10.0.0.50:2377</span><br><span class="line">This node joined a swarm as a worker.</span><br></pre></td></tr></table></figure><ul><li>部署app</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost compose]$docker stack deploy -c docker-compose.yml getstartedlab</span><br><span class="line">Creating network getstartedlab_webnet</span><br><span class="line">Creating service getstartedlab_web</span><br><span class="line">Creating service getstartedlab_Visualizer</span><br><span class="line">[root@localhost compose]$</span><br></pre></td></tr></table></figure><blockquote><p>添加了2个服务.web和Visualizer</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost compose]$docker stack ps getstartedlab</span><br><span class="line">ID                  NAME                         IMAGE                             NODE                    DESIRED STATE       CURRENT STATE                ERROR               PORTS</span><br><span class="line">ds77cn4hgd9w        getstartedlab_web.1          friendlyhello:latest              php                     Running             Running about a minute ago</span><br><span class="line">agzj3veqno63        getstartedlab_Visualizer.1   dockersamples/visualizer:stable   localhost.localdomain   Running             Running about a minute ago</span><br><span class="line">3hq0if79g3gk        getstartedlab_web.2          friendlyhello:latest              php                     Running             Running about a minute ago</span><br><span class="line">iuxh7qjfpikw        getstartedlab_web.3          friendlyhello:latest              localhost.localdomain   Running             Running 53 seconds ago</span><br><span class="line">ba9hcq5zmlbd        getstartedlab_web.4          friendlyhello:latest              php                     Running             Running about a minute ago</span><br><span class="line">o600yqmqets7        getstartedlab_web.5          friendlyhello:latest              localhost.localdomain   Running             Running 55 seconds ago</span><br><span class="line">[root@localhost compose]$</span><br></pre></td></tr></table></figure><p>访问任意一台服务器的8080端口,可以看到Visualizer服务正在运行</p><p><img src="https://docs.docker.com/get-started/images/get-started-visualizer1.png" alt=""></p><blockquote><p>这是我借用的官网的图片.</p></blockquote><p>可以看到,visualizer运行在swarm manager节点上,5个web服务运行在swarm集群上.visualizer是一个不需要任何依赖,而可以运行在任何app的独立服务.现在尝试一下创建一个具有依赖项的服务:提供访问计数器的Redis服务</p><hr><h3 id="编辑docker-compose文件"><a href="#编辑docker-compose文件" class="headerlink" title="编辑docker-compose文件"></a>编辑docker-compose文件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">version: &quot;3&quot;</span><br><span class="line">services:</span><br><span class="line">  web:</span><br><span class="line">    # replace username/repo:tag with your name and image details</span><br><span class="line">    image: ianch/friendlyhello:v1</span><br><span class="line">    deploy:</span><br><span class="line">      replicas: 5</span><br><span class="line">      resources:</span><br><span class="line">        limits:</span><br><span class="line">          cpus: &quot;0.1&quot;</span><br><span class="line">          memory: 50M</span><br><span class="line">      restart_policy:</span><br><span class="line">        condition: on-failure</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;4000:80&quot;</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">  Visualizer:</span><br><span class="line">    image: dockersamples/visualizer:stable</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;8080:8080&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/var/run/docker.sock:/var/run/docker.sock&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line"></span><br><span class="line">  redis:</span><br><span class="line">    image: redis</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;6379:6379&quot;</span><br><span class="line">    volumes:</span><br><span class="line">      - &quot;/home/docker/data:/data&quot;</span><br><span class="line">    deploy:</span><br><span class="line">      placement:</span><br><span class="line">        constraints: [node.role == manager]</span><br><span class="line">    command: redis-server --appendonly yes</span><br><span class="line">    networks:</span><br><span class="line">      - webnet</span><br><span class="line">networks:</span><br><span class="line">  webnet:</span><br></pre></td></tr></table></figure><p> 这里我们添加了一个redis服务.在Docker HUB上有redis官方镜像,并且已经暴露了6379端口.所以这里只需要指定redis镜像即可..同样redis也只运行在manager节点服务器.</p><p> 这里为了持久化数据,在启动redis容器的时候指定了appendonly参数,并且挂载了本机的/home/docker/data目录映射到容器的/data.(redis容器默认保存数据路径)</p><ul><li>在manager节点创建/home/docker/data目录</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost compose]$mkdir -pv /home/docker/data</span><br><span class="line">mkdir: 已创建目录 &quot;/home/docker&quot;</span><br><span class="line">mkdir: 已创建目录 &quot;/home/docker/data&quot;</span><br></pre></td></tr></table></figure><ul><li>部署compose</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost compose]$docker stack deploy -c docker-compose.yml getstartedlab</span><br><span class="line">Updating service getstartedlab_web (id: mtgafxttekwfh0tkhkaespa1v)</span><br><span class="line">image friendlyhello:latest could not be accessed on a registry to record</span><br><span class="line">its digest. Each node will access friendlyhello:latest independently,</span><br><span class="line">possibly leading to different nodes running different</span><br><span class="line">versions of the image.</span><br><span class="line"></span><br><span class="line">Updating service getstartedlab_Visualizer (id: zmim1kj44afsr9xay8ppxker6)</span><br><span class="line">Creating service getstartedlab_redis</span><br></pre></td></tr></table></figure><p>可以看到3个services都启动起来了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost compose]$docker service ls</span><br><span class="line">ID                  NAME                       MODE                REPLICAS            IMAGE                             PORTS</span><br><span class="line">zmim1kj44afs        getstartedlab_Visualizer   replicated          1/1                 dockersamples/visualizer:stable   *:8080-&gt;8080/tcp</span><br><span class="line">elomaiu5go9p        getstartedlab_redis        replicated          1/1                 redis:latest                      *:6379-&gt;6379/tcp</span><br><span class="line">mtgafxttekwf        getstartedlab_web          replicated          5/5                 friendlyhello:latest              *:4000-&gt;80/tcp</span><br></pre></td></tr></table></figure><p>在浏览器访问服务器的4000端口可以看到有一个访问计数器在增加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> huangyong@huangyong-Macbook-Pro  ~  curl http://10.0.0.50:4000</span><br><span class="line">&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; eed56ca4164b&lt;br/&gt;&lt;b&gt;Visits:&lt;/b&gt; 5%                                                                                                           huangyong@huangyong-Macbook-Pro  ~  curl http://10.0.0.50:4000</span><br><span class="line">&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; 777d2cab6468&lt;br/&gt;&lt;b&gt;Visits:&lt;/b&gt; 6%                                                                                                           huangyong@huangyong-Macbook-Pro  ~  curl http://10.0.0.50:4000</span><br><span class="line">&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; 213e6a729c6a&lt;br/&gt;&lt;b&gt;Visits:&lt;/b&gt; 7%                                                                                                           huangyong@huangyong-Macbook-Pro  ~  curl http://10.0.0.50:4000</span><br><span class="line">&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; 85ccc6b1cb18&lt;br/&gt;&lt;b&gt;Visits:&lt;/b&gt; 8%                                                                                                           huangyong@huangyong-Macbook-Pro  ~ </span><br></pre></td></tr></table></figure><p>访问另外一台服务器也可以看到同样结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> huangyong@huangyong-Macbook-Pro  ~  curl http://10.0.0.12:4000</span><br><span class="line">&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; e77e36db18be&lt;br/&gt;&lt;b&gt;Visits:&lt;/b&gt; 10%                                                                                                          huangyong@huangyong-Macbook-Pro  ~  curl http://10.0.0.50:4000</span><br><span class="line">&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; eed56ca4164b&lt;br/&gt;&lt;b&gt;Visits:&lt;/b&gt; 11%                                                                                                          huangyong@huangyong-Macbook-Pro  ~  curl http://10.0.0.12:4000</span><br><span class="line">&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; eed56ca4164b&lt;br/&gt;&lt;b&gt;Visits:&lt;/b&gt; 12%</span><br></pre></td></tr></table></figure><p>访问visulizer容器的8080端口,可以看到redis服务运行</p><p><img src="https://docs.docker.com/get-started/images/visualizer-with-redis.png" alt=""></p><hr><h3 id="管理命令"><a href="#管理命令" class="headerlink" title="管理命令"></a>管理命令</h3><p>使用docker node ls 列出swarm集群的所有节点<br>使用docker service ls 列出所有服务<br>docker service ps &lt;service_name&gt; 列出某个服务的所有tasks</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$docker node ls</span><br><span class="line">ID                            HOSTNAME                STATUS              AVAILABILITY        MANAGER STATUS      ENGINE VERSION</span><br><span class="line">056r5hr2xb6jjzmbw64m3btd2 *   localhost.localdomain   Ready               Active              Leader              18.09.2</span><br><span class="line">r58bkpsxgi4mjaxrn8octuxw1     php                     Ready               Active                                  18.09.3</span><br><span class="line">[root@localhost ~]$docker service ls</span><br><span class="line">ID                  NAME                       MODE                REPLICAS            IMAGE                             PORTS</span><br><span class="line">zmim1kj44afs        getstartedlab_Visualizer   replicated          1/1                 dockersamples/visualizer:stable   *:8080-&gt;8080/tcp</span><br><span class="line">elomaiu5go9p        getstartedlab_redis        replicated          1/1                 redis:latest                      *:6379-&gt;6379/tcp</span><br><span class="line">mtgafxttekwf        getstartedlab_web          replicated          5/5                 friendlyhello:latest              *:4000-&gt;80/tcp</span><br><span class="line"></span><br><span class="line">[root@localhost ~]$docker service ps getstartedlab_web</span><br><span class="line">ID                  NAME                  IMAGE                  NODE                    DESIRED STATE       CURRENT STATE          ERROR               PORTS</span><br><span class="line">ds77cn4hgd9w        getstartedlab_web.1   friendlyhello:latest   php                     Running             Running 14 hours ago</span><br><span class="line">3hq0if79g3gk        getstartedlab_web.2   friendlyhello:latest   php                     Running             Running 14 hours ago</span><br><span class="line">iuxh7qjfpikw        getstartedlab_web.3   friendlyhello:latest   localhost.localdomain   Running             Running 14 hours ago</span><br><span class="line">ba9hcq5zmlbd        getstartedlab_web.4   friendlyhello:latest   php                     Running             Running 14 hours ago</span><br><span class="line">o600yqmqets7        getstartedlab_web.5   friendlyhello:latest   localhost.localdomain   Running             Running 14 hours ago</span><br><span class="line">[root@localhost ~]$</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;学习Docker-Stack&quot;&gt;&lt;a href=&quot;#学习Docker-Stack&quot; class=&quot;headerlink&quot; title=&quot;学习Docker Stack&quot;&gt;&lt;/a&gt;学习Docker Stack&lt;/h2&gt;&lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;&lt;p&gt;一个stack是一组共享依赖包的多个相关的services,并且可以编排和扩展.其实从第4小节开始,在利用compose文件部署app时,就已经开始一直使用stack.但是还只是运行在一个单一服务器的单一service.&lt;br&gt;现在,你可以学习在多个服务器上,运行多个相关的services.&lt;/p&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;使用下面的docker-compose.yml文件替换第4小节中的docker-compose.yml&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;version: &amp;quot;3&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;services:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  web:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    # replace username/repo:tag with your name and image details&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    image: ianch/friendlyhello:v1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    deploy:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      replicas: 5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      resources:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        limits:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          cpus: &amp;quot;0.1&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          memory: 50M&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      restart_policy:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        condition: on-failure&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ports:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      - &amp;quot;4000:80&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    networks:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      - webnet&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  Visualizer:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    image: dockersamples/visualizer:stable&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ports:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      - &amp;quot;8080:8080&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    volumes:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      - &amp;quot;/var/run/docker.sock:/var/run/docker.sock&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    deploy:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      placement:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        constraints: [node.role == manager]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    networks:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      - webnet&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;networks:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  webnet:&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="docker" scheme="https://jesse.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://jesse.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker学习笔记---docker网络之host,Container,None网络</title>
    <link href="https://jesse.top/2020/06/29/docker/docker%E5%AE%98%E7%BD%91%E5%AD%A6%E4%B9%A0-7.docker%E7%BD%91%E7%BB%9C%E4%B9%8Bhost,Container,None%E7%BD%91%E7%BB%9C/"/>
    <id>https://jesse.top/2020/06/29/docker/docker官网学习-7.docker网络之host,Container,None网络/</id>
    <published>2020-06-29T03:59:58.000Z</published>
    <updated>2020-06-29T13:14:06.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker官网学习-7-docker网络之host-Container-None网络"><a href="#docker官网学习-7-docker网络之host-Container-None网络" class="headerlink" title="docker官网学习-7.docker网络之host,Container,None网络"></a>docker官网学习-7.docker网络之host,Container,None网络</h2><h3 id="host网络介绍"><a href="#host网络介绍" class="headerlink" title="host网络介绍"></a>host网络介绍</h3><p>如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。</p><hr><h3 id="创建host网络"><a href="#创建host网络" class="headerlink" title="创建host网络"></a>创建host网络</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">docker run -tid --net=host --name busybox busybox1</span><br><span class="line"></span><br><span class="line">#host网络下的容器没有虚拟网卡,而是和宿主机共享网络</span><br><span class="line">[root@localhost ~]$docker exec  -it busybox1 ifconfig</span><br><span class="line">docker0   Link encap:Ethernet  HWaddr 02:42:89:26:D1:C9</span><br><span class="line">          inet addr:192.168.1.5  Bcast:192.168.1.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:1072032 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:1997027 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:0</span><br><span class="line">          RX bytes:61915874 (59.0 MiB)  TX bytes:1934238839 (1.8 GiB)</span><br></pre></td></tr></table></figure><blockquote><p>注:host网络只能工作在Linux主机上.</p><p>如果容器没有暴露任何端口,那host网络没有任何效果</p></blockquote><a id="more"></a><p>host网络示意图</p><p><img src="http://cdn.img2.a-site.cn/pic.php?url=aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXovUVAwQVk3dGRKblV4eFJNWjRRcDl0b21GaFFRMDNYVUVObjRZOVg0Q2tRRVZMV2dFZGt4MWljeThKY3VERXFhTGFZZUhiaDB1TWJZeVVtTjhQQ1l0bDl3LzA/d3hfZm10PXBuZw==" alt=""></p><hr><h3 id="Container网络介绍"><a href="#Container网络介绍" class="headerlink" title="Container网络介绍"></a>Container网络介绍</h3><p>这个模式指定新创建的容器和已经存在的一个容器共享一个 Network Namespace，而不是和宿主机共享。新创建的容器不会创建自己的网卡，配置自己的 IP，而是和一个指定的容器共享 IP、端口范围等。同样，两个容器除了网络方面，其他的如文件系统、进程列表等还是隔离的。两个容器的进程可以通过 lo 网卡设备通信。</p><p>Container网络示意图</p><p><img src="http://cdn.img2.a-site.cn/pic.php?url=aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXovUVAwQVk3dGRKblV4eFJNWjRRcDl0b21GaFFRMDNYVUVtaWM5elRoU1d1UmdSc2xVT2oyeHpmeUljZXdpY2E3VkpibE03Nnc5N01PZFRLVEl2TkdpYTBPd2cvMD93eF9mbXQ9cG5n" alt=""></p><hr><h3 id="None网络"><a href="#None网络" class="headerlink" title="None网络"></a>None网络</h3><p>使用none模式，Docker容器拥有自己的Network Namespace，但是，并不为Docker容器进行任何网络配置。也就是说，这个Docker容器没有网卡、IP、路由等信息。需要我们自己为Docker容器添加网卡、配置IP等。</p><p>Node模式示意图:</p><p><img src="http://cdn.img2.a-site.cn/pic.php?url=aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXovUVAwQVk3dGRKblV4eFJNWjRRcDl0b21GaFFRMDNYVUVMeFREaWNxUVFYQ0dObVlUNFlRdVdQYkxBRk1TVmhvRFlrcUtENFVLczVXbWtqbTM1THNpY1FZUS8wP3d4X2ZtdD1wbmc=" alt=""></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;docker官网学习-7-docker网络之host-Container-None网络&quot;&gt;&lt;a href=&quot;#docker官网学习-7-docker网络之host-Container-None网络&quot; class=&quot;headerlink&quot; title=&quot;docker官网学习-7.docker网络之host,Container,None网络&quot;&gt;&lt;/a&gt;docker官网学习-7.docker网络之host,Container,None网络&lt;/h2&gt;&lt;h3 id=&quot;host网络介绍&quot;&gt;&lt;a href=&quot;#host网络介绍&quot; class=&quot;headerlink&quot; title=&quot;host网络介绍&quot;&gt;&lt;/a&gt;host网络介绍&lt;/h3&gt;&lt;p&gt;如果启动容器的时候使用host模式，那么这个容器将不会获得一个独立的Network Namespace，而是和宿主机共用一个Network Namespace。容器将不会虚拟出自己的网卡，配置自己的IP等，而是使用宿主机的IP和端口。但是，容器的其他方面，如文件系统、进程列表等还是和宿主机隔离的。&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;创建host网络&quot;&gt;&lt;a href=&quot;#创建host网络&quot; class=&quot;headerlink&quot; title=&quot;创建host网络&quot;&gt;&lt;/a&gt;创建host网络&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker run -tid --net=host --name busybox busybox1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;#host网络下的容器没有虚拟网卡,而是和宿主机共享网络&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[root@localhost ~]$docker exec  -it busybox1 ifconfig&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;docker0   Link encap:Ethernet  HWaddr 02:42:89:26:D1:C9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          inet addr:192.168.1.5  Bcast:192.168.1.255  Mask:255.255.255.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          RX packets:1072032 errors:0 dropped:0 overruns:0 frame:0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          TX packets:1997027 errors:0 dropped:0 overruns:0 carrier:0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          collisions:0 txqueuelen:0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;          RX bytes:61915874 (59.0 MiB)  TX bytes:1934238839 (1.8 GiB)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;注:host网络只能工作在Linux主机上.&lt;/p&gt;
&lt;p&gt;如果容器没有暴露任何端口,那host网络没有任何效果&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="docker" scheme="https://jesse.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://jesse.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker学习笔记---docker网络之bridge</title>
    <link href="https://jesse.top/2020/06/29/docker/docker%E5%AE%98%E7%BD%91%E5%AD%A6%E4%B9%A0-7.docker%E7%BD%91%E7%BB%9C%E4%B9%8Bbridge/"/>
    <id>https://jesse.top/2020/06/29/docker/docker官网学习-7.docker网络之bridge/</id>
    <published>2020-06-29T03:59:58.000Z</published>
    <updated>2020-06-30T12:32:51.210Z</updated>
    
    <content type="html"><![CDATA[<h2 id="docker官网学习–docker网络之bridge"><a href="#docker官网学习–docker网络之bridge" class="headerlink" title="docker官网学习–docker网络之bridge"></a>docker官网学习–docker网络之bridge</h2><p>本节介绍docker基础网络概念.以便能认识和利用各种不同的网络类型功能.</p><p>docker的网络支持插件化,驱动化定制.有一些网络驱动已经默认集成到docker中.docker网络主要有以下类型</p><ul><li>bridge</li><li>host</li><li>overlay</li><li>macvlan</li><li>none</li><li>其他网络插件</li></ul><hr><a id="more"></a><h4 id="bridge"><a href="#bridge" class="headerlink" title="bridge"></a>bridge</h4><p>​    bridge是docker默认的网络驱动.如果在<code>docker run</code>启动一个容器时没有指定任何网络驱动.那么默认就是bridge桥接网络.桥接网络通常适用于应用进程部署在多个独立的容器中,并且容器之间需要互相通信的场景中.</p><p>   在docker环境中.bridge使用软件桥接允许容器之间通过同一个bridge互联.隔离没有连到这个bridge网络的其他容器网络.docker网络自动创建iptables规则阻止其他网络的容器访问.</p><p>当Docker进程启动时，会在主机上创建一个名为docker0的虚拟网桥，此主机上启动的Docker容器会连接到这个虚拟网桥上。虚拟网桥的工作方式和物理交换机类似，这样主机上的所有容器就通过交换机连在了一个二层网络中。</p><p>从docker0子网中分配一个IP给容器使用，并设置docker0的IP地址为容器的默认网关。在主机上创建一对虚拟网卡veth pair设备，Docker将veth pair设备的一端放在新创建的容器中，并命名为eth0（容器的网卡），另一端放在主机中，以vethxxx这样类似的名字命名，并将这个网络设备加入到docker0网桥中。可以通过brctl show命令查看。</p><p>在Linux中.可以使用brctl命令查看和管理网桥(需要先安装bridge-utils软件包).例如查看本机上的网桥及其端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[work@docker conf.d]$sudo brctl show</span><br><span class="line">bridge namebridge idSTP enabledinterfaces</span><br><span class="line">br-17ace6d9d81a8000.024236cdd4d7noveth82ed0e5</span><br><span class="line">br-d9897c225d258000.024237d1c9f6noveth6981090</span><br><span class="line">veth8e29dbf</span><br><span class="line">vethd511728</span><br><span class="line">docker08000.0242322e2e42noveth0a0e27d</span><br><span class="line">veth0c50104</span><br><span class="line">veth3fe7f4d</span><br></pre></td></tr></table></figure><p>docker 0网桥下关联了很多vethxxxxx规范命名的interfaces.每一个vethxxxx接口对应一个docker容器.在docker容器中一般是eth0的网卡</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[work@docker conf.d]$docker exec -it nginx ifconfig</span><br><span class="line">eth0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 172.17.0.8  netmask 255.255.0.0  broadcast 0.0.0.0</span><br><span class="line">        inet6 fe80::42:acff:fe11:8  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 02:42:ac:11:00:08  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 1428365  bytes 189142687 (180.3 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 1403620  bytes 287806317 (274.4 MiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p>bridge网桥就是这样通信的,docker服务端通过vethxxxx端口和容器的eth0虚拟网卡进行通信.docker容器将宿主机的docker 0虚拟网卡的IP作为它的网关:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@docker conf.d]$docker exec -it nginx route -n</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination     Gateway         Genmask         Flags Metric Ref    Use Iface</span><br><span class="line">0.0.0.0         172.17.0.1      0.0.0.0         UG    0      0        0 eth0</span><br></pre></td></tr></table></figure><p>bridge模式是docker的默认网络模式，不写–net参数，就是bridge模式。使用docker run -p时，docker实际是在iptables做了DNAT规则，实现端口转发功能。可以使用iptables -t nat -vnL查看。</p><p>bridge网络模式如下所示:</p><p><img src="http://cdn.img2.a-site.cn/pic.php?url=aHR0cDovL21tYml6LnFwaWMuY24vbW1iaXovUVAwQVk3dGRKblV4eFJNWjRRcDl0b21GaFFRMDNYVUViTWFab1lmbU9pYk56NDZwc0FMcDk0bHR1MllTNVZHMmZtNGUxTTNwM0tOUmVQN04xZVh2OHlBLzA/d3hfZm10PXBuZw==" alt=""></p><p>​    bridge网桥是docker的默认网络驱动.如果用户在创建容器时自定义了Bridge网络.那么自定义Bridge要优于docker默认的Bridge</p><p> <strong>用户定义的bridge和默认bridge的区别</strong></p><ul><li><p>用户定义的bridge在多个容器之间提供更好的隔离性和协调性.</p><p>连到同一个自定义的bridge的容器之间的所有端口互通.而无需通过-p参数暴露到宿主机.这让容器之间的通信更简单,而且提供更好的安全性.例如:</p><p>连到同一个自定义的bridge网络的Nginx容器和mysql容器.及时mysql容器没有暴露任何端口.nginx也可以访问mysql容器的3306端口.</p><p>而默认的Bridge网络,则需要将mysql容器通过<code>-p</code>参数暴露3306端口给宿主机.</p></li><li><p>自定义bridge网络提供容器的主机名DNS解析</p></li></ul><p>​        默认的bridge网络下的容器间不能通过主机名互相访问,只能通过IP地址.(除非使用—link参数,但是这个参数已经废弃).而用户自定义的bridge网络则可以直接访问对方的主机名.</p><ul><li>自定义bridge网络配置更方便</li></ul><p>​        配置一个默认bridge网络,会影响到全局所有容器.而且需要重启docker服务.使用<code>docker network create</code>可以创建一个自定义bridge网络.,而且可以分别配置</p><hr><h4 id="创建和管理自定义bridge网络"><a href="#创建和管理自定义bridge网络" class="headerlink" title="创建和管理自定义bridge网络"></a>创建和管理自定义bridge网络</h4><p>创建命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#创建自定义网络名称为my-net</span><br><span class="line">docker network create my-net</span><br><span class="line"></span><br><span class="line">#还可以指定网络号,子网掩码等信息</span><br><span class="line">[root@localhost ~]$docker network create --help</span><br><span class="line"></span><br><span class="line">Usage:docker network create [OPTIONS] NETWORK</span><br><span class="line"></span><br><span class="line">Create a network</span><br><span class="line"></span><br><span class="line">Options:</span><br><span class="line">      --attachable           Enable manual container attachment</span><br><span class="line">      --aux-address map      Auxiliary IPv4 or IPv6 addresses used by Network driver (default map)</span><br><span class="line">      --config-from string   The network from which copying the configuration</span><br><span class="line">      --config-only          Create a configuration only network</span><br><span class="line">  -d, --driver string        Driver to manage the Network (default &quot;bridge&quot;)</span><br><span class="line">      --gateway strings      IPv4 or IPv6 Gateway for the master subnet</span><br><span class="line">      --ingress              Create swarm routing-mesh network</span><br><span class="line">      --internal             Restrict external access to the network</span><br><span class="line">      --ip-range strings     Allocate container ip from a sub-range</span><br><span class="line">      --ipam-driver string   IP Address Management Driver (default &quot;default&quot;)</span><br><span class="line">      --ipam-opt map         Set IPAM driver specific options (default map)</span><br><span class="line">      --ipv6                 Enable IPv6 networking</span><br><span class="line">      --label list           Set metadata on a network</span><br><span class="line">  -o, --opt map              Set driver specific options (default map)</span><br><span class="line">      --scope string         Control the network&apos;s scope</span><br><span class="line">      --subnet strings       Subnet in CIDR format that represents a network segment</span><br></pre></td></tr></table></figure><p>删除自定义网络:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#如果有容器正在使用该网络,需要先断开容器</span><br><span class="line">docker network rm my-net</span><br></pre></td></tr></table></figure><hr><h4 id="管理自定义网络下的容器"><a href="#管理自定义网络下的容器" class="headerlink" title="管理自定义网络下的容器"></a>管理自定义网络下的容器</h4><p>创建一个自定义网络下的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#在创建容器的时候指定自定义网络名</span><br><span class="line"></span><br><span class="line">docker create --name my-nginx \</span><br><span class="line">  --network my-net \</span><br><span class="line">  --publish 8080:80 \</span><br><span class="line">  nginx:latest</span><br></pre></td></tr></table></figure><p>将一个正在运行的容器关联(移除)自定义网络</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#关联容器和自定义网络命令格式:</span><br><span class="line">docker network connect</span><br><span class="line"></span><br><span class="line">#例如,将一个正在运行的mysql容器关联到my-net网络下</span><br><span class="line">docker network connect my-net mysql</span><br><span class="line"></span><br><span class="line">#相反从自定义网络下移除一个容器命令:</span><br><span class="line">docker network disconnect</span><br><span class="line"></span><br><span class="line">#例如,将一个正在运行的mysql容器从my-net网络下移除</span><br><span class="line">docker network disconnect my-net mysql</span><br></pre></td></tr></table></figure><hr><h3 id="实验"><a href="#实验" class="headerlink" title="实验:"></a>实验:</h3><ul><li><strong>默认的bridge网络,容器之间无法互相访问对方的主机名.只能通过iP地址通信</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$docker run -itd --rm --name=busybox busybox</span><br><span class="line">b3c8be3b3b716579caf11d3852f6c6e04a41b4dc020d9478be1b1f3a4d76cf1f</span><br><span class="line"></span><br><span class="line">[root@localhost ~]$docker run -itd --rm --name=busybox1 busybox</span><br><span class="line">a54d962f6a692d96f0bc2fbca37e1b47e59e6b61541f42b8d6872a5008a46b87</span><br><span class="line"></span><br><span class="line">[root@localhost ~]$docker exec busybox ping busybox1</span><br><span class="line">ping: bad address &apos;busybox1&apos;</span><br><span class="line">[root@localhost ~]$</span><br><span class="line"></span><br><span class="line">#通过IP地址可以通信</span><br><span class="line"></span><br><span class="line">[root@localhost ~]$docker exec busybox ping 172.17.0.8</span><br><span class="line">PING 172.17.0.8 (172.17.0.8): 56 data bytes</span><br><span class="line">64 bytes from 172.17.0.8: seq=0 ttl=64 time=0.136 ms</span><br><span class="line">64 bytes from 172.17.0.8: seq=1 ttl=64 time=0.079 ms</span><br><span class="line">64 bytes from 172.17.0.8: seq=2 ttl=64 time=0.131 ms</span><br></pre></td></tr></table></figure><ul><li><strong>自定义的Bridge网络,可以在容器之间互相访问主机名</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#创建一个自定义网络</span><br><span class="line">[root@localhost ~]$docker network create jesse</span><br><span class="line">e10a936177681cbfc321f67f961f2a717079ef1790c50e82381296fa77bd7d5f</span><br><span class="line"></span><br><span class="line">[root@localhost ~]$docker network ls | grep jesse</span><br><span class="line">e10a93617768        jesse                  bridge              local</span><br><span class="line"></span><br><span class="line">#创建容器,使用network参数指定网络</span><br><span class="line">[root@localhost ~]$docker run --name busybox1 -itd --network jesse --rm busybox</span><br><span class="line">aedf164ea1769741ae6480583abdc838022f49506761d4054daabdb7fffcd852</span><br><span class="line"></span><br><span class="line">[root@localhost ~]$docker run --name busybox2 -itd --network jesse --rm busybox</span><br><span class="line">523bdd54fa12423e25a8ac84f9faef1679ee6031f2d5d2a87c0cacd64f8650ad</span><br><span class="line"></span><br><span class="line">[root@localhost ~]$docker exec busybox1 ping busybox2</span><br><span class="line">PING busybox2 (172.20.0.3): 56 data bytes</span><br><span class="line">64 bytes from 172.20.0.3: seq=0 ttl=64 time=0.116 ms</span><br><span class="line">64 bytes from 172.20.0.3: seq=1 ttl=64 time=0.078 ms</span><br></pre></td></tr></table></figure><ul><li>连接到不同的bridge网络下的容器互相之间网络隔离</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">docker network create bridge</span><br><span class="line">docker network create kong-net</span><br><span class="line"></span><br><span class="line">[work@docker conf.d]$docker run --name busybox1 --network bridge -itd busybox</span><br><span class="line">f95a229aa7eb5d7022bef4441a075b0ad37ecc50e2a02015f09790d23b28dc33</span><br><span class="line"></span><br><span class="line">[work@docker conf.d]$docker run --name busybox2 --network kong-net -itd busybox</span><br><span class="line">a9236a25199cc43a899285462afa851a52cdaf871776a93829897676fc7dd82c</span><br><span class="line"></span><br><span class="line">#busybox1和busybox2不在同一个IP网段</span><br><span class="line">#busybox1的IP</span><br><span class="line">[work@docker conf.d]$docker inspect busybox1 </span><br><span class="line">172.17.0.11</span><br><span class="line"></span><br><span class="line">#busybox2的IP</span><br><span class="line">[work@docker conf.d]$docker exec -it busybox2 ifconfig eth0</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 02:42:AC:12:00:05</span><br><span class="line">          inet addr:172.18.0.5  Bcast:0.0.0.0  Mask:255.255.0.0</span><br><span class="line">          </span><br><span class="line">#主机名无法访问</span><br><span class="line">[work@docker conf.d]$docker exec -it busybox1 ping busybox2</span><br><span class="line">ping: bad address &apos;busybox2&apos;</span><br><span class="line"></span><br><span class="line">#busybox1容器也无法ping busybox2容器的IP</span><br><span class="line">[work@docker conf.d]$docker exec -it busybox1 ping 172.18.0.5</span><br><span class="line">PING 172.18.0.5 (172.18.0.5): 56 data bytes</span><br><span class="line">^C</span><br><span class="line">--- 172.18.0.5 ping statistics ---</span><br><span class="line">32 packets transmitted, 0 packets received, 100% packet loss</span><br></pre></td></tr></table></figure><blockquote><p>由于博客不能识别go模板语法,所以省去了go模板,直接用docker inspect busybox1命令来代替.实际场景中该命令无法直接获取容器IP</p></blockquote><h4 id="将容器从自定义bridge网络中移除"><a href="#将容器从自定义bridge网络中移除" class="headerlink" title="将容器从自定义bridge网络中移除"></a>将容器从自定义bridge网络中移除</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#将jesse从jesse网络移除</span><br><span class="line">[root@localhost ~]$docker network disconnect jesse busybox1</span><br><span class="line"></span><br><span class="line">#此时jesse网络下只有busybox2容器</span><br><span class="line">[root@localhost ~]$docker network inspect jesse</span><br><span class="line"></span><br><span class="line">#此时busybox1容器的网卡被移除了</span><br><span class="line">[root@localhost ~]$docker inspect busybox1 </span><br><span class="line">&lt;no value&gt;</span><br><span class="line"></span><br><span class="line">root@localhost ~]$docker exec -it busybox1 ifconfig</span><br><span class="line">lo        Link encap:Local Loopback</span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:11 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:11 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:618 (618.0 B)  TX bytes:618 (618.0 B)</span><br></pre></td></tr></table></figure><h4 id="将一个正在运行的容器加入到自定义bridge网络"><a href="#将一个正在运行的容器加入到自定义bridge网络" class="headerlink" title="将一个正在运行的容器加入到自定义bridge网络"></a>将一个正在运行的容器加入到自定义bridge网络</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#将jesse加回到jesse网络</span><br><span class="line">[root@localhost ~]$docker network connect jesse busybox1</span><br><span class="line"></span><br><span class="line">#获得新的IP地址</span><br><span class="line">[root@localhost ~]$docker inspect busybox1 </span><br><span class="line">172.20.0.2</span><br></pre></td></tr></table></figure><hr><h4 id="宿主机转发容器端口"><a href="#宿主机转发容器端口" class="headerlink" title="宿主机转发容器端口"></a>宿主机转发容器端口</h4><p>默认情况下,bridge网络不会转发外部的请求到容器.开启转发需要更改2个设置:</p><p>1.修改内容,开启转发</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.conf.all.forwarding=1</span><br><span class="line"></span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure><p>2.更改iptables的转发的默认规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo iptables -P FORWARD ACCEPT</span><br></pre></td></tr></table></figure><h4 id="更改默认Bridge网络配置"><a href="#更改默认Bridge网络配置" class="headerlink" title="更改默认Bridge网络配置"></a>更改默认Bridge网络配置</h4><p>docker0网桥是在docker daemon启动时自动创建的.IP默认为172.17.0.1/16.所有连到docker 0网桥的docker容器都会在这个IP范围内选取一个未占用的IP使用.并连接到docker 0网桥上</p><p>docker提供了一些参数帮助用户自定义docker0网桥的设置</p><ul><li>—bip=CIDR: 设置Docker0的IP地址和子网范围.使用CIDR格式.例如192.168.0.1/24.需要注意的是这个参数仅仅是配置docker0的,对其他自定义的网桥无效.</li><li>—fixed-cidr=CIDR:限制docker容器获取iP的范围.默认情况下docker容器获取的IP范围为整个docker0网桥的IP地址段,也就是—bip指定的地址范围.此参数可以将docker容器缩小到某个子网范围.</li><li>—mtu=BYTES: 指定docker0的最大传输单元(MTU)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">#更改daemon.json配置文件.下面这个例子修改了docker0网络的网段地址</span><br><span class="line">vim /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;],</span><br><span class="line">  &quot;bip&quot;: &quot;192.168.1.5/24&quot;,</span><br><span class="line">  &quot;mtu&quot;: 1500,</span><br><span class="line">  &quot;dns&quot;: [&quot;114.114.114.114&quot;,&quot;114.114.115.115&quot;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">#重启docker服务</span><br><span class="line">[root@localhost ~]$systemctl restart docker</span><br><span class="line"></span><br><span class="line">[root@localhost ~]$ifconfig | grep -A 5 docker0</span><br><span class="line">docker0: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.1.5  netmask 255.255.255.0  broadcast 192.168.1.255</span><br><span class="line">        ether 02:42:89:26:d1:c9  txqueuelen 0  (Ethernet)</span><br><span class="line">        RX packets 1072032  bytes 61915874 (59.0 MiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 1997027  bytes 1934238839 (1.8 GiB)</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;docker官网学习–docker网络之bridge&quot;&gt;&lt;a href=&quot;#docker官网学习–docker网络之bridge&quot; class=&quot;headerlink&quot; title=&quot;docker官网学习–docker网络之bridge&quot;&gt;&lt;/a&gt;docker官网学习–docker网络之bridge&lt;/h2&gt;&lt;p&gt;本节介绍docker基础网络概念.以便能认识和利用各种不同的网络类型功能.&lt;/p&gt;
&lt;p&gt;docker的网络支持插件化,驱动化定制.有一些网络驱动已经默认集成到docker中.docker网络主要有以下类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;bridge&lt;/li&gt;
&lt;li&gt;host&lt;/li&gt;
&lt;li&gt;overlay&lt;/li&gt;
&lt;li&gt;macvlan&lt;/li&gt;
&lt;li&gt;none&lt;/li&gt;
&lt;li&gt;其他网络插件&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="docker" scheme="https://jesse.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://jesse.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker学习笔记---docker使用阿里云私有仓库</title>
    <link href="https://jesse.top/2020/06/29/docker/docker%E5%AE%98%E7%BD%91%E5%AD%A6%E4%B9%A0%E2%80%943.%E4%BD%BF%E7%94%A8%E9%98%BF%E9%87%8C%E4%BA%91%E5%9B%BD%E5%86%85%E9%95%9C%E5%83%8F%E5%92%8C%E4%BB%93%E5%BA%93/"/>
    <id>https://jesse.top/2020/06/29/docker/docker官网学习—3.使用阿里云国内镜像和仓库/</id>
    <published>2020-06-29T03:59:58.000Z</published>
    <updated>2020-06-29T13:11:08.185Z</updated>
    
    <content type="html"><![CDATA[<h3 id="docker使用阿里云私有仓库"><a href="#docker使用阿里云私有仓库" class="headerlink" title="docker使用阿里云私有仓库"></a>docker使用阿里云私有仓库</h3><p>注册阿里云镜像服务:</p><p>以下是我的阿里云镜像仓库链接:<br><a href="https://cr.console.aliyun.com/cn-hangzhou/repositories" target="_blank" rel="noopener">https://cr.console.aliyun.com/cn-hangzhou/repositories</a></p><p>一.使用阿里云镜像加速器<br><a href="https://cr.console.aliyun.com/cn-hangzhou/mirrors" target="_blank" rel="noopener">https://cr.console.aliyun.com/cn-hangzhou/mirrors</a></p><p>镜像加速地址:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://0w5ygvsg.mirror.aliyuncs.com</span><br></pre></td></tr></table></figure><p>如果是Centos系统,可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -p /etc/docker</span><br><span class="line">sudo tee /etc/docker/daemon.json &lt;&lt;-&apos;EOF&apos;</span><br><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [&quot;https://0w5ygvsg.mirror.aliyuncs.com&quot;]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><hr><a id="more"></a><h4 id="使用阿里云的镜像仓库"><a href="#使用阿里云的镜像仓库" class="headerlink" title="使用阿里云的镜像仓库"></a>使用阿里云的镜像仓库</h4><p>首先在阿里云镜像服务控制台创建镜像仓库和命令空间:</p><p><a href="https://cr.console.aliyun.com/cn-hangzhou/repositories" target="_blank" rel="noopener">https://cr.console.aliyun.com/cn-hangzhou/repositories</a></p><p>我的镜像仓库和命名空间都是:jesse_images<br>这是我的镜像仓库地址:registry.cn-hangzhou.aliyuncs.com/jesse_images/jesse_images</p><p>下面演示,如何推送本地镜像到阿里云仓库</p><p>1.在本地docker服务器登陆阿里云镜像仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker_python]$docker login --username=jessehuang408 registry.cn-hangzhou.aliyuncs.com</span><br></pre></td></tr></table></figure><p>2.将本地镜像推送到仓库执行以下两条命令</p><ul><li>为本地镜像打个标签</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker tag [ImageId] registry.cn-hangzhou.aliyuncs.com/jesse_images/jesse_images:[镜像版本号]</span><br></pre></td></tr></table></figure><ul><li>将镜像推送到仓库</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push registry.cn-hangzhou.aliyuncs.com/jesse_images/jesse_images:[镜像版本号]</span><br></pre></td></tr></table></figure><p>下面演示将friendlyhello这个镜像推送到阿里云远程仓库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@localhost docker_python]$docker images</span><br><span class="line">REPOSITORY                                                    TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">friendlyhello                                                 latest              f091d1bb803c        43 minutes ago      131MB</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker tag f091d1bb803c registry.cn-hangzhou.aliyuncs.com/jesse_images/jesse_images:v2.0</span><br><span class="line"></span><br><span class="line">docker push registry.cn-hangzhou.aliyuncs.com/jesse_images/jesse_images:v2.0</span><br></pre></td></tr></table></figure><p>在本机可以看到镜像:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@localhost docker_python]$docker images</span><br><span class="line">REPOSITORY                                                    TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">friendlyhello                                                 latest              f091d1bb803c        43 minutes ago      131MB</span><br><span class="line">registry.cn-hangzhou.aliyuncs.com/jesse_images/jesse_images   v2.0                f091d1bb803c        43 minutes ago      131MB</span><br></pre></td></tr></table></figure><p>登陆阿里云的镜像服务控制台,在镜像仓库的管理界面可以看到上传上去的镜像</p><p>如果是从阿里云镜像仓库拉取镜像,执行以下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo docker pull registry.cn-hangzhou.aliyuncs.com/jesse_images/jesse_images:[镜像版本号]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;docker使用阿里云私有仓库&quot;&gt;&lt;a href=&quot;#docker使用阿里云私有仓库&quot; class=&quot;headerlink&quot; title=&quot;docker使用阿里云私有仓库&quot;&gt;&lt;/a&gt;docker使用阿里云私有仓库&lt;/h3&gt;&lt;p&gt;注册阿里云镜像服务:&lt;/p&gt;
&lt;p&gt;以下是我的阿里云镜像仓库链接:&lt;br&gt;&lt;a href=&quot;https://cr.console.aliyun.com/cn-hangzhou/repositories&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cr.console.aliyun.com/cn-hangzhou/repositories&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;一.使用阿里云镜像加速器&lt;br&gt;&lt;a href=&quot;https://cr.console.aliyun.com/cn-hangzhou/mirrors&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://cr.console.aliyun.com/cn-hangzhou/mirrors&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;镜像加速地址:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;https://0w5ygvsg.mirror.aliyuncs.com&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果是Centos系统,可以通过修改daemon配置文件/etc/docker/daemon.json来使用加速器:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo mkdir -p /etc/docker&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo tee /etc/docker/daemon.json &amp;lt;&amp;lt;-&amp;apos;EOF&amp;apos;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;quot;registry-mirrors&amp;quot;: [&amp;quot;https://0w5ygvsg.mirror.aliyuncs.com&amp;quot;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;EOF&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo systemctl daemon-reload&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo systemctl restart docker&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="docker" scheme="https://jesse.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://jesse.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker学习笔记---Dockerfile</title>
    <link href="https://jesse.top/2020/06/29/docker/docker%E5%AE%98%E7%BD%91%E5%AD%A6%E4%B9%A0%E2%80%942.dockerfile/"/>
    <id>https://jesse.top/2020/06/29/docker/docker官网学习—2.dockerfile/</id>
    <published>2020-06-29T03:59:58.000Z</published>
    <updated>2020-06-30T12:32:51.210Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><p>Dockerfile可以用来编译一个docker镜像.Dockerfile是一个包含一系列指令的文本文档,使用<code>docker build</code>命令,用户可以依据dockerfile和上下文编译一个镜像.</p><p>使用dockerfile需要注意一些事项</p><p><strong>1.上下文</strong></p><p>docker build编译镜像时,会将当前目录下的Dockerfile和所有文件打包添加发送到docker daemon服务端.所以一般情况下创建一个空目录编辑dockerfile文件.然后将需要copy和add的文件放进和dockerfile同一目录下.</p><p>dockerfile中的<code>copy</code>以及<code>add</code>命令,添加文件到docker镜像中时.不要使用绝对路径.例如/home/work/a.txt..docker deamon只能识别到当前上下文环境,无法识别到其他目录.但是可以使用当前上下文的相对路径.</p><p><strong>2.分层</strong></p><p>dockerfile编译镜像时,每条指令都是一个镜像层.除了From指令外,每一行指令都是基于上一行生成的临时镜像运行一个容器.执行一条指令就类似于docker commit命令生成一个新的镜像.所以两条指令之间互不关联.</p><a id="more"></a><p>例如,下列的dockerfile并不能在/data/目录下创建files文件.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">RUN mkdir /data</span><br><span class="line">RUN cd /data</span><br><span class="line">RUN touch files</span><br></pre></td></tr></table></figure><p>下列的dockerfile甚至不会创建/data/file文件,也不会修改/data/目录权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">RUN useradd foo</span><br><span class="line">VOLUME /data</span><br><span class="line">RUN touch /data/file</span><br><span class="line">RUN chown -R foo:foo /data</span><br></pre></td></tr></table></figure></p><p>想要实现这个需求,可以这样写:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">RUN useradd foo</span><br><span class="line">RUN mkdir /data &amp;&amp; touch /data/file</span><br><span class="line">RUN chown -R foo:foo /data</span><br><span class="line">VOLUME /data</span><br></pre></td></tr></table></figure><hr><p><strong>3.精简</strong></p><p>由于dockerfile在构建镜像时,dockerfile文本中每一行语句会产生每一层镜像.</p><p>例如下面这个dockerfile:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">From ubuntu</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get -y install vim git wget net-tools</span><br><span class="line">RUN useradd foo</span><br><span class="line">RUN mkdir /data</span><br><span class="line">RUN touch /data/file</span><br><span class="line">RUN chown -R foo:foo /data</span><br></pre></td></tr></table></figure><p>在编译时,每一个RUN语句都会构建一层镜像.(实际上所有指令都是这样,不仅仅是RUN)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]$docker build -t test:v1 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/7 : From ubuntu</span><br><span class="line"> ---&gt; 94e814e2efa8</span><br><span class="line">Step 2/7 : RUN apt-get update</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 5520126e7fcc</span><br><span class="line">Step 3/7 : RUN apt-get -y install vim git wget net-tools</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; cb24e170539c</span><br><span class="line">Step 4/7 : RUN useradd foo</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; ca31aeba0309</span><br><span class="line">Step 5/7 : RUN mkdir /data</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; d5c6e0f32f6b</span><br><span class="line">Step 6/7 : RUN touch /data/file</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 9c4b06e9b25d</span><br><span class="line">Step 7/7 : RUN chown -R foo:foo /data</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 75ecea0b0795</span><br><span class="line">Successfully built 75ecea0b0795</span><br><span class="line">Successfully tagged test:v1</span><br></pre></td></tr></table></figure><p>这种写法会导致镜像层非常多,镜像文件也会相对较大.所以一般推荐更精简的语法,每一条功能相同的语句,尽量写在一行.上面的dockerfile可以优化成:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">From ubuntu</span><br><span class="line">RUN apt-get update \</span><br><span class="line">    &amp;&amp; apt-get -y install \</span><br><span class="line">       vim \</span><br><span class="line">       git \</span><br><span class="line">       wget \</span><br><span class="line">       net-tools</span><br><span class="line"></span><br><span class="line">RUN useradd foo</span><br><span class="line">RUN mkdir /data &amp;&amp;  touch /data/file &amp;&amp;  chown -R foo:foo /data</span><br></pre></td></tr></table></figure><p>这次编译只需构建4层镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]$docker build -t test:v1 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/4 : From ubuntu</span><br><span class="line"> ---&gt; 94e814e2efa8</span><br><span class="line">Step 2/4 : RUN apt-get update     &amp;&amp; apt-get -y install        vim        git        wget        net-tools</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 7aa2bc9041e0</span><br><span class="line">Step 3/4 : RUN useradd foo</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 5a13764414e6</span><br><span class="line">Step 4/4 : RUN mkdir /data &amp;&amp;  touch /data/file &amp;&amp;  chown -R foo:foo /data</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; bd61817d7526</span><br><span class="line">Successfully built bd61817d7526</span><br><span class="line">Successfully tagged test:v1</span><br></pre></td></tr></table></figure><p>4.使用<code>no-install-recommends</code></p><p>如果是使用APT包管理器,则应该在执行apt-get install 命令时加上<code>no-install-recommends`</code>参数.这样ATP就仅安装核心依赖.而不安装其他推荐和建议的包,这会显著减少不必要包的下载数量</p><hr><h3 id="Dockerfile指令介绍"><a href="#Dockerfile指令介绍" class="headerlink" title="Dockerfile指令介绍"></a>Dockerfile指令介绍</h3><p>介绍完Dockerfile的概念和特点后,接下来了解一下Dockerfile语法中的具体指令的介绍和用法</p><p>下面是一个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Use an official Python runtime as a parent image</span><br><span class="line">FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line"># Set the working directory to /app</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># Copy the current directory contents into the container at /app</span><br><span class="line">COPY . /app</span><br><span class="line"></span><br><span class="line"># Install any needed packages specified in requirements.txt</span><br><span class="line">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class="line"></span><br><span class="line"># Make port 80 available to the world outside this container</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"># Define environment variable</span><br><span class="line">ENV NAME World</span><br><span class="line"></span><br><span class="line"># Run app.py when the container launches</span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure><hr><ul><li>FROM </li></ul><p>格式: <code>FROM image</code> 或者 <code>FROM image:tag</code></p><p>表示从一个基础镜像构建.Dockerfile必须以FROM语句作为第一条非注释语句.</p><ul><li><p>WORKDIR: 表示工作目录,后续的相对路径也是基于这个目录</p></li><li><p>COPY</p></li></ul><p>格式: <code>copy src dest</code></p><p>复制宿主机上的文件到镜像中.src是当前上下文中的文件或者目录.dest是容器中的目标文件或者目录.src指定的源可以有多个.此外 src还支持通配符.例如: <code>COPY hom* /mydir/</code> 表示添加所有当前目录下的hom开头的文件到目录/mydir/下</p><p><dest>可以是文件或者目录.但是必须是镜像中的绝对路径,或者是WORKDIR的相对路径.若<dest>以反斜杠/结尾,则指向的是目录,否则指向文件.当 src 有多个源时, dest必须是目录.如果 dest 目录不存在,则会自动被创建</dest></dest></p><ul><li>ADD</li></ul><p>格式: <code>ADD src dest</code></p><p> ADD和COPY命令有相同功能,都支持复制本地文件到镜像里.但ADD能从互联网的URL下载文件到镜像..src还可以是一个本地的压缩归档文件.ADD会自动将tar,gz等压缩包上传到镜像后进行解压.</p><p> 但是如果src是一个URL的归档格式文件,则不会自动解压.</p><ul><li>RUN</li></ul><p>RUN命令有两种格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN &lt;command&gt; (shell格式)  </span><br><span class="line">RUN [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec格式)</span><br></pre></td></tr></table></figure><p>RUN指令的两种格式表示命令在容器中的两种运行方式.当使用shell格式时,命令通过<code>/bin/sh -c</code>运行.当使用exec格式时.命令直接运行,不调用shell程序.exec格式中的参数会被当成JSON数组被Docker解析.所以必须使用双引号,不能使用单引号. </p><p>另外由于exec格式不会在shell中运行.所以无法识别ENV环境变量.例如当执行<code>CMD [&quot;echo&quot;,&quot;$HOME&quot;]</code>时,$HOME不会被变量替换.如果希望运行shell程序.可以写成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;sh&quot;,&quot;-c&quot;,&quot;echo&quot;,&quot;$HOME&quot;]</span><br></pre></td></tr></table></figure><ul><li>EXPOSE: 镜像需要暴露出来的端口. </li></ul><blockquote><p>要注意的是,这里只是说明镜像需要暴露哪些端口,在镜像构建完毕,启动容器时,仍然需要-p参数来映射端口,否则端口不会自动映射</p></blockquote><ul><li><p>ENV</p><p>格式: <code>ENV &lt;key&gt; &lt;value&gt;</code> 或者 <code>ENV &lt;key&gt;=&lt;value&gt;</code></p><p>ENV指令用来声明环境变量,并且可以被(ADD,COPY,WORKDIR等)指令调用.调用ENV环境变量的格式和shell一样:<code>\$variable_name</code>或者 <code>\${variable_name}</code></p></li><li><p>CMD </p></li></ul><p>CMD命令有3种格式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD &lt;command&gt; (shell格式)  </span><br><span class="line">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec格式)  </span><br><span class="line">CMD [&quot;param1&quot;,&quot;param2&quot;] (为ENTRYPOINT命令提供参数)</span><br></pre></td></tr></table></figure><p>CMD提供容器启动后执行的命令.或者是为ENTRYPOINT传递一些参数.一个dockerfile文件只允许存在一条CMD指令.如果存在多条CMD指令,以最后一条为准.但是如果用户在 docker run 时指定了命令,则会覆盖CMD中的指令</p><ul><li>ENTRYPOINT</li></ul><p>ENTRYPOINT有两种格式.和上文CMD一样分为shell格式和exec格式.</p><p>ENTRYPOINT和CMD类似,指定容器启动时执行的命令.和CMD一样一个Dockerfile文件中可以有多个ENTRYPOINT命令.但只有最后一条生效.但是又有一些区别.当使用shell格式时,ENTRYPOINT会忽略任何CMD指令和 <code>docker run</code>启动容器时手动输入的指令.并且会运行在 /bin/sh -c环境中,成为它的子进程.进程在容器中PID不是1,也不能接收UNIX信号.(也就是在执行 <code>docker stop &lt;container&gt;</code>时,进程接收不到SIGTERM指令)</p><p>当使用exec格式时, docker run 手动指定的命令,将作为参数覆盖CMD指定的参数传递到ENTRYPOINT.(也就是说 docker run启动容器时指定的不再是具体命令,而是命令的参数).</p><hr><p>创建上面dockerfile中所需要的app.py和requirements.txt文件,并且将他们和Dockerfile文件放在同一目录下:</p><p>requirements.txt:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker_python]$cat requirements.txt</span><br><span class="line">Flask</span><br><span class="line">Redis</span><br></pre></td></tr></table></figure><p>app.py:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">root@localhost docker_python]$cat app.py</span><br><span class="line">from flask import Flask</span><br><span class="line">from redis import Redis, RedisError</span><br><span class="line">import os</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line"># Connect to Redis</span><br><span class="line">redis = Redis(host=&quot;redis&quot;, db=0, socket_connect_timeout=2, socket_timeout=2)</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">def hello():</span><br><span class="line">    try:</span><br><span class="line">        visits = redis.incr(&quot;counter&quot;)</span><br><span class="line">    except RedisError:</span><br><span class="line">        visits = &quot;&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;&quot;</span><br><span class="line"></span><br><span class="line">    html = &quot;&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Visits:&lt;/b&gt; &#123;visits&#125;&quot;</span><br><span class="line">    return html.format(name=os.getenv(&quot;NAME&quot;, &quot;world&quot;), hostname=socket.gethostname(), visits=visits)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run(host=&apos;0.0.0.0&apos;, port=80)</span><br><span class="line">[root@localhost docker_python]$</span><br></pre></td></tr></table></figure><hr><h4 id="开始构建镜像"><a href="#开始构建镜像" class="headerlink" title="开始构建镜像"></a>开始构建镜像</h4><p>首先确保Dockerfile里所需的文件,以及Dockerfile都在同一目录下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker_python]$ls</span><br><span class="line">app.py  Dockerfile  requirements.txt</span><br></pre></td></tr></table></figure><p>运行以下命令来构建一个镜像.使用–tag参数(或者-t),可以为镜像打个标签:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --tag=friendlyhello .</span><br></pre></td></tr></table></figure><p>构建过程略..在构建过程中,注意以下现象:</p><p>1.构建镜像层:</p><p>部分指令会创建一个新的镜像层,而有些指令则不会.关于如何区分命令是否会新建镜像层,一个基本的原则是:</p><p>如果指令的作用是像镜像中添加新的文件或者程序,那么就会新建镜像层.(例如:RUN,COPY,ADD,FROM等)</p><p>如果只是告诉docker如何构建或者运行应用程序,增加或者修改容器的元数据,那么不会构建新的镜像层.(例如:WORKDIR,EXPOSE,ENV,ENTERPOINT等)</p><p>2.构建步骤:</p><p>基本等过程大致为:</p><p>运行临时容器—-&gt;在该容器中运行Dockerfile指令—-&gt;将运行结果保存为一个新等镜像层——&gt; 删除临时容器</p><p>构建完成后,通过以下命令可以看到构建的镜像</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker_python]$docker images</span><br><span class="line">REPOSITORY                 TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line">friendlyhello              latest              f091d1bb803c        About a minute ago   131MB</span><br></pre></td></tr></table></figure><blockquote><p>或者也可以是输入以下命令 docker image ls</p></blockquote><blockquote><p>可能会疑惑,为什么tag标签是latest..镜像的完整标签格式应该是:friendlyhello:lastest.<br>如果需要在构建镜像时指定版本.可以使用: –tag=friendlyhello:v0.0.1</p></blockquote><hr><h4 id="使用构建的镜像启动一个容器"><a href="#使用构建的镜像启动一个容器" class="headerlink" title="使用构建的镜像启动一个容器"></a>使用构建的镜像启动一个容器</h4><p>输入以下命令,利用刚才的镜像启动一个容器:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4000:80 friendlyhello</span><br></pre></td></tr></table></figure><p>执行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker_python]$docker run -p 4000:80 friendlyhello</span><br><span class="line"> * Serving Flask app &quot;app&quot; (lazy loading)</span><br><span class="line"> * Environment: production</span><br><span class="line">   WARNING: Do not use the development server in a production environment.</span><br><span class="line">   Use a production WSGI server instead.</span><br><span class="line"> * Debug mode: off</span><br><span class="line"> * Running on http://0.0.0.0:80/ (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure><ul><li>docker run 表示启动一个容器</li><li>-p 宿主机端口:容器端口  表示将宿主机的端口映射给容器.如果是-P 80 表示随机映射一个宿主机的端口给容器</li></ul><p>此时可以在其他电脑上访问这个容器的80端口,下面是在我的PC上访问宿主机的4000端口,也就是刚才启动的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> ✘ huangyong@huangyong-Macbook-Pro  ~  curl http://10.0.0.50:4000</span><br><span class="line">&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; f9b1b804404f&lt;br/&gt;&lt;b&gt;Visits:&lt;/b&gt; &lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;%</span><br></pre></td></tr></table></figure><p>容器默认是在前台执行,加上-d参数可以时容器运行在后台:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 4000:80 friendlyhello</span><br></pre></td></tr></table></figure><p>docker ps命令可以显示正在运行中的容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker_python]$docker ps</span><br><span class="line">CONTAINER ID        IMAGE                      COMMAND             CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">fcf7d29ac627        friendlyhello              &quot;python app.py&quot;     5 seconds ago       Up 1 second         0.0.0.0:4000-&gt;80/tcp     stoic_colden</span><br></pre></td></tr></table></figure><blockquote><p>docker container ls命令也有同样的效果</p></blockquote><hr><p>这一节(包括第3小节)涉及到的基础命令如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker build -t friendlyhello .  # Create image using this directory&apos;s Dockerfile</span><br><span class="line">docker run -p 4000:80 friendlyhello  # Run &quot;friendlyname&quot; mapping port 4000 to 80</span><br><span class="line">docker run -d -p 4000:80 friendlyhello         # Same thing, but in detached mode</span><br><span class="line">docker container ls                                # List all running containers</span><br><span class="line">docker container ls -a             # List all containers, even those not running</span><br><span class="line">docker container stop &lt;hash&gt;           # Gracefully stop the specified container</span><br><span class="line">docker container kill &lt;hash&gt;         # Force shutdown of the specified container</span><br><span class="line">docker container rm &lt;hash&gt;        # Remove specified container from this machine</span><br><span class="line">docker container rm $(docker container ls -a -q)         # Remove all containers</span><br><span class="line">docker image ls -a                             # List all images on this machine</span><br><span class="line">docker image rm &lt;image id&gt;            # Remove specified image from this machine</span><br><span class="line">docker image rm $(docker image ls -a -q)   # Remove all images from this machine</span><br><span class="line">docker login             # Log in this CLI session using your Docker credentials</span><br><span class="line">docker tag &lt;image&gt; username/repository:tag  # Tag &lt;image&gt; for upload to registry</span><br><span class="line">docker push username/repository:tag            # Upload tagged image to registry</span><br><span class="line">docker run username/repository:tag                   # Run image from a registry</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Dockerfile&quot;&gt;&lt;a href=&quot;#Dockerfile&quot; class=&quot;headerlink&quot; title=&quot;Dockerfile&quot;&gt;&lt;/a&gt;Dockerfile&lt;/h3&gt;&lt;p&gt;Dockerfile可以用来编译一个docker镜像.Dockerfile是一个包含一系列指令的文本文档,使用&lt;code&gt;docker build&lt;/code&gt;命令,用户可以依据dockerfile和上下文编译一个镜像.&lt;/p&gt;
&lt;p&gt;使用dockerfile需要注意一些事项&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1.上下文&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;docker build编译镜像时,会将当前目录下的Dockerfile和所有文件打包添加发送到docker daemon服务端.所以一般情况下创建一个空目录编辑dockerfile文件.然后将需要copy和add的文件放进和dockerfile同一目录下.&lt;/p&gt;
&lt;p&gt;dockerfile中的&lt;code&gt;copy&lt;/code&gt;以及&lt;code&gt;add&lt;/code&gt;命令,添加文件到docker镜像中时.不要使用绝对路径.例如/home/work/a.txt..docker deamon只能识别到当前上下文环境,无法识别到其他目录.但是可以使用当前上下文的相对路径.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2.分层&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;dockerfile编译镜像时,每条指令都是一个镜像层.除了From指令外,每一行指令都是基于上一行生成的临时镜像运行一个容器.执行一条指令就类似于docker commit命令生成一个新的镜像.所以两条指令之间互不关联.&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="https://jesse.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://jesse.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>kuberentes Ingress</title>
    <link href="https://jesse.top/2020/06/26/kubernetes/kubernetes%20Ingress/"/>
    <id>https://jesse.top/2020/06/26/kubernetes/kubernetes Ingress/</id>
    <published>2020-06-26T03:59:58.000Z</published>
    <updated>2020-06-26T10:04:38.304Z</updated>
    
    <content type="html"><![CDATA[<h2 id="kuberentes-Ingress"><a href="#kuberentes-Ingress" class="headerlink" title="kuberentes Ingress"></a>kuberentes Ingress</h2><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://segmentfault.com/a/1190000019908991" target="_blank" rel="noopener">K8s ingress 学习博客</a></p><p>ingress是暴露服务给外部客户端的另外一种方法.(前面我们学习过2种服务类型可以实现同样的目的:NodePort和LoadBalance)</p><p>但是这几种Service都有局限性:</p><ul><li>ClusterIP的默认Serivce方式只能在集群内部访问。</li><li><p>NodePort:当有几十上百的服务在集群中运行时，NodePort的端口管理是灾难。</p></li><li><p>LoadBalance方式受限于云平台，且通常在云平台部署ELB还需要额外的费用。</p></li></ul><p>所幸k8s还提供了一种集群维度暴露服务的方式，也就是ingress。ingress可以简单理解为service的service，他通过独立的ingress对象来制定请求转发的规则，把请求路由到一个或多个service中。这样就把服务与请求规则解耦了，可以从业务维度统一考虑业务的暴露，而不用为每个service单独考虑。</p><p>Ingress可以为多个Service提供服务,可以根据请求的HOST和PATH,将请求代理到相关的Service中.而且Ingres工作在HTTP层,可以实现7层代理特性,诸如:coockies和会话亲和力</p><a id="more"></a><hr><h2 id="ingress与ingress-controller"><a href="#ingress与ingress-controller" class="headerlink" title="ingress与ingress-controller"></a>ingress与ingress-controller</h2><p>要理解ingress，需要区分两个概念，ingress和ingress-controller：</p><ul><li>ingress对象：</li></ul><p>指的是k8s中的一个api对象，一般用yaml配置。作用是定义请求如何转发到service的规则，可以理解为配置模板。</p><ul><li>ingress-controller：</li></ul><p>具体实现反向代理及负载均衡的程序，对ingress定义的规则进行解析，根据配置的规则来实现请求转发。</p><p>简单来说，ingress-controller才是负责具体转发的组件，通过各种方式将它暴露在集群入口，外部对集群的请求流量会先到ingress-controller，而ingress对象是用来告诉ingress-controller该如何转发请求，比如哪些域名哪些path要转发到哪些服务等等。</p><hr><h2 id="ingress-controller"><a href="#ingress-controller" class="headerlink" title="ingress-controller"></a>ingress-controller</h2><p>ingress-controller并不是k8s自带的组件，实际上ingress-controller只是一个统称，用户可以选择不同的ingress-controller实.</p><p>目前，由k8s维护的ingress-controller只有google云的GCE与ingress-nginx两个，其他还有很多第三方维护的ingress-controller，具体可以参考官方文档。</p><p>但是不管哪一种ingress-controller，实现的机制都大同小异，只是在具体配置上有差异。一般来说，ingress-controller的形式都是一个pod，里面跑着daemon程序和反向代理程序。daemon负责不断监控集群的变化，根据ingress对象生成配置并应用新配置到反向代理，比如nginx-ingress就是动态生成nginx配置，动态更新upstream，并在需要的时候reload程序应用新配置。</p><p>为了方便，后面的例子都以k8s官方维护的nginx-ingress为例。</p><hr><h2 id="ingress"><a href="#ingress" class="headerlink" title="ingress"></a>ingress</h2><p>ingress是一个API对象，和其他对象一样，通过yaml文件来配置。ingress通过http或https暴露集群内部service，给service提供外部URL、负载均衡、SSL/TLS能力以及基于host的方向代理。ingress要依靠ingress-controller来具体实现以上功能。</p><hr><h2 id="ingress的部署"><a href="#ingress的部署" class="headerlink" title="ingress的部署"></a>ingress的部署</h2><p>ingress的部署，需要考虑两个方面：</p><p>1.ingress-controller是作为pod来运行的，以什么方式部署比较好</p><p>2.ingress解决了把如何请求路由到集群内部，那它自己怎么暴露给外部比较好</p><p>下面列举一些目前常见的部署和暴露方式，具体使用哪种方式还是得根据实际需求来考虑决定。</p><p><strong>Deployment+LoadBalancer模式的Service</strong></p><p>如果要把ingress部署在公有云，那用这种方式比较合适。用Deployment部署ingress-controller，创建一个type为LoadBalancer的service关联这组pod。大部分公有云，都会为LoadBalancer的service自动创建一个负载均衡器，通常还绑定了公网地址。只要把域名解析指向该地址，就实现了集群服务的对外暴露。</p><p><strong>Deployment+NodePort模式的Service</strong></p><p>同样用deployment模式部署ingress-controller，并创建对应的服务，但是type为NodePort。这样，ingress就会暴露在集群节点ip的特定端口上。由于nodeport暴露的端口是随机端口，一般会在前面再搭建一套负载均衡器来转发请求。该方式一般用于宿主机是相对固定的环境ip地址不变的场景。<br>NodePort方式暴露ingress虽然简单方便，但是NodePort多了一层NAT，在请求量级很大时可能对性能会有一定影响。</p><p><strong>DaemonSet+HostNetwork+nodeSelector</strong></p><p>用DaemonSet结合nodeselector来部署ingress-controller到特定的node上，然后使用HostNetwork直接把该pod与宿主机node的网络打通，直接使用宿主机的80/433端口就能访问服务。这时，ingress-controller所在的node机器就很类似传统架构的边缘节点，比如机房入口的nginx服务器。该方式整个请求链路最简单，性能相对NodePort模式更好。缺点是由于直接利用宿主机节点的网络和端口，一个node只能部署一个ingress-controller pod。比较适合大并发的生产环境使用。</p><hr><h2 id="ingress-controller部署"><a href="#ingress-controller部署" class="headerlink" title="ingress-controller部署"></a>ingress-controller部署</h2><p>参考文档: <a href="https://www.kuboard.cn/install/install-k8s.html#%E5%AE%89%E8%A3%85-ingress-controller" target="_blank" rel="noopener">kubernetes集群部署</a></p><hr><h2 id="配置一个简单的Ingress对象"><a href="#配置一个简单的Ingress对象" class="headerlink" title="配置一个简单的Ingress对象"></a>配置一个简单的Ingress对象</h2><p>编辑一个简单的yaml配置文件如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# cat kubia-ingress.yaml</span><br><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia</span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">    - host: kubia.example.com </span><br><span class="line">      http:</span><br><span class="line">        paths:</span><br><span class="line">        - path: /</span><br><span class="line">          backend:</span><br><span class="line">            #将访问请求转发到上一节中创建的kubia-svc-nodeport的Serivce上</span><br><span class="line">            serviceName: kubia-svc-nodeport</span><br><span class="line">            #kubia-svc-nodeport的源端口</span><br><span class="line">            servicePort: 80</span><br></pre></td></tr></table></figure><p>接下来,可以将kubia.exanple.com域名解析到任意一个Node服务器节点的IP地址,然后请求这个域名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> huangyong@huangyong-Macbook-Pro  ~  curl http://kubia.example.com</span><br><span class="line">You&apos;ve hit kubia-hd429</span><br><span class="line"> huangyong@huangyong-Macbook-Pro  ~  curl http://kubia.example.com</span><br><span class="line">You&apos;ve hit kubia-fcc59</span><br><span class="line"> huangyong@huangyong-Macbook-Pro  ~  curl http://kubia.example.com</span><br><span class="line">You&apos;ve hit kubia-rm9qf</span><br></pre></td></tr></table></figure><hr><h2 id="ingress关联多个Service"><a href="#ingress关联多个Service" class="headerlink" title="ingress关联多个Service"></a>ingress关联多个Service</h2><p>ingress的rules字段可以包含多个转发规则,可以将不同的访问URL或者HOST代理到相关联的不同的Service中.参考下面的例子</p><ul><li>不同的PATH转发到不同的Service</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia-ingress-kubia</span><br><span class="line"></span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">    - host: kubia.example.com</span><br><span class="line">      paths:</span><br><span class="line">       - path: /foo</span><br><span class="line">         backend:</span><br><span class="line">            serviceName: kubia-svc-foo</span><br><span class="line">            servicePort: 80</span><br><span class="line"></span><br><span class="line">       - path: /bar</span><br><span class="line">         backend:</span><br><span class="line">            serviceName: kubia-svc-bar</span><br><span class="line">            servicePort: 80</span><br></pre></td></tr></table></figure><ul><li>不同的Host转发到不同的Service</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia-ingress-kubia2</span><br><span class="line"></span><br><span class="line">spec:</span><br><span class="line">  rules:</span><br><span class="line">    - host: foo.example.com</span><br><span class="line">      paths:</span><br><span class="line">       - path: /</span><br><span class="line">         backend:</span><br><span class="line">            serviceName: kubia-svc-foo</span><br><span class="line">            servicePort: 80</span><br><span class="line">    - host: bar.example.com</span><br><span class="line">      paths:</span><br><span class="line">       - path: /</span><br><span class="line">         backend:</span><br><span class="line">            serviceName: kubia-svc-bar</span><br><span class="line">            servicePort: 80</span><br></pre></td></tr></table></figure><hr><h2 id="Ingress处理https-TLS传输"><a href="#Ingress处理https-TLS传输" class="headerlink" title="Ingress处理https TLS传输"></a>Ingress处理https TLS传输</h2><p>当用户使用TLS链接时,ingress负责处理用户的TLS请求,但是和后端的Pod仍然是以http连接,要实现这一点,Https的证书和秘钥必须挂载在ingress控制器上.</p><p>证书和秘钥可以保存在kubernetes的secret资源对象中.然后在ingress的mainfest资源中引用.</p><p>下面先创建一个自签名的证书和私钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# openssl genrsa -out tls.key 2048</span><br><span class="line"></span><br><span class="line">[root@k8s-master ~]#openssl req -new -x509 -key tls.key -out tls.cert -days 360 -subj /CN=kubia.example.com</span><br></pre></td></tr></table></figure><p>创建Secret</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl create secret tls tls-secret --cert=tls.cert --key=tls.key</span><br><span class="line">secret/tls-secret created</span><br></pre></td></tr></table></figure><h3 id="创建https的ingress"><a href="#创建https的ingress" class="headerlink" title="创建https的ingress"></a>创建https的ingress</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">apiVersion: extensions/v1beta1</span><br><span class="line">kind: Ingress</span><br><span class="line">metadata:</span><br><span class="line">  name: kubia</span><br><span class="line">spec:</span><br><span class="line">  tls:</span><br><span class="line">   - hosts:</span><br><span class="line">     - kubia.example.com</span><br><span class="line">     secretName: tls-secret</span><br><span class="line"></span><br><span class="line">  rules:</span><br><span class="line">   - host: kubia.example.com</span><br><span class="line">     http:</span><br><span class="line">       paths:</span><br><span class="line">         - path: /</span><br><span class="line">           backend:</span><br><span class="line">              serviceName: kubia</span><br><span class="line">              servicePort: 80</span><br></pre></td></tr></table></figure><p>更新ingress资源kubia</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl apply -f kubia-ingress-tls.yaml</span><br><span class="line">ingress.extensions/kubia configured</span><br></pre></td></tr></table></figure><p>ingress支持443端口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-master ~]# kubectl get ing</span><br><span class="line">NAME    HOSTS               ADDRESS   PORTS     AGE</span><br><span class="line">kubia   kubia.example.com             80, 443   6h4m</span><br></pre></td></tr></table></figure><p>现在客户端可以https访问kubia.expample.com</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> ✘ huangyong@huangyong-Macbook-Pro  ~  curl -k https://kubia.example.com</span><br><span class="line">You&apos;ve hit kubia-xgnkq</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;kuberentes-Ingress&quot;&gt;&lt;a href=&quot;#kuberentes-Ingress&quot; class=&quot;headerlink&quot; title=&quot;kuberentes Ingress&quot;&gt;&lt;/a&gt;kuberentes Ingress&lt;/h2&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://segmentfault.com/a/1190000019908991&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;K8s ingress 学习博客&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;ingress是暴露服务给外部客户端的另外一种方法.(前面我们学习过2种服务类型可以实现同样的目的:NodePort和LoadBalance)&lt;/p&gt;
&lt;p&gt;但是这几种Service都有局限性:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ClusterIP的默认Serivce方式只能在集群内部访问。&lt;/li&gt;
&lt;li&gt;&lt;p&gt;NodePort:当有几十上百的服务在集群中运行时，NodePort的端口管理是灾难。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;LoadBalance方式受限于云平台，且通常在云平台部署ELB还需要额外的费用。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所幸k8s还提供了一种集群维度暴露服务的方式，也就是ingress。ingress可以简单理解为service的service，他通过独立的ingress对象来制定请求转发的规则，把请求路由到一个或多个service中。这样就把服务与请求规则解耦了，可以从业务维度统一考虑业务的暴露，而不用为每个service单独考虑。&lt;/p&gt;
&lt;p&gt;Ingress可以为多个Service提供服务,可以根据请求的HOST和PATH,将请求代理到相关的Service中.而且Ingres工作在HTTP层,可以实现7层代理特性,诸如:coockies和会话亲和力&lt;/p&gt;
    
    </summary>
    
      <category term="kubernetes" scheme="https://jesse.top/categories/kubernetes/"/>
    
    
      <category term="k8s" scheme="https://jesse.top/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>harbor私有仓库部署</title>
    <link href="https://jesse.top/2020/06/26/docker/harbor%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E9%83%A8%E7%BD%B2/"/>
    <id>https://jesse.top/2020/06/26/docker/harbor私有仓库部署/</id>
    <published>2020-06-26T03:59:58.000Z</published>
    <updated>2020-06-26T03:03:12.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="harbor私有仓库部署"><a href="#harbor私有仓库部署" class="headerlink" title="harbor私有仓库部署"></a>harbor私有仓库部署</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>harbor是docker的私有仓库,可以部署在局域网服务器上,用来管理docker镜像.虽然docker官方也提供公共镜像仓库,但是由于是境外网站,拉取镜像速度非常慢,而且有被墙的可能.部署私有仓库非常有必要</p><p>harbor是vmware公司开源的企业级的docker registry管理项目.</p><blockquote><p>处于数据脱敏需要,以下内容中隐藏了真实域名.而使用hub.xxxxxx.com替代</p></blockquote><hr><h3 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h3><p>harbor github: <a href="https://github.com/goharbor/harbor" target="_blank" rel="noopener">goharbor/harbor</a></p><p>官网文档介绍: <a href="https://goharbor.io/docs/1.10/" target="_blank" rel="noopener">harbor doc</a></p><p>在部署中遇到的各种坑,都可以通过查阅文档,或者搜索github的issue解决</p><hr><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>harbor是docker-compose部署的.包括一系列组件:nginx.core,log,register等等.</p><p>但是由于本机已经存在一个Nginx镜像.所以用Nginx代理到harbor的Nginx.<strong>如果是独立的服务器部署Harbor的话,则不会存在这个问题,可以直接跳过这一章节.</strong></p><p>nginx代理框架大概是:</p><p><strong>nginx—-&gt;harbor-nginx—–&gt;habor</strong></p><p>由于docker提交镜像需要Https协议,所以:</p><p><strong>nginx—301跳转到nginx https—–&gt;harbor-nginx http—-&gt; habor</strong></p><p>但是这样的部署方式,有一个问题:</p><p>私有仓库可以正常login但是push镜像的时候,又提示未验证.</p><p>该问题尝试过很多解决方案,但是均无法解决</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@idc-function-docker ~]# docker login --username=admin -pHarbor12345 hub.xxxxxx.com</span><br><span class="line">WARNING! Using --password via the CLI is insecure. Use --password-stdin.</span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br><span class="line">[root@idc-function-docker ~]# docker push hub.xxxxxx.com/master/nginx:latest</span><br><span class="line">The push refers to repository [hub.xxxxxx.com/master/nginx]</span><br><span class="line">d37eecb5b769: Pushing [==================================================&gt;]  3.584kB</span><br><span class="line">99134ec7f247: Preparing</span><br><span class="line">c3a984abe8a8: Preparing</span><br><span class="line">unauthorized: authentication required</span><br></pre></td></tr></table></figure><p>所以现在的架构是</p><p><strong>nginx—301跳转到Nginx https——&gt; harbor-nginx https——&gt;harbor</strong></p><hr><h3 id="harbor部署前提条件"><a href="#harbor部署前提条件" class="headerlink" title="harbor部署前提条件"></a>harbor部署前提条件</h3><ul><li>安装docker-ce</li><li>安装docker-composer</li><li>准备一个空目录.比如/data.或者/data/harbor (注意,最好是空目录,不要和其他项目混杂一起)</li><li>安装好https域名证书</li></ul><hr><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>docker和docker-compose的安装就略过了.这里提一句,我用的是acme.sh部署letsencrypt的证书</p><p>接下来开始部署harbor</p><ul><li>1.去github下载离线安装包.离线安装包虽然比较大,但是安装过程快速,且不会中断</li></ul><p>这里安装的是最新版,v1.10.1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在github下载 harbor-offline-installer-v1.10.1.tgz</span><br><span class="line">tar xvf 解压</span><br></pre></td></tr></table></figure><ul><li>2.解压后,进入harbor文件,编辑harbor.yaml配置文件.需要改动以下几个地方</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">hostname hub.xxxxxx.com  #定义主机名,可以使用IP,也可以用域名</span><br><span class="line"></span><br><span class="line">#定义https的服务器证书和秘钥的文件路径</span><br><span class="line">https:</span><br><span class="line">  # https port for harbor, default is 443</span><br><span class="line">  port: 443</span><br><span class="line">  # The path of cert and key files for nginx</span><br><span class="line">  certificate: /data/letsencrypt/hub.xxxxxx.com/fullchain.cer</span><br><span class="line">  private_key: /data/letsencrypt/hub.xxxxxx.com/hub.xxxxxx.com.key</span><br><span class="line">  </span><br><span class="line">#这是harbor命令行和浏览器登陆的初始密码..用户名是admin</span><br><span class="line">harbor_admin_password: Harbor12345</span><br><span class="line"></span><br><span class="line">#这是数据目录,最好是一个空目录</span><br><span class="line">data_volume: /data/apps/harbor</span><br><span class="line"></span><br><span class="line">#日志文件保存路径</span><br><span class="line">log:</span><br><span class="line">    location: /data/logs/harbor</span><br></pre></td></tr></table></figure><ul><li>3.执行install.sh文件.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#该脚本会检查主机的环境,拉取相关镜像.以及根据配置文件生成docker-compose文件.</span><br><span class="line">[root@idc-function-docker harbor]#./install.sh</span><br></pre></td></tr></table></figure><blockquote><p> 这个脚本执行到最后会报错,提示80端口和nginx容器已经被占用了.但是没关系.</p></blockquote><ul><li>4.修改docker-composer文件.(如果本机上没有nginx或者80端口没有被占用,这一步可以不做)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#将Nginx容器名改成hub-nginx</span><br><span class="line">#将80和443的端口映射修改一下,比如我这里</span><br><span class="line">proxy:</span><br><span class="line">    image: goharbor/nginx-photon:v1.10.1</span><br><span class="line">    container_name: hub-nginx</span><br><span class="line">ports:</span><br><span class="line">      - 8081:8080</span><br><span class="line">      - 4443:8443</span><br></pre></td></tr></table></figure><ul><li><ol start="5"><li>启动docker-compose</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@idc-function-docker harbor]#docker-compose up -d</span><br></pre></td></tr></table></figure><ul><li><ol start="6"><li>宿主机的nginx开启代理. (如果不是采用nginx代理的话,可以忽略这一步)</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#我这里是有一个独立的Nginx容器</span><br><span class="line">[root@idc-function-docker harbor]# cat/data/conf/nginx/conf.d/dwd-docker-hub.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">  server_name hub.xxxxxx.com;</span><br><span class="line">  listen 443 ssl http2;</span><br><span class="line">  ssl_certificate  /data/letsencrypt/hub.xxxxxx.com/fullchain.cer;</span><br><span class="line">  ssl_certificate_key /data/letsencrypt/hub.xxxxxx.com/hub.xxxxxx.com.key;</span><br><span class="line">  include /data/letsencrypt/options-ssl-nginx.conf; # managed by Certbot</span><br><span class="line">  ssl_dhparam /data/letsencrypt/ssl-dhparams.pem; # managed by Certbot</span><br><span class="line"></span><br><span class="line">  add_header      Strict-Transport-Security &quot;max-age=31536000&quot; always;</span><br><span class="line">  location / &#123;</span><br><span class="line"></span><br><span class="line">    proxy_pass https://172.16.20.30:4443; #代理到宿主机的4443端口,宿主机会将4443代理到hub-docer容器的443端口</span><br><span class="line">    client_max_body_size 2000m; #这里要定义大一点,否则提交镜像的时候,会提示 413 Request Entity Too Large</span><br><span class="line">                proxy_buffering off;</span><br><span class="line">                proxy_ssl_verify off;</span><br><span class="line">                proxy_set_header Host $http_host;</span><br><span class="line">                proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">                proxy_set_header Connection &quot;Upgrade&quot;;</span><br><span class="line">                proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    if ($host = hub.xxxxxx.com)&#123;</span><br><span class="line">        return 301 https://$host$request_uri;</span><br><span class="line">    &#125; # managed by Certbot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  listen 80;</span><br><span class="line">    server_name hub.xxxxxx.com;</span><br><span class="line">    return 404; # managed by Certbot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此,部署就完成了.</p><p>我之前在部署的过程中遇到无数的坑,,可能都是由于harbor没有使用Https引起的</p><hr><p>浏览器访问<a href="https://hub.xxxxxx.com,用初始的账号密码登陆,可以新建项目,创建用户等" target="_blank" rel="noopener">https://hub.xxxxxx.com,用初始的账号密码登陆,可以新建项目,创建用户等</a>.</p><p>我这里创建了一个master的公开项目</p><hr><p>登陆和push镜像没有任何问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@idc-function-docker ~]# docker login --username=admin -pHarbor12345 hub.xxxxxx.com</span><br><span class="line">WARNING! Using --password via the CLI is insecure. Use --password-stdin.</span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br><span class="line">[root@idc-function-docker ~]# docker push hub.xxxxxx.com/master/nginx:latest</span><br><span class="line">The push refers to repository [hub.xxxxxx.com/master/nginx]</span><br><span class="line">d37eecb5b769: Layer already exists</span><br><span class="line">99134ec7f247: Layer already exists</span><br><span class="line">c3a984abe8a8: Layer already exists</span><br><span class="line">latest: digest: sha256:7ac7819e1523911399b798309025935a9968b277d86d50e5255465d6592c0266 size: 948</span><br><span class="line">[root@idc-function-docker ~]#</span><br></pre></td></tr></table></figure><p>在另外一台客户端上,尝试pull镜像不需要密码.如果需要密码pull镜像,可以将项目设置为私有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$docker pull  hub.xxxxxx.com/master/nginx:latest</span><br><span class="line">latest: Pulling from master/nginx</span><br><span class="line">Digest: sha256:7ac7819e1523911399b798309025935a9968b277d86d50e5255465d6592c0266</span><br><span class="line">Status: Downloaded newer image for hub.xxxxxx.com/master/nginx:latest</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;harbor私有仓库部署&quot;&gt;&lt;a href=&quot;#harbor私有仓库部署&quot; class=&quot;headerlink&quot; title=&quot;harbor私有仓库部署&quot;&gt;&lt;/a&gt;harbor私有仓库部署&lt;/h2&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;harbor是docker的私有仓库,可以部署在局域网服务器上,用来管理docker镜像.虽然docker官方也提供公共镜像仓库,但是由于是境外网站,拉取镜像速度非常慢,而且有被墙的可能.部署私有仓库非常有必要&lt;/p&gt;
&lt;p&gt;harbor是vmware公司开源的企业级的docker registry管理项目.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;处于数据脱敏需要,以下内容中隐藏了真实域名.而使用hub.xxxxxx.com替代&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;社区&quot;&gt;&lt;a href=&quot;#社区&quot; class=&quot;headerlink&quot; title=&quot;社区&quot;&gt;&lt;/a&gt;社区&lt;/h3&gt;&lt;p&gt;harbor github: &lt;a href=&quot;https://github.com/goharbor/harbor&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;goharbor/harbor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官网文档介绍: &lt;a href=&quot;https://goharbor.io/docs/1.10/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;harbor doc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在部署中遇到的各种坑,都可以通过查阅文档,或者搜索github的issue解决&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;框架&quot;&gt;&lt;a href=&quot;#框架&quot; class=&quot;headerlink&quot; title=&quot;框架&quot;&gt;&lt;/a&gt;框架&lt;/h3&gt;&lt;p&gt;harbor是docker-compose部署的.包括一系列组件:nginx.core,log,register等等.&lt;/p&gt;
&lt;p&gt;但是由于本机已经存在一个Nginx镜像.所以用Nginx代理到harbor的Nginx.&lt;strong&gt;如果是独立的服务器部署Harbor的话,则不会存在这个问题,可以直接跳过这一章节.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;nginx代理框架大概是:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;nginx—-&amp;gt;harbor-nginx—–&amp;gt;habor&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于docker提交镜像需要Https协议,所以:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;nginx—301跳转到nginx https—–&amp;gt;harbor-nginx http—-&amp;gt; habor&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是这样的部署方式,有一个问题:&lt;/p&gt;
&lt;p&gt;私有仓库可以正常login但是push镜像的时候,又提示未验证.&lt;/p&gt;
&lt;p&gt;该问题尝试过很多解决方案,但是均无法解决&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="https://jesse.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://jesse.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker安装最新版Kong(v1.0)+konga</title>
    <link href="https://jesse.top/2020/06/26/Linux-Web/docker%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88Kong(v1.0)%20konga/"/>
    <id>https://jesse.top/2020/06/26/Linux-Web/docker安装最新版Kong(v1.0) konga/</id>
    <published>2020-06-26T03:59:58.000Z</published>
    <updated>2020-06-26T07:32:53.722Z</updated>
    
    <content type="html"><![CDATA[<h3 id="docker安装最新版Kong-v1-0-konga"><a href="#docker安装最新版Kong-v1-0-konga" class="headerlink" title="docker安装最新版Kong(v1.0)+konga"></a>docker安装最新版Kong(v1.0)+konga</h3><p>参考以下文档:</p><p><a href="https://docs.konghq.com/install/docker/?_ga=2.167535422.1288669860.1553147426-917309945.1539077269" target="_blank" rel="noopener">Kong installation</a></p><p><a href="https://github.com/pantsel/konga#installation" target="_blank" rel="noopener">konga github</a></p><hr><h4 id="docker安装kong-postgresql"><a href="#docker安装kong-postgresql" class="headerlink" title="docker安装kong+postgresql"></a>docker安装kong+postgresql</h4><p>1.创建一个docker网络用于docker,postgresql和konga容器间通信</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create kong-net</span><br></pre></td></tr></table></figure><p>2.启动posgtresql容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name kong-database \</span><br><span class="line">               --network=kong-net \</span><br><span class="line">               -p 5432:5432 \</span><br><span class="line">               -e &quot;POSTGRES_USER=kong&quot; \</span><br><span class="line">               -e &quot;POSTGRES_DB=kong&quot; \</span><br><span class="line">               postgres:9.6</span><br></pre></td></tr></table></figure><p>3.初始化postgresql数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm \</span><br><span class="line">    --network=kong-net \</span><br><span class="line">    -e &quot;KONG_DATABASE=postgres&quot; \</span><br><span class="line">    -e &quot;KONG_PG_HOST=kong-database&quot; \</span><br><span class="line">    -e &quot;KONG_CASSANDRA_CONTACT_POINTS=kong-database&quot; \</span><br><span class="line">    kong:latest kong migrations bootstrap</span><br></pre></td></tr></table></figure><blockquote><p>注意两点:</p><p>1.最好是先删除本地的kong镜像.因为本地的Kong:lastest镜像不一定就是最新版</p><p>2.如果本地的kong:latest镜像地域0.15版本,则不支持bootstrap命令.可以将bootstrap命令替换成up</p></blockquote><a id="more"></a><p>4.启动kong容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name kong \</span><br><span class="line">     --network=kong-net \</span><br><span class="line">     -v /data/logs/kong:/var/log/kong \</span><br><span class="line">     -v /data/apps/kong/plugins/:/usr/local/share/lua/5.1/kong/plugins/ \</span><br><span class="line">     -e &quot;KONG_DATABASE=postgres&quot; \</span><br><span class="line">     -e &quot;KONG_PG_HOST=kong-database&quot; \</span><br><span class="line">     -e &quot;KONG_CASSANDRA_CONTACT_POINTS=kong-database&quot; \</span><br><span class="line">     -e &quot;KONG_PROXY_ACCESS_LOG=/var/log/kong/access.log&quot; \</span><br><span class="line">     -e &quot;KONG_ADMIN_ACCESS_LOG=/var/log/kong/admin_access.log&quot; \</span><br><span class="line">     -e &quot;KONG_PROXY_ERROR_LOG=/var/log/kong/error.log&quot; \</span><br><span class="line">     -e &quot;KONG_ADMIN_ERROR_LOG=/var/log/kong/admin_error.log&quot; \</span><br><span class="line">     -e &quot;KONG_ADMIN_LISTEN=0.0.0.0:8001, 0.0.0.0:8444 ssl&quot; \</span><br><span class="line">     -p 8000:8000 \</span><br><span class="line">     -p 8443:8443 \</span><br><span class="line">     -p 8001:8001 \</span><br><span class="line">     -p 8444:8444 \</span><br><span class="line">     kong:latest</span><br></pre></td></tr></table></figure><blockquote><p>这里我映射了kong的插件目录和日志目录. </p></blockquote><ul><li>注意:要先吧kong容器里的/usr/local/share/lua/5.1/kong/plugins/目录下内容复制到宿主机的/data/apps/kong/plugins/目录下.否则宿主机的空目录会覆盖容器的插件目录,导致容器无法启动.</li></ul><p>kong容器目录拷贝到宿主机方法如下:</p><p>1.先不挂载目录启动kong容器</p><p>2.执行命令拷贝kong容器的/usr/local/share/lua/5.1/kong/plugins/ 目录到宿主机/data/apps/kong/plugins/目录下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[work@docker ~]$docker cp kong:/usr/local/share/lua/5.1/kong/plugins/  /data/apps/kong/plugins/</span><br></pre></td></tr></table></figure><blockquote><p>如果不需要将容器的kong插件目录映射到宿主机的话,这一步可以不需要做</p></blockquote><p>容器已经成功启动:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@docker conf.d]$docker ps | grep -E &quot;kong|postgre&quot;</span><br><span class="line">10fc881cca4b        kong:latest                                 &quot;/docker-entrypoin...&quot;   About an hour ago   Up About an hour    0.0.0.0:8000-8001-&gt;8000-8001/tcp, 0.0.0.0:8443-8444-&gt;8443-8444/tcp                                             kong</span><br><span class="line"></span><br><span class="line">afd1487e29a0        postgres:9.6                                &quot;docker-entrypoint...&quot;   3 hours ago         Up 3 hours          0.0.0.0:5432-&gt;5432/tcp                                                                                         kong-database</span><br></pre></td></tr></table></figure><hr><h4 id="安装konga"><a href="#安装konga" class="headerlink" title="安装konga"></a>安装konga</h4><p>konga是管理kong的一个dashboard界面.</p><p>1.先初始化数据库.这里也是用后端的postgresql数据库.官方命令如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm pantsel/konga:latest -c prepare -a &#123;&#123;adapter&#125;&#125; -u &#123;&#123;connection-uri&#125;&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>argument</th><th>description</th><th>default</th></tr></thead><tbody><tr><td>-c</td><td>command</td><td>-</td></tr><tr><td>-a</td><td>adapter (can be <code>postgres</code> or <code>mysql</code>)</td><td>-</td></tr><tr><td>-u</td><td>full database connection url</td></tr></tbody></table><p>执行以下命令,初始化数据库:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm pantsel/konga:latest -c prepare -a postgres -u  postgres://kong@10.0.0.250:5432/konga</span><br></pre></td></tr></table></figure><blockquote><p>这里稍微有点疑问的是数据库的connection url ..完整的connection url地址是: postgres://user:password@host:port/konga</p><p> postgres:<a href="mailto://kong@10.0.0.250" target="_blank" rel="noopener">//kong@10.0.0.250</a>:5432/konga —— 这里kong代表用户名,由于没有密码所以没有指定密码.10.0.0.250是postgresql的host主机名.konga表示初始化一个数据库</p></blockquote><p>执行结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[work@docker ~]$docker run --rm pantsel/konga:latest -c prepare -a postgres -u  postgres://kong@10.0.0.250:5432/konga</span><br><span class="line">debug: Preparing database...</span><br><span class="line">Using postgres DB Adapter.</span><br><span class="line">Database `konga` does not exist. Creating...</span><br><span class="line">Database `konga` created! Continue...</span><br><span class="line">debug: Hook:api_health_checks:process() called</span><br><span class="line">debug: Hook:health_checks:process() called</span><br><span class="line">debug: Hook:start-scheduled-snapshots:process() called</span><br><span class="line">debug: Hook:upstream_health_checks:process() called</span><br><span class="line">debug: Hook:user_events_hook:process() called</span><br><span class="line">debug: Seeding User...</span><br><span class="line">debug: User seed planted</span><br><span class="line">debug: Seeding Kongnode...</span><br><span class="line">debug: Kongnode seed planted</span><br><span class="line">debug: Seeding Emailtransport...</span><br><span class="line">debug: Emailtransport seed planted</span><br><span class="line">debug: Database migrations completed!</span><br></pre></td></tr></table></figure><ol start="2"><li>启动konga</li></ol><p>命令格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 1337:1337 </span><br><span class="line">             --network &#123;&#123;kong-network&#125;&#125; \ // optional</span><br><span class="line">             -e &quot;TOKEN_SECRET=&#123;&#123;somerandomstring&#125;&#125;&quot; \</span><br><span class="line">             -e &quot;DB_ADAPTER=the-name-of-the-adapter&quot; \ // &apos;mongo&apos;,&apos;postgres&apos;,&apos;sqlserver&apos;  or &apos;mysql&apos;</span><br><span class="line">             -e &quot;DB_HOST=your-db-hostname&quot; \</span><br><span class="line">             -e &quot;DB_PORT=your-db-port&quot; \ // Defaults to the default db port</span><br><span class="line">             -e &quot;DB_USER=your-db-user&quot; \ // Omit if not relevant</span><br><span class="line">             -e &quot;DB_PASSWORD=your-db-password&quot; \ // Omit if not relevant</span><br><span class="line">             -e &quot;DB_DATABASE=your-db-name&quot; \ // Defaults to &apos;konga_database&apos;</span><br><span class="line">             -e &quot;DB_PG_SCHEMA=my-schema&quot;\ // Optionally define a schema when integrating with prostgres</span><br><span class="line">             -e &quot;NODE_ENV=production&quot; \ // or &apos;development&apos; | defaults to &apos;development&apos;</span><br><span class="line">             --name konga \</span><br><span class="line">             pantsel/konga</span><br></pre></td></tr></table></figure><p>执行如下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 1337:1337 -d \</span><br><span class="line">             --network=kong-net \</span><br><span class="line">             -e &quot;DB_ADAPTER=postgres&quot; \</span><br><span class="line">             -e &quot;DB_HOST=10.0.0.250&quot; \</span><br><span class="line">             -e &quot;DB_PORT=5432&quot; \</span><br><span class="line">             -e &quot;DB_USER=kong&quot; \</span><br><span class="line">             -e &quot;DB_DATABASE=konga&quot; \</span><br><span class="line">             -e &quot;NODE_ENV=production&quot; \</span><br><span class="line">             --name konga \</span><br><span class="line">             pantsel/konga</span><br></pre></td></tr></table></figure><p>容器成功启动:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beb70407b417        pantsel/konga                               &quot;/app/start.sh&quot;          2 hours ago         Up 2 hours          0.0.0.0:1337-&gt;1337/tcp                                                                                         konga</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;docker安装最新版Kong-v1-0-konga&quot;&gt;&lt;a href=&quot;#docker安装最新版Kong-v1-0-konga&quot; class=&quot;headerlink&quot; title=&quot;docker安装最新版Kong(v1.0)+konga&quot;&gt;&lt;/a&gt;docker安装最新版Kong(v1.0)+konga&lt;/h3&gt;&lt;p&gt;参考以下文档:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.konghq.com/install/docker/?_ga=2.167535422.1288669860.1553147426-917309945.1539077269&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kong installation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/pantsel/konga#installation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;konga github&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;docker安装kong-postgresql&quot;&gt;&lt;a href=&quot;#docker安装kong-postgresql&quot; class=&quot;headerlink&quot; title=&quot;docker安装kong+postgresql&quot;&gt;&lt;/a&gt;docker安装kong+postgresql&lt;/h4&gt;&lt;p&gt;1.创建一个docker网络用于docker,postgresql和konga容器间通信&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker network create kong-net&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2.启动posgtresql容器&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker run -d --name kong-database \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               --network=kong-net \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               -p 5432:5432 \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               -e &amp;quot;POSTGRES_USER=kong&amp;quot; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               -e &amp;quot;POSTGRES_DB=kong&amp;quot; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               postgres:9.6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3.初始化postgresql数据库&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker run --rm \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    --network=kong-net \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -e &amp;quot;KONG_DATABASE=postgres&amp;quot; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -e &amp;quot;KONG_PG_HOST=kong-database&amp;quot; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -e &amp;quot;KONG_CASSANDRA_CONTACT_POINTS=kong-database&amp;quot; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    kong:latest kong migrations bootstrap&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;注意两点:&lt;/p&gt;
&lt;p&gt;1.最好是先删除本地的kong镜像.因为本地的Kong:lastest镜像不一定就是最新版&lt;/p&gt;
&lt;p&gt;2.如果本地的kong:latest镜像地域0.15版本,则不支持bootstrap命令.可以将bootstrap命令替换成up&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux-Web" scheme="https://jesse.top/categories/Linux-Web/"/>
    
      <category term="kong" scheme="https://jesse.top/categories/Linux-Web/kong/"/>
    
    
      <category term="kong" scheme="https://jesse.top/tags/kong/"/>
    
  </entry>
  
</feed>
