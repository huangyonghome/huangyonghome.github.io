<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jesse&#39;s home</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jesse.top/"/>
  <updated>2020-06-26T03:09:18.121Z</updated>
  <id>https://jesse.top/</id>
  
  <author>
    <name>Jesse</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>kong+postgresql+konga集群环境部署</title>
    <link href="https://jesse.top/2020/06/26/Linux-Web/kong%20postgresql%20konga/"/>
    <id>https://jesse.top/2020/06/26/Linux-Web/kong postgresql konga/</id>
    <published>2020-06-26T03:59:58.000Z</published>
    <updated>2020-06-26T03:09:18.121Z</updated>
    
    <content type="html"><![CDATA[<h2 id="kong-postgresql-konga集群环境部署"><a href="#kong-postgresql-konga集群环境部署" class="headerlink" title="kong+postgresql+konga集群环境部署"></a>kong+postgresql+konga集群环境部署</h2><h3 id="kong简介"><a href="#kong简介" class="headerlink" title="kong简介"></a>kong简介</h3><p>Kong是Mashape开源的一款API网关，起初是用来管理 Mashape 公司15000个微服务的，后来在2015年开源,现在已经在很多创业公司、大型企业和政府机构中广泛使用。基于nginx,Lua和Cassandra或PostgreSQL，支持分布式操作，有很强的可移植性和可扩展性。可以在任何一种基础设施上运行,作为应用和API之间的中间层，加上众多功能强大的插件，可以实现认证授权、访问控制等功能。并且提供易于使用的RESTful API来操作和配置系统。</p><p>有关kong的详细介绍请参考官网.</p><p>–</p><h3 id="postgreSQL简介"><a href="#postgreSQL简介" class="headerlink" title="postgreSQL简介"></a>postgreSQL简介</h3><p><a href="https://baike.baidu.com/item/PostgreSQL/530240" target="_blank" rel="noopener">PostgreSQL</a> 是一个免费的对象-关系数据库服务器(数据库管理系统)，它在灵活的 BSD-风格许可证下发行。它提供了相对其他开放源代码数据库系统(比如 MySQL 和 Firebird)，和专有系统(比如 Oracle、Sybase、IBM 的 DB2 和 Microsoft SQL Server)之外的另一种选择。</p><p>–</p><h3 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h3><ul><li><strong>kong cluster</strong></li></ul><p>kong 集群并不意味着客户端请求将会负载均衡到kong集群中的每个节点上，kong集群并不是开箱即用，仍然需要在kong集群多节点上层搭建负载均衡，以便分发请求。 一个kong集群只是意味着集群内的节点，都共享同样的配置。</p><p>有关Kong cluster集群的详细介绍请参考官网:<a href="https://docs.konghq.com/0.14.x/clustering/" target="_blank" rel="noopener">Kong cluser document</a></p><p>为了提高冗余性和健壮性.我们对kong的每个环节都进行了冗余设计.一个基本的kong集群架构大概如下图所示:</p><p><img src="https://img1.jesse.top/kong-flow.png" alt=""></p><a id="more"></a><p>–</p><h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3><p><strong>环境</strong>: </p><p>阿里云ECS Centos7.4操作系统<br>Kong: 1.0最新版<br>postgresql 9.6</p><p>konga 最新版</p><p><strong>集群架构说明:</strong></p><p>dwd-kong-node1节点服务器部署postgresql master主库</p><p>dwd-kong-node2节点服务器部署postgresql slave从库</p><p>在两个Kong节点服务器上都部署konga,但是konga指向postgresql master主库</p><p>–</p><h4 id="安装postgresql"><a href="#安装postgresql" class="headerlink" title="安装postgresql"></a>安装postgresql</h4><p>安装方式官网参考: <a href="https://www.postgresql.org/" target="_blank" rel="noopener">Installing Postgresql</a></p><p><strong>安装步骤</strong></p><p>1.安装Postgre9.6版本的Yum源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install https://download.postgresql.org/pub/repos/yum/9.6/redhat/rhel-7-x86_64/pgdg-centos96-9.6-3.noarch.rpm</span><br></pre></td></tr></table></figure><p>2.安装postgresql</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install postgresql96 postgresql96-server -y</span><br></pre></td></tr></table></figure><p>3.切换到root用户下,初始化数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/pgsql-9.6/bin/postgresql96-setup initdb</span><br></pre></td></tr></table></figure><p>4.修改数据库的配置文件,监听所有接口</p><p>postgresql的配置文件默认路径在:/var/lib/pgsql/9.6/data/postgresql.conf</p><p>修改下列配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">listen_addresses = &apos;*&apos; #监听所有接口.由于我服务器只有内网地址,所有可以侦听在所有接口,(如果有公网地址,最好不要只样做)</span><br><span class="line">log_directory = &apos;/data/logs/postgre&apos; #指定日志文件的父目录</span><br></pre></td></tr></table></figure><p>5.修改数据库远程访问配置文件.开启远程访问</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /var/lib/pgsql/9.6/data/postgresql.conf/pg_hba.conf</span><br><span class="line"></span><br><span class="line">修改下列两项:</span><br><span class="line">#修改为md5认证,下列10.0.0.0/8是内网地址段</span><br><span class="line">host    all             all             127.0.0.1/32            md5</span><br><span class="line">host    all             all             10.0.0.0/8           md5</span><br></pre></td></tr></table></figure><p>6.创建日志目录,并且赋权给postgres用户(安装postgresql后默认会创建这个用户)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@dwd-kong-node1 data]# mkdir /data/logs/postgre</span><br><span class="line">[root@dwd-kong-node1 data]# chown -R postgre.postgre /data/logs/postgre</span><br></pre></td></tr></table></figure><p>7.启动postgresql数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable postgresql-9.6</span><br><span class="line">systemctl start postgresql-9.6</span><br></pre></td></tr></table></figure><hr><h3 id="创建数据库用户密码"><a href="#创建数据库用户密码" class="headerlink" title="创建数据库用户密码"></a>创建数据库用户密码</h3><p>1.切换到postgres用户,输入psql登陆数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@dwd-kong-node1 data]# su - postgres</span><br><span class="line">Last login: Mon Apr  8 09:27:12 CST 2019 on pts/0</span><br><span class="line">-bash-4.2$</span><br><span class="line">-bash-4.2$ psql</span><br><span class="line">psql (11.2, server 9.6.12)</span><br><span class="line">Type &quot;help&quot; for help.</span><br><span class="line"></span><br><span class="line">postgres=#</span><br></pre></td></tr></table></figure><p>2.创建kong用户和kong数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE USER kong; </span><br><span class="line">CREATE DATABASE kong OWNER kong;</span><br></pre></td></tr></table></figure><p>3.创建konga的数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE DATABASE konga OWNER kong;</span><br></pre></td></tr></table></figure><p>4.为kong用户创建一个密码,密码也是kong</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alter user kong with password &apos;kong&apos;;</span><br></pre></td></tr></table></figure><p>5.输入\l,可以看到当前的数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">postgres=# \l</span><br><span class="line">                                  List of databases</span><br><span class="line">   Name    |  Owner   | Encoding |   Collate   |    Ctype    |   Access privileges</span><br><span class="line">-----------+----------+----------+-------------+-------------+-----------------------</span><br><span class="line"> kong      | kong     | UTF8     | en_US.UTF-8 | en_US.UTF-8 |</span><br><span class="line"> konga     | kong     | UTF8     | en_US.UTF-8 | en_US.UTF-8 |</span><br><span class="line"> postgres  | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 |</span><br><span class="line"> template0 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +</span><br><span class="line">           |          |          |             |             | postgres=CTc/postgres</span><br><span class="line"> template1 | postgres | UTF8     | en_US.UTF-8 | en_US.UTF-8 | =c/postgres          +</span><br><span class="line">           |          |          |             |             | postgres=CTc/postgres</span><br><span class="line">(5 rows)</span><br></pre></td></tr></table></figure><p>6.查看当前数据库有哪些用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">postgres=# select * from pg_roles;</span><br><span class="line">      rolname      | rolsuper | rolinherit | rolcreaterole | rolcreatedb | rolcanlogin | rolreplication | rolconnlimit | rolpassword | rolvaliduntil | rolbypassrls | rolconfig |  oid</span><br><span class="line">-------------------+----------+------------+---------------+-------------+-------------+----------------+--------------+-------------+---------------+--------------+-----------+-------</span><br><span class="line"> postgres          | t        | t          | t             | t           | t           | t              |           -1 | ********    |               | t            |           |    10</span><br><span class="line"> pg_signal_backend | f        | t          | f             | f           | f           | f              |           -1 | ********    |               | f            |           |  4200</span><br><span class="line"> kong              | f        | t          | f             | f           | t           | f              |           -1 | ********    |               | f            |           | 16384</span><br><span class="line">(3 rows)</span><br></pre></td></tr></table></figure><hr><h4 id="安装Kong"><a href="#安装Kong" class="headerlink" title="安装Kong"></a>安装Kong</h4><p>安装方法可以参考官网:<a href="https://docs.konghq.com/install/centos/?_ga=2.110797315.728319704.1539597667-917309945.1539077269#packages" target="_blank" rel="noopener">Install Kong</a></p><p>1.下载,安装rpm安装包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget -O kong-community-edition-1.0.0.el7.noarch.rpm  https://kong.bintray.com/kong-community-edition-rpm/centos/7/:kong-community-edition-1.0.0.el7.noarch.rpm</span><br><span class="line"></span><br><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install kong-community-edition-1.0.0.el7.noarch.rpm</span><br></pre></td></tr></table></figure><p>2.dwd-kong-node1修改kong配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/kong</span><br><span class="line">sudo cp kong.conf.default kong.conf</span><br><span class="line"></span><br><span class="line">[root@dwd-kong-node1 data]#  sed -r &apos;/^[[:space:]]+#*/d&apos; /etc/kong/kong.conf | sed &apos;/^#/d&apos; | sed &apos;/^$/d&apos;</span><br><span class="line"></span><br><span class="line">prefix = /data/logs/kong/       # Working directory. Equivalent to Nginx&apos;s</span><br><span class="line">proxy_access_log = access.log       # Path for proxy port request access</span><br><span class="line">proxy_error_log = error.log         # Path for proxy port request error</span><br><span class="line">admin_listen = 0.0.0.0:8001     # Address and port on which Kong will expose</span><br><span class="line">database = postgres             # Determines which of PostgreSQL or Cassandra</span><br><span class="line">pg_host = 127.0.0.1             # The PostgreSQL host to connect to.</span><br><span class="line">pg_port = 5432                  # The port to connect to.</span><br><span class="line">pg_user = kong                  # The username to authenticate if required.</span><br><span class="line">pg_password = kong                 # The password to authenticate if required.</span><br><span class="line">pg_database = kong              # The database name to connect to.</span><br><span class="line">cluster_listen = 0.0.0.0:7946   # Address and port used to communicate with</span><br><span class="line">cluster_listen_rpc = 127.0.0.1:7373  # Address and port used to communicate</span><br></pre></td></tr></table></figure><p>3.dwd-kong-node2修改kong配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@dwd-kong-node2 system]# clear</span><br><span class="line">[root@dwd-kong-node2 system]# sed -r &apos;/^[[:space:]]+#*/d&apos; /etc/kong/kong.conf | sed &apos;/^#/d&apos; | sed &apos;/^$/d&apos;</span><br><span class="line">prefix = /data/logs/kong/       # Working directory. Equivalent to Nginx&apos;s</span><br><span class="line">proxy_access_log = access.log       # Path for proxy port request access</span><br><span class="line">proxy_error_log = error.log         # Path for proxy port request error</span><br><span class="line">database = postgres             # Determines which of PostgreSQL or Cassandra</span><br><span class="line">pg_host = 10.111.30.174             # The PostgreSQL host to connect to.</span><br><span class="line">pg_port = 5432                  # The port to connect to.</span><br><span class="line">pg_user = kong                  # The username to authenticate if required.</span><br><span class="line">pg_password = kong                 # The password to authenticate if required.</span><br><span class="line">pg_database = kong              # The database name to connect to.</span><br><span class="line">pg_ssl = off                    # Toggles client-server TLS connections</span><br><span class="line">pg_ssl_verify = off             # Toggles server certificate verification if</span><br><span class="line">cluster_listen = 0.0.0.0:7946   # Address and port used to communicate with</span><br><span class="line">cluster_listen_rpc = 127.0.0.1:7373  # Address and port used to communicate</span><br></pre></td></tr></table></figure><blockquote><p>唯一区别就是这里的数据库指向dwd-kong-node1上的postgresql(IP:10.111.30.174),而非本机.</p></blockquote><p>3.创建kong目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/logs/kong/</span><br></pre></td></tr></table></figure><p>4.在dwd-kong-node1上准备数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kong migrations bootstrap -c /etc/kong/kong.conf</span><br></pre></td></tr></table></figure><blockquote><p>由于dwd-kong-node2上指向了node1的数据库,所以在node2上不需要执行这个命令</p></blockquote><p>5.启动kong</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kong start -c /etc/kong/kong.conf</span><br></pre></td></tr></table></figure><p>查看端口.可以看到postgresql和kong的侦听端口都已经成功启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[root@dwd-kong-node1 data]# netstat -tulpn</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class="line">tcp        0      0 0.0.0.0:5432            0.0.0.0:*               LISTEN      26580/postmaster</span><br><span class="line">tcp        0      0 0.0.0.0:8443            0.0.0.0:*               LISTEN      24746/nginx: master</span><br><span class="line">tcp        0      0 0.0.0.0:5822            0.0.0.0:*               LISTEN      29688/sshd</span><br><span class="line">tcp        0      0 0.0.0.0:8000            0.0.0.0:*               LISTEN      24746/nginx: master</span><br><span class="line">tcp        0      0 0.0.0.0:8001            0.0.0.0:*               LISTEN      24746/nginx: master</span><br><span class="line">tcp6       0      0 :::5432                 :::*                    LISTEN      26580/postmaster</span><br><span class="line">udp        0      0 0.0.0.0:68              0.0.0.0:*                           748/dhclient</span><br><span class="line">udp        0      0 10.111.30.174:123       0.0.0.0:*                           6290/ntpd</span><br><span class="line">udp        0      0 127.0.0.1:123           0.0.0.0:*                           6290/ntpd</span><br><span class="line">udp        0      0 0.0.0.0:123             0.0.0.0:*                           6290/ntpd</span><br><span class="line">udp        0      0 0.0.0.0:34019           0.0.0.0:*                           748/dhclient</span><br><span class="line">udp6       0      0 :::31421                :::*                                748/dhclient</span><br><span class="line">udp6       0      0 :::123                  :::*                                6290/ntpd</span><br></pre></td></tr></table></figure><hr><h3 id="搭建konga"><a href="#搭建konga" class="headerlink" title="搭建konga"></a>搭建konga</h3><p>konga是管理kong各个组件(serveice,route,plugin,upstream,consumer)的可视化UI管理工具.在增删改查各个组件的配置时非常方便.</p><p>个人觉得UI界面比kong-dashboard要漂亮</p><p>konga的github参考:<a href="https://github.com/pantsel/konga" target="_blank" rel="noopener">konga</a></p><hr><p>1.确保需要有node.js环境.如果没有npm工具,必须先安装nodejs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@DWD-BETA kong]$ npm -v</span><br><span class="line">6.4.1</span><br><span class="line">[work@DWD-BETA kong]$ node -v</span><br><span class="line">v10.15.3</span><br></pre></td></tr></table></figure><p>2.安装bower,gulp包.安装git软件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install bower</span><br><span class="line">npm install gulp</span><br><span class="line">yum install git</span><br></pre></td></tr></table></figure><p>3.work用户下安装konga</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/pantsel/konga.git</span><br><span class="line">$ cd konga</span><br><span class="line">$ npm i</span><br></pre></td></tr></table></figure><p>4.编辑.env环境文件(dwd-kong-node2的文件内容中将下列的localhost修改为node1服务器的IP:10.111.30.174)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">work@dwd-kong-node1 konga]$ cat .env_example</span><br><span class="line">PORT=1337</span><br><span class="line">NODE_ENV=production</span><br><span class="line">KONGA_HOOK_TIMEOUT=120000</span><br><span class="line">DB_ADAPTER=postgres</span><br><span class="line">DB_URI=postgresql://localhost:5432/konga</span><br><span class="line">KONGA_LOG_LEVEL=warn</span><br><span class="line">TOKEN_SECRET=some_secret_token</span><br><span class="line">DB_USER=kong</span><br><span class="line">DB_PASSWORD=kong</span><br><span class="line">DB_DATABASE=konga</span><br></pre></td></tr></table></figure><p>5.启动konga</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">work@dwd-kong-node1 konga]$ npm start</span><br></pre></td></tr></table></figure><p>6.如果启动报错,则安装依赖</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">work@dwd-kong-node1 konga]$ npm run bower-deps</span><br></pre></td></tr></table></figure><p>这个程序默认是前台启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[work@dwd-kong-node1 konga]$ npm start</span><br><span class="line"></span><br><span class="line">&gt; kongadmin@0.14.3 start /home/work/konga</span><br><span class="line">&gt; node --harmony app.js</span><br><span class="line"></span><br><span class="line">No DB Adapter defined. Using localDB...</span><br><span class="line">debug: Hook:api_health_checks:process() called</span><br><span class="line">debug: Hook:health_checks:process() called</span><br><span class="line">debug: Hook:start-scheduled-snapshots:process() called</span><br><span class="line">debug: Hook:upstream_health_checks:process() called</span><br><span class="line">debug: Hook:user_events_hook:process() called</span><br><span class="line">debug: User had models, so no seed needed</span><br><span class="line">debug: Kongnode had models, so no seed needed</span><br><span class="line">debug: Emailtransport seeds updated</span><br><span class="line">debug: -------------------------------------------------------</span><br><span class="line">debug: :: Mon Apr 08 2019 18:34:31 GMT+0800 (China Standard Time)</span><br><span class="line">debug: Environment : development</span><br><span class="line">debug: Port        : 1337</span><br><span class="line">debug: -------------------------------------------------------</span><br></pre></td></tr></table></figure><p>此时在浏览器输入:<a href="http://10.111.30.174:1337" target="_blank" rel="noopener">http://10.111.30.174:1337</a> 就能访问konga了.</p><hr><h3 id="systemctl管理kong和konga进程"><a href="#systemctl管理kong和konga进程" class="headerlink" title="systemctl管理kong和konga进程"></a>systemctl管理kong和konga进程</h3><ul><li>kong</li></ul><p>在/usr/lib/systemd/system路径下编辑kong.service文件.内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">work@dwd-kong-node1 system]$ pwd</span><br><span class="line">/usr/lib/systemd/system</span><br><span class="line">[work@dwd-kong-node1 system]$ cat kong.service</span><br><span class="line">[Unit]</span><br><span class="line">Description= kong service</span><br><span class="line">After=syslog.target network.target postgresql-9.6.target</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=work</span><br><span class="line">Group=work</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/kong start -c /etc/kong/kong.conf</span><br><span class="line">ExecReload=/usr/local/bin/kong reload -c /etc/kong/kong.conf</span><br><span class="line">ExecStop=/usr/local/bin/kong stop</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><ul><li>konga</li></ul><p>在/usr/lib/systemd/system路径下编辑konga.service文件.内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[work@dwd-kong-node1 system]$ cat konga.service</span><br><span class="line">[Unit]</span><br><span class="line">Description= konga service</span><br><span class="line">After=syslog.target network.target postgresql-9.6.target  kong.target</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=work</span><br><span class="line">Group=work</span><br><span class="line">Type=forking</span><br><span class="line">#需要指定工作目录,因为npm命令要在konga的目录下执行</span><br><span class="line">WorkingDirectory=/home/work/konga</span><br><span class="line">ExecStart=/usr/local/bin/npm start</span><br><span class="line">ExecStop=kill $(netstat -tlnp |grep 1337|  awk &apos;&#123;print $NF&#125;&apos; | awk -F &quot;/&quot; &apos;&#123;print $1&#125;&apos;)</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><ul><li>启动进程,且设置开机启动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[work@dwd-kong-node2 ~]$ sudo systemctl enable kong</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/kong.service to /usr/lib/systemd/system/kong.service.</span><br><span class="line">[work@dwd-kong-node2 ~]$ sudo systemctl enable konga.service</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/konga.service to /usr/lib/systemd/system/konga.service.</span><br><span class="line">[work@dwd-kong-node2 ~]$ sudo systemctl start kong.service</span><br><span class="line">[work@dwd-kong-node2 ~]$ sudo systemctl start konga.service</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;kong-postgresql-konga集群环境部署&quot;&gt;&lt;a href=&quot;#kong-postgresql-konga集群环境部署&quot; class=&quot;headerlink&quot; title=&quot;kong+postgresql+konga集群环境部署&quot;&gt;&lt;/a&gt;kong+postgresql+konga集群环境部署&lt;/h2&gt;&lt;h3 id=&quot;kong简介&quot;&gt;&lt;a href=&quot;#kong简介&quot; class=&quot;headerlink&quot; title=&quot;kong简介&quot;&gt;&lt;/a&gt;kong简介&lt;/h3&gt;&lt;p&gt;Kong是Mashape开源的一款API网关，起初是用来管理 Mashape 公司15000个微服务的，后来在2015年开源,现在已经在很多创业公司、大型企业和政府机构中广泛使用。基于nginx,Lua和Cassandra或PostgreSQL，支持分布式操作，有很强的可移植性和可扩展性。可以在任何一种基础设施上运行,作为应用和API之间的中间层，加上众多功能强大的插件，可以实现认证授权、访问控制等功能。并且提供易于使用的RESTful API来操作和配置系统。&lt;/p&gt;
&lt;p&gt;有关kong的详细介绍请参考官网.&lt;/p&gt;
&lt;p&gt;–&lt;/p&gt;
&lt;h3 id=&quot;postgreSQL简介&quot;&gt;&lt;a href=&quot;#postgreSQL简介&quot; class=&quot;headerlink&quot; title=&quot;postgreSQL简介&quot;&gt;&lt;/a&gt;postgreSQL简介&lt;/h3&gt;&lt;p&gt;&lt;a href=&quot;https://baike.baidu.com/item/PostgreSQL/530240&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;PostgreSQL&lt;/a&gt; 是一个免费的对象-关系数据库服务器(数据库管理系统)，它在灵活的 BSD-风格许可证下发行。它提供了相对其他开放源代码数据库系统(比如 MySQL 和 Firebird)，和专有系统(比如 Oracle、Sybase、IBM 的 DB2 和 Microsoft SQL Server)之外的另一种选择。&lt;/p&gt;
&lt;p&gt;–&lt;/p&gt;
&lt;h3 id=&quot;集群架构&quot;&gt;&lt;a href=&quot;#集群架构&quot; class=&quot;headerlink&quot; title=&quot;集群架构&quot;&gt;&lt;/a&gt;集群架构&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;kong cluster&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;kong 集群并不意味着客户端请求将会负载均衡到kong集群中的每个节点上，kong集群并不是开箱即用，仍然需要在kong集群多节点上层搭建负载均衡，以便分发请求。 一个kong集群只是意味着集群内的节点，都共享同样的配置。&lt;/p&gt;
&lt;p&gt;有关Kong cluster集群的详细介绍请参考官网:&lt;a href=&quot;https://docs.konghq.com/0.14.x/clustering/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kong cluser document&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;为了提高冗余性和健壮性.我们对kong的每个环节都进行了冗余设计.一个基本的kong集群架构大概如下图所示:&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://img1.jesse.top/kong-flow.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Linux-Web" scheme="https://jesse.top/categories/Linux-Web/"/>
    
      <category term="kong" scheme="https://jesse.top/categories/Linux-Web/kong/"/>
    
    
      <category term="kong" scheme="https://jesse.top/tags/kong/"/>
    
  </entry>
  
  <entry>
    <title>harbor私有仓库部署</title>
    <link href="https://jesse.top/2020/06/26/docker/harbor%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93%E9%83%A8%E7%BD%B2/"/>
    <id>https://jesse.top/2020/06/26/docker/harbor私有仓库部署/</id>
    <published>2020-06-26T03:59:58.000Z</published>
    <updated>2020-06-26T03:03:12.763Z</updated>
    
    <content type="html"><![CDATA[<h2 id="harbor私有仓库部署"><a href="#harbor私有仓库部署" class="headerlink" title="harbor私有仓库部署"></a>harbor私有仓库部署</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>harbor是docker的私有仓库,可以部署在局域网服务器上,用来管理docker镜像.虽然docker官方也提供公共镜像仓库,但是由于是境外网站,拉取镜像速度非常慢,而且有被墙的可能.部署私有仓库非常有必要</p><p>harbor是vmware公司开源的企业级的docker registry管理项目.</p><blockquote><p>处于数据脱敏需要,以下内容中隐藏了真实域名.而使用hub.xxxxxx.com替代</p></blockquote><hr><h3 id="社区"><a href="#社区" class="headerlink" title="社区"></a>社区</h3><p>harbor github: <a href="https://github.com/goharbor/harbor" target="_blank" rel="noopener">goharbor/harbor</a></p><p>官网文档介绍: <a href="https://goharbor.io/docs/1.10/" target="_blank" rel="noopener">harbor doc</a></p><p>在部署中遇到的各种坑,都可以通过查阅文档,或者搜索github的issue解决</p><hr><h3 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h3><p>harbor是docker-compose部署的.包括一系列组件:nginx.core,log,register等等.</p><p>但是由于本机已经存在一个Nginx镜像.所以用Nginx代理到harbor的Nginx.<strong>如果是独立的服务器部署Harbor的话,则不会存在这个问题,可以直接跳过这一章节.</strong></p><p>nginx代理框架大概是:</p><p><strong>nginx—-&gt;harbor-nginx—–&gt;habor</strong></p><p>由于docker提交镜像需要Https协议,所以:</p><p><strong>nginx—301跳转到nginx https—–&gt;harbor-nginx http—-&gt; habor</strong></p><p>但是这样的部署方式,有一个问题:</p><p>私有仓库可以正常login但是push镜像的时候,又提示未验证.</p><p>该问题尝试过很多解决方案,但是均无法解决</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[root@idc-function-docker ~]# docker login --username=admin -pHarbor12345 hub.xxxxxx.com</span><br><span class="line">WARNING! Using --password via the CLI is insecure. Use --password-stdin.</span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br><span class="line">[root@idc-function-docker ~]# docker push hub.xxxxxx.com/master/nginx:latest</span><br><span class="line">The push refers to repository [hub.xxxxxx.com/master/nginx]</span><br><span class="line">d37eecb5b769: Pushing [==================================================&gt;]  3.584kB</span><br><span class="line">99134ec7f247: Preparing</span><br><span class="line">c3a984abe8a8: Preparing</span><br><span class="line">unauthorized: authentication required</span><br></pre></td></tr></table></figure><p>所以现在的架构是</p><p><strong>nginx—301跳转到Nginx https——&gt; harbor-nginx https——&gt;harbor</strong></p><hr><h3 id="harbor部署前提条件"><a href="#harbor部署前提条件" class="headerlink" title="harbor部署前提条件"></a>harbor部署前提条件</h3><ul><li>安装docker-ce</li><li>安装docker-composer</li><li>准备一个空目录.比如/data.或者/data/harbor (注意,最好是空目录,不要和其他项目混杂一起)</li><li>安装好https域名证书</li></ul><hr><h3 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h3><p>docker和docker-compose的安装就略过了.这里提一句,我用的是acme.sh部署letsencrypt的证书</p><p>接下来开始部署harbor</p><ul><li>1.去github下载离线安装包.离线安装包虽然比较大,但是安装过程快速,且不会中断</li></ul><p>这里安装的是最新版,v1.10.1.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在github下载 harbor-offline-installer-v1.10.1.tgz</span><br><span class="line">tar xvf 解压</span><br></pre></td></tr></table></figure><ul><li>2.解压后,进入harbor文件,编辑harbor.yaml配置文件.需要改动以下几个地方</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">hostname hub.xxxxxx.com  #定义主机名,可以使用IP,也可以用域名</span><br><span class="line"></span><br><span class="line">#定义https的服务器证书和秘钥的文件路径</span><br><span class="line">https:</span><br><span class="line">  # https port for harbor, default is 443</span><br><span class="line">  port: 443</span><br><span class="line">  # The path of cert and key files for nginx</span><br><span class="line">  certificate: /data/letsencrypt/hub.xxxxxx.com/fullchain.cer</span><br><span class="line">  private_key: /data/letsencrypt/hub.xxxxxx.com/hub.xxxxxx.com.key</span><br><span class="line">  </span><br><span class="line">#这是harbor命令行和浏览器登陆的初始密码..用户名是admin</span><br><span class="line">harbor_admin_password: Harbor12345</span><br><span class="line"></span><br><span class="line">#这是数据目录,最好是一个空目录</span><br><span class="line">data_volume: /data/apps/harbor</span><br><span class="line"></span><br><span class="line">#日志文件保存路径</span><br><span class="line">log:</span><br><span class="line">    location: /data/logs/harbor</span><br></pre></td></tr></table></figure><ul><li>3.执行install.sh文件.</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#该脚本会检查主机的环境,拉取相关镜像.以及根据配置文件生成docker-compose文件.</span><br><span class="line">[root@idc-function-docker harbor]#./install.sh</span><br></pre></td></tr></table></figure><blockquote><p> 这个脚本执行到最后会报错,提示80端口和nginx容器已经被占用了.但是没关系.</p></blockquote><ul><li>4.修改docker-composer文件.(如果本机上没有nginx或者80端口没有被占用,这一步可以不做)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#将Nginx容器名改成hub-nginx</span><br><span class="line">#将80和443的端口映射修改一下,比如我这里</span><br><span class="line">proxy:</span><br><span class="line">    image: goharbor/nginx-photon:v1.10.1</span><br><span class="line">    container_name: hub-nginx</span><br><span class="line">ports:</span><br><span class="line">      - 8081:8080</span><br><span class="line">      - 4443:8443</span><br></pre></td></tr></table></figure><ul><li><ol start="5"><li>启动docker-compose</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@idc-function-docker harbor]#docker-compose up -d</span><br></pre></td></tr></table></figure><ul><li><ol start="6"><li>宿主机的nginx开启代理. (如果不是采用nginx代理的话,可以忽略这一步)</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#我这里是有一个独立的Nginx容器</span><br><span class="line">[root@idc-function-docker harbor]# cat/data/conf/nginx/conf.d/dwd-docker-hub.conf</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line"></span><br><span class="line">  server_name hub.xxxxxx.com;</span><br><span class="line">  listen 443 ssl http2;</span><br><span class="line">  ssl_certificate  /data/letsencrypt/hub.xxxxxx.com/fullchain.cer;</span><br><span class="line">  ssl_certificate_key /data/letsencrypt/hub.xxxxxx.com/hub.xxxxxx.com.key;</span><br><span class="line">  include /data/letsencrypt/options-ssl-nginx.conf; # managed by Certbot</span><br><span class="line">  ssl_dhparam /data/letsencrypt/ssl-dhparams.pem; # managed by Certbot</span><br><span class="line"></span><br><span class="line">  add_header      Strict-Transport-Security &quot;max-age=31536000&quot; always;</span><br><span class="line">  location / &#123;</span><br><span class="line"></span><br><span class="line">    proxy_pass https://172.16.20.30:4443; #代理到宿主机的4443端口,宿主机会将4443代理到hub-docer容器的443端口</span><br><span class="line">    client_max_body_size 2000m; #这里要定义大一点,否则提交镜像的时候,会提示 413 Request Entity Too Large</span><br><span class="line">                proxy_buffering off;</span><br><span class="line">                proxy_ssl_verify off;</span><br><span class="line">                proxy_set_header Host $http_host;</span><br><span class="line">                proxy_set_header Upgrade $http_upgrade;</span><br><span class="line">                proxy_set_header Connection &quot;Upgrade&quot;;</span><br><span class="line">                proxy_set_header X-Forwarded-Proto $scheme;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    if ($host = hub.xxxxxx.com)&#123;</span><br><span class="line">        return 301 https://$host$request_uri;</span><br><span class="line">    &#125; # managed by Certbot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  listen 80;</span><br><span class="line">    server_name hub.xxxxxx.com;</span><br><span class="line">    return 404; # managed by Certbot</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此,部署就完成了.</p><p>我之前在部署的过程中遇到无数的坑,,可能都是由于harbor没有使用Https引起的</p><hr><p>浏览器访问<a href="https://hub.xxxxxx.com,用初始的账号密码登陆,可以新建项目,创建用户等" target="_blank" rel="noopener">https://hub.xxxxxx.com,用初始的账号密码登陆,可以新建项目,创建用户等</a>.</p><p>我这里创建了一个master的公开项目</p><hr><p>登陆和push镜像没有任何问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">root@idc-function-docker ~]# docker login --username=admin -pHarbor12345 hub.xxxxxx.com</span><br><span class="line">WARNING! Using --password via the CLI is insecure. Use --password-stdin.</span><br><span class="line">WARNING! Your password will be stored unencrypted in /root/.docker/config.json.</span><br><span class="line">Configure a credential helper to remove this warning. See</span><br><span class="line">https://docs.docker.com/engine/reference/commandline/login/#credentials-store</span><br><span class="line"></span><br><span class="line">Login Succeeded</span><br><span class="line">[root@idc-function-docker ~]# docker push hub.xxxxxx.com/master/nginx:latest</span><br><span class="line">The push refers to repository [hub.xxxxxx.com/master/nginx]</span><br><span class="line">d37eecb5b769: Layer already exists</span><br><span class="line">99134ec7f247: Layer already exists</span><br><span class="line">c3a984abe8a8: Layer already exists</span><br><span class="line">latest: digest: sha256:7ac7819e1523911399b798309025935a9968b277d86d50e5255465d6592c0266 size: 948</span><br><span class="line">[root@idc-function-docker ~]#</span><br></pre></td></tr></table></figure><p>在另外一台客户端上,尝试pull镜像不需要密码.如果需要密码pull镜像,可以将项目设置为私有</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]$docker pull  hub.xxxxxx.com/master/nginx:latest</span><br><span class="line">latest: Pulling from master/nginx</span><br><span class="line">Digest: sha256:7ac7819e1523911399b798309025935a9968b277d86d50e5255465d6592c0266</span><br><span class="line">Status: Downloaded newer image for hub.xxxxxx.com/master/nginx:latest</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;harbor私有仓库部署&quot;&gt;&lt;a href=&quot;#harbor私有仓库部署&quot; class=&quot;headerlink&quot; title=&quot;harbor私有仓库部署&quot;&gt;&lt;/a&gt;harbor私有仓库部署&lt;/h2&gt;&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;harbor是docker的私有仓库,可以部署在局域网服务器上,用来管理docker镜像.虽然docker官方也提供公共镜像仓库,但是由于是境外网站,拉取镜像速度非常慢,而且有被墙的可能.部署私有仓库非常有必要&lt;/p&gt;
&lt;p&gt;harbor是vmware公司开源的企业级的docker registry管理项目.&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;处于数据脱敏需要,以下内容中隐藏了真实域名.而使用hub.xxxxxx.com替代&lt;/p&gt;
&lt;/blockquote&gt;
&lt;hr&gt;
&lt;h3 id=&quot;社区&quot;&gt;&lt;a href=&quot;#社区&quot; class=&quot;headerlink&quot; title=&quot;社区&quot;&gt;&lt;/a&gt;社区&lt;/h3&gt;&lt;p&gt;harbor github: &lt;a href=&quot;https://github.com/goharbor/harbor&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;goharbor/harbor&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;官网文档介绍: &lt;a href=&quot;https://goharbor.io/docs/1.10/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;harbor doc&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在部署中遇到的各种坑,都可以通过查阅文档,或者搜索github的issue解决&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;框架&quot;&gt;&lt;a href=&quot;#框架&quot; class=&quot;headerlink&quot; title=&quot;框架&quot;&gt;&lt;/a&gt;框架&lt;/h3&gt;&lt;p&gt;harbor是docker-compose部署的.包括一系列组件:nginx.core,log,register等等.&lt;/p&gt;
&lt;p&gt;但是由于本机已经存在一个Nginx镜像.所以用Nginx代理到harbor的Nginx.&lt;strong&gt;如果是独立的服务器部署Harbor的话,则不会存在这个问题,可以直接跳过这一章节.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;nginx代理框架大概是:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;nginx—-&amp;gt;harbor-nginx—–&amp;gt;habor&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;由于docker提交镜像需要Https协议,所以:&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;nginx—301跳转到nginx https—–&amp;gt;harbor-nginx http—-&amp;gt; habor&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;但是这样的部署方式,有一个问题:&lt;/p&gt;
&lt;p&gt;私有仓库可以正常login但是push镜像的时候,又提示未验证.&lt;/p&gt;
&lt;p&gt;该问题尝试过很多解决方案,但是均无法解决&lt;/p&gt;
    
    </summary>
    
      <category term="docker" scheme="https://jesse.top/categories/docker/"/>
    
    
      <category term="docker" scheme="https://jesse.top/tags/docker/"/>
    
  </entry>
  
  <entry>
    <title>docker安装最新版Kong(v1.0)+konga</title>
    <link href="https://jesse.top/2020/06/26/Linux-Web/docker%E5%AE%89%E8%A3%85%E6%9C%80%E6%96%B0%E7%89%88Kong(v1.0)%20konga/"/>
    <id>https://jesse.top/2020/06/26/Linux-Web/docker安装最新版Kong(v1.0) konga/</id>
    <published>2020-06-26T03:59:58.000Z</published>
    <updated>2020-06-26T02:58:34.379Z</updated>
    
    <content type="html"><![CDATA[<h3 id="docker安装最新版Kong-v1-0-konga"><a href="#docker安装最新版Kong-v1-0-konga" class="headerlink" title="docker安装最新版Kong(v1.0)+konga"></a>docker安装最新版Kong(v1.0)+konga</h3><p>参考以下文档:</p><p><a href="https://docs.konghq.com/install/docker/?_ga=2.167535422.1288669860.1553147426-917309945.1539077269" target="_blank" rel="noopener">Kong installation</a></p><p><a href="https://github.com/pantsel/konga#installation" target="_blank" rel="noopener">konga github</a></p><hr><h4 id="docker安装kong-postgresql"><a href="#docker安装kong-postgresql" class="headerlink" title="docker安装kong+postgresql"></a>docker安装kong+postgresql</h4><p>1.创建一个docker网络用于docker,postgresql和konga容器间通信</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create kong-net</span><br></pre></td></tr></table></figure><p>2.启动posgtresql容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name kong-database \</span><br><span class="line">               --network=kong-net \</span><br><span class="line">               -p 5432:5432 \</span><br><span class="line">               -e &quot;POSTGRES_USER=kong&quot; \</span><br><span class="line">               -e &quot;POSTGRES_DB=kong&quot; \</span><br><span class="line">               postgres:9.6</span><br></pre></td></tr></table></figure><p>3.初始化postgresql数据库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --rm \</span><br><span class="line">    --network=kong-net \</span><br><span class="line">    -e &quot;KONG_DATABASE=postgres&quot; \</span><br><span class="line">    -e &quot;KONG_PG_HOST=kong-database&quot; \</span><br><span class="line">    -e &quot;KONG_CASSANDRA_CONTACT_POINTS=kong-database&quot; \</span><br><span class="line">    kong:latest kong migrations bootstrap</span><br></pre></td></tr></table></figure><blockquote><p>注意两点:</p><p>1.最好是先删除本地的kong镜像.因为本地的Kong:lastest镜像不一定就是最新版</p><p>2.如果本地的kong:latest镜像地域0.15版本,则不支持bootstrap命令.可以将bootstrap命令替换成up</p></blockquote><a id="more"></a><p>4.启动kong容器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">docker run -d --name kong \</span><br><span class="line">     --network=kong-net \</span><br><span class="line">     -v /data/logs/kong:/var/log/kong \</span><br><span class="line">     -v /data/apps/kong/plugins/:/usr/local/share/lua/5.1/kong/plugins/ \</span><br><span class="line">     -e &quot;KONG_DATABASE=postgres&quot; \</span><br><span class="line">     -e &quot;KONG_PG_HOST=kong-database&quot; \</span><br><span class="line">     -e &quot;KONG_CASSANDRA_CONTACT_POINTS=kong-database&quot; \</span><br><span class="line">     -e &quot;KONG_PROXY_ACCESS_LOG=/var/log/kong/access.log&quot; \</span><br><span class="line">     -e &quot;KONG_ADMIN_ACCESS_LOG=/var/log/kong/admin_access.log&quot; \</span><br><span class="line">     -e &quot;KONG_PROXY_ERROR_LOG=/var/log/kong/error.log&quot; \</span><br><span class="line">     -e &quot;KONG_ADMIN_ERROR_LOG=/var/log/kong/admin_error.log&quot; \</span><br><span class="line">     -e &quot;KONG_ADMIN_LISTEN=0.0.0.0:8001, 0.0.0.0:8444 ssl&quot; \</span><br><span class="line">     -p 8000:8000 \</span><br><span class="line">     -p 8443:8443 \</span><br><span class="line">     -p 8001:8001 \</span><br><span class="line">     -p 8444:8444 \</span><br><span class="line">     kong:latest</span><br></pre></td></tr></table></figure><blockquote><p>这里我映射了kong的插件目录和日志目录. </p></blockquote><ul><li>注意:要先吧kong容器里的/usr/local/share/lua/5.1/kong/plugins/目录下内容复制到宿主机的/data/apps/kong/plugins/目录下.否则宿主机的空目录会覆盖容器的插件目录,导致容器无法启动.</li></ul><p>kong容器目录拷贝到宿主机方法如下:</p><p>1.先不挂载目录启动kong容器</p><p>2.执行命令拷贝kong容器的/usr/local/share/lua/5.1/kong/plugins/ 目录到宿主机/data/apps/kong/plugins/目录下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[work@docker ~]$docker cp kong:/usr/local/share/lua/5.1/kong/plugins/  /data/apps/kong/plugins/</span><br></pre></td></tr></table></figure><blockquote><p>如果不需要将容器的kong插件目录映射到宿主机的话,这一步可以不需要做</p></blockquote><p>容器已经成功启动:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@docker conf.d]$docker ps | grep -E &quot;kong|postgre&quot;</span><br><span class="line">10fc881cca4b        kong:latest                                 &quot;/docker-entrypoin...&quot;   About an hour ago   Up About an hour    0.0.0.0:8000-8001-&gt;8000-8001/tcp, 0.0.0.0:8443-8444-&gt;8443-8444/tcp                                             kong</span><br><span class="line"></span><br><span class="line">afd1487e29a0        postgres:9.6                                &quot;docker-entrypoint...&quot;   3 hours ago         Up 3 hours          0.0.0.0:5432-&gt;5432/tcp                                                                                         kong-database</span><br></pre></td></tr></table></figure><hr><h4 id="安装konga"><a href="#安装konga" class="headerlink" title="安装konga"></a>安装konga</h4><p>konga是管理kong的一个dashboard界面.</p><p>1.先初始化数据库.这里也是用后端的postgresql数据库.官方命令如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm pantsel/konga:latest -c prepare -a &#123;&#123;adapter&#125;&#125; -u &#123;&#123;connection-uri&#125;&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>argument</th><th>description</th><th>default</th></tr></thead><tbody><tr><td>-c</td><td>command</td><td>-</td></tr><tr><td>-a</td><td>adapter (can be <code>postgres</code> or <code>mysql</code>)</td><td>-</td></tr><tr><td>-u</td><td>full database connection url</td></tr></tbody></table><p>执行以下命令,初始化数据库:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --rm pantsel/konga:latest -c prepare -a postgres -u  postgres://kong@10.0.0.250:5432/konga</span><br></pre></td></tr></table></figure><blockquote><p>这里稍微有点疑问的是数据库的connection url ..完整的connection url地址是: postgres://user:password@host:port/konga</p><p> postgres:<a href="mailto://kong@10.0.0.250" target="_blank" rel="noopener">//kong@10.0.0.250</a>:5432/konga —— 这里kong代表用户名,由于没有密码所以没有指定密码.10.0.0.250是postgresql的host主机名.konga表示初始化一个数据库</p></blockquote><p>执行结果如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[work@docker ~]$docker run --rm pantsel/konga:latest -c prepare -a postgres -u  postgres://kong@10.0.0.250:5432/konga</span><br><span class="line">debug: Preparing database...</span><br><span class="line">Using postgres DB Adapter.</span><br><span class="line">Database `konga` does not exist. Creating...</span><br><span class="line">Database `konga` created! Continue...</span><br><span class="line">debug: Hook:api_health_checks:process() called</span><br><span class="line">debug: Hook:health_checks:process() called</span><br><span class="line">debug: Hook:start-scheduled-snapshots:process() called</span><br><span class="line">debug: Hook:upstream_health_checks:process() called</span><br><span class="line">debug: Hook:user_events_hook:process() called</span><br><span class="line">debug: Seeding User...</span><br><span class="line">debug: User seed planted</span><br><span class="line">debug: Seeding Kongnode...</span><br><span class="line">debug: Kongnode seed planted</span><br><span class="line">debug: Seeding Emailtransport...</span><br><span class="line">debug: Emailtransport seed planted</span><br><span class="line">debug: Database migrations completed!</span><br></pre></td></tr></table></figure><ol start="2"><li>启动konga</li></ol><p>命令格式如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -p 1337:1337 </span><br><span class="line">             --network &#123;&#123;kong-network&#125;&#125; \ // optional</span><br><span class="line">             -e &quot;TOKEN_SECRET=&#123;&#123;somerandomstring&#125;&#125;&quot; \</span><br><span class="line">             -e &quot;DB_ADAPTER=the-name-of-the-adapter&quot; \ // &apos;mongo&apos;,&apos;postgres&apos;,&apos;sqlserver&apos;  or &apos;mysql&apos;</span><br><span class="line">             -e &quot;DB_HOST=your-db-hostname&quot; \</span><br><span class="line">             -e &quot;DB_PORT=your-db-port&quot; \ // Defaults to the default db port</span><br><span class="line">             -e &quot;DB_USER=your-db-user&quot; \ // Omit if not relevant</span><br><span class="line">             -e &quot;DB_PASSWORD=your-db-password&quot; \ // Omit if not relevant</span><br><span class="line">             -e &quot;DB_DATABASE=your-db-name&quot; \ // Defaults to &apos;konga_database&apos;</span><br><span class="line">             -e &quot;DB_PG_SCHEMA=my-schema&quot;\ // Optionally define a schema when integrating with prostgres</span><br><span class="line">             -e &quot;NODE_ENV=production&quot; \ // or &apos;development&apos; | defaults to &apos;development&apos;</span><br><span class="line">             --name konga \</span><br><span class="line">             pantsel/konga</span><br></pre></td></tr></table></figure><p>执行如下命令:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 1337:1337 -d \</span><br><span class="line">             --network=kong-net \</span><br><span class="line">             -e &quot;DB_ADAPTER=postgres&quot; \</span><br><span class="line">             -e &quot;DB_HOST=10.0.0.250&quot; \</span><br><span class="line">             -e &quot;DB_PORT=5432&quot; \</span><br><span class="line">             -e &quot;DB_USER=kong&quot; \</span><br><span class="line">             -e &quot;DB_DATABASE=konga&quot; \</span><br><span class="line">             -e &quot;NODE_ENV=production&quot; \</span><br><span class="line">             --name konga \</span><br><span class="line">             pantsel/konga</span><br></pre></td></tr></table></figure><p>容器成功启动:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">beb70407b417        pantsel/konga                               &quot;/app/start.sh&quot;          2 hours ago         Up 2 hours          0.0.0.0:1337-&gt;1337/tcp                                                                                         konga</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;docker安装最新版Kong-v1-0-konga&quot;&gt;&lt;a href=&quot;#docker安装最新版Kong-v1-0-konga&quot; class=&quot;headerlink&quot; title=&quot;docker安装最新版Kong(v1.0)+konga&quot;&gt;&lt;/a&gt;docker安装最新版Kong(v1.0)+konga&lt;/h3&gt;&lt;p&gt;参考以下文档:&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://docs.konghq.com/install/docker/?_ga=2.167535422.1288669860.1553147426-917309945.1539077269&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kong installation&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/pantsel/konga#installation&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;konga github&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;docker安装kong-postgresql&quot;&gt;&lt;a href=&quot;#docker安装kong-postgresql&quot; class=&quot;headerlink&quot; title=&quot;docker安装kong+postgresql&quot;&gt;&lt;/a&gt;docker安装kong+postgresql&lt;/h4&gt;&lt;p&gt;1.创建一个docker网络用于docker,postgresql和konga容器间通信&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker network create kong-net&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;2.启动posgtresql容器&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker run -d --name kong-database \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               --network=kong-net \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               -p 5432:5432 \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               -e &amp;quot;POSTGRES_USER=kong&amp;quot; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               -e &amp;quot;POSTGRES_DB=kong&amp;quot; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;               postgres:9.6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3.初始化postgresql数据库&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;$ docker run --rm \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    --network=kong-net \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -e &amp;quot;KONG_DATABASE=postgres&amp;quot; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -e &amp;quot;KONG_PG_HOST=kong-database&amp;quot; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    -e &amp;quot;KONG_CASSANDRA_CONTACT_POINTS=kong-database&amp;quot; \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    kong:latest kong migrations bootstrap&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;注意两点:&lt;/p&gt;
&lt;p&gt;1.最好是先删除本地的kong镜像.因为本地的Kong:lastest镜像不一定就是最新版&lt;/p&gt;
&lt;p&gt;2.如果本地的kong:latest镜像地域0.15版本,则不支持bootstrap命令.可以将bootstrap命令替换成up&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="Linux-Web" scheme="https://jesse.top/categories/Linux-Web/"/>
    
    
      <category term="nginx" scheme="https://jesse.top/tags/nginx/"/>
    
      <category term="web" scheme="https://jesse.top/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>k8s挂载NFS网络磁盘</title>
    <link href="https://jesse.top/2020/06/26/kubernetes/k8s%E6%8C%82%E8%BD%BDNFS%E7%BD%91%E7%BB%9C%E7%A3%81%E7%9B%98/"/>
    <id>https://jesse.top/2020/06/26/kubernetes/k8s挂载NFS网络磁盘/</id>
    <published>2020-06-26T03:59:58.000Z</published>
    <updated>2020-06-26T03:04:46.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="k8s挂载NFS网络磁盘"><a href="#k8s挂载NFS网络磁盘" class="headerlink" title="k8s挂载NFS网络磁盘"></a>k8s挂载NFS网络磁盘</h2><p>按照<kubernetes in="" action="">这本书NFS做持久化存储的例子,发现了一个坑.,启动pod失败,报如下错误</kubernetes></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chown: changing ownership of &apos;/data/db&apos;: Operation not permitted</span><br></pre></td></tr></table></figure><p>网上也有人遇到这个问题.可以参考这篇文档: <a href="https://blog.csdn.net/herhun_chen/article/details/90247123" target="_blank" rel="noopener">Kubernetes 集群挂载NFS Volume</a></p><a id="more"></a><p>以下是pod的yaml文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">[root@k8s-m01 ~]# cat mongodb-pod-nfs.yaml</span><br><span class="line">apiVersion: v1</span><br><span class="line">kind: Pod</span><br><span class="line">metadata:</span><br><span class="line">  name: mongodb</span><br><span class="line">spec:</span><br><span class="line">  volumes:</span><br><span class="line">     - name: mongodb-data</span><br><span class="line">       nfs:</span><br><span class="line">         server: 10.111.5.184</span><br><span class="line">         path: /data/k8s/</span><br><span class="line"></span><br><span class="line">  containers:</span><br><span class="line">     - image: mongo</span><br><span class="line">       name: mongodb</span><br><span class="line">       volumeMounts:</span><br><span class="line">         - name: mongodb-data</span><br><span class="line">           mountPath: /data/db</span><br><span class="line">       ports:</span><br><span class="line">         - containerPort: 27017</span><br><span class="line">           protocol: TCP</span><br></pre></td></tr></table></figure><p>出现这种<figure class="highlight plain"><figcaption><span>not permitted```的权限类问题,肯定是NFS的挂载有问题.但是在所有k8s的节点上往NFS共享磁盘写文件,又是正常的.</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">解决这个问题需要在NFS服务器的```/etx/exports```配置文件修改成如下配置</span><br></pre></td></tr></table></figure></p><p>[work@hsq-beta-rpc ~]$cat /etc/exports<br>/data/k8s/ 10.111.0.0/16(rw,fsid=0,async,no_subtree_check,no_auth_nlm,insecure,no_root_squash)<br><code>`</code></p><blockquote><p>注意,以上配置其实是一行.没有换行</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;k8s挂载NFS网络磁盘&quot;&gt;&lt;a href=&quot;#k8s挂载NFS网络磁盘&quot; class=&quot;headerlink&quot; title=&quot;k8s挂载NFS网络磁盘&quot;&gt;&lt;/a&gt;k8s挂载NFS网络磁盘&lt;/h2&gt;&lt;p&gt;按照&lt;kubernetes in=&quot;&quot; action=&quot;&quot;&gt;这本书NFS做持久化存储的例子,发现了一个坑.,启动pod失败,报如下错误&lt;/kubernetes&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;chown: changing ownership of &amp;apos;/data/db&amp;apos;: Operation not permitted&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;网上也有人遇到这个问题.可以参考这篇文档: &lt;a href=&quot;https://blog.csdn.net/herhun_chen/article/details/90247123&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Kubernetes 集群挂载NFS Volume&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="kubernetes" scheme="https://jesse.top/categories/kubernetes/"/>
    
    
      <category term="k8s" scheme="https://jesse.top/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>kong+casssandra集群环境部署</title>
    <link href="https://jesse.top/2020/06/26/Linux-Web/kong%20casssandra%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    <id>https://jesse.top/2020/06/26/Linux-Web/kong casssandra集群环境部署/</id>
    <published>2020-06-26T03:59:58.000Z</published>
    <updated>2020-06-26T03:07:42.986Z</updated>
    
    <content type="html"><![CDATA[<h2 id="kong-casssandra集群环境部署"><a href="#kong-casssandra集群环境部署" class="headerlink" title="kong+casssandra集群环境部署"></a>kong+casssandra集群环境部署</h2><h3 id="kong简介"><a href="#kong简介" class="headerlink" title="kong简介"></a>kong简介</h3><p>Kong是Mashape开源的一款API网关，起初是用来管理 Mashape 公司15000个微服务的，后来在2015年开源,现在已经在很多创业公司、大型企业和政府机构中广泛使用。基于nginx,Lua和Cassandra或PostgreSQL，支持分布式操作，有很强的可移植性和可扩展性。可以在任何一种基础设施上运行,作为应用和API之间的中间层，加上众多功能强大的插件，可以实现认证授权、访问控制等功能。并且提供易于使用的RESTful API来操作和配置系统。</p><p>有关kong的详细介绍请参考官网.</p><p>–</p><h3 id="cassandra简介"><a href="#cassandra简介" class="headerlink" title="cassandra简介"></a>cassandra简介</h3><p>Cassandra 是一个来自 Apache 的分布式数据库，具有高度可扩展性，可用于管理大量的结构化数据。它提供了高可用性，没有单点故障。kong支持PostgreSQL或者Cassandra两种数据库.这里我们选择了cassandra.</p><p>有关cassandra的详细介绍和使用方法.请参考官网</p><a id="more"></a><p>–</p><h3 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h3><ul><li><strong>kong cluster</strong></li></ul><p>kong 集群并不意味着客户端请求将会负载均衡到kong集群中的每个节点上，kong集群并不是开箱即用，仍然需要在kong集群多节点上层搭建负载均衡，以便分发请求。 一个kong集群只是意味着集群内的节点，都共享同样的配置。</p><p>有关Kong cluster集群的详细介绍请参考官网:<a href="https://docs.konghq.com/0.14.x/clustering/" target="_blank" rel="noopener">Kong cluser document</a></p><p>为了提高冗余性和健壮性.我们对kong的每个环节都进行了冗余设计.一个基本的kong集群架构大概如下图所示:</p><p><img src="http://pabkmteb4.bkt.clouddn.com/kong-flow.png" alt=""></p><p>–</p><h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3><p><strong>环境</strong>: </p><p>阿里云ECS Centos7.4操作系统<br>Kong: 0.14 最新版<br>Cassandra: 3.11 最新版</p><p>–</p><h4 id="安装Cassandra"><a href="#安装Cassandra" class="headerlink" title="安装Cassandra"></a>安装Cassandra</h4><p>安装方式官网参考: <a href="http://cassandra.apache.org/doc/latest/getting_started/installing.html#installation-from-binary-tarball-files" target="_blank" rel="noopener">Installing Cassandra</a></p><p><strong>安装前提条件</strong></p><p>1.安装JDK 8版本<br>2.安装2.7以上版本的Python.(cassandra管理工具:cqlsh 需要python2.7以上环境)</p><p><strong>安装步骤</strong></p><p>1.下载cassandra二进制文件.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirrors.tuna.tsinghua.edu.cn/apache/cassandra/3.11.3/apache-cassandra-3.11.3-bin.tar.gz</span><br></pre></td></tr></table></figure><p>2.将cassandra目录添加进环境变量.用work用户运行cassandra</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /usr/local/cassandra</span><br><span class="line">sudo chown -R work:work /usr/local/cassandra</span><br><span class="line">sudo tar -xvf apache-cassandra-3.11.3-bin.tar.gz -C /usr/local/cassandra</span><br><span class="line"></span><br><span class="line">cd /usr/local/cassandra</span><br><span class="line">sudo mv apache-cassandra-3.11.3/* .</span><br><span class="line">sudo rm apache-cassandra-3.11.3/ -rf</span><br></pre></td></tr></table></figure><p>添加进环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br><span class="line"></span><br><span class="line">export JAVA_HOME=/usr/local/java</span><br><span class="line">export CASSANDRA_HOME=/usr/local/cassandra</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$CASSANDRA_HOME/bin</span><br></pre></td></tr></table></figure><p>–</p><h4 id="配置Cassandra-以及cassandra集群"><a href="#配置Cassandra-以及cassandra集群" class="headerlink" title="配置Cassandra,以及cassandra集群"></a>配置Cassandra,以及cassandra集群</h4><p>1.编辑cassandra的cassandra.yml配置文件.修改下列配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 kong]$ vim /usr/local/cassandra/conf/cassandra.yaml</span><br><span class="line"></span><br><span class="line">#定义Cassandra集群名</span><br><span class="line">cluster_name: &apos;dwd_cassandra&apos;</span><br><span class="line">#定义hints路径.可以使用默认路径</span><br><span class="line">hints_directory: /data/cassandra/hints</span><br><span class="line"></span><br><span class="line">#采用密码方式连接数据库.默认情况下不需要任何用户密码就可以登录数据库</span><br><span class="line">authenticator: PasswordAuthenticator</span><br><span class="line"></span><br><span class="line">#定义数据库文件路径.可以使用默认/var/lib路径</span><br><span class="line">data_file_directories:</span><br><span class="line">      - /data/cassandra</span><br><span class="line"></span><br><span class="line">#定义commit日志路径.可以使用默认路径</span><br><span class="line">commitlog_directory: /data/cassandra/commitlog</span><br><span class="line"></span><br><span class="line">#缓存文件路径</span><br><span class="line">saved_caches_directory: /data/cassandra/saved_caches</span><br><span class="line"></span><br><span class="line">#关键配置,定义集群种子服务器地址.这里定义服务器的内网地址.不能使用0.0.0.0或者127的本机地址,可以加入多个集群节点的地址,IP地址之间用逗号分隔</span><br><span class="line">- seeds: &quot;10.25.87.159&quot;</span><br><span class="line"></span><br><span class="line">#listen地址</span><br><span class="line">listen_address: 10.25.87.159</span><br><span class="line"></span><br><span class="line">#rpc地址</span><br><span class="line">rpc_address: 10.25.87.159</span><br></pre></td></tr></table></figure><p>2.创建刚才定义的路径目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -pv /data/cassandra </span><br><span class="line">sudo chown -R work.work /data/</span><br></pre></td></tr></table></figure><p>3.启动cassandra.直接在命令行执行cassandra</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 kong]$ cassandra </span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">[work@kong-node1 kong]$ /usr/local/cassandra/bin/cassandra</span><br></pre></td></tr></table></figure><ol start="4"><li>使用cqlsh工具登陆cassandra数据库.创建cassandra用户密码,以及创建键空间</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#注意由于cassandra只侦听了内网的地址,因此要指定IP地址.</span><br><span class="line">#默认账号密码都是cassandra</span><br><span class="line">[work@kong-node1 kong]$ cqlsh 10.25.87.159  -ucassandra -pcassandra </span><br><span class="line"></span><br><span class="line">#创建一个kong用户.并且为超级用户</span><br><span class="line">cassandra@cqlsh&gt; create user kong with password &apos;kong&apos; superuser;</span><br><span class="line"></span><br><span class="line">#创建一个keyspace.命名为kong</span><br><span class="line">cassandra@cqlsh&gt; CREATE KEYSPACE kong WITH REPLICATION = &#123; &apos;class&apos; : &apos;SimpleStrategy&apos;, &apos;replication_factor&apos; : 1&#125;;</span><br><span class="line"></span><br><span class="line">cassandra@cqlsh&gt; exit</span><br></pre></td></tr></table></figure><p>5.删除自带的cassandra用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 cassandra]$ cqlsh 10.25.87.159  -ukong -pkong</span><br><span class="line">kong@cqlsh&gt; desc kong;</span><br><span class="line"></span><br><span class="line">CREATE KEYSPACE kong WITH replication = &#123;&apos;class&apos;: &apos;SimpleStrategy&apos;, &apos;replication_factor&apos;: &apos;1&apos;&#125;  AND durable_writes = true;</span><br><span class="line"></span><br><span class="line">kong@cqlsh&gt; drop user cassandra;</span><br></pre></td></tr></table></figure><p>–</p><h4 id="安装Kong"><a href="#安装Kong" class="headerlink" title="安装Kong"></a>安装Kong</h4><p>安装方法可以参考官网:<a href="https://docs.konghq.com/install/centos/?_ga=2.110797315.728319704.1539597667-917309945.1539077269#packages" target="_blank" rel="noopener">Install Kong</a></p><p>1.下载,安装rpm安装包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget -O kong-community-edition-0.14.1.el7.noarch.rpm  https://bintray.com/kong/kong-community-edition-rpm/download_file?file_path=centos/7/kong-community-edition-0.14.1.el7.noarch.rpm</span><br><span class="line"></span><br><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install kong-community-edition-0.14.1.el7.noarch.rpm</span><br></pre></td></tr></table></figure><p>2.修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/kong</span><br><span class="line">sudo cp kong.conf.default kong.conf</span><br><span class="line"></span><br><span class="line">sudo vim kong.conf</span><br><span class="line"></span><br><span class="line">#修改日志文件路径</span><br><span class="line">prefix = /data/kong/</span><br><span class="line"></span><br><span class="line">#由于磁盘空间有限,关闭kong的代理日志.后端真实服务器会记录nginx访问日志</span><br><span class="line">proxy_access_log = off</span><br><span class="line">proxy_error_log = off</span><br><span class="line"></span><br><span class="line">#在所有地址侦听管理端口,当然只侦听127地址会更安全.</span><br><span class="line">admin_listen = 0.0.0.0:8001, 0.0.0.0:8444 ssl</span><br><span class="line"></span><br><span class="line">#指定使用cassandra数据库</span><br><span class="line">database = cassandra</span><br><span class="line">#数据库地址,端口</span><br><span class="line">cassandra_contact_points = 10.25.87.159</span><br><span class="line">cassandra_port = 9042</span><br><span class="line"></span><br><span class="line">#上文定义的cassandra数据库的用户密码和键空间</span><br><span class="line">cassandra_keyspace = kong</span><br><span class="line">cassandra_username = kong</span><br><span class="line">cassandra_password = kong</span><br><span class="line"></span><br><span class="line">#kong官方建议的cassandra一致性机制</span><br><span class="line">cassandra_consistency = QUORUM</span><br><span class="line"></span><br><span class="line">#以下是集群的数据库和缓存方面的配置.详细介绍请参考官网</span><br><span class="line">db_update_frequency = 5</span><br><span class="line">db_update_propagation = 2</span><br></pre></td></tr></table></figure><p>3.创建kong目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/kong</span><br></pre></td></tr></table></figure><p>4.准备启动工作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kong migrations up -c /etc/kong/kong.conf</span><br></pre></td></tr></table></figure><p>5.启动kong</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kong start -c /etc/kong/kong.conf</span><br></pre></td></tr></table></figure><p>查看端口.可以看到cassandra和kong的侦听端口都已经成功启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">work@kong-node1 kong]$ netstat -tulnp</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class="line">tcp        0      0 0.0.0.0:8443            0.0.0.0:*               LISTEN      29342/nginx: master</span><br><span class="line">tcp        0      0 0.0.0.0:8444            0.0.0.0:*               LISTEN      29342/nginx: master</span><br><span class="line">tcp        0      0 127.0.0.1:7199          0.0.0.0:*               LISTEN      28598/java</span><br><span class="line">tcp        0      0 0.0.0.0:8000            0.0.0.0:*               LISTEN      29342/nginx: master</span><br><span class="line">tcp        0      0 0.0.0.0:8001            0.0.0.0:*               LISTEN      29342/nginx: master</span><br><span class="line">tcp        0      0 127.0.0.1:35503         0.0.0.0:*               LISTEN      28598/java</span><br><span class="line">tcp        0      0 10.25.87.159:9042       0.0.0.0:*               LISTEN      28598/java</span><br><span class="line">tcp        0      0 10.25.87.159:7000       0.0.0.0:*               LISTEN      28598/java</span><br></pre></td></tr></table></figure><hr><h3 id="部署另外一台kong和cassandra"><a href="#部署另外一台kong和cassandra" class="headerlink" title="部署另外一台kong和cassandra"></a>部署另外一台kong和cassandra</h3><p>今天在阿里云镜像了kong-node1的服务器.新的服务器名字为kong-node2.<br>软件已经安装,只需要修改部分配置</p><h5 id="修改node1和node2上的cassandra配置"><a href="#修改node1和node2上的cassandra配置" class="headerlink" title="修改node1和node2上的cassandra配置"></a>修改node1和node2上的cassandra配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在node1和node2上:</span><br><span class="line">[work@kong-node2 ~]$ vim /usr/local/cassandra/conf/cassandra.yaml</span><br><span class="line">#修改seeds配置.添加2台服务器的内网IP地址</span><br><span class="line">- seeds: &quot;10.25.87.159, 10.80.229.244&quot; </span><br><span class="line"></span><br><span class="line">在node2上修改侦听地址</span><br><span class="line">[work@kong-node2 ~]$ vim /usr/local/cassandra/conf/cassandra.yaml</span><br><span class="line">#将下列地址改成node2内网地址</span><br><span class="line">listen_address: 10.80.229.244</span><br><span class="line">rpc_address: 10.80.229.244</span><br></pre></td></tr></table></figure><h5 id="在node2上修改kong的配置文件"><a href="#在node2上修改kong的配置文件" class="headerlink" title="在node2上修改kong的配置文件:"></a>在node2上修改kong的配置文件:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">work@kong-node2 ~]$ vim /etc/kong/kong.conf</span><br><span class="line">#连接本机的cassandra数据库地址</span><br><span class="line">cassandra_contact_points = 10.80.229.244</span><br></pre></td></tr></table></figure><blockquote><p>note:千万不要启动node2上的cassandra.因为node2是从node1镜像过去的.所以数据库的token是一模一样的.</p></blockquote><h5 id="在node2上删除cassandra的数据库-这一步非常重要-因为这是从node1镜像过来的-所以node2上的数据库是node1的数据"><a href="#在node2上删除cassandra的数据库-这一步非常重要-因为这是从node1镜像过来的-所以node2上的数据库是node1的数据" class="headerlink" title="在node2上删除cassandra的数据库.这一步非常重要.因为这是从node1镜像过来的.所以node2上的数据库是node1的数据"></a>在node2上删除cassandra的数据库.这一步非常重要.因为这是从node1镜像过来的.所以node2上的数据库是node1的数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /data/cassandra/*</span><br></pre></td></tr></table></figure><h5 id="启动node2上的数据库"><a href="#启动node2上的数据库" class="headerlink" title="启动node2上的数据库"></a>启动node2上的数据库</h5><p>直接在命令行执行:cassandra</p><h5 id="查看cassandra的单台服务器状态"><a href="#查看cassandra的单台服务器状态" class="headerlink" title="查看cassandra的单台服务器状态"></a>查看cassandra的单台服务器状态</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 bin]$ nodetool info</span><br><span class="line">ID                     : 4fe1df37-e69e-4a25-acdc-4b2d73a92225</span><br><span class="line">Gossip active          : true</span><br><span class="line">Thrift active          : false</span><br><span class="line">Native Transport active: true</span><br><span class="line">Load                   : 522.87 KiB</span><br><span class="line">Generation No          : 1540372001</span><br><span class="line">Uptime (seconds)       : 63895</span><br><span class="line">Heap Memory (MB)       : 404.89 / 1004.00</span><br><span class="line">Off Heap Memory (MB)   : 0.00</span><br><span class="line">Data Center            : datacenter1</span><br><span class="line">Rack                   : rack1</span><br><span class="line">Exceptions             : 0</span><br><span class="line">Key Cache              : entries 59, size 5.03 KiB, capacity 50 MiB, 7540 hits, 7911 requests, 0.953 recent hit rate, 14400 save period in seconds</span><br><span class="line">Row Cache              : entries 0, size 0 bytes, capacity 0 bytes, 0 hits, 0 requests, NaN recent hit rate, 0 save period in seconds</span><br><span class="line">Counter Cache          : entries 0, size 0 bytes, capacity 25 MiB, 0 hits, 0 requests, NaN recent hit rate, 7200 save period in seconds</span><br><span class="line">Chunk Cache            : entries 28, size 1.75 MiB, capacity 219 MiB, 1237 misses, 26133 requests, 0.953 recent hit rate, NaN microseconds miss latency</span><br><span class="line">Percent Repaired       : 100.0%</span><br><span class="line">Token                  : (invoke with -T/--tokens to see all 256 tokens)</span><br></pre></td></tr></table></figure><h5 id="查看cassandra集群状态-可以看到集群中2台服务器"><a href="#查看cassandra集群状态-可以看到集群中2台服务器" class="headerlink" title="查看cassandra集群状态.可以看到集群中2台服务器"></a>查看cassandra集群状态.可以看到集群中2台服务器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 bin]$ nodetool status</span><br><span class="line">Datacenter: datacenter1</span><br><span class="line">=======================</span><br><span class="line">Status=Up/Down</span><br><span class="line">|/ State=Normal/Leaving/Joining/Moving</span><br><span class="line">--  Address        Load       Tokens       Owns (effective)  Host ID                               Rack</span><br><span class="line">UN  10.80.229.244  339.93 KiB  256          51.3%             04a75f63-be99-4f3e-93ff-937bbe9656d8  rack1</span><br><span class="line">UN  10.25.87.159   522.87 KiB  256          48.7%             4fe1df37-e69e-4a25-acdc-4b2d73a92225  rack1</span><br></pre></td></tr></table></figure><hr><h4 id="以下是我踩过的坑-在没有删除node2上的数据库文件情况下-直接启动cassnadra"><a href="#以下是我踩过的坑-在没有删除node2上的数据库文件情况下-直接启动cassnadra" class="headerlink" title="以下是我踩过的坑.在没有删除node2上的数据库文件情况下,直接启动cassnadra."></a>以下是我踩过的坑.在没有删除node2上的数据库文件情况下,直接启动cassnadra.</h4><p>启动node2的cassandra后.发现集群无法正常启动.使用cassandra自带的nodetool工具可以查看集群状态.这里只有自己一台服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node2 ~]$ nodetool status</span><br><span class="line">Datacenter: datacenter1</span><br><span class="line">=======================</span><br><span class="line">Status=Up/Down</span><br><span class="line">|/ State=Normal/Leaving/Joining/Moving</span><br><span class="line">--  Address        Load       Tokens       Owns (effective)  Host ID                               Rack</span><br><span class="line">UN  10.80.229.244  600.05 KiB  256          100.0%            4fe1df37-e69e-4a25-acdc-4b2d73a92225  rack1</span><br></pre></td></tr></table></figure><p>查看cassandra启动日志,发现日志提示和node1有一样的token:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">less /usr/local/cassandra/logs/system.log</span><br><span class="line"></span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,874 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token -9066137612411979055.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,874 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token -912539082610246005.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,874 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token -9125687604150710607.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,874 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token -9186325188411815558.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,874 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token -934168442605847346.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,874 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token -937629522304513228.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,874 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token -983284835358960159.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,875 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token 1111859401021864246.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,875 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token 1185525604491731552.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,875 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token 1209704333924286496.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,875 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token 1243859262038298713.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,875 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token 1284321765579584761.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,875 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token 1472069791929520463.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,875 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token 1479257042759500258.  Ignoring /10.25.87.159</span><br></pre></td></tr></table></figure><p>不仅如此,在node1上启动kong,提示cassandra数据库验证失败.以及提示kong需要migrations up(只需要在第一次启动kong时才需要migratios up):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 bin]$ kong restart -c /etc/kong/kong.conf</span><br><span class="line">Error: /usr/local/share/lua/5.1/kong/cmd/start.lua:37: [cassandra error] the current database schema does not match this version of Kong. Please run `kong migrations up` to update/initialize the database schema. Be aware that Kong migrations should only run from a single node, and that nodes running migrations concurrently will conflict with each other and might corrupt your database schema!</span><br></pre></td></tr></table></figure><p>kong migrations失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> work@kong-node1 bin]$ kong migrations up -c /etc/kong/kong.conf</span><br><span class="line">migrating core for keyspace kong</span><br><span class="line">core migrated up to: 2015-01-12-175310_skeleton</span><br><span class="line">Error: [cassandra error] Error during migration 2015-01-12-175310_init_schema: [Invalid] Undefined column name request_host</span><br></pre></td></tr></table></figure><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>启动node1和node2的cassandra</p><p>1.在node1和node2上drop kong的键空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 bin]$ cqlsh 10.25.87.159 -ukong -pkong</span><br><span class="line">Connected to dwd_cassandra at 10.25.87.159:9042.</span><br><span class="line">[cqlsh 5.0.1 | Cassandra 3.11.3 | CQL spec 3.4.4 | Native protocol v4]</span><br><span class="line">Use HELP for help.</span><br><span class="line">kong@cqlsh&gt; drop keyspace kong;</span><br><span class="line">kong@cqlsh&gt; exit</span><br><span class="line"></span><br><span class="line">[work@kong-node2 ~]$ cqlsh 10.80.229.244 -ukong -pkong</span><br><span class="line">Connected to dwd_cassandra at 10.80.229.244:9042.</span><br><span class="line">[cqlsh 5.0.1 | Cassandra 3.11.3 | CQL spec 3.4.4 | Native protocol v4]</span><br><span class="line">Use HELP for help.</span><br><span class="line">kong@cqlsh&gt; drop KEYSPACE kong;</span><br><span class="line">ConfigurationException: Cannot drop non existing keyspace &apos;kong&apos;.</span><br><span class="line">kong@cqlsh&gt; exit</span><br></pre></td></tr></table></figure><p>2.删除kong的键空间目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[work@kong-node1 bin]$ rm -rf  /data/cassandra/kong/</span><br><span class="line">[work@kong-node1 bin]$ ll /data/cassandra/kong/</span><br><span class="line">ls: cannot access /data/cassandra/kong/: No such file or directory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[work@kong-node2 ~]$ rm -rf /data/cassandra/kong/</span><br><span class="line">[work@kong-node2 ~]$ ll /data/cassandra/kong/</span><br><span class="line">ls: cannot access /data/cassandra/kong/: No such file or directory</span><br></pre></td></tr></table></figure><p>3.在node1上创建kong键空间.创建完毕后,应该会同步到node2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 bin]$ cqlsh 10.25.87.159 -ukong -pkong</span><br><span class="line">Connected to dwd_cassandra at 10.25.87.159:9042.</span><br><span class="line">[cqlsh 5.0.1 | Cassandra 3.11.3 | CQL spec 3.4.4 | Native protocol v4]</span><br><span class="line">Use HELP for help.</span><br><span class="line">kong@cqlsh&gt; CREATE KEYSPACE kong WITH REPLICATION = &#123; &apos;class&apos; : &apos;SimpleStrategy&apos;, &apos;replication_factor&apos; : 1&#125;;</span><br><span class="line">kong@cqlsh&gt; exit</span><br></pre></td></tr></table></figure><p>4.在node1上执行 kong migrations up ,执行完后同样会同步到node2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">work@kong-node1 bin]$ kong migrations up -c /etc/kong/kong.conf</span><br><span class="line">migrating core for keyspace kong</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">66 migrations ran</span><br><span class="line">waiting for Cassandra schema consensus (10000ms timeout)...</span><br><span class="line">Cassandra schema consensus: reached</span><br></pre></td></tr></table></figure><p>5.在node1和node2上启动kong</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 bin]$ kong restart -c /etc/kong/kong.conf</span><br><span class="line"></span><br><span class="line">[work@kong-node2 ~]$ kong start -c /etc/kong/kong.conf</span><br><span class="line">Kong started</span><br></pre></td></tr></table></figure><hr><h3 id="搭建kong-dashboard"><a href="#搭建kong-dashboard" class="headerlink" title="搭建kong-dashboard"></a>搭建kong-dashboard</h3><p>kong-dashboard是管理kong各个组件(serveice,route,plugin,upstream,consumer)的可视化UI管理工具.在增删改查各个组件的配置时非常方便.</p><p>现在kong-dashboard也支持到了最新版的kong和kong的最新组件.</p><p>kong-dashboard的github参考:<a href="https://github.com/PGBI/kong-dashboard" target="_blank" rel="noopener">kong-dashboar</a></p><hr><p>1.确保需要有node.js环境.如果没有npm工具,必须先安装nodejs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@DWD-BETA kong]$ npm -v</span><br><span class="line">5.6.0</span><br><span class="line">[work@DWD-BETA kong]$ node -v</span><br><span class="line">v8.10.0</span><br></pre></td></tr></table></figure><p>2.root用户执行下列安装命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@DWD-BETA ~]# npm install -g kong-dashboard</span><br><span class="line">/usr/local/src/nodejs/bin/kong-dashboard -&gt; /usr/local/src/nodejs/lib/node_modules/kong-dashboard/bin/kong-dashboard.js</span><br><span class="line">+ kong-dashboard@3.5.0</span><br><span class="line">added 184 packages in 28.8s</span><br></pre></td></tr></table></figure><p>3.启动kong-dashboard.启动方式有以下几种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Start Kong Dashboard</span><br><span class="line">kong-dashboard start --kong-url http://kong:8001</span><br><span class="line"></span><br><span class="line"># Start Kong Dashboard on a custom port</span><br><span class="line">kong-dashboard start \</span><br><span class="line">  --kong-url http://kong:8001 \</span><br><span class="line">  --port [port]</span><br><span class="line"></span><br><span class="line"># Start Kong Dashboard with basic auth</span><br><span class="line">kong-dashboard start \</span><br><span class="line">  --kong-url http://kong:8001 \</span><br><span class="line">  --basic-auth user1=password1 user2=password2</span><br><span class="line"></span><br><span class="line"># See full list of start options</span><br><span class="line">kong-dashboard start --help</span><br></pre></td></tr></table></figure><p>但是kong-dashboard是前台启动,没有deamnize模式.所以将kong-dashboard加入到supervisor进程管理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@DWD-BETA ~]# vim /etc/supervisor/conf.d/kong-dashboard.conf</span><br><span class="line"></span><br><span class="line">[program:kong-dashboard]</span><br><span class="line">command=/usr/local/src/nodejs/bin/kong-dashboard start --kong-url http://localhost:8001</span><br><span class="line">numprocs=1</span><br><span class="line">user=work</span><br><span class="line">stdout_logfile = /data/logs/kong/kong-dashboard.log</span><br><span class="line">redirect_stderr = true</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br></pre></td></tr></table></figure><p>修改权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@DWD-BETA ~]# chown -R work.work /etc/supervisor/conf.d/</span><br></pre></td></tr></table></figure><p>更新supervisor配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@DWD-BETA ~]# supervisorctl update kong-dashboard</span><br><span class="line">kong-dashboard: added process group</span><br></pre></td></tr></table></figure><p>但是由于我这台服务器上8080端口已经被使用,所以启动kong-dashboard报错:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">work@DWD-BETA kong]$ /usr/local/src/nodejs/bin/kong-dashboard start --kong-url http://localhost:8001</span><br><span class="line">Connecting to Kong on http://localhost:8001 ...</span><br><span class="line">Connected to Kong on http://localhost:8001.</span><br><span class="line">Kong version is 0.14.1</span><br><span class="line">Starting Kong Dashboard on port 8080</span><br><span class="line">events.js:183</span><br><span class="line">      throw er; // Unhandled &apos;error&apos; event</span><br><span class="line">      ^</span><br><span class="line"></span><br><span class="line">Error: listen EADDRINUSE :::8080</span><br><span class="line">    at Object._errnoException (util.js:1022:11)</span><br><span class="line">    at _exceptionWithHostPort (util.js:1044:20)</span><br><span class="line">    at Server.setupListenHandle [as _listen2] (net.js:1367:14)</span><br><span class="line">    at listenInCluster (net.js:1408:12)</span><br><span class="line">    at Server.listen (net.js:1492:7)</span><br><span class="line">    at Application.listen (/usr/local/src/nodejs/lib/node_modules/kong-dashboard/node_modules/koa/lib/application.js:65:19)</span><br><span class="line">    at Server.start (/usr/local/src/nodejs/lib/node_modules/kong-dashboard/lib/server.js:32:9)</span><br><span class="line">    at startKongDashboard (/usr/local/src/nodejs/lib/node_modules/kong-dashboard/bin/kong-dashboard.js:189:10)</span><br><span class="line">    at request.get.then.then (/usr/local/src/nodejs/lib/node_modules/kong-dashboard/bin/kong-dashboard.js:178:5)</span><br><span class="line">    at &lt;anonymous&gt;</span><br></pre></td></tr></table></figure><p>8080端口被jenkins占用了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@DWD-BETA kong]$ netstat -tulnp | grep 8080</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      17955/java</span><br></pre></td></tr></table></figure><p>更换kong-dashboard端口为8081</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[program:kong-dashboard]</span><br><span class="line">command=/usr/local/src/nodejs/bin/kong-dashboard  start --kong-url http://localhost:8001 --port 8081</span><br><span class="line">numprocs=1</span><br><span class="line">user=work</span><br><span class="line">stdout_logfile = /data/logs/kong/kong-dashboard.log</span><br><span class="line">redirect_stderr = true</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br></pre></td></tr></table></figure><p>更新supervisor后,仍然无法启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[work@DWD-BETA kong]$ supervisorctl update kong-dashboard</span><br><span class="line">kong-dashboard: stopped</span><br><span class="line">kong-dashboard: updated process group</span><br><span class="line">[work@DWD-BETA kong]$ supervisorctl status kong-dashboard</span><br><span class="line">kong-dashboard                   BACKOFF   Exited too quickly (process log may have details)</span><br></pre></td></tr></table></figure><p>手动启动正常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[work@DWD-BETA kong]$ /usr/local/src/nodejs/bin/kong-dashboard  start --kong-url http://localhost:8001 --port 8081</span><br><span class="line">Connecting to Kong on http://localhost:8001 ...</span><br><span class="line">Connected to Kong on http://localhost:8001.</span><br><span class="line">Kong version is 0.14.1</span><br><span class="line">Starting Kong Dashboard on port 8081</span><br><span class="line">Kong Dashboard has started on port 8081</span><br><span class="line">^C</span><br></pre></td></tr></table></figure><p>查看supervisor启动日志文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[work@DWD-BETA kong]$ less /data/logs/kong/kong-dashboard.log</span><br><span class="line">/usr/bin/env: node: No such file or directory</span><br><span class="line">/usr/bin/env: node: No such file or directory</span><br><span class="line">/usr/bin/env: node: No such file or directory</span><br><span class="line">/usr/bin/env: node: No such file or directory</span><br></pre></td></tr></table></figure><p>网上查找解决方案.说是要链接以下文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/bin/nodejs /usr/bin/node</span><br></pre></td></tr></table></figure><p>但是这台服务器上nodejs路径不同,所以执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[work@DWD-BETA kong]$ sudo ln -s /usr/local/src/nodejs /usr/bin/node</span><br></pre></td></tr></table></figure><p>仍然无法启动,提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/env: node: Permission denied</span><br><span class="line">/usr/bin/env: node: Permission denied</span><br><span class="line">/usr/bin/env: node: Permission denied</span><br><span class="line">/usr/bin/env: node: Permission denied</span><br><span class="line">/usr/bin/env: node: Permission denied</span><br><span class="line">/usr/bin/env: node: Permission denied</span><br></pre></td></tr></table></figure><p>修改kong-dashboard启动用户为root.仍然无法启动.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[program:kong-dashboard]</span><br><span class="line">command=/usr/local/src/nodejs/bin/kong-dashboard  start --kong-url http://127.0.0.1:8001 --port 8081</span><br><span class="line">numprocs=1</span><br><span class="line">user=root</span><br><span class="line">stdout_logfile = /data/logs/kong/kong-dashboard.log</span><br><span class="line">redirect_stderr = true</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br></pre></td></tr></table></figure><hr><p>操作失误在创建软件的时候,删除了nodejs源目录.重新安装了npm和kong-dashboard</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">解压nodejs包到:/usr/local/node/</span><br><span class="line"></span><br><span class="line">#设置环境变量: </span><br><span class="line">[root@DWD-BETA ~]# cat /etc/profile | tail -2</span><br><span class="line">export NODEJS_HOME=/usr/local/node/</span><br><span class="line">export PATH=$PATH:$NODEJS_HOME/bin</span><br><span class="line"></span><br><span class="line">[root@DWD-BETA ~]# node -v</span><br><span class="line">v8.10.0</span><br><span class="line">[root@DWD-BETA ~]# npm -v</span><br><span class="line">5.6.0</span><br></pre></td></tr></table></figure><p>创建链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@DWD-BETA ~]# ln -s /usr/local/node/bin/node /usr/bin/node</span><br><span class="line">root@DWD-BETA ~]# ll /usr/bin/node -d</span><br><span class="line">lrwxrwxrwx 1 root root 24 Nov  3 11:25 /usr/bin/node -&gt; /usr/local/node/bin/node</span><br></pre></td></tr></table></figure><p>修改supervisor配置文件中的命令路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[program:kong-dashboard]</span><br><span class="line">command=/usr/local/node/bin/kong-dashboard  start --kong-url http://127.0.0.1:8001 --port 8081</span><br><span class="line">numprocs=1</span><br><span class="line">priority=3</span><br><span class="line">user=root</span><br><span class="line">stdout_logfile = /data/logs/kong/kong-dashboard.log</span><br><span class="line">redirect_stderr = true</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br></pre></td></tr></table></figure><p>启动kong-dashboard</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@DWD-BETA ~]# supervisorctl update kong-dashboard</span><br><span class="line">kong-dashboard: stopped</span><br><span class="line">kong-dashboard: updated process group</span><br><span class="line"></span><br><span class="line">[root@DWD-BETA ~]# supervisorctl status kong-dashboard</span><br><span class="line">kong-dashboard                   RUNNING   pid 16635, uptime 0:05:02</span><br></pre></td></tr></table></figure><p>启动完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@DWD-BETA ~]# netstat -tulnp | grep 8081</span><br><span class="line">tcp6       0      0 :::8081                 :::*                    LISTEN      16635/node</span><br></pre></td></tr></table></figure><hr><h3 id="将cassandra加入到supervisor进程管理"><a href="#将cassandra加入到supervisor进程管理" class="headerlink" title="将cassandra加入到supervisor进程管理"></a>将cassandra加入到supervisor进程管理</h3><p>cassandra加入supervisor进程托管遇到不少问题.踩过以下2个坑:</p><p>1.启动报错,提示需要更高级版本的java.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cassandra 3.0 and later require Java 8u40 or later.</span><br><span class="line">Cassandra 3.0 and later require Java 8u40 or later.</span><br><span class="line">Cassandra 3.0 and later require Java 8u40 or later.</span><br><span class="line">Cassandra 3.0 and later require Java 8u40 or later.</span><br><span class="line">Cassandra 3.0 and later require Java 8u40 or later.</span><br><span class="line">Cassandra 3.0 and later require Java 8u40 or later.</span><br><span class="line">Cassandra 3.0 and later require Java 8u40 or later.</span><br></pre></td></tr></table></figure><p>我的解决方案:</p><ul><li>在cassandra的supervisor配置文件中加入环境变量:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">environment=JAVA_HOME=&quot;/usr/local/java&quot;  #这样cassandra会识别用户自定义安装的Java.</span><br></pre></td></tr></table></figure><ul><li>配置软链</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/local/java/bin/java /usr/bin/java</span><br></pre></td></tr></table></figure><p>2.仍然无法启动,因为命令行是以daemon方式启动.在cassandra的supervisor配置文件中的启动参数加入-f选项.</p><p>最终的cassandra配置文件如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[program:cassandra]</span><br><span class="line">command=/usr/local/cassandra/bin/cassandra -f</span><br><span class="line">directory=/usr/local/cassandra/</span><br><span class="line">environment=JAVA_HOME=&quot;/usr/local/java&quot;</span><br><span class="line">enviroment=PATH=&quot;$JAVA_HOME/bin:$PATH&quot;</span><br><span class="line">priority=0</span><br><span class="line">numprocs=1</span><br><span class="line">user=work</span><br><span class="line">stdout_logfile = /data/logs/cassandra/cassandra_supervisor.log</span><br><span class="line">redirect_stderr = true</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br></pre></td></tr></table></figure><hr><h3 id="将kong加入到supervisor"><a href="#将kong加入到supervisor" class="headerlink" title="将kong加入到supervisor"></a>将kong加入到supervisor</h3><p>1.由于默认kong启动是以daemon方式启动.所以修改/etc/kong/kong.conf配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#将下列行修改为off,且取消注释</span><br><span class="line">nginx_daemon = off</span><br></pre></td></tr></table></figure><p>2.编辑kong的supervisor配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[program:kong]</span><br><span class="line">command=/usr/local/bin/kong start -c /etc/kong/kong.conf</span><br><span class="line">numprocs=1</span><br><span class="line">priority=0</span><br><span class="line">user=work</span><br><span class="line">stdout_logfile = /data/logs/kong/kong_supervisor.log</span><br><span class="line">redirect_stderr = true</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br></pre></td></tr></table></figure><blockquote><p>注意由于kong启动的时候会连接后端的cassandra数据库,所以需要先启动cassandra,再启动kong.这就是为什么supervisor里要加入priority参数.优先级越小,启动顺序越优先.停止顺序越靠后.     </p></blockquote><p><strong>但是经过我的验证,发现priority参数没什么鸟用.当我start all,stop all时.永远是cassandra进程首先启动和关闭,无论priority优先级是大还是小.而不是supervisor官网介绍的那样效果</strong></p><p>启动没问题:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node2 ~]$ supervisorctl status</span><br><span class="line">cassandra                        RUNNING   pid 13531, uptime 0:10:09</span><br><span class="line">kong                             RUNNING   pid 14460, uptime 0:00:35</span><br><span class="line">kong-dashboard                   RUNNING   pid 14496, uptime 0:00:17</span><br></pre></td></tr></table></figure><p>但是发现supervisor管理kong进程有很严重的问题.</p><p>因为kong启动后包括2个进程:kong和nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">work@kong-node1 conf.d]$ ps aux | grep kong</span><br><span class="line">work      3198  0.2  0.0 130104  2700 ?        S    17:12   0:00 perl /usr/local/openresty/bin/resty /usr/local/bin/kong start -c /etc/kong/kong.conf</span><br><span class="line">work      3215  6.3  0.1 259600 11800 ?        S    17:12   0:00 nginx: master process /usr/local/openresty/nginx/sbin/nginx -p /data/kong -c nginx.conf</span><br></pre></td></tr></table></figure><p>.这个时候如果用supervisorctl restart kong进程会出现无法启动的情况.这是因为supervisor kill掉了kong进程.但是没有kill Ningx进程.所以重新启动kong的时候,由于nginx进程仍然存在,故无法启动.例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 conf.d]$ ps aux | grep kong</span><br><span class="line">work      2917  0.0  0.1 259600 11820 ?        S    17:05   0:00 nginx: master process /usr/local/openresty/nginx/sbin/nginx -p /data/kong -c nginx.conf</span><br><span class="line">work      3191  0.0  0.0 112704   976 pts/0    S+   17:11   0:00 grep --color=auto kong</span><br><span class="line">[work@kong-node1 conf.d]$ kill 2917</span><br><span class="line">[work@kong-node1 conf.d]$ ps aux | grep kong</span><br><span class="line">work      3193  0.0  0.0 112704   976 pts/0    S+   17:11   0:00 grep --color=auto kong</span><br><span class="line">[work@kong-node1 conf.d]$ supervisorctl start kong</span><br><span class="line">kong: started</span><br><span class="line"></span><br><span class="line">#kong启动后包含2个进程</span><br><span class="line">[work@kong-node1 conf.d]$ ps aux | grep kong</span><br><span class="line">work      3198  0.2  0.0 130104  2700 ?        S    17:12   0:00 perl /usr/local/openresty/bin/resty /usr/local/bin/kong start -c /etc/kong/kong.conf</span><br><span class="line">work      3215  6.3  0.1 259600 11800 ?        S    17:12   0:00 nginx: master process /usr/local/openresty/nginx/sbin/nginx -p /data/kong -c nginx.conf</span><br><span class="line">work      3228  0.0  0.0 112704   976 pts/0    R+   17:12   0:00 grep --color=auto kong</span><br><span class="line"></span><br><span class="line">#supervisor关闭了Kong进程后,无法启动.</span><br><span class="line">[work@kong-node1 conf.d]$ supervisorctl restart kong</span><br><span class="line">kong: stopped</span><br><span class="line">kong: ERROR (spawn error)</span><br><span class="line"></span><br><span class="line">#因为虽然kong进程杀死了.但是nginx进程还在.所以kong的8000端口仍然被占用</span><br><span class="line">[work@kong-node1 conf.d]$ ps aux | grep kong</span><br><span class="line">work      3215  0.1  0.1 259600 11800 ?        S    17:12   0:00 nginx: master process /usr/local/openresty/nginx/sbin/nginx -p /data/kong -c nginx.conf</span><br><span class="line">work      3307  0.0  0.0 112704   976 pts/0    S+   17:15   0:00 grep --color=auto kong</span><br><span class="line"></span><br><span class="line">#查看启动日志,提示kong进程已经启动了.</span><br><span class="line">Error: Kong is already running in /data/kong</span><br><span class="line"></span><br><span class="line">  Run with --v (verbose) or --vv (debug) for more details</span><br></pre></td></tr></table></figure><p><strong>暂时就不用supervisor管理了,采用命令行直接启动方式</strong></p><hr><p><strong>命令行启动kong.只有一个Nginx进程.没有Perl进程.不知道何故</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node2 conf.d]$kong start -c /etc/kong/kong.conf</span><br><span class="line">Kong started</span><br><span class="line">[work@kong-node2 conf.d]$ps aux | grep kong</span><br><span class="line">work     15558  0.0  0.0 259600  6540 ?        Ss   17:29   0:00 nginx: master process /usr/local/openresty/nginx/sbin/nginx -p /data/kong -c nginx.conf</span><br></pre></td></tr></table></figure><hr><h3 id="将kong-Cassandra加入到systemctl管理工具"><a href="#将kong-Cassandra加入到systemctl管理工具" class="headerlink" title="将kong,Cassandra加入到systemctl管理工具"></a>将kong,Cassandra加入到systemctl管理工具</h3><ul><li><strong>cassandra</strong></li></ul><p>systemctl文件如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 ~]$cd /usr/lib/systemd/system</span><br><span class="line">[work@kong-node1 system]$vim cassandra.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Cassandra</span><br><span class="line">After=network.target</span><br><span class="line">Before=kong.target </span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=work</span><br><span class="line">Group=work</span><br><span class="line">ExecStart=/usr/local/cassandra/bin/cassandra -f</span><br><span class="line">ExecStop=kill $(pgrep -f cassandra)</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><blockquote><p>注意.如果java是二进制包,则需要将Bin文件链接到系统环境变量目录下.因为systemctl不会读取profile环境,所以不能识别到java.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 system]$which java</span><br><span class="line">/usr/bin/java</span><br><span class="line">[work@kong-node1 system]$ll /usr/bin/java</span><br><span class="line">lrwxrwxrwx 1 root root 24 Nov 14 17:46 /usr/bin/java -&gt; /usr/local/java/bin/java</span><br></pre></td></tr></table></figure><p>第二种方法是在systemctl中指定环境变量.指定environment参数(这种方法理论可行,但是没有论证)</p><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Cassandra</span><br><span class="line">After=network.target</span><br><span class="line">Before=kong.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=work</span><br><span class="line">Group=work</span><br><span class="line">environment=JAVA_HOME=/usr/local/java</span><br><span class="line">environment=PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">ExecStart=/usr/local/cassandra/bin/cassandra -f</span><br><span class="line">ExecStop=kill $(pgrep -f cassandra)</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><hr><ul><li><strong>kong</strong></li></ul><p>在同目录下编辑kong服务配置.</p><blockquote><p>注意,需要在cassandra后端数据库启动后,才能启动kong服务</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 system]$vim kong.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description= kong service</span><br><span class="line">After=syslog.target network.target cassandra.target</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=work</span><br><span class="line">Group=work</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/kong start -c /etc/kong/kong.conf</span><br><span class="line">ExecReload=/usr/local/bin/kong reload -c /etc/kong/kong.conf</span><br><span class="line">ExecStop=/usr/local/bin/kong stop</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><ul><li><strong>在kong-node2上启动kong-dashbaord</strong></li></ul><blockquote><p>dashbaord服务启动需要在cassandra,kong服务启动之后</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node2 system]$vim kong-dashboard.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=kong-dashboard</span><br><span class="line">After=network.target cassandra.target kong.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=work</span><br><span class="line">Group=work</span><br><span class="line">ExecStart=/usr/local/bin/kong-dashboard start --kong-url http://10.111.30.158:8001</span><br><span class="line">ExecStop=kill $(pgrep -f kong-dashboard)</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><ul><li>加入到开启自启动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable cassandra</span><br><span class="line">systemctl enable kong</span><br><span class="line">systemctl enable kong-dashboard</span><br></pre></td></tr></table></figure><p>经过反复论证,systemctl可以管理以上服务.</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;kong-casssandra集群环境部署&quot;&gt;&lt;a href=&quot;#kong-casssandra集群环境部署&quot; class=&quot;headerlink&quot; title=&quot;kong+casssandra集群环境部署&quot;&gt;&lt;/a&gt;kong+casssandra集群环境部署&lt;/h2&gt;&lt;h3 id=&quot;kong简介&quot;&gt;&lt;a href=&quot;#kong简介&quot; class=&quot;headerlink&quot; title=&quot;kong简介&quot;&gt;&lt;/a&gt;kong简介&lt;/h3&gt;&lt;p&gt;Kong是Mashape开源的一款API网关，起初是用来管理 Mashape 公司15000个微服务的，后来在2015年开源,现在已经在很多创业公司、大型企业和政府机构中广泛使用。基于nginx,Lua和Cassandra或PostgreSQL，支持分布式操作，有很强的可移植性和可扩展性。可以在任何一种基础设施上运行,作为应用和API之间的中间层，加上众多功能强大的插件，可以实现认证授权、访问控制等功能。并且提供易于使用的RESTful API来操作和配置系统。&lt;/p&gt;
&lt;p&gt;有关kong的详细介绍请参考官网.&lt;/p&gt;
&lt;p&gt;–&lt;/p&gt;
&lt;h3 id=&quot;cassandra简介&quot;&gt;&lt;a href=&quot;#cassandra简介&quot; class=&quot;headerlink&quot; title=&quot;cassandra简介&quot;&gt;&lt;/a&gt;cassandra简介&lt;/h3&gt;&lt;p&gt;Cassandra 是一个来自 Apache 的分布式数据库，具有高度可扩展性，可用于管理大量的结构化数据。它提供了高可用性，没有单点故障。kong支持PostgreSQL或者Cassandra两种数据库.这里我们选择了cassandra.&lt;/p&gt;
&lt;p&gt;有关cassandra的详细介绍和使用方法.请参考官网&lt;/p&gt;
    
    </summary>
    
      <category term="Linux-Web" scheme="https://jesse.top/categories/Linux-Web/"/>
    
      <category term="kong" scheme="https://jesse.top/categories/Linux-Web/kong/"/>
    
    
      <category term="kong" scheme="https://jesse.top/tags/kong/"/>
    
  </entry>
  
  <entry>
    <title>Linux 使用parted+LVM分区</title>
    <link href="https://jesse.top/2020/06/26/Linux-Basic/Skills/Linux%20%E4%BD%BF%E7%94%A8parted%20LVM%E5%88%86%E5%8C%BA/"/>
    <id>https://jesse.top/2020/06/26/Linux-Basic/Skills/Linux 使用parted LVM分区/</id>
    <published>2020-06-26T02:59:58.000Z</published>
    <updated>2020-06-26T03:10:46.695Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Linux-使用parted-LVM分区"><a href="#Linux-使用parted-LVM分区" class="headerlink" title="Linux 使用parted+LVM分区"></a>Linux 使用parted+LVM分区</h2><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>fdisk使用MBR分区硬盘,但是最大只能识别到2T的磁盘,如果单块磁盘超过2T则需要使用GPT分区格式</p><hr><h4 id="分区步骤"><a href="#分区步骤" class="headerlink" title="分区步骤"></a>分区步骤</h4><p>分区方法和fdisk大同小异</p><ul><li>1.parted 磁盘名 .进入交互式界面</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@archiver-mysql ~]# parted /dev/vdb</span><br><span class="line">GNU Parted 3.1</span><br><span class="line">Using /dev/vdb</span><br><span class="line">Welcome to GNU Parted! Type &apos;help&apos; to view a list of commands.</span><br></pre></td></tr></table></figure><ul><li>2.mklabel gpt 转换为gpt分区</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(parted) mklabel gpt</span><br><span class="line">Warning: The existing disk label on /dev/vdb will be destroyed and all data on this disk will be lost. Do you want to continue?</span><br><span class="line">Yes/No? yes</span><br></pre></td></tr></table></figure><p>3.mkpart分区</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">(parted) mkpart</span><br><span class="line">Partition name?  []? data  </span><br><span class="line">File system type?  [ext2]? ext4</span><br><span class="line">Start?</span><br><span class="line">Start?</span><br><span class="line">Start? 0% #起始和结束为止要用百分比格式,使4K对齐</span><br><span class="line">End? 100%</span><br><span class="line"></span><br><span class="line">#也可以直接在一条命令上输入</span><br><span class="line">mkpart data ext4 0% 100%</span><br></pre></td></tr></table></figure><p>至此,gpt分区就完成了.可以看到单块磁盘有5T空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">(parted) print</span><br><span class="line">Model: Virtio Block Device (virtblk)</span><br><span class="line">Disk /dev/vdb: 5498GB</span><br><span class="line">Sector size (logical/physical): 512B/512B</span><br><span class="line">Partition Table: gpt</span><br><span class="line">Disk Flags:</span><br><span class="line"></span><br><span class="line">Number  Start   End     Size    File system  Name  Flags</span><br><span class="line"> 1      1049kB  5498GB  5498GB               data</span><br></pre></td></tr></table></figure><hr><h3 id="二-LVM分区"><a href="#二-LVM分区" class="headerlink" title="二 LVM分区"></a>二 LVM分区</h3><p>步骤一样</p><ul><li>1.pvcreate /dev/vdb1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@archiver-mysql ~]# pvcreate /dev/vdb1</span><br><span class="line">WARNING: ext4 signature detected on /dev/vdb1 at offset 1080. Wipe it? [y/n]: y</span><br><span class="line">  Wiping ext4 signature on /dev/vdb1.</span><br><span class="line">  Physical volume &quot;/dev/vdb1&quot; successfully created.</span><br><span class="line">  </span><br><span class="line">  [root@archiver-mysql ~]# pvdisplay</span><br><span class="line">  &quot;/dev/vdb1&quot; is a new physical volume of &quot;&lt;5.00 TiB&quot;</span><br><span class="line">  --- NEW Physical volume ---</span><br><span class="line">  PV Name               /dev/vdb1</span><br><span class="line">  VG Name</span><br><span class="line">  PV Size               &lt;5.00 TiB</span><br><span class="line">  Allocatable           NO</span><br><span class="line">  PE Size               0</span><br><span class="line">  Total PE              0</span><br><span class="line">  Free PE               0</span><br><span class="line">  Allocated PE          0</span><br><span class="line">  PV UUID               0SKSgB-TBHZ-PKU8-La1Q-dG00-23Df-4ZXoy4</span><br></pre></td></tr></table></figure><ul><li>2.vgextend vg名 pv名</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@archiver-mysql ~]# vgdisplay</span><br><span class="line">  --- Volume group ---</span><br><span class="line">  VG Name               mysql_log_vggroup  #这个是vg名字</span><br><span class="line">  System ID</span><br><span class="line">  Format                lvm2</span><br><span class="line">  Metadata Areas        1</span><br><span class="line">  Metadata Sequence No  2</span><br><span class="line">  VG Access             read/write</span><br><span class="line">  VG Status             resizable</span><br><span class="line">  MAX LV                0</span><br><span class="line">  Cur LV                1</span><br><span class="line">  Open LV               1</span><br><span class="line">  Max PV                0</span><br><span class="line">  Cur PV                1</span><br><span class="line">  Act PV                1</span><br><span class="line">  VG Size               &lt;100.00 GiB</span><br><span class="line">  PE Size               4.00 MiB</span><br><span class="line">  Total PE              25599</span><br><span class="line">  Alloc PE / Size       25599 / &lt;100.00 GiB</span><br><span class="line">  Free  PE / Size       0 / 0</span><br><span class="line">  VG UUID               JERXbu-vnc0-X2Kz-1PRH-2Q4v-kIc3-bRjNkE</span><br><span class="line">  </span><br><span class="line">  [root@archiver-mysql ~]# vgcreate mysql_data_vggroup /dev/vdb1 #这是vgcreate命令</span><br><span class="line">  Volume group &quot;mysql_data_vggroup&quot; successfully created</span><br></pre></td></tr></table></figure><ul><li>3.lvcreate -n lv卷名字  -l +100%free vg卷名字</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@archiver-mysql ~]# lvcreate -n mysql_data_lvgroup -l +100%free mysql_data_vggroup</span><br></pre></td></tr></table></figure><ul><li>4.格式化卷</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@archiver-mysql ~]# mkfs.ext4 /dev/mysql_data_vggroup/mysql_data_lvgroup</span><br></pre></td></tr></table></figure><ul><li><ol start="5"><li>挂载</li></ol></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@archiver-mysql ~]# mount /dev/mysql_data_vggroup/mysql_data_lvgroup /data</span><br></pre></td></tr></table></figure><ul><li>6.别忘记写入/etc/fstab开启自启文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;/dev/mapper/mysql_data_vggroup-mysql_data_lvgroup /data ext4 defaults 0 0&quot; &gt;&gt; /etc/fstab</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Linux-使用parted-LVM分区&quot;&gt;&lt;a href=&quot;#Linux-使用parted-LVM分区&quot; class=&quot;headerlink&quot; title=&quot;Linux 使用parted+LVM分区&quot;&gt;&lt;/a&gt;Linux 使用parted+LVM分区&lt;/h2&gt;&lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;&lt;p&gt;fdisk使用MBR分区硬盘,但是最大只能识别到2T的磁盘,如果单块磁盘超过2T则需要使用GPT分区格式&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;分区步骤&quot;&gt;&lt;a href=&quot;#分区步骤&quot; class=&quot;headerlink&quot; title=&quot;分区步骤&quot;&gt;&lt;/a&gt;分区步骤&lt;/h4&gt;&lt;p&gt;分区方法和fdisk大同小异&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.parted 磁盘名 .进入交互式界面&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@archiver-mysql ~]# parted /dev/vdb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;GNU Parted 3.1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Using /dev/vdb&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Welcome to GNU Parted! Type &amp;apos;help&amp;apos; to view a list of commands.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;2.mklabel gpt 转换为gpt分区&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;(parted) mklabel gpt&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Warning: The existing disk label on /dev/vdb will be destroyed and all data on this disk will be lost. Do you want to continue?&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Yes/No? yes&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;3.mkpart分区&lt;/p&gt;
    
    </summary>
    
      <category term="Linux-Basic" scheme="https://jesse.top/categories/Linux-Basic/"/>
    
      <category term="Skills" scheme="https://jesse.top/categories/Linux-Basic/Skills/"/>
    
    
      <category term="LVM" scheme="https://jesse.top/tags/LVM/"/>
    
  </entry>
  
  <entry>
    <title>33.Python之路 - 特殊操作符</title>
    <link href="https://jesse.top/2020/06/26/python/04-Object-Oriented/Python%E4%B9%8B%E8%B7%AF%20-%20%E7%89%B9%E6%AE%8A%E6%93%8D%E4%BD%9C%E7%AC%A6/"/>
    <id>https://jesse.top/2020/06/26/python/04-Object-Oriented/Python之路 - 特殊操作符/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:33:37.359Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-特殊操作符"><a href="#Python之路-特殊操作符" class="headerlink" title="Python之路 - 特殊操作符"></a>Python之路 - 特殊操作符</h1><h2 id="介绍-🍀"><a href="#介绍-🍀" class="headerlink" title="介绍  🍀"></a>介绍  🍀</h2><p>在 Python 中 , 我们自定义类都是基于 Object 对象实现的 , 而在 Object 对象中有一些特殊的操作符 (<code>__method__</code>) 控制着整个对象的行为 , 所以 , 如果我们想对对象的行为进行控制 , 我们就需要自己来实现这些方法 ; 当然很多人称这些方法为 Python 魔法方法 (魔术方法) </p><p>下面 , 看看这些方法吧</p><h2 id="基本行为-🍀"><a href="#基本行为-🍀" class="headerlink" title="基本行为  🍀"></a>基本行为  🍀</h2><table><thead><tr><th>操作符</th><th>控制行为</th><th>调用说明</th></tr></thead><tbody><tr><td><code>__new__</code></td><td>对象创建</td><td><code>__init__</code> 只是用处初始化 , <code>__new__</code> 调用的结果会交给 <code>__init__</code> 进一步处理</td></tr><tr><td><code>__init__</code></td><td>对象初始化</td><td>构造函数 , 进行属性设置</td></tr><tr><td><code>__del__</code></td><td>对象删除</td><td>析构函数 , 进行对象的销毁</td></tr><tr><td><code>__repr__</code></td><td>对象显示 , 针对对象</td><td>终端显示 , 返回值必须为字符串 , 实例见表下方</td></tr><tr><td><code>__str__</code></td><td>对象显示 , 针对 <code>print</code></td><td><code>print</code> 显示结果 , 返回值必须为字符串 , 如果未实现该方法 , <code>print</code> 将使用 <code>__repr__</code></td></tr><tr><td><code>__bytes__</code></td><td>字节对象转换</td><td>返回值必须为一个bytes对象 , bytes(obj)</td></tr><tr><td><code>__format__</code></td><td>格式化字符串</td><td>返回值必须为字符串对象 , format(obj)</td></tr><tr><td><code>__lt__</code></td><td><code>&lt;</code> 运算</td><td><code>x &lt; y</code> , 返回布尔值 , 下同</td></tr><tr><td><code>__le__</code></td><td><code>&lt;=</code> 运算</td><td><code>x &lt;= y</code></td></tr><tr><td><code>__eq__</code></td><td><code>=</code> 运算</td><td><code>x == y</code></td></tr><tr><td><code>__ne__</code></td><td><code>!=</code> 运算</td><td><code>x != y</code></td></tr><tr><td><code>__gt__</code></td><td><code>&gt;</code> 运算</td><td><code>x &gt; y</code></td></tr><tr><td><code>__ge__</code></td><td><code>&gt;=</code> 运算</td><td><code>x &gt;= y</code></td></tr><tr><td><code>__hash__</code></td><td>可哈希</td><td>返回一个哈希对象 , hash(obj) , 注意 : 定义该方法同时应该定义 <code>__eq__</code></td></tr><tr><td><code>__bool__</code></td><td>真假测试</td><td>返回布尔值</td></tr><tr><td><code>__call__</code></td><td>对象调用</td><td>在对象被调用时执行</td></tr><tr><td><code>__len__</code></td><td><code>len()</code></td><td>使用 <code>len(obj)</code> 时被调用 , 为防止值测试抛出 <code>OverflowError</code> , 必须定义 <code>__bool__()</code></td></tr></tbody></table><p><code>__repr__</code> 与 <code>__str__</code> 对比实例 : </p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 类定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;repr:%s&gt;'</span> % self.name</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'&lt;str:%s&gt;'</span> % self.name</span><br><span class="line"></span><br><span class="line"><span class="comment"># 终端结果</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Foo(<span class="string">'Lyon'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj</span><br><span class="line">&lt;repr:Lyon&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(obj)</span><br><span class="line">&lt;str:Lyon&gt;</span><br></pre></td></tr></table></figure><h2 id="访问行为-🍀"><a href="#访问行为-🍀" class="headerlink" title="访问行为  🍀"></a>访问行为  🍀</h2><table><thead><tr><th>操作符</th><th>控制行为</th><th>调用说明</th></tr></thead><tbody><tr><td><code>__getattr__</code></td><td><code>.</code> 属性访问运算</td><td>获取 <code>x.name</code> , <code>__getattribute__</code> 查询失败后被调用 , 下方实例进一步说明</td></tr><tr><td><code>__getattribute__</code></td><td><code>.</code> 属性访问运算</td><td>获取 <code>x.name</code> , 查询属性时被调用</td></tr><tr><td><code>__setattr__</code></td><td><code>.</code> 属性赋值运算</td><td><code>self.attr = value → self.__setattr__(&quot;attr&quot;, value)</code> , 见下方实例进一步说明</td></tr><tr><td><code>__delattr__</code></td><td><code>.</code> 属性删除运算</td><td><code>del obj.name</code> 时被调用</td></tr><tr><td><code>__dir__</code></td><td><code>dir</code> 运算</td><td><code>dir()</code> 调用时被调用 , 必须返回一个序列 , <code>dir()</code> 会将序列转换成 list 并排序</td></tr></tbody></table><p><code>__getattr__</code> 说明实例 : </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __getattr__</span></span><br><span class="line"><span class="comment"># 注意在定义__getattr__或者__getattribute__时,不要出现 self. 因为这样会导致递归调用</span></span><br><span class="line"><span class="comment"># 正确的方式是,使用object的__getattr__,__getattribute__,或者直接定义返回值</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Attribute &lt;%s&gt; fetch failure'</span> % item</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattribute__</span><span class="params">(self, item)</span>:</span></span><br><span class="line">        <span class="comment"># return object.__getattribute__(self, item)</span></span><br><span class="line">        <span class="keyword">if</span> item == <span class="string">"name"</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'Lyon'</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(item)</span><br><span class="line"></span><br><span class="line">x = Foo(<span class="string">'Lyon'</span>)</span><br><span class="line">print(x.name)</span><br><span class="line">print(x.age)</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">Lyon</span></span><br><span class="line"><span class="string">Attribute &lt;age&gt; fetch failure</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p> <code>__setattr__</code>  说明实例 : </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># __setattr__</span></span><br><span class="line"><span class="comment"># 与__getattr__一样,在定义__setattr__时,不要出现 self. 因为这样会导致递归调用</span></span><br><span class="line"><span class="comment"># 正确的方式是,使用object的__setattr__,或者使用self.__dict__[key]</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span><span class="params">(self, key, value)</span>:</span></span><br><span class="line">        <span class="comment"># object.__setattr__(self, key, value)</span></span><br><span class="line">        <span class="keyword">if</span> key == <span class="string">"name"</span>:</span><br><span class="line">            self.__dict__[key] = value</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> AttributeError(key + <span class="string">' not allowed'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">x = Foo(<span class="string">'Lyon'</span>)</span><br><span class="line">x.name = <span class="string">"Kenneth"</span></span><br><span class="line">x.age = <span class="number">18</span></span><br><span class="line">print(x.__dict__)</span><br><span class="line">module1</span><br></pre></td></tr></table></figure><h2 id="描述器行为-🍀"><a href="#描述器行为-🍀" class="headerlink" title="描述器行为  🍀"></a>描述器行为  🍀</h2><table><thead><tr><th>操作符</th><th>控制行为</th><th>调用说明</th></tr></thead><tbody><tr><td><code>__get__</code></td><td><code>.</code> 对象访问运算</td><td>访问对象时被调用 , 对象访问意指 <code>.</code> 后面接的不是一个属性而是一个对象 , 见下方实例说明</td></tr><tr><td><code>__set__</code></td><td><code>.</code> 对象赋值运算</td><td>对象赋值时被调用</td></tr><tr><td><code>__delete__</code></td><td><code>.</code> 对象删除运算</td><td>对象删除时被调用</td></tr><tr><td><code>__set_name__</code></td><td>所有者创建</td><td>在创建所有者时被调用 , Python 3.6 新增</td></tr></tbody></table><p><code>__get__</code> , <code>__set__</code> , <code>__delete__</code> 实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 关于对象访问一说,是建立在两个的使用基础上的</span></span><br><span class="line"><span class="comment"># 单纯来讲,就是所有者类中的一个属性,是另一个类的实例</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dependency</span>:</span></span><br><span class="line">    <span class="string">""" 附属类 """</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line">        print(<span class="string">'%s.%s is called...'</span> % (<span class="string">'Dependency'</span>, <span class="string">'__get__'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line">        print(<span class="string">'%s.%s is called...'</span> % (<span class="string">'Dependency'</span>, <span class="string">'__set__'</span>))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delete__</span><span class="params">(self, instance)</span>:</span></span><br><span class="line">        print(<span class="string">'%s.%s is called...'</span> % (<span class="string">'Dependency'</span>, <span class="string">'__delete__'</span>))</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Owner</span>:</span></span><br><span class="line">    <span class="string">""" 所有者类 """</span></span><br><span class="line">    dependency = Dependency()</span><br><span class="line"></span><br><span class="line">o = Owner()</span><br><span class="line">o.dependency</span><br><span class="line">o.dependency = <span class="string">'Lyon'</span></span><br><span class="line"><span class="keyword">del</span> o.dependency</span><br><span class="line"></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">Dependency.__get__ is called...</span></span><br><span class="line"><span class="string">Dependency.__set__ is called...</span></span><br><span class="line"><span class="string">Dependency.__delete__ is called...</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p><code>__set_name__</code> 是在上例 <code>Owner</code> 实例创建时被调用 , Python 3.6 新增</p><h2 id="容器行为-🍀"><a href="#容器行为-🍀" class="headerlink" title="容器行为  🍀"></a>容器行为  🍀</h2><table><thead><tr><th>操作符</th><th>控制行为</th><th>调用说明</th></tr></thead><tbody><tr><td><code>__getitem__</code></td><td>序列方式访问</td><td><code>self[key]</code> 时被调用</td></tr><tr><td><code>__missing__</code></td><td>序列方式访问失败</td><td><code>self[key]</code> 时 key 不在字典中被调用</td></tr><tr><td><code>__setitem__</code></td><td>序列方式赋值</td><td><code>self[key] = value</code> 时被调用</td></tr><tr><td><code>__delitem__</code></td><td>序列方式删除</td><td><code>del self[key]</code> 时被调用</td></tr><tr><td><code>__iter__</code></td><td>迭代环境</td><td>通过 <code>iter(obj)</code> 调用 , 如使用for循环进行遍历</td></tr><tr><td><code>__reversed__</code></td><td><code>reversed()</code></td><td><code>reversed(obj)</code> 时被调用</td></tr><tr><td><code>__contains__</code></td><td>成员关系 <code>in</code></td><td><code>item in self</code> 时调用</td></tr></tbody></table><h2 id="运算行为-🍀"><a href="#运算行为-🍀" class="headerlink" title="运算行为  🍀"></a>运算行为  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 基本运算行为</span></span><br><span class="line">object.__add__(self, other)              <span class="comment"># +</span></span><br><span class="line">object.__sub__(self, other)              <span class="comment"># -</span></span><br><span class="line">object.__mul__(self, other)              <span class="comment"># *</span></span><br><span class="line">object.__matmul__(self, other)           <span class="comment"># @</span></span><br><span class="line">object.__truediv__(self, other)          <span class="comment"># /</span></span><br><span class="line">object.__floordiv__(self, other)         <span class="comment"># //</span></span><br><span class="line">object.__mod__(self, other)              <span class="comment"># %</span></span><br><span class="line">object.__divmod__(self, other)           <span class="comment"># divmod()</span></span><br><span class="line">object.__pow__(self, other[, modulo])    <span class="comment"># pow()  **</span></span><br><span class="line">object.__lshift__(self, other)           <span class="comment"># &lt;&lt;</span></span><br><span class="line">object.__rshift__(self, other)           <span class="comment"># &gt;&gt;</span></span><br><span class="line">object.__and__(self, other)              <span class="comment"># &amp;</span></span><br><span class="line">object.__xor__(self, other)              <span class="comment"># ^</span></span><br><span class="line">object.__or__(self, other)               <span class="comment"># |</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 二进制运算行为</span></span><br><span class="line">object.__radd__(self, other)             </span><br><span class="line">object.__rsub__(self, other)             </span><br><span class="line">object.__rmul__(self, other)             </span><br><span class="line">object.__rmatmul__(self, other)          </span><br><span class="line">object.__rtruediv__(self, other)        </span><br><span class="line">object.__rfloordiv__(self, other)       </span><br><span class="line">object.__rmod__(self, other)             </span><br><span class="line">object.__rdivmod__(self, other)  </span><br><span class="line">object.__rpow__(self, other)</span><br><span class="line">object.__rlshift__(self, other)         </span><br><span class="line">object.__rrshift__(self, other)          </span><br><span class="line">object.__rand__(self, other)            </span><br><span class="line">object.__rxor__(self, other)           </span><br><span class="line">object.__ror__(self, other) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 加=运算行为</span></span><br><span class="line">object.__iadd__(self, other)             <span class="comment"># +=</span></span><br><span class="line">object.__isub__(self, other)             <span class="comment"># -=</span></span><br><span class="line">object.__imul__(self, other)             <span class="comment"># *=</span></span><br><span class="line">object.__imatmul__(self, other)</span><br><span class="line">object.__itruediv__(self, other)</span><br><span class="line">object.__ifloordiv__(self, other)</span><br><span class="line">object.__imod__(self, other)</span><br><span class="line">object.__ipow__(self, other[, modulo])</span><br><span class="line">object.__ilshift__(self, other)</span><br><span class="line">object.__irshift__(self, other)</span><br><span class="line">object.__iand__(self, other)</span><br><span class="line">object.__ixor__(self, other)</span><br><span class="line">object.__ior__(self, other)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 一元算数运算</span></span><br><span class="line">object.__neg__(self)</span><br><span class="line">object.__pos__(self)</span><br><span class="line">object.__abs__(self)</span><br><span class="line">object.__invert__(self)</span><br><span class="line"></span><br><span class="line"><span class="comment"># complex(),int(),float()</span></span><br><span class="line">object.__complex__(self)</span><br><span class="line">object.__int__(self)</span><br><span class="line">object.__float__(self)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整数值hex(X),bin(X),oct(X),o[X],O[X:]</span></span><br><span class="line">object.__index__(self)</span><br><span class="line"></span><br><span class="line"><span class="comment"># round(),trunc(),floor(),ceil()</span></span><br><span class="line">object.__round__(self[, ndigits])</span><br><span class="line">object.__trunc__(self)</span><br><span class="line">object.__floor__(self)</span><br><span class="line">object.__ceil__(self)</span><br></pre></td></tr></table></figure><h2 id="上下文管理行为-🍀"><a href="#上下文管理行为-🍀" class="headerlink" title="上下文管理行为  🍀"></a>上下文管理行为  🍀</h2><table><thead><tr><th>操作符</th><th>控制行为</th><th>调用说明</th></tr></thead><tbody><tr><td><code>__enter__</code></td><td>进入上下文环境</td><td>使用with进入上下文环境时被调用</td></tr><tr><td><code>__exit__</code></td><td>退出上下文环境</td><td>退出上下文环境时被调用</td></tr></tbody></table><p>实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 返回值赋值给as指定变量</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, exc_type, exc_val, exc_tb)</span>:</span></span><br><span class="line">        print(<span class="string">'exc_type'</span>,exc_type)  <span class="comment"># 异常类型</span></span><br><span class="line">        print(<span class="string">'exc_val'</span>,exc_val)    <span class="comment"># 异常值</span></span><br><span class="line">        print(<span class="string">'exc_tb'</span>,exc_tb)      <span class="comment"># 追溯信息</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">True</span>                 <span class="comment"># 返回值为True,那么异常会被清空,就好像啥都没发生一样,</span></span><br><span class="line">                                    <span class="comment"># with后的语句正常执行</span></span><br><span class="line">                                    <span class="comment"># 为False异常会抛出</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> Foo(<span class="string">'Lyon'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">raise</span> AttributeError(<span class="string">'ignore exception'</span>)</span><br><span class="line">print(<span class="string">'over'</span>)</span><br></pre></td></tr></table></figure><h2 id="slots-🍀"><a href="#slots-🍀" class="headerlink" title="__slots__  🍀"></a>__slots__  🍀</h2><p><code>__slots__</code> 的作用是阻止在实例化类时为实例分配dict , 默认情况下每个类都会有一个dict,通过<code>__dict__</code> 访问 , 这个dict维护了这个实例的所有属性 </p><p>作用 : </p><ul><li>减少内存使用</li><li>限制对实例添加新的属性</li></ul><p>缺点 : </p><ul><li>不可被继承</li><li>不可动弹添加新属性</li></ul><p>实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    __slots__ = [<span class="string">'name'</span>, <span class="string">'age'</span>]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"></span><br><span class="line">f = Foo(<span class="string">'Lyon'</span>, <span class="number">18</span>)</span><br><span class="line">print(f.name)</span><br><span class="line">print(f.age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 报错</span></span><br><span class="line">f.sex = <span class="string">'Man'</span></span><br></pre></td></tr></table></figure><p>更多 <a href="https://docs.python.org/3/reference/datamodel.html#object.__index__" target="_blank" rel="noopener">Data model</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-特殊操作符&quot;&gt;&lt;a href=&quot;#Python之路-特殊操作符&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 特殊操作符&quot;&gt;&lt;/a&gt;Python之路 - 特殊操作符&lt;/h1&gt;&lt;h2 id=&quot;介绍-🍀&quot;&gt;&lt;a href=&quot;#介绍-🍀&quot; class=&quot;headerlink&quot; title=&quot;介绍  🍀&quot;&gt;&lt;/a&gt;介绍  🍀&lt;/h2&gt;&lt;p&gt;在 Python 中 , 我们自定义类都是基于 Object 对象实现的 , 而在 Object 对象中有一些特殊的操作符 (&lt;code&gt;__method__&lt;/code&gt;) 控制着整个对象的行为 , 所以 , 如果我们想对对象的行为进行控制 , 我们就需要自己来实现这些方法 ; 当然很多人称这些方法为 Python 魔法方法 (魔术方法) &lt;/p&gt;
&lt;p&gt;下面 , 看看这些方法吧&lt;/p&gt;
&lt;h2 id=&quot;基本行为-🍀&quot;&gt;&lt;a href=&quot;#基本行为-🍀&quot; class=&quot;headerlink&quot; title=&quot;基本行为  🍀&quot;&gt;&lt;/a&gt;基本行为  🍀&lt;/h2&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;操作符&lt;/th&gt;
&lt;th&gt;控制行为&lt;/th&gt;
&lt;th&gt;调用说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__new__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对象创建&lt;/td&gt;
&lt;td&gt;&lt;code&gt;__init__&lt;/code&gt; 只是用处初始化 , &lt;code&gt;__new__&lt;/code&gt; 调用的结果会交给 &lt;code&gt;__init__&lt;/code&gt; 进一步处理&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__init__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对象初始化&lt;/td&gt;
&lt;td&gt;构造函数 , 进行属性设置&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__del__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对象删除&lt;/td&gt;
&lt;td&gt;析构函数 , 进行对象的销毁&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__repr__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对象显示 , 针对对象&lt;/td&gt;
&lt;td&gt;终端显示 , 返回值必须为字符串 , 实例见表下方&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__str__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对象显示 , 针对 &lt;code&gt;print&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;print&lt;/code&gt; 显示结果 , 返回值必须为字符串 , 如果未实现该方法 , &lt;code&gt;print&lt;/code&gt; 将使用 &lt;code&gt;__repr__&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__bytes__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;字节对象转换&lt;/td&gt;
&lt;td&gt;返回值必须为一个bytes对象 , bytes(obj)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__format__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;格式化字符串&lt;/td&gt;
&lt;td&gt;返回值必须为字符串对象 , format(obj)&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__lt__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;&lt;/code&gt; 运算&lt;/td&gt;
&lt;td&gt;&lt;code&gt;x &amp;lt; y&lt;/code&gt; , 返回布尔值 , 下同&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__le__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;lt;=&lt;/code&gt; 运算&lt;/td&gt;
&lt;td&gt;&lt;code&gt;x &amp;lt;= y&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__eq__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;=&lt;/code&gt; 运算&lt;/td&gt;
&lt;td&gt;&lt;code&gt;x == y&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__ne__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;!=&lt;/code&gt; 运算&lt;/td&gt;
&lt;td&gt;&lt;code&gt;x != y&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__gt__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;&lt;/code&gt; 运算&lt;/td&gt;
&lt;td&gt;&lt;code&gt;x &amp;gt; y&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__ge__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;&amp;gt;=&lt;/code&gt; 运算&lt;/td&gt;
&lt;td&gt;&lt;code&gt;x &amp;gt;= y&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__hash__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;可哈希&lt;/td&gt;
&lt;td&gt;返回一个哈希对象 , hash(obj) , 注意 : 定义该方法同时应该定义 &lt;code&gt;__eq__&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__bool__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;真假测试&lt;/td&gt;
&lt;td&gt;返回布尔值&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__call__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;对象调用&lt;/td&gt;
&lt;td&gt;在对象被调用时执行&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;&lt;code&gt;__len__&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;&lt;code&gt;len()&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;使用 &lt;code&gt;len(obj)&lt;/code&gt; 时被调用 , 为防止值测试抛出 &lt;code&gt;OverflowError&lt;/code&gt; , 必须定义 &lt;code&gt;__bool__()&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;__repr__&lt;/code&gt; 与 &lt;code&gt;__str__&lt;/code&gt; 对比实例 : &lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Object-Oriented" scheme="https://jesse.top/categories/python/Object-Oriented/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>29.Python之路 - 属性方法,类方法,静态方法</title>
    <link href="https://jesse.top/2020/06/26/python/04-Object-Oriented/05-Python%E4%B9%8B%E8%B7%AF%20-%20%E5%B1%9E%E6%80%A7%E6%96%B9%E6%B3%95-%E7%B1%BB%E6%96%B9%E6%B3%95-%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"/>
    <id>https://jesse.top/2020/06/26/python/04-Object-Oriented/05-Python之路 - 属性方法-类方法-静态方法/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:31:02.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-属性方法-类方法-静态方法"><a href="#Python之路-属性方法-类方法-静态方法" class="headerlink" title="Python之路 - 属性方法,类方法,静态方法"></a>Python之路 - 属性方法,类方法,静态方法</h1><h2 id="属性方法-🍀"><a href="#属性方法-🍀" class="headerlink" title="属性方法  🍀"></a>属性方法  🍀</h2><p>属性方法就是通过使用装饰器 <code>@property</code> , 将一个方法变成一个静态属性 , 于是我们就可以通过访问属性 , 来或得一个方法的返回值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> urllib.request <span class="keyword">import</span> urlopen</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Web_page</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, url)</span>:</span></span><br><span class="line">        self.url = url</span><br><span class="line">        self.__content = <span class="keyword">None</span></span><br><span class="line">    <span class="comment"># 将content方法变成属性</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">content</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 返回私有属性</span></span><br><span class="line">        <span class="keyword">return</span> self.__content <span class="keyword">if</span> self.__content <span class="keyword">else</span> urlopen(self.url).read()</span><br><span class="line">con = Web_page(<span class="string">'www.baidu.com'</span>)</span><br><span class="line">res = con.content</span><br><span class="line">print(res)</span><br></pre></td></tr></table></figure><a id="more"></a><p>在property中为我们实现了三种方法 , get , set , delete</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="comment"># 获取属性</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">AAA</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"执行了get方法"</span>)</span><br><span class="line">    <span class="comment"># 设定属性值</span></span><br><span class="line"><span class="meta">    @AAA.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">AAA</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        print(<span class="string">"执行了set方法"</span>)</span><br><span class="line">    <span class="comment"># 删除属性</span></span><br><span class="line"><span class="meta">    @AAA.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">AAA</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"执行了delete方法"</span>)</span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">f = Foo()</span><br><span class="line"><span class="comment"># 获取属性</span></span><br><span class="line">f.AAA</span><br><span class="line"><span class="comment"># 设置属性值,必须设置参数,即使不使用</span></span><br><span class="line">f.AAA = <span class="string">'aaa'</span></span><br><span class="line"><span class="comment"># 删除属性值</span></span><br><span class="line"><span class="keyword">del</span> f.AAA</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">执行了get方法</span></span><br><span class="line"><span class="string">执行了set方法</span></span><br><span class="line"><span class="string">执行了delete方法</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>换一种写法看看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_AAA</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'执行了get方法'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_AAA</span><span class="params">(self,value)</span>:</span></span><br><span class="line">        print(<span class="string">'执行了set方法'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delete_AAA</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'执行了delete方法'</span>)</span><br><span class="line">    <span class="comment"># 实例化property类</span></span><br><span class="line">    AAA = property(get_AAA, set_AAA, delete_AAA)</span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">f = Foo()</span><br><span class="line"><span class="comment"># 获取属性直接调用,执行了get_AAA</span></span><br><span class="line">f.AAA</span><br><span class="line"><span class="comment"># 设置属性值,传入参数执行了set_AAA</span></span><br><span class="line">f.AAA = <span class="string">'aaa'</span></span><br><span class="line"><span class="comment"># 删除属性值,执行了delete_AAA</span></span><br><span class="line"><span class="keyword">del</span> f.AAA</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">执行了get方法</span></span><br><span class="line"><span class="string">执行了set方法</span></span><br><span class="line"><span class="string">执行了delete方法</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>实际应用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Goods</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 原价</span></span><br><span class="line">        self.original_price = <span class="number">100</span></span><br><span class="line">        <span class="comment"># 折扣</span></span><br><span class="line">        self.discount = <span class="number">0.8</span></span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">price</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 实际价格 = 原价 * 折扣</span></span><br><span class="line">        new_price = self.original_price * self.discount</span><br><span class="line">        <span class="keyword">return</span> new_price</span><br><span class="line"><span class="meta">    @price.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">price</span><span class="params">(self, value)</span>:</span></span><br><span class="line">        self.original_price = value</span><br><span class="line"><span class="meta">    @price.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">price</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">del</span> self.original_price</span><br><span class="line">goods = Goods()</span><br><span class="line">goods.price         </span><br><span class="line">goods.price = <span class="number">200</span>  </span><br><span class="line">print(goods.price)</span><br><span class="line"><span class="keyword">del</span> goods.price</span><br></pre></td></tr></table></figure><h2 id="类方法-🍀"><a href="#类方法-🍀" class="headerlink" title="类方法  🍀"></a>类方法  🍀</h2><p>类方法是通过@classmethod装饰器 , 将普通方法变成类方法 , 类方法只能与类属性交互 , 不能访问实例变量 , 并且默认有一个cls参数传进来表示本类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    country = <span class="string">'China'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"><span class="meta">    @classmethod    </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(cls)</span>:</span></span><br><span class="line">        <span class="comment"># 在类方法中不能使用实例变量,会抛出AttributeError</span></span><br><span class="line">        print(<span class="string">"I come from &#123;&#125;"</span>.format(cls.country))</span><br><span class="line">        <span class="comment"># print("&#123;&#125; come from &#123;&#125;".format(self.name,cls.country))  报错</span></span><br><span class="line">p = Person(<span class="string">'lyon'</span>,<span class="string">'18'</span>)</span><br><span class="line">p.search()</span><br><span class="line"><span class="comment"># 执行结果: I come from China</span></span><br></pre></td></tr></table></figure><p>_PS_:类方法中的默认参数可以改成self , 并不会改变结果 , 同样只能访问类变量 , 不能访问实例变量</p><h2 id="静态方法-🍀"><a href="#静态方法-🍀" class="headerlink" title="静态方法  🍀"></a>静态方法  🍀</h2><p>静态方法是通过@staticmethod装饰器将类中的方法变成一个静态方法 </p><p>静态方法就像静态属性一样 , 在类中可以通过 self. 的方式进行调用 , 但是静态是不能够访问实例变量或类变量的 , 也就是说静态方法中的self已经跟本类没有关系了 , 它与本类唯一的关联就是需要通过类名来进行调用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    country = <span class="string">'China'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="comment"># 已经跟本类没有太大的关系了,所以类中的属性无法调用</span></span><br><span class="line"><span class="meta">    @staticmethod    </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"我是静态方法"</span>)</span><br><span class="line">p = Person(<span class="string">'lyon'</span>,<span class="string">'18'</span>)</span><br><span class="line">p.search()</span><br><span class="line"><span class="comment"># 执行结果: 我是静态方法</span></span><br></pre></td></tr></table></figure><p>加上self , self只为一个普通参数而已 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    country = <span class="string">'China'</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">search</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"&#123;&#125; come from &#123;&#125;"</span>.format(self.name,self.country))</span><br><span class="line">p = Person(<span class="string">'lyon'</span>,<span class="string">'18'</span>)</span><br><span class="line"><span class="comment"># 将实例传入search方法中</span></span><br><span class="line">p.search(p)</span><br><span class="line"><span class="comment"># 执行结果: lyon come from China</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-属性方法-类方法-静态方法&quot;&gt;&lt;a href=&quot;#Python之路-属性方法-类方法-静态方法&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 属性方法,类方法,静态方法&quot;&gt;&lt;/a&gt;Python之路 - 属性方法,类方法,静态方法&lt;/h1&gt;&lt;h2 id=&quot;属性方法-🍀&quot;&gt;&lt;a href=&quot;#属性方法-🍀&quot; class=&quot;headerlink&quot; title=&quot;属性方法  🍀&quot;&gt;&lt;/a&gt;属性方法  🍀&lt;/h2&gt;&lt;p&gt;属性方法就是通过使用装饰器 &lt;code&gt;@property&lt;/code&gt; , 将一个方法变成一个静态属性 , 于是我们就可以通过访问属性 , 来或得一个方法的返回值&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; urllib.request &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; urlopen&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Web_page&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self, url)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.url = url&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.__content = &lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 将content方法变成属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;    @property&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;content&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;# 返回私有属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; self.__content &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt; self.__content &lt;span class=&quot;keyword&quot;&gt;else&lt;/span&gt; urlopen(self.url).read()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;con = Web_page(&lt;span class=&quot;string&quot;&gt;&#39;www.baidu.com&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;res = con.content&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(res)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Object-Oriented" scheme="https://jesse.top/categories/python/Object-Oriented/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>28.Python之路 - 面向对象特性之封装</title>
    <link href="https://jesse.top/2020/06/26/python/04-Object-Oriented/04-Python%E4%B9%8B%E8%B7%AF%20-%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E5%B0%81%E8%A3%85/"/>
    <id>https://jesse.top/2020/06/26/python/04-Object-Oriented/04-Python之路 - 面向对象之封装/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:30:31.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-面向对象特性之封装"><a href="#Python之路-面向对象特性之封装" class="headerlink" title="Python之路 - 面向对象特性之封装"></a>Python之路 - 面向对象特性之封装</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>封装就是把客观事物封装成抽象的类 , 并且类可以把自己的数据和方法只让可信的类或者对象操作 , 对不可信的进行信息隐藏</p><h2 id="私有问题-🍀"><a href="#私有问题-🍀" class="headerlink" title="私有问题  🍀"></a>私有问题  🍀</h2><p>当我们类中的一些属性或者方法想要对不可信的类或者对象隐藏时 , 我们就可以将这些属性或者方法 , 定义成私有属性或者私有方法</p><p>在Python中用双下划线开头的方式将属性隐藏起来 , 即带双下划线就为私有属性或者私有方法</p><ul><li>私有属性</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        <span class="comment"># 定义私有属性</span></span><br><span class="line">        self.__name = name</span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">a = A(<span class="string">"Lyon"</span>)</span><br><span class="line"><span class="comment"># 访问a中的__name属性</span></span><br><span class="line">print(a.__name)</span><br><span class="line"><span class="comment"># 执行结果 : AttributeError: 'A' object has no attribute '__name'</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">结果报错,意思是对象A中没有__name这个属性</span></span><br><span class="line"><span class="string">也就是说,外部已经不能直接利用 .__name 来访问这个属性了</span></span><br><span class="line"><span class="string">因为此时它是一个私有属性</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>将属性定义成私有属性其实是一种变形操作 , 即类中所有以双下划线开头的名称都会自动变形成:_类名+名称 如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        <span class="comment"># 定义私有属性</span></span><br><span class="line">        self.__name = name</span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">a = A(<span class="string">"Lyon"</span>)</span><br><span class="line"><span class="comment"># 访问a中的__name属性</span></span><br><span class="line">print(a._A__name)      </span><br><span class="line"><span class="comment"># 执行结果: Lyon</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">__name自动变形为 _A__name</span></span><br><span class="line"><span class="string">所以使用a._A__name是可以访问到的</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>由上可知变形的特点如下:</p><ol><li>类中定义的__name只能在内部使用 , 并且内部使用是引用的变形的结果,即( self._A__name)</li><li>这种变形其实是针对外部的变形 , 在外部是无法通过__name访问的</li></ol><p><strong><em>PS : 这种变形机制其实并没有真正意义上限制我们从外部直接访问属性 , 知道了类名和属性名就可以拼出名字 : _类名__属性 , 然后就可以访问了 , 如 a._A__name . 并且变形的过程只在类的定义时发生一次</em></strong> </p><ul><li>私有方法</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__func</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"In the A"</span>)</span><br><span class="line">a = A()</span><br><span class="line">a.__func()</span><br><span class="line"><span class="comment"># 执行结果: AttributeError: 'A' object has no attribute '__func'</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a._A__func()</span><br><span class="line"><span class="comment"># 执行结果: In the A</span></span><br></pre></td></tr></table></figure><h2 id="当私有遇到继承-🍀"><a href="#当私有遇到继承-🍀" class="headerlink" title="当私有遇到继承  🍀"></a>当私有遇到继承  🍀</h2><p>当我们在继承中使用私有属性或者方法时 , 因为变形机制 , 我们已经不能将私有属性或者方法 , 来与普通属性或者方法那样看待了</p><ul><li>私有属性继承</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, ame)</span>:</span></span><br><span class="line">        self.__name = ame</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, ame)</span>:</span></span><br><span class="line">        self.__name = name</span><br><span class="line">        <span class="comment"># 继承父类中的属性</span></span><br><span class="line">        super().__init__(ame)</span><br><span class="line">a = B(<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line">print(a._A__name)</span><br><span class="line">print(a._B__name)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">b</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>例子说明 : 在上节中已经知道变形操作这回事了 , 当遇到继承时需要注意的就是 , 我们表面上看到的是两个类中都只有一个__name属性 , 但是由于变形 , 使其在定义完成后就分别变成了_A__name 和 _B__name  , 所以继承时已经是两个不同的属性了 , 所以两个属性都存在 , 只是我们表面上还是看不到</p><ul><li>私有方法继承</li></ul><p>与私有属性继承一样 , 需要注意私有方法名变形的问题</p><p>我们可以利用这一特点 , 来实现继承时达到子类不会覆盖父类方法的效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__func</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'from A'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__func()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__func</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'from B'</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.__func()</span><br><span class="line">b=B()</span><br><span class="line">b.test1()</span><br><span class="line">b.test2()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">from A</span></span><br><span class="line"><span class="string">from B</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="封装与扩展性-🍀"><a href="#封装与扩展性-🍀" class="headerlink" title="封装与扩展性  🍀"></a>封装与扩展性  🍀</h2><p>封装在于明确区分内外 , 使得类实现者可以修改封装内的东西而不影响外部调用者的代码 ; 而外部使用者只知道一个接口(函数) , 只要接口(函数)名 , 参数不变 , 使用者的代码永远无需改变 . 这就提供了一个良好的合作基础 , 相当于只要接口这个基础约定不变 , 则代码改变也不足为虑</p><p>原始类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Room</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, owner, width, length, high)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.owner = owner</span><br><span class="line">        self.__width = width</span><br><span class="line">        self.__length = length</span><br><span class="line">        self.__high = high</span><br><span class="line">    <span class="comment"># 对外提供的求面积接口,隐藏内部实现详解</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tell_area</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__width * self.__length</span><br><span class="line">r1 = Room(<span class="string">'卧室'</span>,<span class="string">'Lyon'</span>,<span class="string">'0.3'</span>,<span class="string">'2'</span>,<span class="string">'2'</span>)</span><br><span class="line">r1.tell_area()</span><br></pre></td></tr></table></figure><p>修改类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Room</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, owner, width, length, high)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.owner = owner</span><br><span class="line">        self.__width = width</span><br><span class="line">        self.__length = length</span><br><span class="line">        self.__high = high</span><br><span class="line">    <span class="comment"># 对外提供的求体积接口,隐藏内部实现详解</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">tell_area</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.__width * self.__length * self.__high</span><br><span class="line">r1 = Room(<span class="string">'卧室'</span>,<span class="string">'Lyon'</span>,<span class="string">'0.3'</span>,<span class="string">'2'</span>,<span class="string">'2'</span>)</span><br><span class="line">r1.tell_area()</span><br></pre></td></tr></table></figure><p>我们发现我们将类的功能作出了修改 , 但是对于使用类功能的人来说 , 接口并没有发生变化 , 他们依然可以用原来的接口使用新功能</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-面向对象特性之封装&quot;&gt;&lt;a href=&quot;#Python之路-面向对象特性之封装&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 面向对象特性之封装&quot;&gt;&lt;/a&gt;Python之路 - 面向对象特性之封装&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;封装就是把客观事物封装成抽象的类 , 并且类可以把自己的数据和方法只让可信的类或者对象操作 , 对不可信的进行信息隐藏&lt;/p&gt;
&lt;h2 id=&quot;私有问题-🍀&quot;&gt;&lt;a href=&quot;#私有问题-🍀&quot; class=&quot;headerlink&quot; title=&quot;私有问题  🍀&quot;&gt;&lt;/a&gt;私有问题  🍀&lt;/h2&gt;&lt;p&gt;当我们类中的一些属性或者方法想要对不可信的类或者对象隐藏时 , 我们就可以将这些属性或者方法 , 定义成私有属性或者私有方法&lt;/p&gt;
&lt;p&gt;在Python中用双下划线开头的方式将属性隐藏起来 , 即带双下划线就为私有属性或者私有方法&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;私有属性&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;A&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;__init__&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self,name)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;# 定义私有属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        self.__name = name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 实例化&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;a = A(&lt;span class=&quot;string&quot;&gt;&quot;Lyon&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 访问a中的__name属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(a.__name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 执行结果 : AttributeError: &#39;A&#39; object has no attribute &#39;__name&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;结果报错,意思是对象A中没有__name这个属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;也就是说,外部已经不能直接利用 .__name 来访问这个属性了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;因为此时它是一个私有属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Object-Oriented" scheme="https://jesse.top/categories/python/Object-Oriented/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>21.Python之路 - 序列化</title>
    <link href="https://jesse.top/2020/06/26/python/03-Modules/06-Python%E4%B9%8B%E8%B7%AF%20-%20%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>https://jesse.top/2020/06/26/python/03-Modules/06-Python之路 - 序列化/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:04:42.183Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-序列化"><a href="#Python之路-序列化" class="headerlink" title="Python之路 - 序列化"></a>Python之路 - 序列化</h1><h2 id="介绍-🍀"><a href="#介绍-🍀" class="headerlink" title="介绍  🍀"></a>介绍  🍀</h2><p>先说个例子 , 当我们将一个字典或者列表再或者变量存入磁盘中 , 而存入磁盘后原本数据类型就得不到保持了 . 这个时候我们就得用序列化和反序列化了</p><p>序列化是将对象进行存储时保持当时对象的状态 , 实现其生命周期的延长 </p><p>反序列化则是将存储的对象读取出来并转成原本的数据类型</p><p>序列化的目的</p><ol><li>以某种存储形式使自定义对象持久化</li><li>将对象从一个地方传递到另一个地方</li><li>使程序更具维护性</li></ol><a id="more"></a><p><strong><em>此时应该想到 eval :</em></strong>那么问题来了 , 序列化所达到的功能我用eval()也能达到啊 , eval()直接就可以把字符串转换成python解释器能解释的代码 , 即可以直接将字符串中的字典 , 列表都转成原来的数据类型 . 但是要注意的是 , eval本来就是将字符串内容转换成python可以执行的代码 , 并执行它 , 这样看来eval就不安全了 , 因为如果在我能读取的内容中含有一些其他的 ‘ 危险代码 ‘ 如 ‘ 删除文件 ‘ , 于是造成了毁灭性的打击 , 所以eval是存在风险的 </p><p>Python为我们提供了三个序列化工具 , 分别是 json , pickle , shelve</p><h2 id="json-🍀"><a href="#json-🍀" class="headerlink" title="json  🍀"></a>json  🍀</h2><p>用于字符串和python数据类型之间进行转换 , 因为json表示出来就是一个字符串</p><p>json模块提供了四个方法</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>dump</td><td>接收一个文件句柄 , 将原数据类型转换成字符串写入文件</td></tr><tr><td>load</td><td>接收一个文件句柄 , 将文件中的字符串转换成原数据类型返回</td></tr><tr><td>dumps</td><td>接收一个数据类型 , 将其转换成字符串</td></tr><tr><td>loads</td><td>接收一个字符串 , 将其转换成原数据类型</td></tr></tbody></table><p>dump 和 load 实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入json模块</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># 创建一个文件句柄</span></span><br><span class="line">f = open(<span class="string">'json_file'</span>,<span class="string">'w'</span>)</span><br><span class="line"><span class="comment"># 创建一个字典</span></span><br><span class="line">dic = &#123;<span class="string">'k1'</span>:<span class="string">'v1'</span>,<span class="string">'k2'</span>:<span class="string">'v2'</span>&#125;</span><br><span class="line"><span class="comment"># 将字典转换成字符串写入文件</span></span><br><span class="line">json.dump(dic,f)</span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">f.close()</span><br><span class="line"><span class="comment"># 创建一个文件句柄</span></span><br><span class="line">f = open(<span class="string">'json_file'</span>)</span><br><span class="line"><span class="comment"># 将文件中的字符串读出并转换成原数据类型</span></span><br><span class="line">dic2 = json.load(f)</span><br><span class="line"><span class="comment"># 关闭文件句柄</span></span><br><span class="line">f.close()</span><br><span class="line"><span class="comment"># 打印类型和结果</span></span><br><span class="line">print(type(dic2),dic2)</span><br><span class="line"><span class="comment"># &lt;class 'dict'&gt; &#123;'k1': 'v1', 'k2': 'v2'&#125;</span></span><br></pre></td></tr></table></figure><p>dumps 和 loads 实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入json模块</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># 创建一个新列表</span></span><br><span class="line">lst = [<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>]</span><br><span class="line"><span class="comment"># 将列表转换成字符串,用j_d来接收返回值</span></span><br><span class="line">j_d = json.dumps(lst)</span><br><span class="line"><span class="comment"># 将字符串转换成原数据类型,用j_s来接收返回值</span></span><br><span class="line">j_s = json.loads(j_d)</span><br><span class="line"><span class="comment"># 打印j_d的值以及类型</span></span><br><span class="line">print(j_d,type(j_d))</span><br><span class="line"><span class="comment"># ["1", "2", "3", "4"] &lt;class 'str'&gt;</span></span><br><span class="line"><span class="comment"># 打印j_s的值以及类型</span></span><br><span class="line">print(j_s,type(j_s))</span><br><span class="line"><span class="comment"># ['1', '2', '3', '4'] &lt;class 'list'&gt;</span></span><br></pre></td></tr></table></figure><p>loads的特殊情况</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入json模块</span></span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"><span class="comment"># 创建一个字符串,内部为一个字典</span></span><br><span class="line">dic_s = <span class="string">"&#123;'k1':'v1','k2':'v2','k3':3&#125;"</span></span><br><span class="line"><span class="comment"># 将字符串转换成字典</span></span><br><span class="line">json.loads(dic_s)</span><br><span class="line"><span class="comment"># 解释器出现报错</span></span><br><span class="line"><span class="comment"># json.decoder.JSONDecodeError: Expecting property name enclosed in double quotes: line 1 column 2 (char 1)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">报错原因,用json的loads功能时,字符串类型的字典中的字符串必须由 "" 表示</span></span><br><span class="line"><span class="string">即上面的dic_s应该改为 '&#123;"k1":"v1","k2":"v2","k3":3&#125;'</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">结论:用json的loads功能时,字符串类型的字典中的字符串必须由 "" 表示</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>PS : json可用于不同语言之间的数据交换</p><h2 id="pickle-🍀"><a href="#pickle-🍀" class="headerlink" title="pickle   🍀"></a>pickle   🍀</h2><p>用于python特有的类型和python的数据类型间进行转换</p><p>pickle模块也提供了四个方法 , 与json一样 dumps , dump , loads , load</p><p>由于pickle是对于python特有的类型 , 所以 load 和 loads方法不仅支持字典 , 列表  , 它还能把python中任意的数据类型进行序列化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">-------dumps和loads--------</span><br><span class="line"><span class="comment"># 导入pickle模块</span></span><br><span class="line"><span class="keyword">import</span> pickle</span><br><span class="line"><span class="comment"># 创建一个字典</span></span><br><span class="line">dic = &#123;<span class="string">'k1'</span>:<span class="string">'v1'</span>,<span class="string">'k2'</span>:<span class="string">'v2'</span>&#125;</span><br><span class="line"><span class="comment"># 将字典转换成二进制内容</span></span><br><span class="line">p_d = pickle.dumps(dic)</span><br><span class="line"><span class="comment"># 将二进制内容转换成字典</span></span><br><span class="line">p_l = pickle.loads(p_d)</span><br><span class="line"><span class="comment"># 打印p_d</span></span><br><span class="line">print(p_d)  </span><br><span class="line"><span class="comment"># b'\x80\x03&#125;q\x00(X\x02\x00\x00\x00k2q\x01X\x02\x00\x00\x00v2q\x02X\x02\x00\x00\x00k1q\x03X\x02\x00\x00\x00v1q\x04u.'</span></span><br><span class="line"><span class="comment"># 打印p_d的类型</span></span><br><span class="line">print(type(p_d))</span><br><span class="line"><span class="comment"># &lt;class 'bytes'&gt;</span></span><br><span class="line"><span class="comment"># 打印p_l</span></span><br><span class="line">print(p_l)</span><br><span class="line"><span class="comment"># &#123;'k2': 'v2', 'k1': 'v1'&#125;</span></span><br><span class="line"><span class="comment"># 打印p_l的类型</span></span><br><span class="line">print(type(p_l))</span><br><span class="line"><span class="comment"># &lt;class 'dict'&gt;</span></span><br><span class="line">---------dump 和 load---------</span><br><span class="line"><span class="comment"># 创建一个文件句柄</span></span><br><span class="line">f = open(<span class="string">'pickle_file'</span>,<span class="string">'wb'</span>)</span><br><span class="line"><span class="comment"># 写入内容</span></span><br><span class="line">pickle.dump(<span class="string">'lyon'</span>,f)</span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">f.close()</span><br><span class="line"><span class="comment"># 创建一个文件句柄</span></span><br><span class="line">f = open(<span class="string">'pickle_file'</span>,<span class="string">'rb'</span>)</span><br><span class="line"><span class="comment"># 读出内容</span></span><br><span class="line">p_f = pickle.load(f)</span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">f.close()</span><br><span class="line"><span class="comment"># 打印</span></span><br><span class="line">print(p_f)</span><br><span class="line"><span class="comment"># lyon</span></span><br></pre></td></tr></table></figure><p><strong>但是pickle仅仅只能对python中的数据进行序列化 , 反序列化时其他语言就无法读懂了这是什么了</strong> , 所以我们一般用推荐使用json</p><h2 id="shelve-🍀"><a href="#shelve-🍀" class="headerlink" title="shelve  🍀"></a>shelve  🍀</h2><p>shelve也是python提供给我们的序列化工具 , 比pickle用起来简单一些</p><p>shelve只提供给我们一个open方法 , 是用key来访问的 ,  使用起来和字典类似</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入shelve模块</span></span><br><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line"><span class="comment"># shelve提供open方法</span></span><br><span class="line">f = shelve.open(<span class="string">'shelve_file'</span>)</span><br><span class="line"><span class="comment"># 直接对文件句柄进行操作,就可以写入文件中</span></span><br><span class="line">f[<span class="string">'key'</span>] = &#123;<span class="string">'int'</span>:<span class="number">10</span>, <span class="string">'float'</span>:<span class="number">9.5</span>, <span class="string">'string'</span>:<span class="string">'Sample data'</span>&#125;  </span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">f.close()</span><br><span class="line"><span class="comment"># 打开文件</span></span><br><span class="line">f1 = shelve.open(<span class="string">'shelve_file'</span>)</span><br><span class="line"><span class="comment"># 直接用key取值,key不存在就报错</span></span><br><span class="line">existing = f1[<span class="string">'key'</span>]</span><br><span class="line"><span class="comment"># 关闭文件</span></span><br><span class="line">f1.close()</span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line">print(existing)</span><br><span class="line"><span class="comment"># &#123;'float': 9.5, 'int': 10, 'string': 'Sample data'&#125;</span></span><br></pre></td></tr></table></figure><p>shelve不支持多个应用同时往一个数据库进行操作 , 所以当我们知道我们的应用如果只进行操作 , 我们可以设置shelve.open() 方法的参数来进行</p><p> shelve.open(filename, flag=’c’, protocol=None, writeback=False)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line"><span class="comment"># flag参数为设置操作模式,r 设置只读模式</span></span><br><span class="line">f = shelve.open(<span class="string">'shelve_file'</span>, flag=<span class="string">'r'</span>)</span><br><span class="line">existing = f[<span class="string">'key'</span>]</span><br><span class="line">f.close()</span><br><span class="line">print(existing)</span><br></pre></td></tr></table></figure><p><code>writeback</code>参数 , 可以减少我们出错的概率 , 并且让对象的持久化对用户更加的透明了 ; 但这种方式并不是所有的情况下都需要 , 首先 , 使用writeback以后 , shelf在open()的时候会增加额外的内存消耗 , 并且当数据库在close()的时候会将缓存中的每一个对象都写入到数据库 , 这也会带来额外的等待时间 , 因为shelve没有办法知道缓存中哪些对象修改了 , 哪些对象没有修改 , 因此所有的对象都会被写入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> shelve</span><br><span class="line">f1 = shelve.open(<span class="string">'shelve_file'</span>)</span><br><span class="line">print(f1[<span class="string">'key'</span>])</span><br><span class="line">f1[<span class="string">'key'</span>][<span class="string">'new_value'</span>] = <span class="string">'this was not here before'</span></span><br><span class="line">f1.close()</span><br><span class="line"><span class="comment"># 设置writeback</span></span><br><span class="line">f2 = shelve.open(<span class="string">'shelve_file'</span>, writeback=<span class="keyword">True</span>)</span><br><span class="line">print(f2[<span class="string">'key'</span>])</span><br><span class="line">f2[<span class="string">'key'</span>][<span class="string">'new_value'</span>] = <span class="string">'this was not here before'</span></span><br><span class="line">f2.close()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-序列化&quot;&gt;&lt;a href=&quot;#Python之路-序列化&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 序列化&quot;&gt;&lt;/a&gt;Python之路 - 序列化&lt;/h1&gt;&lt;h2 id=&quot;介绍-🍀&quot;&gt;&lt;a href=&quot;#介绍-🍀&quot; class=&quot;headerlink&quot; title=&quot;介绍  🍀&quot;&gt;&lt;/a&gt;介绍  🍀&lt;/h2&gt;&lt;p&gt;先说个例子 , 当我们将一个字典或者列表再或者变量存入磁盘中 , 而存入磁盘后原本数据类型就得不到保持了 . 这个时候我们就得用序列化和反序列化了&lt;/p&gt;
&lt;p&gt;序列化是将对象进行存储时保持当时对象的状态 , 实现其生命周期的延长 &lt;/p&gt;
&lt;p&gt;反序列化则是将存储的对象读取出来并转成原本的数据类型&lt;/p&gt;
&lt;p&gt;序列化的目的&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;以某种存储形式使自定义对象持久化&lt;/li&gt;
&lt;li&gt;将对象从一个地方传递到另一个地方&lt;/li&gt;
&lt;li&gt;使程序更具维护性&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Modules" scheme="https://jesse.top/categories/python/Modules/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>24.Python之路 - tarfile&amp;zipfile&amp;shutil模块</title>
    <link href="https://jesse.top/2020/06/26/python/03-Modules/09-Python%E4%B9%8B%E8%B7%AF-tarfile&amp;zipfile&amp;shutil%E6%A8%A1%E5%9D%97/"/>
    <id>https://jesse.top/2020/06/26/python/03-Modules/09-Python之路-tarfile&amp;zipfile&amp;shutil模块/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:06:12.518Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-tarfile-amp-zipfile-amp-shutil模块"><a href="#Python之路-tarfile-amp-zipfile-amp-shutil模块" class="headerlink" title="Python之路 -  tarfile&amp;zipfile&amp;shutil模块"></a>Python之路 -  tarfile&amp;zipfile&amp;shutil模块</h1><h2 id="介绍-🍀"><a href="#介绍-🍀" class="headerlink" title="介绍 🍀"></a>介绍 🍀</h2><p>tarfile和zipfile,shutil都是文件压缩,打包,解压的模块.其中shuttile还支持文件的拷贝,复制等功能</p><h2 id="zipfile模块-🍀"><a href="#zipfile模块-🍀" class="headerlink" title="zipfile模块 🍀"></a>zipfile模块 🍀</h2><ul><li>单个文件压缩</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import zipfile</span><br><span class="line">with zipfile.ZipFile(&apos;log.zip&apos;,&apos;w&apos;) as z:</span><br><span class="line">    z.write(&apos;sys.log&apos;)     #将文件sys.log添加到log.zip这个压缩包.下面2行代码功能一样</span><br><span class="line">    z.write(&apos;test.log&apos;)</span><br><span class="line">    z.write(&apos;advance.log&apos;)</span><br></pre></td></tr></table></figure><ul><li>查看上面log.zip压缩包内的文件</li></ul><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#用```r```只读模式打开压缩包</span><br><span class="line">with zipfile.ZipFile(&apos;log.zip&apos;,&apos;r&apos;) as z:</span><br><span class="line">    print(z.namelist())  #namelist方法以列表形式返回压缩包内的所有文件</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [&apos;sys.log&apos;, &apos;test.log&apos;, &apos;advance.log&apos;]</span><br></pre></td></tr></table></figure><ul><li>追加新的文件到log.zip压缩包</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#用```a```追加模式打开压缩包</span><br><span class="line">with zipfile.ZipFile(&apos;log.zip&apos;,&apos;a&apos;) as z:</span><br><span class="line">    z.write(&apos;user.db&apos;)</span><br><span class="line">    #查看文件</span><br><span class="line">    print(z.namelist())</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [&apos;sys.log&apos;, &apos;test.log&apos;, &apos;advance.log&apos;, &apos;user.db&apos;]</span><br></pre></td></tr></table></figure><ul><li>解压压缩包.解压的目标目录如果不存在,会自动创建</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">with zipfile.ZipFile(&apos;log.zip&apos;,&apos;r&apos;) as z:</span><br><span class="line">    z.extractall(path=&apos;log&apos;) #解压到log目录下</span><br><span class="line"></span><br><span class="line">#查看log目录下文件:</span><br><span class="line">print(os.listdir(&apos;log&apos;))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [&apos;advance.log&apos;, &apos;sys.log&apos;, &apos;test.log&apos;, &apos;user.db&apos;]</span><br></pre></td></tr></table></figure><ul><li>压缩目录下的所有文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">def addfile(zipfilename, dirname):</span><br><span class="line">    if os.path.isfile(dirname):</span><br><span class="line">        with zipfile.ZipFile(zipfilename, &apos;a&apos;) as z:</span><br><span class="line">            z.write(dirname)</span><br><span class="line">    else:</span><br><span class="line">        with zipfile.ZipFile(zipfilename, &apos;a&apos;) as z:</span><br><span class="line">            for root, dirs, files in os.walk(dirname): 获取子目录下的所有文件以及父目录名</span><br><span class="line">                for single_file in files:</span><br><span class="line">                    filepath = os.path.join(root, single_file) 将子目录和子目录下文件名路径拼接</span><br><span class="line">                    z.write(filepath)</span><br><span class="line"></span><br><span class="line">addfile(&apos;module2-1.zip&apos;, &apos;module2&apos;)</span><br></pre></td></tr></table></figure><h2 id="tarfile模块-🍀"><a href="#tarfile模块-🍀" class="headerlink" title="tarfile模块  🍀"></a>tarfile模块  🍀</h2><p>tarfile模块和zipfile模块使用方法大同小异.</p><ul><li>压缩单个文件</li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with tarfile.open(&apos;module2.tar&apos;,&apos;w&apos;) as tar:</span><br><span class="line">    tar.add(&apos;sys.log&apos;)</span><br><span class="line">    tar.add(&apos;test.log&apos;)</span><br></pre></td></tr></table></figure></li><li><p>解压文件</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">with tarfile.open(&apos;a.tar&apos;, &apos;r&apos;) as tar:</span><br><span class="line">    print(tar.getmembers())     # 查看压缩包内文件成员</span><br><span class="line">    # tar.extract(&apos;test.txt&apos;)  # 可选择解压某个文件</span><br><span class="line">    # tar.extractall(&apos;ccc&apos;)  # 可设置解压路径</span><br><span class="line">    tar.extractall()  # 解压全部</span><br></pre></td></tr></table></figure><ul><li>压缩目录下的所有文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def compress_file(tarfilename, dirname):    # tarfilename是压缩包名字，dirname是要打包的目录</span><br><span class="line">    if os.path.isfile(dirname):</span><br><span class="line">        with tarfile.open(tarfilename, &apos;w&apos;) as tar:</span><br><span class="line">            tar.add(dirname)</span><br><span class="line">    else:</span><br><span class="line">        with tarfile.open(tarfilename, &apos;w&apos;) as tar:</span><br><span class="line">            for root, dirs, files in os.walk(dirname):</span><br><span class="line">                for single_file in files:</span><br><span class="line">                    # if single_file != tarfilename:</span><br><span class="line">                    filepath = os.path.join(root, single_file)</span><br><span class="line">                    tar.add(filepath)</span><br><span class="line"></span><br><span class="line">compress_file(&apos;test.tar&apos;, &apos;test.txt&apos;)</span><br><span class="line">compress_file(&apos;t.tar&apos;, &apos;.&apos;)</span><br></pre></td></tr></table></figure><ul><li>添加文件到已有的压缩包中</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def addfile(tarfilename, dirname):    # tarfilename是压缩包名字，dirname是要打包的目录</span><br><span class="line">    if os.path.isfile(dirname):</span><br><span class="line">        with tarfile.open(tarfilename, &apos;a&apos;) as tar:</span><br><span class="line">            tar.add(dirname)</span><br><span class="line">    else:</span><br><span class="line">        with tarfile.open(tarfilename, &apos;a&apos;) as tar:</span><br><span class="line">            for root, dirs, files in os.walk(dirname):</span><br><span class="line">                for single_file in files:</span><br><span class="line">                    # if single_file != tarfilename:</span><br><span class="line">                    filepath = os.path.join(root, single_file)</span><br><span class="line">                    tar.add(filepath)</span><br><span class="line"></span><br><span class="line">addfile(&apos;t.tar&apos;, &apos;ttt.txt&apos;)</span><br><span class="line">addfile(&apos;t.tar&apos;, &apos;ttt&apos;)</span><br></pre></td></tr></table></figure><h2 id="shutil模块-🍀"><a href="#shutil模块-🍀" class="headerlink" title="shutil模块  🍀"></a>shutil模块  🍀</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#将文件内容拷贝到另外一个文件中</span><br><span class="line"></span><br><span class="line">shutil.copyfileobj(open(&apos;sys.log&apos;,&apos;r&apos;),open(&apos;new.log&apos;,&apos;w&apos;))</span><br><span class="line"></span><br><span class="line">#文件拷贝,如果目的文件不存在,则新建一个</span><br><span class="line">shutil.copyfile(&apos;sys.log&apos;,&apos;sys_copy.log&apos;)</span><br><span class="line"></span><br><span class="line">#仅拷贝权限..内容,组,用户均不变.目标文件必须实现存在</span><br><span class="line">shutil.copymode(&apos;sys.log&apos;,&apos;sys_copy.log&apos;)</span><br><span class="line"></span><br><span class="line">#仅拷贝状态的信息.目标文件必须实现存在</span><br><span class="line">shutil.copystat(&apos;sys.log&apos;,&apos;sys_copy.log&apos;)</span><br><span class="line"></span><br><span class="line">#拷贝文件和权限</span><br><span class="line">shutil.copy(&apos;sys.log&apos;,&apos;sys_copy.log&apos;)</span><br><span class="line"></span><br><span class="line">#递归拷贝目录.注意对目录父级目录要有可写权限，ignore的意思是排除.并且目标目录不能存在</span><br><span class="line"></span><br><span class="line">shutil.copytree(&apos;module2&apos;,&apos;module2_copy&apos;,</span><br><span class="line">                ignore=shutil.ignore_patterns(&quot;__init__.py&quot;))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#拷贝软连接</span><br><span class="line"></span><br><span class="line">shutil.copytree(&apos;module2&apos;,&apos;module2_copy&apos;,symlinks=True,</span><br><span class="line">                ignore=shutil.ignore_patterns(&quot;__init__.py&quot;))</span><br><span class="line"></span><br><span class="line">#递归删除目录</span><br><span class="line"></span><br><span class="line">shutil.rmtree(&apos;module2_copy&apos;)</span><br></pre></td></tr></table></figure><ul><li>shutil模块创建压缩文件</li></ul><p>创建压缩包并返回文件路径，例如：zip、tar</p><p>base_name： 压缩包的文件名，也可以是压缩包的路径。只是文件名时，则保存至当前目录，否则保存至指定路径，</p><p>如 data_bak         =&gt;保存至当前路径</p><p>如：/tmp/data_bak   =&gt;保存至/tmp/</p><p>format：    压缩包种类，“zip”, “tar”, “bztar”，“gztar”</p><p>root_dir：    要压缩的文件夹路径（默认当前目录）</p><p>owner：        用户，默认当前用户</p><p>group：        组，默认当前组</p><p>logger：    用于记录日志，通常是logging.Logger对象</p><ul><li>打包module2目录为module2.tar.gz.放到当前文件</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">shutil.make_archive(base_name=&quot;module2&quot;,</span><br><span class="line">                    format=&quot;gztar&quot;,</span><br><span class="line">                    root_dir=&apos;module2&apos;)</span><br></pre></td></tr></table></figure><ul><li>解压shutile压缩包</li></ul><p>shutil.unpack_archive(‘压缩包文件名’,extract_dir=’解压目标文件夹’,format=’压缩包格式’) </p><p>目标文件夹如果不存在,则自动创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutil.unpack_archive(&apos;module2.tar.gz&apos;,extract_dir=&apos;log&apos;,format=&apos;gztar&apos;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-tarfile-amp-zipfile-amp-shutil模块&quot;&gt;&lt;a href=&quot;#Python之路-tarfile-amp-zipfile-amp-shutil模块&quot; class=&quot;headerlink&quot; title=&quot;Python之路 -  tarfile&amp;amp;zipfile&amp;amp;shutil模块&quot;&gt;&lt;/a&gt;Python之路 -  tarfile&amp;amp;zipfile&amp;amp;shutil模块&lt;/h1&gt;&lt;h2 id=&quot;介绍-🍀&quot;&gt;&lt;a href=&quot;#介绍-🍀&quot; class=&quot;headerlink&quot; title=&quot;介绍 🍀&quot;&gt;&lt;/a&gt;介绍 🍀&lt;/h2&gt;&lt;p&gt;tarfile和zipfile,shutil都是文件压缩,打包,解压的模块.其中shuttile还支持文件的拷贝,复制等功能&lt;/p&gt;
&lt;h2 id=&quot;zipfile模块-🍀&quot;&gt;&lt;a href=&quot;#zipfile模块-🍀&quot; class=&quot;headerlink&quot; title=&quot;zipfile模块 🍀&quot;&gt;&lt;/a&gt;zipfile模块 🍀&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;单个文件压缩&lt;/li&gt;
&lt;/ul&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;import zipfile&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;with zipfile.ZipFile(&amp;apos;log.zip&amp;apos;,&amp;apos;w&amp;apos;) as z:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    z.write(&amp;apos;sys.log&amp;apos;)     #将文件sys.log添加到log.zip这个压缩包.下面2行代码功能一样&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    z.write(&amp;apos;test.log&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    z.write(&amp;apos;advance.log&amp;apos;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;ul&gt;
&lt;li&gt;查看上面log.zip压缩包内的文件&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Modules" scheme="https://jesse.top/categories/python/Modules/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>25.Python之路 - 面向对象</title>
    <link href="https://jesse.top/2020/06/26/python/04-Object-Oriented/01-Python%E4%B9%8B%E8%B7%AF%20-%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%88%9D%E8%AF%86/"/>
    <id>https://jesse.top/2020/06/26/python/04-Object-Oriented/01-Python之路 - 面向对象初识/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:29:02.802Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-面向对象"><a href="#Python之路-面向对象" class="headerlink" title="Python之路 - 面向对象"></a>Python之路 - 面向对象</h1><h2 id="介绍-🍀"><a href="#介绍-🍀" class="headerlink" title="介绍  🍀"></a>介绍  🍀</h2><p>编程范式</p><p>编程是程序员用 特定的语法 + 数据结构 + 算法组成的代码来告诉计算机如何执行任务的过程 , 而实现一个任务的方式有很多种不同的方式 ,  对这些不同的编程方式的特点进行归纳总结得出来的编程方式类别，即为编程范式</p><ul><li>面向过程编程  Procedural Programming</li></ul><p>面向过程编程就是程序从上到下一步步执行 , 基本设计思路就是程序一开始是要着手解决一个大的问题 , 然后把一个大问题分解成很多个小问题或子过程 , 这些子过程再执行的过程再继续分解直到小问题足够简单到可以在一个小步骤范围内解决</p><p>在Python中 , 我们通过把大段代码拆成函数 , 通过一层一层的函数调用 , 就可以把复杂任务分解成简单的任务 , 这种分解可以称之为面向过程的程序设计 . 函数就是面向过程的程序设计的基本单元</p><ul><li>函数式编程  Functional Programming</li></ul><p>函数式编程就是一种抽象程度很高的编程范式 , 纯粹的函数式编程语言编写的函数没有变量 , 函数式编程的一个特点就是 , 允许把函数本身作为参数传入另一个函数 , 还允许返回一个函数  , Python对函数式编程提供部分支持 . 由于Python允许使用变量 , 因此 , Python不是纯函数式编程语言</p><ul><li>面向对象编程  Object Oriented Programming</li></ul><p>面向对象编程是利用”类”和”对象”来创建各种模型来实现对真实世界的描述 , 使用面向对象编程的原因一方面是因为它可以使程序的维护和扩展变得更简单 , 并且可以大大提高程序开发效率 , 另外 , 基于面向对象的程序可以使它人更加容易理解你的代码逻辑 , 从而使团队开发变得更从容</p><a id="more"></a><h2 id="类与实例-🍀"><a href="#类与实例-🍀" class="headerlink" title="类与实例  🍀"></a>类与实例  🍀</h2><p>类的语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>一个栗子🌰</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个人的'类',首字母要大写</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="comment"># 构造函数,初始化属性</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line"><span class="comment"># 人可以吃饭</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">    print(<span class="string">"I am eatting"</span>)</span><br><span class="line"><span class="comment"># 创造了一个叫做'Lyon'的人        </span></span><br><span class="line">p = Person(<span class="string">'Lyon'</span>)</span><br><span class="line"><span class="comment"># 执行吃饭功能</span></span><br><span class="line">p.eat()</span><br><span class="line"><span class="comment"># 执行结果: I am eatting</span></span><br></pre></td></tr></table></figure><ul><li>类 (class)  </li></ul><p>类就是 <code>对现实生活中一类具有共同特征事物的抽象</code><br>ban<br>类起到一个模板的作用 , 当我们创建一个类时 , 就相当于创建了一个初始的’模型’ , 我们可以通过这个’模型’ 来创建出一个个具有相同特征或功能的事物 , 来帮助我们更好的处理问题</p><p>在上述栗子中类名Person 后有一个<code>(object)</code> , 这是新式类的写法 , 而在python3.x 以上的版本中 , 默认为新式类 , 所以也可直接 <code>class Person:</code> </p><p>我们创建类时 , 都默认继承了object类 , object详解见后期文章</p><ul><li>实例 (instance)</li></ul><p>我们知道类是一个抽象 , 既然是抽象那就是不可操作的 , 所以我们如果进行操作 , 就需要将这一抽象的概念变成具体的事物 , 这个过程我们称为实例化</p><p>实例化: <code>由抽象的类转换成实际存在的对象的过程</code></p><p>实例: <code>由类进行实例化所得到的对象</code>  , 上述栗子中的 <code>p</code> 就是一个实例</p><h2 id="属性与方法-🍀"><a href="#属性与方法-🍀" class="headerlink" title="属性与方法  🍀"></a>属性与方法  🍀</h2><p>属性是实体的描述性质或特征 , 比如人有名字 , 年龄 , 性别等 . 当然还有人所能做的事情也是一种属性 , 比如吃饭 , 睡觉 , 喝水等 . 对于这两种属性 , 一种是表示特征的 , 叫做静态属性 , 另一种则是表示功能的 , 叫做动态属性</p><p>在Python中 , 我们将<strong><em>静态属性</em></strong> 就称为<code>属性</code>  , 将<strong><em>动态属性</em></strong> 就称为<code>方法</code>  , 并且以变量来表示属性 , 以函数表示方法</p><p><em>PS:类中的函数已经不叫函数了 , 而叫做方法</em> </p><p>调用方式: 类名 . 属性名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="comment"># 类变量</span></span><br><span class="line">    role = <span class="string">'student'</span></span><br><span class="line">    <span class="comment"># 构造函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        <span class="comment"># 实例变量</span></span><br><span class="line">        self.name = name</span><br></pre></td></tr></table></figure><p>调用方式: 类名 . 方法名( )</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="comment"># 普通方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p><strong><em>特殊的类属性</em></strong></p><table><thead><tr><th>属性名</th><th>说明</th></tr></thead><tbody><tr><td>__dict__</td><td>查看类或对象成员 , 返回一个字典</td></tr><tr><td>__name__</td><td>查看类的名字</td></tr><tr><td>__doc__</td><td>查看类的描述信息 , 即注释部分</td></tr><tr><td>__base__</td><td>查看第一个父类</td></tr><tr><td>__bases__</td><td>查看所有父类 , 返回一个元组</td></tr><tr><td>__module__</td><td>查看类当前所在模块</td></tr><tr><td>__class__</td><td>查看对象通过什么类实例化而来</td></tr></tbody></table><p>PS:对于属性和方法 , 在网上分类各种各样的都有 , 比如字段 , 还有菜鸟教程中的一些 , 其实本质上都是一个东西</p><h2 id="构造函数-🍀"><a href="#构造函数-🍀" class="headerlink" title="构造函数  🍀"></a>构造函数  🍀</h2><p>在上述例子中 , 可以看到有一个__init__ 方法 , 这个方法叫做构造方法 , 用于初始化属性 , 所以如果我们要设置属性 , 那么构造方法是必须要的</p><blockquote><p><strong><em>self</em></strong> </p></blockquote><p>我们直接通过实例来说明</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(id(self))</span><br><span class="line">a = Foo(<span class="string">'Lyon'</span>)</span><br><span class="line"><span class="comment"># 打印实例a的内存地址</span></span><br><span class="line">print(id(a))</span><br><span class="line"><span class="comment"># 调用类中的func方法,即打印self的内存地址</span></span><br><span class="line">a.func()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">1703689404544</span></span><br><span class="line"><span class="string">1703689404544</span></span><br><span class="line"><span class="string">结果分析:</span></span><br><span class="line"><span class="string">我们发现a的内存地址和self的内存地址是一样的,也就是说self其实就是实例本身</span></span><br><span class="line"><span class="string">那么在我们进行实例化的时候,self.name = name 就是给实例添加一个name属性,该属性的值就是我们在实例化时传入的'Lyon'</span></span><br><span class="line"><span class="string">所以如果我们需要给对象添加属性的话,可以直接通过 对象.属性名 = 属性值 的方式进行添加</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>将上栗子中的构造函数再换个姿势看看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = Foo(<span class="string">'Lyon'</span>)</span><br><span class="line"><span class="comment"># 等价于如下,用类名调用类中的方法</span></span><br><span class="line">Foo.__init__(a,<span class="string">'Lyon'</span>)</span><br><span class="line"><span class="comment"># Python解释器会帮我们自动触发__init__方法,所以再如下</span></span><br><span class="line">Foo(a,<span class="string">'Lyon'</span>)</span><br></pre></td></tr></table></figure><h2 id="命名空间-🍀"><a href="#命名空间-🍀" class="headerlink" title="命名空间  🍀"></a>命名空间  🍀</h2><p>在函数中 , Python解释器在执行时 , 会将函数名称依次加载到命名空间 , 类当然也一样</p><p>我们创建一个类时 , Python解释器一执行就会创建一个类的命名空间 , 用来存储类中定义的所有名称( 属性和方法 ) , 而我们进行实例化时 , Python解释器又会为我们创建一个实例命名空间 , 用来存放实例中的名称</p><p>当我们利用 <code>类名. 名称</code>  来访问对象属性 ( 静态与动态 ) 时 , Python解释器会先到该对象的命名空间中去找<strong>该名称</strong>  , 找不到就再到类 ( 该对象实例化之前的类 ) 的命名空间中去找 , 最后如果都没找到 , 那么就抛出异常了 </p><p>访问属性实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    这是一个类</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">a = A()</span><br><span class="line"><span class="comment"># 访问实例a的__doc__属性</span></span><br><span class="line">print(a.__doc__)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    这是一个类</span></span><br><span class="line"><span class="string">    </span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>解释说明: 对于实例a本身是肯定没有__doc__ 属性的 , 这毋庸置疑 , 因为我们根本就没有使用构造函数来增加实例属性 . 根据执行结果显示 , 我们是访问到了这个类中的__doc__ 属性 , 那么你会说这个类也没看见 __doc__ 属性啊 , 其实类A是有的 , 因为它继承了object类 , 至于object类是什么 , 它里面有什么 ? 看后续文章吧</p><h2 id="属性-静态和动态-与类的关系-🍀"><a href="#属性-静态和动态-与类的关系-🍀" class="headerlink" title="属性(静态和动态)与类的关系  🍀"></a>属性(静态和动态)与类的关系  🍀</h2><p>由于Python是动态语言 , 所以Python的赋值机制都是通过动态绑定来实现的</p><blockquote><p><strong>类属性共享给所有对象</strong></p></blockquote><p>先实例后说明</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="comment"># 定义一个类变量,特意用的容器类型来说明</span></span><br><span class="line">    name = [<span class="string">'Lyon'</span>]</span><br><span class="line"><span class="comment"># 实例化</span></span><br><span class="line">a = Foo()</span><br><span class="line">b = Foo()</span><br><span class="line"><span class="comment"># 访问a,b中的name属性</span></span><br><span class="line">print(<span class="string">'实例a中的name属性:'</span>, a.name)</span><br><span class="line">print(<span class="string">'实例b中的name属性:'</span>, b.name)</span><br><span class="line"><span class="comment"># 查看a,b,Foo中name属性的内存地址</span></span><br><span class="line">print(id(a.name))</span><br><span class="line">print(id(b.name))</span><br><span class="line">print(id(Foo.name))</span><br><span class="line">print(<span class="string">'------------------'</span>)</span><br><span class="line"><span class="comment"># 修改类变量</span></span><br><span class="line">Foo.name = <span class="string">'a'</span></span><br><span class="line"><span class="comment"># 再次访问a,b中的name属性</span></span><br><span class="line">print(<span class="string">'实例a中的name属性:'</span>, a.name)</span><br><span class="line">print(<span class="string">'实例b中的name属性:'</span>, b.name)</span><br><span class="line"><span class="comment"># 修改a中的name属性? 不,是新增</span></span><br><span class="line">a.name = [<span class="string">'Lyon'</span>]</span><br><span class="line"><span class="comment"># 再次查看a,b中name属性的内存地址</span></span><br><span class="line">print(id(a.name))</span><br><span class="line">print(id(b.name))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">实例a中的name属性: ['Lyon']</span></span><br><span class="line"><span class="string">实例b中的name属性: ['Lyon']</span></span><br><span class="line"><span class="string">2247471754696</span></span><br><span class="line"><span class="string">2247471754696</span></span><br><span class="line"><span class="string">2247471754696</span></span><br><span class="line"><span class="string">------------------</span></span><br><span class="line"><span class="string">实例a中的name属性: a</span></span><br><span class="line"><span class="string">实例b中的name属性: a</span></span><br><span class="line"><span class="string">2247471792392</span></span><br><span class="line"><span class="string">2247471754696</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>说明: </p><ol><li>特意使用容器类型来进行实验 , 因为在Python中容器类型内存地址一样只有一个原因 , 那就是两者作用的是同一个对象 </li><li>我们第一步查看内存地址时 , a, b, Foo三者中的name属性的内存地址是一样的 , 实例可以通过 <code>实例.类变量名</code> 的方式进行访问 , 并且所有实例都共享类属性name</li><li><code>a.name = [&#39;Lyon&#39;]</code>  这一步其实并不是修改a中的name属性 , 要知道name属性是类的并不是实例的 , 执行这一步会为实例a加上一个新的同名name属性 , 由于赋值绑定会将原来访问类属性name的通道破坏掉 , 但是并不会影响b对类属性name的访问</li></ol><blockquote><p><strong>类中的方法是绑定到所有对象的</strong> </p></blockquote><p>先实例后说明</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">a = Foo()</span><br><span class="line">b = Foo()</span><br><span class="line"><span class="comment"># 打印a,b中func的内存地址</span></span><br><span class="line">print(a.func)</span><br><span class="line">print(b.func)</span><br><span class="line"><span class="comment"># id返回的是10进制表示的内存地址,转换成16进制</span></span><br><span class="line">print(hex(id(a)))</span><br><span class="line">print(hex(id(b)))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">&lt;bound method Foo.func of &lt;__main__.Foo object at 0x000001A7D2F74080&gt;&gt;</span></span><br><span class="line"><span class="string">&lt;bound method Foo.func of &lt;__main__.Foo object at 0x000001A7D3759898&gt;&gt;</span></span><br><span class="line"><span class="string">0x1a7d2f74080</span></span><br><span class="line"><span class="string">0x1a7d3759898</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>说明:</p><ol><li>方法名与内存地址存在一个映射关系 , 通过执行结果我们可以发现 , a.func所在的内存地址与a的内存地址是一样的 , 则说明func绑定到了a中</li><li>a.func 与b.func 的内存地址是不一样的 , 因为每一个实例都开辟了自己内存空间 , func绑定进去的位置自然不一样</li></ol><blockquote><p><strong>实例本身的属性是实例独有的</strong></p></blockquote><p>我们通过类创建一个实例 , 就会在内存中新开辟一块内存空间来存放这个实例的所有属性 , 实例属性一旦创建 , 基本跟类就没有什么太大的关系了 . 如果要修改实例属性那么就只能通过实例来进行修改了 , 并且实例与实例之间也是互不干扰的</p><h2 id="对象交互与类的组合-🍀"><a href="#对象交互与类的组合-🍀" class="headerlink" title="对象交互与类的组合  🍀"></a>对象交互与类的组合  🍀</h2><p>对象交互</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">attack</span><span class="params">(self,per)</span>:</span></span><br><span class="line">        print(<span class="string">"&#123;&#125; attacked &#123;&#125;"</span>.format(self.name, per.name))</span><br><span class="line">lyon = Person(<span class="string">"Lyon"</span>)</span><br><span class="line">kenneth = Person(<span class="string">"kenneth"</span>)</span><br><span class="line">lyon.attack(kenneth)</span><br><span class="line"><span class="comment"># 执行结果: Lyon attacked kenneth</span></span><br></pre></td></tr></table></figure><p>类的组合</p><p>传参时组合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BirthDate</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, year, month, day)</span>:</span></span><br><span class="line">        self.year = year</span><br><span class="line">        self.month = month</span><br><span class="line">        self.day = day</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, birthdate)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.birthdate = birthdate</span><br><span class="line">p = Person(<span class="string">'Lyon'</span>, BirthDate(<span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure><p>定义时组合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BirthDate</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, year, month, day)</span>:</span></span><br><span class="line">        self.year = year</span><br><span class="line">        self.month = month</span><br><span class="line">        self.day = day</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, year, month, day)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.birthdate = BirthDate(year, month, day)</span><br><span class="line">p = Person(<span class="string">'Lyon'</span>, <span class="number">2000</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-面向对象&quot;&gt;&lt;a href=&quot;#Python之路-面向对象&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 面向对象&quot;&gt;&lt;/a&gt;Python之路 - 面向对象&lt;/h1&gt;&lt;h2 id=&quot;介绍-🍀&quot;&gt;&lt;a href=&quot;#介绍-🍀&quot; class=&quot;headerlink&quot; title=&quot;介绍  🍀&quot;&gt;&lt;/a&gt;介绍  🍀&lt;/h2&gt;&lt;p&gt;编程范式&lt;/p&gt;
&lt;p&gt;编程是程序员用 特定的语法 + 数据结构 + 算法组成的代码来告诉计算机如何执行任务的过程 , 而实现一个任务的方式有很多种不同的方式 ,  对这些不同的编程方式的特点进行归纳总结得出来的编程方式类别，即为编程范式&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面向过程编程  Procedural Programming&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;面向过程编程就是程序从上到下一步步执行 , 基本设计思路就是程序一开始是要着手解决一个大的问题 , 然后把一个大问题分解成很多个小问题或子过程 , 这些子过程再执行的过程再继续分解直到小问题足够简单到可以在一个小步骤范围内解决&lt;/p&gt;
&lt;p&gt;在Python中 , 我们通过把大段代码拆成函数 , 通过一层一层的函数调用 , 就可以把复杂任务分解成简单的任务 , 这种分解可以称之为面向过程的程序设计 . 函数就是面向过程的程序设计的基本单元&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数式编程  Functional Programming&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;函数式编程就是一种抽象程度很高的编程范式 , 纯粹的函数式编程语言编写的函数没有变量 , 函数式编程的一个特点就是 , 允许把函数本身作为参数传入另一个函数 , 还允许返回一个函数  , Python对函数式编程提供部分支持 . 由于Python允许使用变量 , 因此 , Python不是纯函数式编程语言&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面向对象编程  Object Oriented Programming&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;面向对象编程是利用”类”和”对象”来创建各种模型来实现对真实世界的描述 , 使用面向对象编程的原因一方面是因为它可以使程序的维护和扩展变得更简单 , 并且可以大大提高程序开发效率 , 另外 , 基于面向对象的程序可以使它人更加容易理解你的代码逻辑 , 从而使团队开发变得更从容&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Object-Oriented" scheme="https://jesse.top/categories/python/Object-Oriented/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>22.Python之路 - logging日志模块</title>
    <link href="https://jesse.top/2020/06/26/python/03-Modules/07-Python%E4%B9%8B%E8%B7%AF%20-logging%E6%97%A5%E5%BF%97%E6%A8%A1%E5%9D%97/"/>
    <id>https://jesse.top/2020/06/26/python/03-Modules/07-Python之路 -logging日志模块/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:05:09.272Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-logging日志模块"><a href="#Python之路-logging日志模块" class="headerlink" title="Python之路 -  logging日志模块"></a>Python之路 -  logging日志模块</h1><h2 id="介绍-🍀"><a href="#介绍-🍀" class="headerlink" title="介绍 🍀"></a>介绍 🍀</h2><p>logging模块是Python内置的标准模块，主要用于输出运行日志，可以设置输出日志的等级、日志保存路径、日志文件回滚等；相比print，具备如下优点：</p><p>可以通过设置不同的日志等级，在release版本中只输出重要信息，而不必显示大量的调试信息；</p><p>print将所有信息都输出到标准输出中，严重影响开发者从标准输出中查看其它数据；logging则可以由开发者决定将信息输出到什么地方，以及怎么输出。</p><a id="more"></a><h2 id="logging模块日志等级-🍀"><a href="#logging模块日志等级-🍀" class="headerlink" title="logging模块日志等级 🍀"></a>logging模块日志等级 🍀</h2><p>logging模块默认定义了以下几个日志等级，它允许开发人员自定义其他日志级别，但是这是不被推荐的，尤其是在开发供别人使用的库时，因为这会导致日志级别的混乱。</p><table><thead><tr><th>日志等级（level）</th><th>描述</th></tr></thead><tbody><tr><td>DEBUG</td><td>详细信息，典型地调试问题时会感兴趣。 详细的debug信息。</td></tr><tr><td>INFO</td><td>证明事情按预期工作。 关键事件。</td></tr><tr><td>WARNING</td><td>表明发生了一些意外，或者不久的将来会发生问题（如‘磁盘满了’）。软件还是在正常工作。</td></tr><tr><td>ERROR</td><td>由于更严重的问题，软件已不能执行一些功能了。 一般错误消息。</td></tr><tr><td>CRITICAL</td><td>严重错误，表明软件已不能继续运行了。</td></tr></tbody></table><p>logging模块定义的模块级别的常用函数</p><table><thead><tr><th>函数</th><th>说明</th></tr></thead><tbody><tr><td>logging.debug(msg, *args, **kwargs)</td><td>创建一条严重级别为DEBUG的日志记录</td></tr><tr><td>logging.info(msg, *args, **kwargs)</td><td>创建一条严重级别为INFO的日志记录</td></tr><tr><td>logging.warning(msg, *args, **kwargs)</td><td>创建一条严重级别为WARNING的日志记录</td></tr><tr><td>logging.error(msg, *args, **kwargs)</td><td>创建一条严重级别为ERROR的日志记录</td></tr><tr><td>logging.critical(msg, *args, **kwargs)</td><td>创建一条严重级别为CRITICAL的日志记录</td></tr><tr><td>logging.log(level, *args, **kwargs)</td><td>创建一条严重级别为level的日志记录</td></tr><tr><td>logging.basicConfig(**kwargs)</td><td>对root logger进行一次性配置</td></tr></tbody></table><h2 id="一-logging模块的基础使用方法-🍀"><a href="#一-logging模块的基础使用方法-🍀" class="headerlink" title="一.logging模块的基础使用方法 🍀"></a>一.logging模块的基础使用方法 🍀</h2><p>看下面的简单例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line">logging.debug(&quot;debug_msg&quot;)</span><br><span class="line">logging.info(&quot;info_msg&quot;)</span><br><span class="line">logging.warning(&quot;warning_msg&quot;)</span><br><span class="line">logging.error(&quot;error_msg&quot;)</span><br><span class="line">logging.critical(&quot;critical_msg&quot;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 执行结果:</span><br><span class="line">WARNING:root:warning_msg</span><br><span class="line">ERROR:root:error_msg</span><br><span class="line">CRITICAL:root:critical_msg</span><br></pre></td></tr></table></figure><p>默认情况下Python的logging模块将日志打印到了标准输出中，且只显示了大于等于WARNING级别的日志，这说明默认的日志级别设置为WARNING（日志级别等级CRITICAL &gt; ERROR &gt; WARNING &gt; INFO &gt; DEBUG）</p><p>默认输出格式为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">默认的日志格式为日志级别：Logger名称：用户输出消息</span><br></pre></td></tr></table></figure><p> logging.basicConfig()函数调整日志级别、输出格式等</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> logging.basicConfig(level=logging.DEBUG,</span><br><span class="line">                    format=&quot;%(asctime)s %(name)s %(levelname)s %(message)s&quot;,</span><br><span class="line">                    datefmt = &apos;%Y-%m-%d  %H:%M:%S&apos;,</span><br><span class="line">                    filename=&apos;sys.log&apos;</span><br><span class="line">                    )</span><br><span class="line"></span><br><span class="line">logging.debug(&quot;debug调试&quot;)</span><br><span class="line">logging.info(&quot;正常日志信息&quot;)</span><br><span class="line">logging.warning(&quot;警告信息&quot;)</span><br><span class="line">logging.error(&quot;错误信息&quot;)</span><br><span class="line">logging.critical(&quot;严重错误&quot;)</span><br></pre></td></tr></table></figure><p>执行后,查看sys.log文件,格式化的记录了日志信息:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">2019-06-15  16:20:21 root DEBUG debug调试</span><br><span class="line">2019-06-15  16:20:21 root INFO 正常日志信息</span><br><span class="line">2019-06-15  16:20:21 root WARNING 警告信息</span><br><span class="line">2019-06-15  16:20:21 root ERROR 错误信息</span><br><span class="line">2019-06-15  16:20:21 root CRITICAL 严重错误</span><br></pre></td></tr></table></figure><p>basicConfig具体参数说明:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">logging.basicConfig()函数中可通过具体参数来更改logging模块默认行为，可用参数有：</span><br><span class="line"></span><br><span class="line">filename：  用指定的文件名创建FiledHandler，这样日志会被存储在指定的文件中。</span><br><span class="line">filemode：  文件打开方式，在指定了filename时使用这个参数，默认值为“a”还可指定为“w”。</span><br><span class="line">format：    指定handler使用的日志显示格式。</span><br><span class="line">datefmt：   指定日期时间格式。</span><br><span class="line">level：     设置rootlogger（后边会讲解具体概念）的日志级别</span><br><span class="line">stream：    用指定的stream创建StreamHandler。可以指定输出到sys.stderr,sys.stdout或者文件(f=open(‘test.log’,’w’))，默认为sys.stderr。若同时列出了filename和stream两个参数，则stream参数会被忽略。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">format参数中可能用到的格式化串：</span><br><span class="line">%(name)s Logger的名字</span><br><span class="line">%(levelno)s 数字形式的日志级别</span><br><span class="line">%(levelname)s 文本形式的日志级别</span><br><span class="line">%(pathname)s 调用日志输出函数的模块的完整路径名，可能没有</span><br><span class="line">%(filename)s 调用日志输出函数的模块的文件名</span><br><span class="line">%(module)s 调用日志输出函数的模块名</span><br><span class="line">%(funcName)s 调用日志输出函数的函数名</span><br><span class="line">%(lineno)d 调用日志输出函数的语句所在的代码行</span><br><span class="line">%(created)f 当前时间，用UNIX标准的表示时间的浮 点数表示</span><br><span class="line">%(relativeCreated)d 输出日志信息时的，自Logger创建以 来的毫秒数</span><br><span class="line">%(asctime)s 字符串形式的当前时间。默认格式是 “2003-07-08 16:49:45,896”。逗号后面的是毫秒</span><br><span class="line">%(thread)d 线程ID。可能没有</span><br><span class="line">%(threadName)s 线程名。可能没有</span><br><span class="line">%(process)d 进程ID。可能没有</span><br><span class="line">%(message)s用户输出的消息</span><br></pre></td></tr></table></figure><h2 id="二-logging模块的进阶使用方法-🍀"><a href="#二-logging模块的进阶使用方法-🍀" class="headerlink" title="二.logging模块的进阶使用方法 🍀"></a>二.logging模块的进阶使用方法 🍀</h2><p>第二种是一个日志流处理流程,通过函数logging.getLogger([name])（返回一个logger对象，如果没有指定名字将返回root logger）。</p><h3 id="logging日志模块四大组件"><a href="#logging日志模块四大组件" class="headerlink" title="logging日志模块四大组件"></a>logging日志模块四大组件</h3><p>在介绍logging模块的日志流处理流程之前，我们先来介绍下logging模块的四大组件：</p><table><thead><tr><th>组件名称</th><th>对应类名</th><th><strong>功能描述</strong></th></tr></thead><tbody><tr><td>日志器</td><td>Logger</td><td>提供了应用程序可一直使用的接口</td></tr><tr><td>处理器</td><td>Handler</td><td>将logger创建的日志记录发送到合适的目的输出</td></tr><tr><td>过滤器</td><td>Filter</td><td>提供了更细粒度的控制工具来决定输出哪条日志记录，丢弃哪条日志记录</td></tr><tr><td>格式器</td><td>Formatter</td><td>决定日志记录的最终输出格式</td></tr></tbody></table><h3 id="这些组件之间的关系描述："><a href="#这些组件之间的关系描述：" class="headerlink" title="这些组件之间的关系描述："></a>这些组件之间的关系描述：</h3><p>日志器（logger）需要通过处理器（handler）将日志信息输出到目标位置，如：文件、sys.stdout、网络等；</p><p>不同的处理器（handler）可以将日志输出到不同的位置；</p><p>日志器（logger）可以设置多个处理器（handler）将同一条日志记录输出到不同的位置；</p><p>每个处理器（handler）都可以设置自己的过滤器（filter）实现日志过滤，从而只保留感兴趣的日志；</p><p>每个处理器（handler）都可以设置自己的格式器（formatter）实现同一条日志以不同的格式输出到不同的地方。</p><p>简单点说就是：日志器（logger）是入口，真正干活儿的是处理器（handler），处理器（handler）还可以通过过滤器（filter）和格式器（formatter）对要输出的日志内容做过滤和格式化等处理操作。</p><h3 id="日志流处理简要流程"><a href="#日志流处理简要流程" class="headerlink" title="日志流处理简要流程"></a>日志流处理简要流程</h3><p>1、创建一个logger</p><p>2、设置下logger的日志的等级</p><p>3、创建合适的Handler(FileHandler要有路径)</p><p>4、设置下每个Handler的日志等级</p><p>5、创建下日志的格式</p><p>6、向Handler中添加上面创建的格式</p><p>7、将上面创建的Handler添加到logger中</p><p>8、打印输出logger.debug\logger.info\logger.warning\logger.error\logger.critical</p><p>###下面是一个例子  🍀</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line"></span><br><span class="line">#step1: 创建logger对象.如果参数为空,则返回root logger</span><br><span class="line">logger = logging.getLogger()</span><br><span class="line"></span><br><span class="line">#step2: 设置logger日志等级.可以是级别名,还可以是数字</span><br><span class="line"></span><br><span class="line">logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line">#step3: 创建输出流对象</span><br><span class="line"></span><br><span class="line">#创建handler文件句柄对象</span><br><span class="line">fh = logging.FileHandler(&apos;test.log&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">#创建控制台输出对象</span><br><span class="line">sh = logging.StreamHandler()</span><br><span class="line"></span><br><span class="line">#step4.定义日志格式</span><br><span class="line"></span><br><span class="line">formatter = logging.Formatter(</span><br><span class="line">    fmt=&quot;%(asctime)s %(name)s %(filename)s %(message)s&quot;,</span><br><span class="line">    datefmt=&quot;%Y/%m/%d %X&quot;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#step5.输出流对象和日志格式进行关联.格式化日志输出</span><br><span class="line"></span><br><span class="line">fh.setFormatter(formatter)</span><br><span class="line">sh.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line">#step6. 添加输出流对象和logger对象</span><br><span class="line"></span><br><span class="line">logger.addHandler(fh)</span><br><span class="line">logger.addHandler(sh)</span><br><span class="line"></span><br><span class="line">#step7: 输出日志</span><br><span class="line"></span><br><span class="line">logger.debug(&quot;debug调试&quot;)</span><br><span class="line">logger.info(&quot;正常日志信息&quot;)</span><br><span class="line">logger.warning(&quot;警告信息&quot;)</span><br><span class="line">logger.error(&quot;错误信息&quot;)</span><br><span class="line">logger.critical(&quot;严重错误&quot;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 执行结果:</span><br><span class="line">2019/06/15 16:26:20 root python06.logging模块.py debug调试</span><br><span class="line">2019/06/15 16:26:20 root python06.logging模块.py 正常日志信息</span><br><span class="line">2019/06/15 16:26:20 root python06.logging模块.py 警告信息</span><br><span class="line">2019/06/15 16:26:20 root python06.logging模块.py 错误信息</span><br><span class="line">2019/06/15 16:26:20 root python06.logging模块.py 严重错误</span><br></pre></td></tr></table></figure><p>python logging 重复写日志问题<br>用Python的logging模块记录日志时，可能会遇到重复记录日志的问题，第一条记录写一次，第二条记录写两次，第三条记录写三次</p><p>稍微修改上面代码,通过函数调用:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line"></span><br><span class="line">def log(msg):</span><br><span class="line">    logger = logging.getLogger()</span><br><span class="line">    logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line">    fh = logging.FileHandler(&apos;test.log&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">    sh = logging.StreamHandler()</span><br><span class="line"></span><br><span class="line">    formatter = logging.Formatter(</span><br><span class="line">        fmt=&quot;%(asctime)s %(name)s %(filename)s %(message)s&quot;,</span><br><span class="line">        datefmt=&quot;%Y/%m/%d %X&quot;</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    fh.setFormatter(formatter)</span><br><span class="line">    sh.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line">    logger.addHandler(fh)</span><br><span class="line">    logger.addHandler(sh)</span><br><span class="line"></span><br><span class="line">    logger.info(msg)</span><br><span class="line"></span><br><span class="line">#解决重复打印日志方法一:每次调用完就关闭文件句柄</span><br><span class="line">    # logger.removeHandler(fh)</span><br><span class="line">    # logger.removeHandler(sh)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">log(&quot;前方注意&quot;)</span><br><span class="line">log(&quot;提示&quot;)</span><br><span class="line">log(&quot;错误&quot;)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 打印结果:</span><br><span class="line">2019/06/15 16:28:20 root python06.logging模块.py 前方注意</span><br><span class="line">2019/06/15 16:28:20 root python06.logging模块.py 提示</span><br><span class="line">2019/06/15 16:28:20 root python06.logging模块.py 提示</span><br><span class="line">2019/06/15 16:28:20 root python06.logging模块.py 错误</span><br><span class="line">2019/06/15 16:28:20 root python06.logging模块.py 错误</span><br><span class="line">2019/06/15 16:28:20 root python06.logging模块.py 错误</span><br></pre></td></tr></table></figure><blockquote><p>重复打印原因：第二次调用log的时候，根据getLogger(name)里的name获取同一个logger，</p><p>而这个logger里已经有了第一次你添加的handler，第二次调用又添加了一个handler，</p><p>所以，这个logger里有了两个同样的handler，以此类推，调用几次就会有几个handler。</p></blockquote><p>第二种解决方法.每次创建文件句柄对象时,先判断是否已经存在一个对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line"></span><br><span class="line">def log(msg):</span><br><span class="line">    logger = logging.getLogger()</span><br><span class="line">    logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line">    #解决方案2.handlers对象,如果没有就创建.否则直接记录日志</span><br><span class="line">    if not logger.handlers:</span><br><span class="line">        fh = logging.FileHandler(&apos;test.log&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">        sh = logging.StreamHandler()</span><br><span class="line"></span><br><span class="line">        formatter = logging.Formatter(</span><br><span class="line">            fmt=&quot;%(asctime)s %(name)s %(filename)s %(message)s&quot;,</span><br><span class="line">            datefmt=&quot;%Y/%m/%d %X&quot;</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        fh.setFormatter(formatter)</span><br><span class="line">        sh.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line">        logger.addHandler(fh)</span><br><span class="line">        logger.addHandler(sh)</span><br><span class="line"></span><br><span class="line">    logger.info(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">log(&quot;前方注意&quot;)</span><br><span class="line">log(&quot;提示&quot;)</span><br><span class="line">log(&quot;错误&quot;)</span><br></pre></td></tr></table></figure><p>一个完整的使用例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import logging</span><br><span class="line"></span><br><span class="line">def log():</span><br><span class="line">    logger = logging.getLogger()</span><br><span class="line">    logger.setLevel(logging.DEBUG)</span><br><span class="line"></span><br><span class="line">    #解决方案2.handlers对象,如果没有就创建.否则直接记录日志</span><br><span class="line">    if not logger.handlers:</span><br><span class="line">        fh = logging.FileHandler(&apos;test.log&apos;,encoding=&apos;utf-8&apos;)</span><br><span class="line">        sh = logging.StreamHandler()</span><br><span class="line"></span><br><span class="line">        formatter = logging.Formatter(</span><br><span class="line">            fmt=&quot;%(asctime)s %(name)s %(filename)s %(message)s&quot;,</span><br><span class="line">            datefmt=&quot;%Y/%m/%d %X&quot;</span><br><span class="line">            )</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        fh.setFormatter(formatter)</span><br><span class="line">        sh.setFormatter(formatter)</span><br><span class="line"></span><br><span class="line">        logger.addHandler(fh)</span><br><span class="line">        logger.addHandler(sh)</span><br><span class="line"></span><br><span class="line">    return logger</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">log_record = log()</span><br><span class="line">log_record.info(&apos;前方注意&apos;)</span><br><span class="line">log_record.error(&apos;前方报错&apos;)</span><br><span class="line">log_record.debug(&apos;前方正常&apos;)</span><br></pre></td></tr></table></figure><h2 id="三-logging模块的高级使用方法-🍀"><a href="#三-logging模块的高级使用方法-🍀" class="headerlink" title="三.logging模块的高级使用方法 🍀"></a>三.logging模块的高级使用方法 🍀</h2><p>将上述配置定义在一个logging字典中.然后用该字典实例化一个logger对象.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line">import os</span><br><span class="line">import logging.config</span><br><span class="line"></span><br><span class="line"># 定义三种日志输出格式 开始</span><br><span class="line"></span><br><span class="line">standard_format = &apos;[%(asctime)s][%(threadName)s:%(thread)d][task_id:%(name)s][%(filename)s:%(lineno)d]&apos; \</span><br><span class="line">                  &apos;[%(levelname)s][%(message)s]&apos; #其中name为getlogger指定的名字</span><br><span class="line"></span><br><span class="line">simple_format = &apos;[%(levelname)s][%(asctime)s][%(filename)s:%(lineno)d]%(message)s&apos;</span><br><span class="line"></span><br><span class="line">id_simple_format = &apos;[%(levelname)s][%(asctime)s] %(message)s&apos;</span><br><span class="line"></span><br><span class="line"># 定义日志输出格式 结束</span><br><span class="line"></span><br><span class="line">logfile_dir = os.path.dirname(os.path.abspath(__file__))  # log文件的目录</span><br><span class="line"></span><br><span class="line">logfile_name = &apos;advance.log&apos;  # log文件名</span><br><span class="line"></span><br><span class="line"># log文件的全路径</span><br><span class="line">logfile_path = os.path.join(logfile_dir, logfile_name)</span><br><span class="line"></span><br><span class="line"># log配置字典</span><br><span class="line">LOGGING_DIC = &#123;</span><br><span class="line">    &apos;version&apos;: 1,</span><br><span class="line">    &apos;disable_existing_loggers&apos;: False,</span><br><span class="line">    #定义2个日志格式</span><br><span class="line">    &apos;formatters&apos;: &#123;</span><br><span class="line">        &apos;standard&apos;: &#123;</span><br><span class="line">            &apos;format&apos;: standard_format</span><br><span class="line">        &#125;,</span><br><span class="line">        &apos;simple&apos;: &#123;</span><br><span class="line">            &apos;format&apos;: simple_format</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;filters&apos;: &#123;&#125;,</span><br><span class="line">    &apos;handlers&apos;: &#123;</span><br><span class="line">        #打印到终端的日志</span><br><span class="line">        &apos;console&apos;: &#123;</span><br><span class="line">            &apos;level&apos;: &apos;DEBUG&apos;,</span><br><span class="line">            &apos;class&apos;: &apos;logging.StreamHandler&apos;,  # 打印到屏幕</span><br><span class="line">            &apos;formatter&apos;: &apos;simple&apos;</span><br><span class="line">        &#125;,</span><br><span class="line">        #打印到文件的日志,收集info及以上的日志</span><br><span class="line">        &apos;default&apos;: &#123;</span><br><span class="line">            &apos;level&apos;: &apos;DEBUG&apos;,</span><br><span class="line">            &apos;class&apos;: &apos;logging.handlers.RotatingFileHandler&apos;,  # 保存到文件</span><br><span class="line">            &apos;formatter&apos;: &apos;standard&apos;,</span><br><span class="line">            &apos;filename&apos;: logfile_path,  # 日志文件</span><br><span class="line">            &apos;maxBytes&apos;: 1024*1024*5,  # 日志大小 5M</span><br><span class="line">            &apos;backupCount&apos;: 5,</span><br><span class="line">            &apos;encoding&apos;: &apos;utf-8&apos;,  # 日志文件的编码，再也不用担心中文log乱码了</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    &apos;loggers&apos;: &#123;</span><br><span class="line">        #logging.getLogger(__name__)拿到的logger配置</span><br><span class="line">        &apos;&apos;: &#123;</span><br><span class="line">            &apos;handlers&apos;: [&apos;default&apos;, &apos;console&apos;],  # 这里把上面定义的两个handler都加上，即log数据既写入文件又打印到屏幕</span><br><span class="line">            &apos;level&apos;: &apos;DEBUG&apos;,</span><br><span class="line">            &apos;propagate&apos;: True,  # 向上（更高level的logger）传递</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def load_my_logging_cfg():</span><br><span class="line">    logging.config.dictConfig(LOGGING_DIC)  # 导入上面定义的logging配置</span><br><span class="line">    logger = logging.getLogger(__name__)  # 生成一个log实例</span><br><span class="line">    return logger</span><br></pre></td></tr></table></figure><p>实例化对象,记录日志:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">log = load_my_logging_cfg()</span><br><span class="line">log.info(&quot;程序正常&quot;)</span><br></pre></td></tr></table></figure><p>执行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[INFO][2019-06-15 16:33:40,852][python06.logging模块.py:271]程序正常</span><br><span class="line"></span><br><span class="line">#advance.log日志输出:</span><br><span class="line">[2019-06-15 16:33:40,852][MainThread:11892][task_id:__main__][python06.logging模块.py:271][INFO][程序正常]</span><br></pre></td></tr></table></figure><p>有了上述方式我们的好处是：所有与logging模块有关的配置都写到字典中就可以了，更加清晰，方便管理</p><p>关于上面字典中的Loggers键子字典中的key为什么为空.?<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"> logger对象都是配置到字典的loggers 键对应的子字典中的</span><br><span class="line">    按照我们对logging模块的理解，要想获取某个东西都是通过名字，也就是key来获取的</span><br><span class="line">    于是我们要获取不同的logger对象就是</span><br><span class="line">    logger=logging.getLogger(&apos;loggers子字典的key名&apos;)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">    但问题是：如果我们想要不同logger名的logger对象都共用一段配置，那么肯定不能在loggers子字典中定义n个key   </span><br><span class="line"> &apos;loggers&apos;: &#123;    </span><br><span class="line">        &apos;l1&apos;: &#123;</span><br><span class="line">            &apos;handlers&apos;: [&apos;default&apos;, &apos;console&apos;],  #</span><br><span class="line">            &apos;level&apos;: &apos;DEBUG&apos;,</span><br><span class="line">            &apos;propagate&apos;: True,  # 向上（更高level的logger）传递</span><br><span class="line">        &#125;,</span><br><span class="line">        &apos;l2: &#123;</span><br><span class="line">            &apos;handlers&apos;: [&apos;default&apos;, &apos;console&apos; ], </span><br><span class="line">            &apos;level&apos;: &apos;DEBUG&apos;,</span><br><span class="line">            &apos;propagate&apos;: False,  # 向上（更高level的logger）传递</span><br><span class="line">        &#125;,</span><br><span class="line">        &apos;l3&apos;: &#123;</span><br><span class="line">            &apos;handlers&apos;: [&apos;default&apos;, &apos;console&apos;],  #</span><br><span class="line">            &apos;level&apos;: &apos;DEBUG&apos;,</span><br><span class="line">            &apos;propagate&apos;: True,  # 向上（更高level的logger）传递</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line">#我们的解决方式是，定义一个空的key</span><br><span class="line">    &apos;loggers&apos;: &#123;</span><br><span class="line">        &apos;&apos;: &#123;</span><br><span class="line">            &apos;handlers&apos;: [&apos;default&apos;, &apos;console&apos;], </span><br><span class="line">            &apos;level&apos;: &apos;DEBUG&apos;,</span><br><span class="line">            &apos;propagate&apos;: True, </span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">这样我们再取logger对象时</span><br><span class="line">logging.getLogger(__name__)，不同的文件__name__不同，这保证了打印日志时标识信息不同，但是拿着该名字去loggers里找key名时却发现找不到，于是默认使用key=&apos;&apos;的配置</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-logging日志模块&quot;&gt;&lt;a href=&quot;#Python之路-logging日志模块&quot; class=&quot;headerlink&quot; title=&quot;Python之路 -  logging日志模块&quot;&gt;&lt;/a&gt;Python之路 -  logging日志模块&lt;/h1&gt;&lt;h2 id=&quot;介绍-🍀&quot;&gt;&lt;a href=&quot;#介绍-🍀&quot; class=&quot;headerlink&quot; title=&quot;介绍 🍀&quot;&gt;&lt;/a&gt;介绍 🍀&lt;/h2&gt;&lt;p&gt;logging模块是Python内置的标准模块，主要用于输出运行日志，可以设置输出日志的等级、日志保存路径、日志文件回滚等；相比print，具备如下优点：&lt;/p&gt;
&lt;p&gt;可以通过设置不同的日志等级，在release版本中只输出重要信息，而不必显示大量的调试信息；&lt;/p&gt;
&lt;p&gt;print将所有信息都输出到标准输出中，严重影响开发者从标准输出中查看其它数据；logging则可以由开发者决定将信息输出到什么地方，以及怎么输出。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Modules" scheme="https://jesse.top/categories/python/Modules/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>23.Python之路 - hashlib加密</title>
    <link href="https://jesse.top/2020/06/26/python/03-Modules/08-Python%E4%B9%8B%E8%B7%AF%20-hashlib%E5%8A%A0%E5%AF%86%E6%A8%A1%E5%9D%97/"/>
    <id>https://jesse.top/2020/06/26/python/03-Modules/08-Python之路 -hashlib加密模块/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:05:44.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-hashlib加密"><a href="#Python之路-hashlib加密" class="headerlink" title="Python之路 - hashlib加密"></a>Python之路 - hashlib加密</h1><h2 id="介绍-🍀"><a href="#介绍-🍀" class="headerlink" title="介绍 🍀"></a>介绍 🍀</h2><p>此模块有人称为摘要算法，也叫做加密算法，或者是哈希算法，散列算法等等，这么多title不用大家记，那么有同学就问他到底是干啥的？ 简单来说就是做加密和校验使用，它的工作原理给大家简单描述一下：它通过一个函数，把任意长度的数据按照一定规则转换为一个固定长度的数据串（通常用16进制的字符串表示）。</p><h4 id="hashlib的特征以及使用要点："><a href="#hashlib的特征以及使用要点：" class="headerlink" title="hashlib的特征以及使用要点："></a>hashlib的特征以及使用要点：</h4><p>1.bytes类型数据 —&gt; 通过hashlib算法 —&gt; 固定长度的字符串</p><p>2.不同的bytes类型数据转化成的结果一定不同。</p><p>3.相同的bytes类型数据转化成的结果一定相同。</p><p>4.此转化过程不可逆。</p><a id="more"></a><h4 id="hashlib的主要用途有两个："><a href="#hashlib的主要用途有两个：" class="headerlink" title="hashlib的主要用途有两个："></a>hashlib的主要用途有两个：</h4><p>1.密码的加密。</p><p>2.文件一致性校验。</p><h2 id="普通密码加密-🍀"><a href="#普通密码加密-🍀" class="headerlink" title="普通密码加密 🍀"></a>普通密码加密 🍀</h2><p>这里以md5加密方式为例.加密步骤非常简单.只需要3个步骤:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">str1 = &quot;jesse&quot;</span><br><span class="line"></span><br><span class="line">#1.实例化一个对象</span><br><span class="line">md5 = hashlib.md5()</span><br><span class="line"></span><br><span class="line">#2.调用update方法给字符串加密</span><br><span class="line">md5.update(str1.encode(&apos;utf-8&apos;))</span><br><span class="line"></span><br><span class="line">#3.打印加密后的值. #a1361cb85be840d6a2d762c68e4910e2</span><br><span class="line">print(md5.hexdigest())</span><br></pre></td></tr></table></figure><p>上面就是普通的md5加密，非常简单，几行代码就可以了.将jesse字符串加密成MD5密文,用于存储密码信息.</p><h4 id="如果需要加密的数据量很大-可以多次update-然后最后得出加密字符串"><a href="#如果需要加密的数据量很大-可以多次update-然后最后得出加密字符串" class="headerlink" title="如果需要加密的数据量很大,可以多次update.然后最后得出加密字符串"></a>如果需要加密的数据量很大,可以多次update.然后最后得出加密字符串</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">res = hashlib.md5()</span><br><span class="line">res.update(&quot;jesse&quot;.encode(&apos;utf-8&apos;))</span><br><span class="line">res.update(&quot;Lyon&quot;.encode(&quot;utf-8&quot;))</span><br><span class="line">print(res.hexdigest())  #f3e1e5c71241e50ff3e373e6243e125e</span><br></pre></td></tr></table></figure><p>上面计算出来的MD5密文是jesseLyon这个字符串</p><h2 id="SHA加密算法-🍀"><a href="#SHA加密算法-🍀" class="headerlink" title="SHA加密算法 🍀"></a>SHA加密算法 🍀</h2><p>另一种常见的摘要算法是SHA，SHA有不同的加密复杂度计算,例如:sha1,sha224,sha512等等，数字越大，加密的方法越复杂，安全性越高，但是效率就会越慢。</p><p>调用SHA加密和调用MD5完全类似：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sha1 = hashlib.sha1()</span><br><span class="line">sha1.update(&apos;jesse&apos;.encode(&apos;utf-8&apos;))</span><br><span class="line">print(sha1.hexdigest())</span><br></pre></td></tr></table></figure><h2 id="加盐加密-🍀"><a href="#加盐加密-🍀" class="headerlink" title="加盐加密 🍀"></a>加盐加密 🍀</h2><p>但是简单的口令，可以非常容易的计算出这些常用口令的MD5值，得到一个反推表.这样，无需破解，只需要对比数据库的MD5，黑客就获得了使用常用口令的用户账号。</p><p>对于用户来讲，当然不要使用过于简单的口令。但是，我们能否在程序设计上对简单口令加强保护呢？由于常用口令的MD5值很容易被计算出来，所以，要确保存储的用户口令不是那些已经被计算出来的常用口令的MD5，<br>这一方法通过对原始口令加一个复杂字符串来实现，俗称“加盐”：</p><h4 id="固定加盐"><a href="#固定加盐" class="headerlink" title="固定加盐"></a>固定加盐</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">salt = hashlib.md5(&quot;addtional_info&quot;.encode(&apos;utf-8&apos;))</span><br><span class="line">salt.update(&apos;jesse&apos;.encode(&apos;utf-8&apos;)) #实际上是让jesse+addtional_info2个字符串一起加密.</span><br><span class="line">print(salt.hexdigest())  #这样即使别人知道你密码,但是也无法知道MD5加密字符串</span><br></pre></td></tr></table></figure><h4 id="动态的盐"><a href="#动态的盐" class="headerlink" title="动态的盐"></a>动态的盐</h4><p>但是如果黑客通过手段窃取到你这个固定的盐之后，也是可以破解出来的。所以，我们还可以动态的盐。</p><p>下面是用用户的username来为该用户的密码加盐:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">username = input(&quot;请输入用户名:&quot;).strip()</span><br><span class="line">password = input(&quot;请输入密码:&quot;).strip()</span><br><span class="line"></span><br><span class="line">if username  and password:</span><br><span class="line">    encrypt = hashlib.md5(username.encode(&quot;utf-8&quot;))</span><br><span class="line">    encrypt.update(password.encode(&quot;utf-8&quot;))</span><br><span class="line">    print(encrypt.hexdigest())</span><br><span class="line">else:</span><br><span class="line">    print(&quot;输入错误&quot;)</span><br></pre></td></tr></table></figure><p>这样，安全性能就大大提高了。</p><h3 id="利用hashlib给用户密码加密的一个例子"><a href="#利用hashlib给用户密码加密的一个例子" class="headerlink" title="利用hashlib给用户密码加密的一个例子"></a>利用hashlib给用户密码加密的一个例子</h3><p>下面是加密算法在一个简单的用户登录程序中的使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">import hashlib,ast</span><br><span class="line"></span><br><span class="line">def user_auth():</span><br><span class="line">    &apos;&apos;&apos; 计算用户密码的加密字符串&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    username = input(&quot;请输入用户名:&quot;).strip()</span><br><span class="line">    password = input(&quot;请输入密码:&quot;).strip()</span><br><span class="line"></span><br><span class="line">    if username  and password:</span><br><span class="line">        encrypt = hashlib.md5(username.encode(&quot;utf-8&quot;))</span><br><span class="line">        encrypt.update(password.encode(&quot;utf-8&quot;))</span><br><span class="line">        password = encrypt.hexdigest()</span><br><span class="line">        return username,password</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;输入错误&quot;)</span><br><span class="line">        exit(1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def register():</span><br><span class="line">    &apos;&apos;&apos;注册用户&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    username,password = user_auth()</span><br><span class="line">    dic1 = &#123;username:password&#125;</span><br><span class="line">    with open(&quot;user.db&quot;, &apos;w&apos;) as f:</span><br><span class="line">        f.write(str(dic1))</span><br><span class="line"></span><br><span class="line">def login():</span><br><span class="line">    &apos;&apos;&apos;用户登录&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">    with open(&quot;user.db&quot;, &apos;r&apos;) as f:</span><br><span class="line">        dic1 = f.read()</span><br><span class="line">    # 将f.read()读取出来的字符串转换成字典.json.loads方法也可以实现,</span><br><span class="line">    # 但是json模块要求是双引号的字符串.这里是一个单引号的字符串,所以需要ast模块</span><br><span class="line">    dic1 = ast.literal_eval(dic1)</span><br><span class="line">    username,password = user_auth()</span><br><span class="line">    if username in dic1 and password == dic1[username]:</span><br><span class="line">        print(&quot;恭喜登录成功&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;用户密码输入不正确&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">dict2 = &#123;&quot;1&quot;:register,&quot;2&quot;:login&#125;</span><br><span class="line"></span><br><span class="line">print(&apos;&apos;&apos;</span><br><span class="line">1:register,2:login</span><br><span class="line">&apos;&apos;&apos;)</span><br><span class="line"></span><br><span class="line">choise = input(&quot;请输入序号:&quot;)</span><br><span class="line"></span><br><span class="line">if choise in dict2:</span><br><span class="line">    dict2[choise]()</span><br><span class="line">else:</span><br><span class="line">    print(&quot;输入错误&quot;)</span><br></pre></td></tr></table></figure><h2 id="文件校验-🍀"><a href="#文件校验-🍀" class="headerlink" title="文件校验 🍀"></a>文件校验 🍀</h2><p>hashlib模块除了可以用于密码加密之外，还有一个常用的功能，那就是文件的一致性校验。文件校验通常用来比较2个文件是否是同一份文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import os,hashlib</span><br><span class="line"></span><br><span class="line">def file_check(file_path):</span><br><span class="line">    file_md5 = hashlib.md5()</span><br><span class="line"></span><br><span class="line">    if os.path.isfile(file_path):</span><br><span class="line">        with open(file_path,&apos;r&apos;) as f:</span><br><span class="line"></span><br><span class="line">        #下面循环可以替换成:for line in f:</span><br><span class="line">            for line in f.readlines():</span><br><span class="line">                #循环文件,每次只update一行数据.避免一次加密整个文件造成系统崩溃</span><br><span class="line">                file_md5.update(line.encode(&apos;utf-8&apos;))</span><br><span class="line">        return file_md5.hexdigest()</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;文件不存在&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#复制2个一模一样的文件,计算出来的MD5值完全相同</span><br><span class="line"></span><br><span class="line">print(file_check(&apos;文件校验1.log&apos;)) #cae4133f1d66a901a90cdafaf6172c07</span><br><span class="line">print(file_check(&apos;文件校验2.log&apos;)) #cae4133f1d66a901a90cdafaf6172c07</span><br><span class="line"></span><br><span class="line">#将文件校验2.log文件最后一行删除一个空格,再次计算.发现MD5值已经不一样</span><br><span class="line"></span><br><span class="line">print(file_check(&apos;文件校验1.log&apos;))  #cae4133f1d66a901a90cdafaf6172c07</span><br><span class="line">print(file_check(&apos;文件校验2.log&apos;))  #c48313c88156e33b7fc7ba21661dad59</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-hashlib加密&quot;&gt;&lt;a href=&quot;#Python之路-hashlib加密&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - hashlib加密&quot;&gt;&lt;/a&gt;Python之路 - hashlib加密&lt;/h1&gt;&lt;h2 id=&quot;介绍-🍀&quot;&gt;&lt;a href=&quot;#介绍-🍀&quot; class=&quot;headerlink&quot; title=&quot;介绍 🍀&quot;&gt;&lt;/a&gt;介绍 🍀&lt;/h2&gt;&lt;p&gt;此模块有人称为摘要算法，也叫做加密算法，或者是哈希算法，散列算法等等，这么多title不用大家记，那么有同学就问他到底是干啥的？ 简单来说就是做加密和校验使用，它的工作原理给大家简单描述一下：它通过一个函数，把任意长度的数据按照一定规则转换为一个固定长度的数据串（通常用16进制的字符串表示）。&lt;/p&gt;
&lt;h4 id=&quot;hashlib的特征以及使用要点：&quot;&gt;&lt;a href=&quot;#hashlib的特征以及使用要点：&quot; class=&quot;headerlink&quot; title=&quot;hashlib的特征以及使用要点：&quot;&gt;&lt;/a&gt;hashlib的特征以及使用要点：&lt;/h4&gt;&lt;p&gt;1.bytes类型数据 —&amp;gt; 通过hashlib算法 —&amp;gt; 固定长度的字符串&lt;/p&gt;
&lt;p&gt;2.不同的bytes类型数据转化成的结果一定不同。&lt;/p&gt;
&lt;p&gt;3.相同的bytes类型数据转化成的结果一定相同。&lt;/p&gt;
&lt;p&gt;4.此转化过程不可逆。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Modules" scheme="https://jesse.top/categories/python/Modules/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>39.Python之路 - Socketserver实现多并发</title>
    <link href="https://jesse.top/2020/06/26/python/05-Network/06-Python%E4%B9%8B%E8%B7%AF%20-%20Socketserver%E5%AE%9E%E7%8E%B0%E5%A4%9A%E5%B9%B6%E5%8F%91/"/>
    <id>https://jesse.top/2020/06/26/python/05-Network/06-Python之路 - Socketserver实现多并发/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:38:01.612Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-Socketserver实现多并发"><a href="#Python之路-Socketserver实现多并发" class="headerlink" title="Python之路 - Socketserver实现多并发"></a>Python之路 - Socketserver实现多并发</h1><h2 id="阅读指引-🍀"><a href="#阅读指引-🍀" class="headerlink" title="阅读指引  🍀"></a>阅读指引  🍀</h2><p>在上面的整理篇章中 , 简单的网络编程基本已经会了 , 一个TCP , 一个UDP , 然后就是粘包问题</p><p>但是在上述中有一个问题 , 在现实生活中 , 一个服务端肯定常常需要同时服务好几个客户端 , 而上述篇章中并没有实现一对多同时进行的情况 , TCP中只能等前一个链接断开后续的才能连上 , 没连上就一直等 ; UDP则是接一次发一次 , 并不能同时接两次发两次 . 为了处理这个问题 , 即实现并发 (后续文章详细讲解) , Python中有一个socketserver模块可以满足我们的要求</p><h2 id="socketserver-🍀"><a href="#socketserver-🍀" class="headerlink" title="socketserver  🍀"></a>socketserver  🍀</h2><p>Python提供了两个级别访问的网络服务:</p><ol><li>低级别的网络服务支持基本的socket , 它提供了标准的BSD Socket API , 可以访问底层操作系统Socket接口的全部方法</li><li>高级别的网络服务模块socketserver , 它提供了服务器中心类 , 可以简化网络服务器的开发</li></ol><p>socket就不用说了 , now socketserver</p><p>我们知道基于TCP的套接字 , 关键就是两个循环 , 一个链接循环(多人) , 一个通信循环(多消息)</p><p>在socketserver模块中分为两大类 : server类 (解决链接问题) 和request类 (解决通信问题) </p><p>如果想进一步了解 , 可以看看官方文档 , &lt; <a href="https://docs.python.org/3/library/socketserver.html?highlight=socketserver#module-socketserver" target="_blank" rel="noopener">socketserver官方文档 </a>&gt;</p><a id="more"></a><h2 id="实现多并发-🍀"><a href="#实现多并发-🍀" class="headerlink" title="实现多并发  🍀"></a>实现多并发  🍀</h2><p>multi_socketserver_server.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socketserver</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyServer</span><span class="params">(socketserver.BaseRequestHandler)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">handle</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 创建一个链接,继承于socketserver中的BaseRequestHandler类</span></span><br><span class="line">        conn = self.request</span><br><span class="line">        <span class="comment"># 发送登录提示</span></span><br><span class="line">        conn.sendall(<span class="string">b"Welcome to login..."</span>)</span><br><span class="line">        print(<span class="string">"Client connect..."</span>)</span><br><span class="line">        <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">            print(<span class="string">"Waitting for recving message..."</span>)</span><br><span class="line">            <span class="comment"># 接收消息</span></span><br><span class="line">            message = conn.recv(<span class="number">1024</span>)</span><br><span class="line">            print(message.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">            <span class="comment"># 收到exit就退出</span></span><br><span class="line">            <span class="keyword">if</span> message == <span class="string">"exit"</span>:</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="comment"># 回复消息</span></span><br><span class="line">            data = input(<span class="string">"Reply message:"</span>)</span><br><span class="line">            <span class="comment"># 发送消息</span></span><br><span class="line">            conn.sendall(data.encode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">  　<span class="comment"># 实例化</span></span><br><span class="line">    server = socketserver.ThreadingTCPServer((<span class="string">'127.0.0.1'</span>, <span class="number">999</span>, ), MyServer)</span><br><span class="line">    <span class="comment"># 调用serve_forever方法</span></span><br><span class="line">    server.serve_forever()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">def serve_forever(self, poll_interval=0.5):</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">Handle one request at a time until shutdown.</span></span><br><span class="line"><span class="string">    Polls for shutdown every poll_interval seconds. Ignores</span></span><br><span class="line"><span class="string">    self.timeout. If you need to do periodic tasks, do them in</span></span><br><span class="line"><span class="string">    another thread.</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>multi_socketserver_client.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 就是一个简单的TCP客户端</span></span><br><span class="line"><span class="keyword">import</span> socket</span><br><span class="line">sock = socket.socket()</span><br><span class="line"><span class="comment"># 连接服务端</span></span><br><span class="line">sock.connect((<span class="string">'127.0.0.1'</span>, <span class="number">999</span>, ))</span><br><span class="line">login = sock.recv(<span class="number">1024</span>)</span><br><span class="line">print(login.decode(<span class="string">'utf-8'</span>))</span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">    message = input(<span class="string">"Please input the message:"</span>).strip()</span><br><span class="line">    <span class="keyword">if</span> message == <span class="string">"exit"</span>:</span><br><span class="line">        sock.sendall(<span class="string">b'exit'</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        sock.sendall(message.encode(<span class="string">'utf-8'</span>))</span><br><span class="line">        print(<span class="string">"Waitting for recving message..."</span>)</span><br><span class="line">        data = sock.recv(<span class="number">1024</span>)</span><br><span class="line">        print(data.decode(<span class="string">'utf-8'</span>))</span><br><span class="line">sock.close()</span><br></pre></td></tr></table></figure><p>到这里 , 我们成功实现了多并发 , 多并发是什么? 这就关系到操作系统中的进程和线程了 , 网络编程既然是实现两个进程间的通信 , 那么就逃不过进程 , 线程等了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-Socketserver实现多并发&quot;&gt;&lt;a href=&quot;#Python之路-Socketserver实现多并发&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - Socketserver实现多并发&quot;&gt;&lt;/a&gt;Python之路 - Socketserver实现多并发&lt;/h1&gt;&lt;h2 id=&quot;阅读指引-🍀&quot;&gt;&lt;a href=&quot;#阅读指引-🍀&quot; class=&quot;headerlink&quot; title=&quot;阅读指引  🍀&quot;&gt;&lt;/a&gt;阅读指引  🍀&lt;/h2&gt;&lt;p&gt;在上面的整理篇章中 , 简单的网络编程基本已经会了 , 一个TCP , 一个UDP , 然后就是粘包问题&lt;/p&gt;
&lt;p&gt;但是在上述中有一个问题 , 在现实生活中 , 一个服务端肯定常常需要同时服务好几个客户端 , 而上述篇章中并没有实现一对多同时进行的情况 , TCP中只能等前一个链接断开后续的才能连上 , 没连上就一直等 ; UDP则是接一次发一次 , 并不能同时接两次发两次 . 为了处理这个问题 , 即实现并发 (后续文章详细讲解) , Python中有一个socketserver模块可以满足我们的要求&lt;/p&gt;
&lt;h2 id=&quot;socketserver-🍀&quot;&gt;&lt;a href=&quot;#socketserver-🍀&quot; class=&quot;headerlink&quot; title=&quot;socketserver  🍀&quot;&gt;&lt;/a&gt;socketserver  🍀&lt;/h2&gt;&lt;p&gt;Python提供了两个级别访问的网络服务:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;低级别的网络服务支持基本的socket , 它提供了标准的BSD Socket API , 可以访问底层操作系统Socket接口的全部方法&lt;/li&gt;
&lt;li&gt;高级别的网络服务模块socketserver , 它提供了服务器中心类 , 可以简化网络服务器的开发&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;socket就不用说了 , now socketserver&lt;/p&gt;
&lt;p&gt;我们知道基于TCP的套接字 , 关键就是两个循环 , 一个链接循环(多人) , 一个通信循环(多消息)&lt;/p&gt;
&lt;p&gt;在socketserver模块中分为两大类 : server类 (解决链接问题) 和request类 (解决通信问题) &lt;/p&gt;
&lt;p&gt;如果想进一步了解 , 可以看看官方文档 , &amp;lt; &lt;a href=&quot;https://docs.python.org/3/library/socketserver.html?highlight=socketserver#module-socketserver&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;socketserver官方文档 &lt;/a&gt;&amp;gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Network" scheme="https://jesse.top/categories/python/Network/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>26.Python之路 - 面向对象之继承</title>
    <link href="https://jesse.top/2020/06/26/python/04-Object-Oriented/02-Python%E4%B9%8B%E8%B7%AF%20-%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B9%8B%E7%BB%A7%E6%89%BF/"/>
    <id>https://jesse.top/2020/06/26/python/04-Object-Oriented/02-Python之路 - 面向对象之继承/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:29:44.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-面向对象之继承"><a href="#Python之路-面向对象之继承" class="headerlink" title="Python之路 - 面向对象之继承"></a>Python之路 - 面向对象之继承</h1><h2 id="抽象与继承-🍀"><a href="#抽象与继承-🍀" class="headerlink" title="抽象与继承  🍀"></a>抽象与继承  🍀</h2><p><strong>抽象</strong> </p><blockquote><p>抽象是从众多的事物中抽取出共同的、本质性的特征，而舍弃其非本质的特征</p></blockquote><p>比如 🍎 , 🍌 , 🍇 ,  等 , 它们共同的特性就是水果 , 我们得出水果这个概念的过程就是一个抽象的过程 , 抽象能使复杂度降低 , 好让人们能够以宏观的角度来了解许多特定的事态</p><p>有抽象就会有具体 , 我们会用抽象的对象来表示一类事物 , 而用具体的对象表示某个事物 , 比如苹果 , 香蕉 , 葡萄都是具体的对象 , 水果则是抽象的对象</p><p><strong>继承</strong> </p><blockquote><p>继承是基于抽象的结果</p></blockquote><p>抽象可以让我们来以宏观的角度了解一类事物事物 , 并且这类事物都拥有该抽象中所有的特征 , 相当于继承了该抽象中的特征 , 这样我们就可以只将这类事物不同的特征放到具体中 , 而不需要再次关心共同特征 , 所以<strong><em>先有抽象后才能有继承</em></strong> </p><p>介绍抽象的概念时利用了水果来进行说明 , 为了更好的理解 , 继承就用动物为例子</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'-----------抽象出动物类-----------'</span></span><br><span class="line"><span class="comment"># 从狗和猫中抽取共同的特征,它们都能吃,喝,睡,玩</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span><span class="params">(object)</span>:</span>           </span><br><span class="line">    <span class="comment"># 吃                 </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">eat</span><span class="params">(self)</span>:</span>        </span><br><span class="line">        <span class="keyword">pass</span>              </span><br><span class="line">    <span class="comment"># 喝                  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">drink</span><span class="params">(self)</span>:</span>      </span><br><span class="line">        <span class="keyword">pass</span>              </span><br><span class="line">    <span class="comment"># 睡                  </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(self)</span>:</span>      </span><br><span class="line">        <span class="keyword">pass</span>           </span><br><span class="line">    <span class="comment"># 玩</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">play</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="string">'------------具体动物类------------'</span></span><br><span class="line"><span class="comment"># 所有的类默认是继承了object类的,让'猫'类继承动物类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="comment"># 抓老鼠</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">catch_mouse</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 让'狗'类继承动物类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span><span class="params">(Animal)</span>:</span></span><br><span class="line">    <span class="comment"># 跳墙</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">jump_wall</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>我们把🌰栗子中的Animal类叫做父类 , 基类或超类 , Cat和Dog类叫做子类或派生类 </p><blockquote><p>简单的继承方式就是在类名后面加入要继承的类</p></blockquote><p>使用继承可以减少我们代码重用 , 简化代码</p><h2 id="新式类与经典类-🍀"><a href="#新式类与经典类-🍀" class="headerlink" title="新式类与经典类  🍀"></a>新式类与经典类  🍀</h2><p>在说新式类与经典类之前 , 先说一说单继承和多继承</p><p><strong>单继承与多继承</strong> </p><blockquote><p>单继承就是只以一个类作为父类进行继承</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 继承基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subclass</span><span class="params">(Parent)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><blockquote><p>多继承就是同时以多个类做为基类进行继承</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义第一个基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent1</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 定义第二个基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent2</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 定义第三个基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent3</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 继承三个基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Subclass1</span><span class="params">(Parent1,Parent2,Parent3)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>在多继承中我们需要考虑一个继承优先的问题 , 就像上面的例子 , 如果我们所定义的三个父类中 , 都拥有一个同样的方法那么Python解释器会怎么去继承父类的方法? 三个同名的方法明显只能选择其中一个进行继承 , 这就关系到经典类和新式类了</p><p><strong>经典类和新式类</strong> </p><p>经典的东西都是比较旧的 , so ,  在Python 2.x 中默认都是经典类 , 只有显示继承了object才是新式类 ; 而Python 3.x 中默认都是新式类 , 不必显示的继承object</p><blockquote><p>经典类与新式类在声明时的区别在于 , 新式类需要加上object关键字</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python 2.x 环境下</span></span><br><span class="line"><span class="comment"># 经典类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 新式类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># python 3.x 环境下</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><blockquote><p>经典类与新式类多继承顺序的区别在于 , 经典类会按照<code>深度优先</code> (纵向)的方式查找 , 新式类会按照<code>广度优先</code> (横向)的方式查找</p></blockquote><p><strong>实例环境Python2</strong> </p><p>经典类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 经典类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"This is from A"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span>  <span class="string">"This is from C"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B,C)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">obj = D()</span><br><span class="line">obj.display()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果: This is from A</span></span><br><span class="line"><span class="string">说明:经典类深度优先,我们通过实例调用display方法时,Python解释器会先找B类,如果B类中没有就会去B类的父类(即A类)中查找,如果在所有的父类中都没有找到需要的方法,才会开始继续找下一个继承的类(即C类)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>新式类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 新式类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span> <span class="string">"This is from A"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">print</span>  <span class="string">"This is from C"</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B,C)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line">obj = D()</span><br><span class="line">obj.display()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果: This is from C</span></span><br><span class="line"><span class="string">说明:新式类广度优先,Python解释器首先到B类进行查找,B类中没有就直接去C类中找,并不会去B类的父类(A类)中去查找,如果C类中没有才会再去B类的父类(A类)中查找,最后如果没找到就会报错</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="派生-🍀"><a href="#派生-🍀" class="headerlink" title="派生  🍀"></a>派生  🍀</h2><p>利用继承机制 , 新的类可以从已有的类中派生</p><p>子类继承了父类 , 父类派生了子类 , 继承是站在子类的角度 , 派生是站在父类的角度 , 我们在子类中可以添加新的属性或方法 . 但是要注意父类属性名与子类属性名相同 , 以及父类与子类中方法名的情况 , 说的有点绕了 , 通过实例进一步描述</p><p>属性名 , 方法名不发生冲突</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="comment"># 基类属性</span></span><br><span class="line">    country = <span class="string">'China'</span></span><br><span class="line">    <span class="comment"># 构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="comment"># 工作方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am working ..."</span>)</span><br><span class="line"><span class="comment"># 派生一个子类,继承基类中的属性和方法</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="comment"># 子类属性</span></span><br><span class="line">    male = <span class="string">'man'</span></span><br><span class="line">    <span class="comment"># 新增睡觉方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am sleeping ..."</span>)</span><br><span class="line"><span class="comment"># 实例化子类</span></span><br><span class="line">man = Man(<span class="string">'Lyon'</span>, <span class="number">18</span>) </span><br><span class="line"><span class="comment"># 调用从基类继承过来的工作方法</span></span><br><span class="line">man.work()</span><br><span class="line"><span class="comment"># 访问从基类继承过来的国家属性</span></span><br><span class="line">print(man.country)</span><br><span class="line"><span class="comment"># 调用子类中的睡觉方法</span></span><br><span class="line">man.sleep()</span><br><span class="line"><span class="comment"># 访问子类中的male属性</span></span><br><span class="line">print(man.male) </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">I am working ...</span></span><br><span class="line"><span class="string">China</span></span><br><span class="line"><span class="string">I am sleepiing ...</span></span><br><span class="line"><span class="string">man</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>属性或方法冲突 , 会按照加载顺序进行覆盖 , 定义过程就已完成</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python解释器开始执行,将Person类的名字以及类中包含的属性名方法名加载到Person类的命名空间</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    country = <span class="string">'China'</span></span><br><span class="line">    <span class="comment"># 注意构造方法也是方法,Python解释器加载时仅仅会将__init__这个名字加载到命名空间,并不会执行内部代码</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="comment"># 加载方法名</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am working ..."</span>)</span><br><span class="line"><span class="comment"># Python解释器将Man类的名字加载到Man的命名空间,随后由于Person类在这步之前已经完成加载,此时就会通过Person类名从Person的命名空间中取出属性和方法名加载到Man类的命名空间</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="comment"># 由于上一已完成Person类中的同名__init__的加载,此时会将其覆盖</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, male, country)</span>:</span></span><br><span class="line">        self.male = male</span><br><span class="line">        self.country = country</span><br><span class="line">    <span class="comment"># 同__init__,将同名work覆盖</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I don't like working ..."</span>)</span><br><span class="line">    <span class="comment"># 加载到Man类的命名空间</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">sleep</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am sleepiing ..."</span>)</span><br><span class="line"><span class="comment"># 实例化Man类</span></span><br><span class="line">man = Man(<span class="string">'male'</span>, <span class="string">'America'</span>)</span><br><span class="line"><span class="comment"># 此work为覆盖后的work即子类自己的work</span></span><br><span class="line">man.work()</span><br><span class="line"><span class="comment"># country为父类的类属性,在实例化时被实例属性覆盖</span></span><br><span class="line">print(man.country)</span><br><span class="line"><span class="comment"># 调用子类中的sleep方法</span></span><br><span class="line">man.sleep()</span><br><span class="line"><span class="comment"># 打印实例属性male</span></span><br><span class="line">print(man.male)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">I don't like working ...</span></span><br><span class="line"><span class="string">America</span></span><br><span class="line"><span class="string">I am sleepiing ...</span></span><br><span class="line"><span class="string">male</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>当然我们在使用时仅需注意一下几点:</p><ol><li>重名时 , 会以子类的方法或属性为主 , 因为父类的会被覆盖</li><li>构造方法里是实例属性 , 子类如果也有构造方法 , 以子类的构造方法为主</li></ol><p>通俗的讲 : <code>我有就用我的 , 没有就拿你的</code> </p><p>但是上述派生中有两个问题:</p><ol><li>当子类父类都有构造方法时 , 如果子类需要父类构造方法中的实例属性怎么办 ?</li><li>当子类父类都有同名方法时 , 如果子类需要用父类中的方法怎么办?</li></ol><p>这两个问题放到下节 <code>super</code>  中解决</p><h2 id="super-🍀"><a href="#super-🍀" class="headerlink" title="super  🍀"></a>super  🍀</h2><p>先解决上节中的两个问题 , 既然父类中的方法被覆盖掉了 , 那么我们不妨再加载一次父类中的方法 , 将子类中的再次覆盖</p><p>解决问题1 : 子类父类构造方法中实例属性集合</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="comment"># 实例属性集合也还是要传参的,只是传入后各拿各的</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, male)</span>:</span></span><br><span class="line">        self.male = male</span><br><span class="line">        <span class="comment"># 通过类名.方法调用Person类中的__init__方法,即将__init__中的代码拿过来用了一遍</span></span><br><span class="line">        Person.__init__(self, name, age)</span><br><span class="line"><span class="comment"># 实例化Man类</span></span><br><span class="line">man = Man(<span class="string">'Lyon'</span>, <span class="number">18</span>, <span class="string">'male'</span>)</span><br><span class="line"><span class="comment"># 访问man中的name实例属性</span></span><br><span class="line">print(man.name)</span><br><span class="line"><span class="comment"># 访问man中的age实例属性</span></span><br><span class="line">print(man.age)</span><br><span class="line"><span class="comment"># 访问man中的male</span></span><br><span class="line">print(man.male)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">Lyon</span></span><br><span class="line"><span class="string">18</span></span><br><span class="line"><span class="string">male</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>解决问题2 : 使用父类中的重名方法</p><p>对于第二个问题明显不能利用问题1同样的方式了 , 因为调用就意味着执行 , 虽然我们可以以问题1中的方式执行父类的方法 , 但是子类的方法也还是会照常执行 , so , 我们得换个方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am working ..."</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I don't like working ..."</span>)</span><br><span class="line">man = Man()</span><br><span class="line"><span class="comment"># 将实例man作为self传入Person类中的work方法</span></span><br><span class="line"><span class="comment"># Person().work()</span></span><br><span class="line">Person.work(man)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果: I am working ...</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>两个问题解决了 , 但是我们发现通过这两种方式来解决会对后期修改造成非常大的麻烦 , 只要类名一变 , 那么我们就得一个个修改 , 开发中来个100个就够你改半小时了 … 所以就有了super</p><blockquote><p>super</p></blockquote><p>super只能用在新式类中 , 在经典类中则只能按照上面的方式进行处理了</p><p>截取官方文档中的一部分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相当于super(type, obj),first argument一般是self实例本身</span></span><br><span class="line">super() -&gt; same as super(__class__, &lt;first argument&gt;)</span><br><span class="line"><span class="comment"># 返回非绑定父类对象</span></span><br><span class="line">super(type) -&gt; unbound super object</span><br><span class="line"><span class="comment"># 返回父类的实例</span></span><br><span class="line">super(type, obj) -&gt; bound super object; requires isinstance(obj, type)</span><br><span class="line"><span class="comment"># 返回父类的实例</span></span><br><span class="line">super(type, type2) -&gt; bound super object; requires issubclass(type2, type)</span><br><span class="line"><span class="comment"># type参数为子类</span></span><br></pre></td></tr></table></figure><p>Python中一切皆对象 , 所以其实super是一个类 , 在我们使用super时事实上调用了super类的初始化函数 , 产生了一个super对象</p><p>首先用super的方式解决上面的问题吧</p><p>问题1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age, male)</span>:</span></span><br><span class="line">        self.male = male</span><br><span class="line">        super().__init__(name, age)</span><br></pre></td></tr></table></figure><p>问题2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I am working ..."</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Man</span><span class="params">(Person)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">work</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"I don't like working ..."</span>)</span><br><span class="line">man = Man()</span><br><span class="line"><span class="comment"># super的第一个参数是要找父类的那个类</span></span><br><span class="line">super(Man,man).work()</span><br></pre></td></tr></table></figure><p>但是在我们使用多继承时 , 这两者的区别就能显现出来了</p><p>使用__init__ </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"This is from A"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"This is from B"</span>)</span><br><span class="line">        A.__init__(self)</span><br><span class="line">        print(<span class="string">"This is from B"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"This is from C"</span>)</span><br><span class="line">        A.__init__(self)</span><br><span class="line">        print(<span class="string">"This is from C"</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B,C)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"This is from D"</span>)</span><br><span class="line">        B.__init__(self)</span><br><span class="line">        C.__init__(self)</span><br><span class="line">        print(<span class="string">"This is from D"</span>)</span><br><span class="line">d = D()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">This is from D</span></span><br><span class="line"><span class="string">This is from B</span></span><br><span class="line"><span class="string">This is from A</span></span><br><span class="line"><span class="string">This is from B</span></span><br><span class="line"><span class="string">This is from C</span></span><br><span class="line"><span class="string">This is from A</span></span><br><span class="line"><span class="string">This is from C</span></span><br><span class="line"><span class="string">This is from D</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>使用super</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"This is from A"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"This is from B"</span>)</span><br><span class="line">        super().__init__()</span><br><span class="line">        print(<span class="string">"This is from B"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"This is from C"</span>)</span><br><span class="line">        super().__init__()</span><br><span class="line">        print(<span class="string">"This is from C"</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span><span class="params">(B,C)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">"This is from D"</span>)</span><br><span class="line">        super().__init__()</span><br><span class="line">        print(<span class="string">"This is from D"</span>)</span><br><span class="line">d = D()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">This is from D</span></span><br><span class="line"><span class="string">This is from B</span></span><br><span class="line"><span class="string">This is from C</span></span><br><span class="line"><span class="string">This is from A</span></span><br><span class="line"><span class="string">This is from C</span></span><br><span class="line"><span class="string">This is from B</span></span><br><span class="line"><span class="string">This is from D</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>用__init__ 和 super我们得到的结果是不一样的 , 因为super是一个类名 , super( ) 事实上调用了super类的初始化函数 , 产生了一个super对象 , 所以使用super可以避免父类被重复调用</p><p>PS : super的查找方式遵循MRO表中的顺序 , MRO表后续文章中在研究</p><h2 id="抽象类与接口-🍀"><a href="#抽象类与接口-🍀" class="headerlink" title="抽象类与接口  🍀"></a>抽象类与接口  🍀</h2><p>Python本身不提供抽象类和接口机制</p><p>抽象类</p><blockquote><p>在Java中抽象类的定义是这样的 : 由abstract 修饰的类叫抽象类 , 该类不能被实例化 , 并且仅支持单继承</p></blockquote><p>在Python中如果要实现抽象类 , 需要借助abc模块 .  ABC是Abstract Base Class的缩写</p><p>在abc模块中有一个用来生成抽象类的元类 <code>ABCMeta</code> </p><p>生成抽象类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入抽象元类和抽象方法</span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta,abstractmethod</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Abstract_class</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line">    <span class="comment"># 使用抽象方法进行约束</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="comment"># 父类可以简单实现,子类必须实现</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'hello func'</span>)</span><br></pre></td></tr></table></figure><p>抽象类提供了继承的概念 , 它的出发点就是为了继承 , 否则它没有存在的任何意义 , 所以说定义的抽象类一定是用来继承的</p><p>接口</p><blockquote><p>在Java中接口是一个抽象类型 , 是抽象方法的集合 , 接口通常以interface来声明 . 一个类通过继承接口的方式 , 从而来继承接口的抽象方法 , 达到约束的目的</p></blockquote><p>在Python中默认是没有的 , 所以我们如果要使用接口 , 有两种方法 , 第一种就是我们在抽象类的基础上进行定义 , 第二种则是借助第三方模块 <code>zope.interface</code> </p><p>这里我们只说第一中方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入抽象元类和抽象方法</span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta,abstractmethod</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Abstract_class</span><span class="params">(metaclass=ABCMeta)</span>:</span></span><br><span class="line">    <span class="comment"># 使用抽象方法进行约束</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="comment"># 父类不能实现,子类必须实现</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>与抽象类中的例子比较 , 因为在Python中抽象类与接口类这两者区分并不清晰 , 我们在对于方法是否实现上 , 修改之后基本就实现了一个接口</p><blockquote><p>什么时候使用抽象类与接口</p></blockquote><ul><li>当几个子类的父类,有相同的功能需要被实现的时候,就使用<code>抽象类</code></li><li>当几个子类,有相同的功能,但是实现各不相同的时候,就使用<code>接口</code> (接口归一)</li></ul><p>接口归一实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABCMeta, abstractmethod</span><br><span class="line"><span class="comment"># 定义接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Payment</span><span class="params">(metaclass = ABCMeta)</span>:</span></span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, money)</span>:</span> <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 继承接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Applepay</span><span class="params">(Payment)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, money)</span>:</span></span><br><span class="line">        print(<span class="string">'The payment method is Applepay , &#123;&#125;'</span>.format(money))</span><br><span class="line"><span class="comment"># 继承接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Zhifubao</span><span class="params">(Payment)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">pay</span><span class="params">(self, money)</span>:</span></span><br><span class="line">        print(<span class="string">'The payment method is Zhiwubaopay , &#123;&#125;'</span>.format(money))</span><br><span class="line"><span class="comment"># 继承接口</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Wexin</span><span class="params">(Payment)</span>:</span></span><br><span class="line">    <span class="comment"># 没有接口中的pay方法,实例化时就报错</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">fuqian</span><span class="params">(self, money)</span>:</span></span><br><span class="line">        print(<span class="string">'The payment method is Wexinpay , &#123;&#125;'</span>.format(money))</span><br><span class="line"><span class="comment"># 接口归一</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">payment</span><span class="params">(obj,money)</span>:</span></span><br><span class="line">    obj.pay(money)</span><br><span class="line"><span class="comment"># 实例化就报错,没有pay方法</span></span><br><span class="line"><span class="comment"># wexin = Wexin()</span></span><br><span class="line">zhifubao = Zhifubao()</span><br><span class="line">apple = Applepay()</span><br><span class="line">payment(zhifubao,<span class="number">100</span>)</span><br><span class="line">payment(apple,<span class="number">1000</span>)</span><br></pre></td></tr></table></figure><p><strong><em>总结</em></strong> </p><ol><li>抽象类与接口都不能被实例化 (抽象方法约束)  , 所以必须被继承才能使用</li><li>抽象类中的方法能够被实现 , 接口中的方法不能被实现</li><li>抽象类中可以有构造方法 , 接口中不可有</li><li>抽象类最好不要用多继承 , 而接口类可以</li></ol><h2 id="isinstance-和-issubclass-🍀"><a href="#isinstance-和-issubclass-🍀" class="headerlink" title="isinstance 和 issubclass  🍀"></a>isinstance 和 issubclass  🍀</h2><p>isinstance(obj, cls) 检查obj是否是类cls的对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">obj = Foo()</span><br><span class="line">print(isinstance(obj, Foo))</span><br><span class="line">print(isinstance(obj, object))</span><br><span class="line">print(isinstance(obj, type))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">True  #obj是类Foo的对象</span></span><br><span class="line"><span class="string">True  #obj是object的对象,Foo类继承了object类</span></span><br><span class="line"><span class="string">False #object类是有type类的实例</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>issubclass(sub, super) 检查sub类是否是super类的派生类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span><span class="params">(A)</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">print(issubclass(B, B))</span><br><span class="line">print(issubclass(B, A))</span><br><span class="line">print(issubclass(B, object))</span><br><span class="line">print(issubclass(B, type))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">True  #B类是自己的派生类</span></span><br><span class="line"><span class="string">True  #B类是A类的派生类</span></span><br><span class="line"><span class="string">True  #B类是object类的派生类,因为A类继承了object类</span></span><br><span class="line"><span class="string">False #B类不是type类的派生类,type类实例化产生了object类</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-面向对象之继承&quot;&gt;&lt;a href=&quot;#Python之路-面向对象之继承&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 面向对象之继承&quot;&gt;&lt;/a&gt;Python之路 - 面向对象之继承&lt;/h1&gt;&lt;h2 id=&quot;抽象与继承-🍀&quot;&gt;&lt;a href=&quot;#抽象与继承-🍀&quot; class=&quot;headerlink&quot; title=&quot;抽象与继承  🍀&quot;&gt;&lt;/a&gt;抽象与继承  🍀&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;抽象&lt;/strong&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;抽象是从众多的事物中抽取出共同的、本质性的特征，而舍弃其非本质的特征&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;比如 🍎 , 🍌 , 🍇 ,  等 , 它们共同的特性就是水果 , 我们得出水果这个概念的过程就是一个抽象的过程 , 抽象能使复杂度降低 , 好让人们能够以宏观的角度来了解许多特定的事态&lt;/p&gt;
&lt;p&gt;有抽象就会有具体 , 我们会用抽象的对象来表示一类事物 , 而用具体的对象表示某个事物 , 比如苹果 , 香蕉 , 葡萄都是具体的对象 , 水果则是抽象的对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;继承&lt;/strong&gt; &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;继承是基于抽象的结果&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;抽象可以让我们来以宏观的角度了解一类事物事物 , 并且这类事物都拥有该抽象中所有的特征 , 相当于继承了该抽象中的特征 , 这样我们就可以只将这类事物不同的特征放到具体中 , 而不需要再次关心共同特征 , 所以&lt;strong&gt;&lt;em&gt;先有抽象后才能有继承&lt;/em&gt;&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;介绍抽象的概念时利用了水果来进行说明 , 为了更好的理解 , 继承就用动物为例子&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Object-Oriented" scheme="https://jesse.top/categories/python/Object-Oriented/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>32.Python之路 - 异常处理</title>
    <link href="https://jesse.top/2020/06/26/python/04-Object-Oriented/08-Python%E4%B9%8B%E8%B7%AF%20-%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://jesse.top/2020/06/26/python/04-Object-Oriented/08-Python之路 - 异常处理/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:32:24.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-异常处理"><a href="#Python之路-异常处理" class="headerlink" title="Python之路 - 异常处理"></a>Python之路 - 异常处理</h1><h2 id="介绍-🍀"><a href="#介绍-🍀" class="headerlink" title="介绍  🍀"></a>介绍  🍀</h2><p>在我们写程序时难免会出现错误 , 一种为语法错误 , 即为python解释器的语法检测都通不过的错误 , 这种错误只能我们在程序执行前就处理好 . 另一种为逻辑错误 , 这是我们在程序设计时所出现的错误 , 也就是我们通常所说的bug </p><p>在编程过程中为了增加友好性 , 在程序出现bug时一般不会将错误信息显示给用户 , 而是显示一个提示错误的页面</p><p>基本语法</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># except: 默认就为Exception</span></span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:<span class="number">0</span></span><br><span class="line">    <span class="comment"># 用户输入</span></span><br><span class="line">    num = input(<span class="string">"Please input the number:"</span>)</span><br><span class="line">    <span class="comment"># 遇到无法int的对象就用except进行捕获</span></span><br><span class="line">    int(num)</span><br><span class="line"><span class="comment"># 利用ValueError来捕获错误,并将捕获的错误返回给e     </span></span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 打印捕获信息</span></span><br><span class="line">    print(e)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果: </span></span><br><span class="line"><span class="string">Please input the number:Lyon</span></span><br><span class="line"><span class="string">invalid literal for int() with base 10: 'Lyon'</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>PS : 在try代码块中只要出现异常 , 那么代码块中异常后面的代码就不会执行了</p><h2 id="异常种类-🍀"><a href="#异常种类-🍀" class="headerlink" title="异常种类  🍀"></a>异常种类  🍀</h2><p>Python中的异常种类非常多 , 上述中说了个ValueError只能处理值错误 , 当我们需要处理其他的错误时 , 就需要对症下药了 , 并且异常其实也是class , 并且所有的异常都继承了BaseException类</p><p>常用异常</p><table><thead><tr><th>异常名称</th><th>说明</th></tr></thead><tbody><tr><td>ValueError</td><td>传入无效的参数</td></tr><tr><td>AttributeError</td><td>与对象的属性相关</td></tr><tr><td>IOError</td><td>输入/输出操作失败 , 基本上是无法打开文件</td></tr><tr><td>ImportError</td><td>无法引入模块或包 , 基本上是路径问题或名称错误</td></tr><tr><td>IndentationError</td><td>缩进错误</td></tr><tr><td>IndexError</td><td>下标索引超出范围 , 即索引不存在</td></tr><tr><td>KeyError</td><td>字典中不存在该key</td></tr><tr><td>KeyboardInterrupt</td><td>用户中断执行 , 即被Ctrl + C</td></tr><tr><td>NameError</td><td>变量还未声明/初始化</td></tr><tr><td>SyntaxError</td><td>语法错误</td></tr><tr><td>TypeError</td><td>传入对象类型与要求的不符合</td></tr><tr><td>UnboundLocalError</td><td>试图访问一个还未被设置的局部变量，基本上是由于另有一个同名的全局变量，导致你以为正在访问它</td></tr><tr><td>ValueError</td><td>传入无效的参数</td></tr></tbody></table><p>继承关系与其他异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 所有异常都继承自BaseException类</span></span><br><span class="line">BaseException </span><br><span class="line"> +-- SystemExit</span><br><span class="line"> +-- KeyboardInterrupt</span><br><span class="line"> +-- GeneratorExit</span><br><span class="line"> +-- Exception</span><br><span class="line">      +-- StopIteration</span><br><span class="line">      +-- StopAsyncIteration</span><br><span class="line">      +-- ArithmeticError</span><br><span class="line">      |    +-- FloatingPointError</span><br><span class="line">      |    +-- OverflowError</span><br><span class="line">      |    +-- ZeroDivisionError</span><br><span class="line">      +-- AssertionError</span><br><span class="line">      +-- AttributeError</span><br><span class="line">      +-- BufferError</span><br><span class="line">      +-- EOFError</span><br><span class="line">      +-- ImportError</span><br><span class="line">           +-- ModuleNotFoundError</span><br><span class="line">      +-- LookupError</span><br><span class="line">      |    +-- IndexError</span><br><span class="line">      |    +-- KeyError</span><br><span class="line">      +-- MemoryError</span><br><span class="line">      +-- NameError</span><br><span class="line">      |    +-- UnboundLocalError</span><br><span class="line">      +-- OSError</span><br><span class="line">      |    +-- BlockingIOError</span><br><span class="line">      |    +-- ChildProcessError</span><br><span class="line">      |    +-- ConnectionError</span><br><span class="line">      |    |    +-- BrokenPipeError</span><br><span class="line">      |    |    +-- ConnectionAbortedError</span><br><span class="line">      |    |    +-- ConnectionRefusedError</span><br><span class="line">      |    |    +-- ConnectionResetError</span><br><span class="line">      |    +-- FileExistsError</span><br><span class="line">      |    +-- FileNotFoundError</span><br><span class="line">      |    +-- InterruptedError</span><br><span class="line">      |    +-- IsADirectoryError</span><br><span class="line">      |    +-- NotADirectoryError</span><br><span class="line">      |    +-- PermissionError</span><br><span class="line">      |    +-- ProcessLookupError</span><br><span class="line">      |    +-- TimeoutError</span><br><span class="line">      +-- ReferenceError</span><br><span class="line">      +-- RuntimeError</span><br><span class="line">      |    +-- NotImplementedError</span><br><span class="line">      |    +-- RecursionError</span><br><span class="line">      +-- SyntaxError</span><br><span class="line">      |    +-- IndentationError</span><br><span class="line">      |         +-- TabError</span><br><span class="line">      +-- SystemError</span><br><span class="line">      +-- TypeError</span><br><span class="line">      +-- ValueError</span><br><span class="line">      |    +-- UnicodeError</span><br><span class="line">      |         +-- UnicodeDecodeError</span><br><span class="line">      |         +-- UnicodeEncodeError</span><br><span class="line">      |         +-- UnicodeTranslateError</span><br><span class="line">      +-- Warning</span><br><span class="line">           +-- DeprecationWarning</span><br><span class="line">           +-- PendingDeprecationWarning</span><br><span class="line">           +-- RuntimeWarning</span><br><span class="line">           +-- SyntaxWarning</span><br><span class="line">           +-- UserWarning</span><br><span class="line">           +-- FutureWarning</span><br><span class="line">           +-- ImportWarning</span><br><span class="line">           +-- UnicodeWarning</span><br><span class="line">           +-- BytesWarning</span><br><span class="line">           +-- ResourceWarning</span><br></pre></td></tr></table></figure><p>为什么要说继承关系 , 因为在使用except是 , 它不但捕获该异常 , 还会把该异常类的子类也全部捕获</p><p> 所以我们把 <code>Exception</code> 也叫做万能异常 ,  因为除了SystemExit , KeyboardInterrupt 和 GeneratorExit 三个异常之外 , 其余所有异常基本都为Exception的子类</p><h2 id="异常其他结构-🍀"><a href="#异常其他结构-🍀" class="headerlink" title="异常其他结构  🍀"></a>异常其他结构  🍀</h2><p>多分支</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">'Lyon'</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    int(name)</span><br><span class="line"><span class="keyword">except</span> IndexError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="keyword">except</span> KeyError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="comment"># ValueError捕获成功</span></span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="comment"># 执行结果:invalid literal for int() with base 10: 'Lyon'</span></span><br></pre></td></tr></table></figure><p>else</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="string">'1'</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">   int(num)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="comment"># 与for..else 和 while...else类似,没被打断就执行</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'没有异常就执行我'</span>)</span><br><span class="line"><span class="comment"># 执行结果: 没有异常就执行我</span></span><br></pre></td></tr></table></figure><p>finally</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">num = <span class="string">'Lyon'</span></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">   int(num)</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">'没有异常就执行我'</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">'不管怎么样都执行我'</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">invalid literal for int() with base 10: 'Lyon'</span></span><br><span class="line"><span class="string">不管怎么样都执行我</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="主动触发异常-🍀"><a href="#主动触发异常-🍀" class="headerlink" title="主动触发异常  🍀"></a>主动触发异常  🍀</h2><p>raise</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> TypeError(<span class="string">'类型错误'</span>)</span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="comment"># 执行结果: 类型错误</span></span><br></pre></td></tr></table></figure><h2 id="自定义异常-🍀"><a href="#自定义异常-🍀" class="headerlink" title="自定义异常  🍀"></a>自定义异常  🍀</h2><p>通过继承BaseException来实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LyonException</span><span class="params">(BaseException)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,msg)</span>:</span></span><br><span class="line">        self.msg = msg</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.msg</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 主动触发异常</span></span><br><span class="line">    <span class="keyword">raise</span> LyonException(<span class="string">'你就是错了,别问为什么'</span>)</span><br><span class="line"><span class="comment"># 捕获LyonException</span></span><br><span class="line"><span class="keyword">except</span> LyonException <span class="keyword">as</span> e:</span><br><span class="line">    print(e)</span><br><span class="line"><span class="comment"># 执行结果: 你就是错了,别问为什么</span></span><br></pre></td></tr></table></figure><h2 id="断言-🍀"><a href="#断言-🍀" class="headerlink" title="断言  🍀"></a>断言  🍀</h2><p>断定条件成立 , 不成立就出现AssertionError异常</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 断定1等于1</span></span><br><span class="line">    <span class="keyword">assert</span> <span class="number">1</span> == <span class="number">1</span></span><br><span class="line">    print(<span class="string">'第一个断言成功就执行'</span>)</span><br><span class="line">    <span class="keyword">assert</span> <span class="number">2</span> == <span class="number">1</span></span><br><span class="line">    print(<span class="string">"第二个断言失败不执行"</span>)</span><br><span class="line"><span class="comment"># 捕获AssertionError异常</span></span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    print(<span class="string">"抓到你了"</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">第一个断言成功就执行</span></span><br><span class="line"><span class="string">抓到你了</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p><strong><em>注意 :</em></strong></p><p>​    不要在任何地方都使用try…except , 因为它本身就是你附加给你程序的一种异常处理的逻辑 , 与你的主要的工作是没有关系的 , 这种东西加多了 , 会导致你的代码可读性变差 , 只有在有些异常无法与之的情况下 , 才应该使用try…except , 其他的逻辑错误应该尽量自行修正</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-异常处理&quot;&gt;&lt;a href=&quot;#Python之路-异常处理&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 异常处理&quot;&gt;&lt;/a&gt;Python之路 - 异常处理&lt;/h1&gt;&lt;h2 id=&quot;介绍-🍀&quot;&gt;&lt;a href=&quot;#介绍-🍀&quot; class=&quot;headerlink&quot; title=&quot;介绍  🍀&quot;&gt;&lt;/a&gt;介绍  🍀&lt;/h2&gt;&lt;p&gt;在我们写程序时难免会出现错误 , 一种为语法错误 , 即为python解释器的语法检测都通不过的错误 , 这种错误只能我们在程序执行前就处理好 . 另一种为逻辑错误 , 这是我们在程序设计时所出现的错误 , 也就是我们通常所说的bug &lt;/p&gt;
&lt;p&gt;在编程过程中为了增加友好性 , 在程序出现bug时一般不会将错误信息显示给用户 , 而是显示一个提示错误的页面&lt;/p&gt;
&lt;p&gt;基本语法&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Object-Oriented" scheme="https://jesse.top/categories/python/Object-Oriented/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>31.Python之路 - 反射</title>
    <link href="https://jesse.top/2020/06/26/python/04-Object-Oriented/07-Python%E4%B9%8B%E8%B7%AF%20-%20%E5%8F%8D%E5%B0%84/"/>
    <id>https://jesse.top/2020/06/26/python/04-Object-Oriented/07-Python之路 - 反射/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:31:56.842Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-反射"><a href="#Python之路-反射" class="headerlink" title="Python之路 - 反射"></a>Python之路 - 反射</h1><h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力 </p><p>Python面向对象中的反射是通过字符串的形式来操作对象相关的属性 , 在Python中一切皆对象 , 并且只要是对象就可以使用反射</p><h2 id="hasattr-🍀"><a href="#hasattr-🍀" class="headerlink" title="hasattr  🍀"></a>hasattr  🍀</h2><p>判断对象中是否具有给定名称的属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasattr</span><span class="params">(*args, **kwargs)</span>:</span> <span class="comment"># real signature unknown</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Return whether the object has an attribute with the given name.  </span></span><br><span class="line"><span class="string">    This is done by calling getattr(obj, name) and catching AttributeError.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>实例1</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个字符串</span></span><br><span class="line">name = <span class="string">'lyon'</span></span><br><span class="line"><span class="comment"># 查看是否具有给定名称的属性</span></span><br><span class="line">bool = hasattr(name,<span class="string">'__len__'</span>)</span><br><span class="line"><span class="comment"># 打印bool</span></span><br><span class="line">print(bool)</span><br><span class="line"><span class="comment"># 执行结果:True</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">说明:很多初学者可能一直不理解为什么说Python里一切皆对象,因为没有意识到,在Python中str、list、int ...等这些数据类型,其实就是用class写出来的一个模型,那么既然是类就会有属性这一说,就可以利用反射来操作对象了</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>实例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">s1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">s2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">this_modules = sys.modules[__name__]</span><br><span class="line">print(type(this_modules),hasattr(this_modules,<span class="string">'s1'</span>))</span><br><span class="line">module1</span><br></pre></td></tr></table></figure><h2 id="getattr-🍀"><a href="#getattr-🍀" class="headerlink" title="getattr  🍀"></a>getattr  🍀</h2><p>从一个对象中获取属性名称</p><a id="more"></a><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getattr</span><span class="params">(object, name, default=None)</span>:</span> <span class="comment"># known special case of getattr</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Get a named attribute from an object; getattr(x, 'y') is equivalent to x.y.</span></span><br><span class="line"><span class="string">    When a default argument is given, it is returned when the attribute doesn't</span></span><br><span class="line"><span class="string">    exist; without it, an exception is raised in that case.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'hello &#123;&#125;'</span>.format(self.name))</span><br><span class="line"><span class="comment"># 创建一个实例a        </span></span><br><span class="line">a = A(<span class="string">'Lyon'</span>,<span class="number">18</span>)</span><br><span class="line"><span class="comment"># 获取静态属性age</span></span><br><span class="line">age = getattr(a,<span class="string">'age'</span>)</span><br><span class="line"><span class="comment"># 打印age</span></span><br><span class="line">print(age)</span><br><span class="line"><span class="comment"># 获取动态属性hello,即方法</span></span><br><span class="line">hello = getattr(a,<span class="string">'hello'</span>)</span><br><span class="line"><span class="comment"># 执行hello</span></span><br><span class="line">hello()</span><br><span class="line"><span class="comment"># 如果不存在就需要设置default参数,否则就报错</span></span><br><span class="line">birthday = getattr(a,<span class="string">'birthday'</span>,<span class="string">'today'</span>)</span><br><span class="line"><span class="comment"># 打印birthday,即为default参数</span></span><br><span class="line">print(birthday)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">18</span></span><br><span class="line"><span class="string">hello Lyon</span></span><br><span class="line"><span class="string">today</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="setattr-🍀"><a href="#setattr-🍀" class="headerlink" title="setattr  🍀"></a>setattr  🍀</h2><p>定义属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">setattr</span><span class="params">(x, y, v)</span>:</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Sets the named attribute on the given object to the specified value.   </span></span><br><span class="line"><span class="string">    setattr(x, 'y', v) is equivalent to ``x.y = v''</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line">b = B()</span><br><span class="line"><span class="comment"># 新增属性,如果存在即为修改</span></span><br><span class="line">setattr(b, <span class="string">'age'</span>, <span class="number">18</span>)</span><br><span class="line"><span class="comment"># 打印age属性</span></span><br><span class="line">print(b.age)</span><br><span class="line"><span class="comment"># 新增add方法</span></span><br><span class="line">setattr(b, <span class="string">'add'</span>, <span class="keyword">lambda</span> age: age + <span class="number">1</span>)</span><br><span class="line"><span class="comment"># 修改age属性</span></span><br><span class="line">b.age = b.add(b.age)</span><br><span class="line"><span class="comment"># 打印age属性</span></span><br><span class="line">print(b.age)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">18</span></span><br><span class="line"><span class="string">19</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="delattr-🍀"><a href="#delattr-🍀" class="headerlink" title="delattr  🍀"></a>delattr  🍀</h2><p>删除对象中的属性</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">delattr</span><span class="params">(x, y)</span>:</span> <span class="comment"># real signature unknown; restored from __doc__</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Deletes the named attribute from the given object.</span></span><br><span class="line"><span class="string">    delattr(x, 'y') is equivalent to ``del x.y''</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self,name,age)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(self)</span>:</span></span><br><span class="line">        self.age = self.age + <span class="number">1</span></span><br><span class="line">c = C(<span class="string">'Lyon'</span>,<span class="number">18</span>)</span><br><span class="line"><span class="comment"># 删除c中的</span></span><br><span class="line">delattr(c,<span class="string">'name'</span>)</span><br><span class="line"><span class="comment"># print(c.name)   报错</span></span><br><span class="line">delattr(c,<span class="string">'add'</span>)</span><br><span class="line"><span class="comment"># c.add()   报错</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-反射&quot;&gt;&lt;a href=&quot;#Python之路-反射&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 反射&quot;&gt;&lt;/a&gt;Python之路 - 反射&lt;/h1&gt;&lt;h2 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h2&gt;&lt;p&gt;反射主要是指程序可以访问、检测和修改它本身状态或行为的一种能力 &lt;/p&gt;
&lt;p&gt;Python面向对象中的反射是通过字符串的形式来操作对象相关的属性 , 在Python中一切皆对象 , 并且只要是对象就可以使用反射&lt;/p&gt;
&lt;h2 id=&quot;hasattr-🍀&quot;&gt;&lt;a href=&quot;#hasattr-🍀&quot; class=&quot;headerlink&quot; title=&quot;hasattr  🍀&quot;&gt;&lt;/a&gt;hasattr  🍀&lt;/h2&gt;&lt;p&gt;判断对象中是否具有给定名称的属性&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;hasattr&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(*args, **kwargs)&lt;/span&gt;:&lt;/span&gt; &lt;span class=&quot;comment&quot;&gt;# real signature unknown&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    Return whether the object has an attribute with the given name.  &lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    This is done by calling getattr(obj, name) and catching AttributeError.&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    &quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实例1&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 定义一个字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;name = &lt;span class=&quot;string&quot;&gt;&#39;lyon&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 查看是否具有给定名称的属性&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;bool = hasattr(name,&lt;span class=&quot;string&quot;&gt;&#39;__len__&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 打印bool&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(bool)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 执行结果:True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;说明:很多初学者可能一直不理解为什么说Python里一切皆对象,因为没有意识到,在Python中str、list、int ...等这些数据类型,其实就是用class写出来的一个模型,那么既然是类就会有属性这一说,就可以利用反射来操作对象了&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;实例2&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; sys&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;s1&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;s2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;pass&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;this_modules = sys.modules[__name__]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(type(this_modules),hasattr(this_modules,&lt;span class=&quot;string&quot;&gt;&#39;s1&#39;&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;module1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h2 id=&quot;getattr-🍀&quot;&gt;&lt;a href=&quot;#getattr-🍀&quot; class=&quot;headerlink&quot; title=&quot;getattr  🍀&quot;&gt;&lt;/a&gt;getattr  🍀&lt;/h2&gt;&lt;p&gt;从一个对象中获取属性名称&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Object-Oriented" scheme="https://jesse.top/categories/python/Object-Oriented/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>21.Python之路 - 正则表达式</title>
    <link href="https://jesse.top/2020/06/26/python/03-Modules/05-Python%E4%B9%8B%E8%B7%AF%20-%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://jesse.top/2020/06/26/python/03-Modules/05-Python之路 - 正则表达式/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:04:10.544Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-正则表达式"><a href="#Python之路-正则表达式" class="headerlink" title="Python之路 - 正则表达式"></a>Python之路 - 正则表达式</h1><h2 id="正则介绍-🍀"><a href="#正则介绍-🍀" class="headerlink" title="正则介绍  🍀"></a>正则介绍  🍀</h2><p>正则表达式并不是python的一部分，而是在各个编程语言都有的一种用于处理字符串的强大工具。</p><p>使用正则处理字符串在效率上可能不如str自带的方法，但是它的功能十分强大。python中的正则封装在re模块中。</p><a id="more"></a><h2 id="匹配方法-🍀"><a href="#匹配方法-🍀" class="headerlink" title="匹配方法  🍀"></a>匹配方法  🍀</h2><p>首先将匹配方法进行说明，即re模块的内置方法</p><blockquote><p><code>re.match</code>(<em>pattern</em>, <em>string</em>, <em>flags=0</em>) :  👈</p></blockquote><p>从字符串的开头开始匹配，匹配成功返回一个<code>_sre.SRE_Match</code>类型，可用<code>.group()</code> 取出结果，失败返回None</p><p><em>pattern</em> : 匹配格式</p><p><em>string</em> : 要匹配的字符串</p><p><em>flags</em> : 编译标志位，用于修改正则表达式的匹配方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入re模块，后续方法实例省略这一步</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> re</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = re.match(<span class="string">'lyon'</span>,<span class="string">'lyon'</span>)</span><br><span class="line"><span class="comment"># 查看类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(res)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">_sre</span>.<span class="title">SRE_Match</span>'&gt;</span></span><br><span class="line"><span class="class"># 用.<span class="title">group</span><span class="params">()</span>取出结果</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">res</span>.<span class="title">group</span><span class="params">()</span></span></span><br><span class="line"><span class="class">'<span class="title">lyon</span>'</span></span><br></pre></td></tr></table></figure><blockquote><p><code>re.search</code>(<em>pattern</em>, <em>string</em>, <em>flags=0</em>) :  👈</p></blockquote><p>扫描整个字符串，匹配成功则返回匹配到的第一个对象（<code>_sre.SRE_Match</code>类型），失败返回None</p><p><em>pattern</em> : 匹配格式</p><p><em>string</em> : 要匹配的字符串</p><p><em>flags</em> : 编译标志位，用于修改正则表达式的匹配方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匹配数字</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.search(<span class="string">'\d+'</span>,<span class="string">'abc123abc'</span>).group()</span><br><span class="line"><span class="string">'123'</span></span><br></pre></td></tr></table></figure><blockquote><p><code>re.findall</code>(<em>pattern</em>, <em>string</em>, <em>flags=0</em>) :  👈</p></blockquote><p>匹配字符串所有的内容，把匹配到的字符串以列表的形式返回</p><p><em>pattern</em> : 匹配格式</p><p><em>string</em> : 要匹配的字符串</p><p><em>flags</em> : 编译标志位，用于修改正则表达式的匹配方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 匹配数字</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">'\d'</span>,<span class="string">'abc123abc456'</span>)</span><br><span class="line">[<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>,<span class="string">'4'</span>,<span class="string">'5'</span>,<span class="string">'6'</span>]</span><br></pre></td></tr></table></figure><blockquote><p><code>re.split</code>(<em>pattern</em>, <em>string</em>, <em>maxsplit=0</em>, <em>flags=0</em>) :  👈</p></blockquote><p>指定格式进行切分，返回一个列表</p><p><em>pattern</em> :  切分格式</p><p><em>string</em> : 要切分的字符串</p><p><em>maxsplit</em> : 切分次数</p><p><em>flags</em> : 编译标志位，用于修改正则表达式的匹配方式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 以数字进行切分</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.split(<span class="string">'\d+'</span>,<span class="string">'abc123abc123+-*/45'</span>)</span><br><span class="line">[<span class="string">'abc'</span>, <span class="string">'abc'</span>, <span class="string">'+-*/'</span>, <span class="string">''</span>]</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>str1 = ‘alex,jerry;jesse|lyon wusir’<br>print(re.split(“ |,|;||“,str1)) </p><blockquote><blockquote><blockquote><p>[‘alex’, ‘jerry’, ‘jesse’, ‘lyon’, ‘wusir’]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt; `re.sub`(*pattern*, *repl*, *string*, *count=0*, *flags=0*) : 👈</span><br><span class="line"></span><br><span class="line">替换匹配到的字符串并返回替换后的结果</span><br><span class="line"></span><br><span class="line">*pattern* : 匹配格式</span><br><span class="line"></span><br><span class="line">*repl* : 替换格式</span><br><span class="line"></span><br><span class="line">*string* : 要匹配替换的字符串</span><br><span class="line"></span><br><span class="line">*flags* : 编译标志位，用于修改正则表达式的匹配方式</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">&gt;&gt;&gt; re.sub(&quot;abc&quot;,&quot;def&quot;,&quot;abc123abc&quot;)</span><br><span class="line">&apos;def123def&apos;</span><br><span class="line"># 只替换查找到的字符串一次</span><br><span class="line">&gt;&gt;&gt; re.sub(&quot;abc&quot;,&quot;def&quot;,&quot;abc123abc&quot;,count=1)</span><br><span class="line">&apos;def123abc&apos;</span><br></pre></td></tr></table></figure></p></blockquote></blockquote></blockquote><p><em>flags说明（轻轻了解） :</em></p><table><thead><tr><th>标志</th><th>说明</th></tr></thead><tbody><tr><td>re.I  (re.IGNORECASE)</td><td>忽略大小写（括号内为全拼写法，效果一样）</td></tr><tr><td>re.M  (MULTILINE)</td><td>多行模式，改变 ‘^’ 和 ‘$’ 的行为 （改变？见下节匹配模式）</td></tr><tr><td>re.S  (DOTALL)</td><td>任意匹配模式，改变 ‘ . ‘  的行为（同上）</td></tr><tr><td>re.L  (LOCALE)</td><td>做本地化识别（locale-aware）匹配，法语等</td></tr><tr><td>re.X  (VERBOSE)</td><td>该标志通过给予更灵活的格式以便将正则表达式写得更易于理解</td></tr><tr><td>re.U</td><td>根据Unicode字符集解析字符，这个标志影响\w,\W,\b,\B</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 忽略大小写</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>re.findall(<span class="string">'a'</span>,<span class="string">'aA123aAAA'</span>,flags=re.I)</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'A'</span>, <span class="string">'a'</span>, <span class="string">'A'</span>, <span class="string">'A'</span>, <span class="string">'A'</span>]</span><br></pre></td></tr></table></figure><p><em>注意转义的问题：当我们的匹配格式中有我们需要匹配的特殊字符，如 ‘ \ ‘、’ </em> ‘、’ + ‘等，为了让解释器知道我们这是需要匹配的，我们可以在格式前加 ‘r’ 进行转义，或者在每个需要匹配的之前加个 ‘ \ ‘来完成转义。*</p><p><em><code>.group()</code>小知识：</em></p><p>在我们使用<code>.group()</code>方法时，要注意如果我们的正则表达式没有匹配到结果，即返回None时，用<code>.group()</code>时就会报错，因为<code>&quot;NoneType&quot;</code>是没有该方法的，只有<code>_sre.SRE_Match</code>类型才能使用该方法。</p><h2 id="匹配模式-🍀"><a href="#匹配模式-🍀" class="headerlink" title="匹配模式   🍀"></a>匹配模式   🍀</h2><h3 id="字符匹配-🍡"><a href="#字符匹配-🍡" class="headerlink" title="字符匹配   🍡"></a>字符匹配   🍡</h3><table><thead><tr><th style="text-align:left">字符</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:left">.</td><td>默认匹配除\n之外的任意一个字符，若指定flag DOTALL,则匹配任意字符，包括换行</td></tr><tr><td style="text-align:left">\d \D</td><td>匹配数字0-9/非数字</td></tr><tr><td style="text-align:left">\s</td><td>匹配空白字符、\t、\n、\r , re.search(“\s+”,”ab\tc1\n3”).group() 结果 ‘\t’</td></tr><tr><td style="text-align:left">\S</td><td>非空白字符</td></tr><tr><td style="text-align:left">\w</td><td>匹配[A-Za-z0-9]</td></tr><tr><td style="text-align:left">\W</td><td>匹配非[A-Za-z0-9]</td></tr><tr><td style="text-align:left">\b</td><td>匹配一个单词边界，也就是指单词和空格间的位置。例如， ‘er\b’ 可以匹配”never” 中的 ‘er’，但不能匹配 “verb” 中的 ‘er’。</td></tr><tr><td style="text-align:left">\B</td><td>匹配非单词边界。’er\B’ 能匹配 “verb” 中的 ‘er’，但不能匹配 “never” 中的 ‘er’。</td></tr></tbody></table><h3 id="次数匹配-🍡"><a href="#次数匹配-🍡" class="headerlink" title="次数匹配  🍡"></a>次数匹配  🍡</h3><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>*</td><td>匹配*号前的字符0次或多次，re.findall(“ab*”,”cabb3abcbbac”)  结果为[‘abb’, ‘ab’, ‘a’]</td></tr><tr><td>+</td><td>匹配前一个字符1次或多次，re.findall(“ab+”,”ab+cd+abb+bba”) 结果[‘ab’, ‘abb’]</td></tr><tr><td>?</td><td>匹配前一个字符0次或者1次</td></tr><tr><td>{m}</td><td>匹配前一个字符m次</td></tr><tr><td>{n,m}</td><td>匹配前一个字符n到m次，re.findall(“ab{1,3}”,”abb abc abbcbbb”) 结果’abb’, ‘ab’, ‘abb’]</td></tr><tr><td>*?/+?/??</td><td>转为非贪婪模式（尽可能少的匹配）</td></tr><tr><td>[…]</td><td>字符集，匹配字符集中任意字符，字符集可给出范围或者逐个列出</td></tr></tbody></table><h3 id="边界匹配-🍡"><a href="#边界匹配-🍡" class="headerlink" title="边界匹配  🍡"></a>边界匹配  🍡</h3><table><thead><tr><th>字符</th><th>描述</th></tr></thead><tbody><tr><td>^</td><td>匹配字符串开头，若指定flags MULTILINE，这种也可以匹配上，(r’^a’,’\nabc\neee’,flags=re.MULTILINE)</td></tr><tr><td>$</td><td>匹配字符结尾，或e.search(“foo$”,”bfoo\nsdfsf”,flags=re.MULTILINE).group()也可以</td></tr><tr><td>\A</td><td>只从字符开头匹配，re.search(“\Aabc”,”alexabc”) 是匹配不到的</td></tr><tr><td>\Z</td><td>匹配字符结尾，同$</td></tr></tbody></table><h3 id="分组匹配-🍡"><a href="#分组匹配-🍡" class="headerlink" title="分组匹配  🍡"></a>分组匹配  🍡</h3><table><thead><tr><th style="text-align:left">字符</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">丨</td><td style="text-align:left">匹配丨左或丨右的字符，re.search(“abc丨ABC”,”ABCBabcCD”).group() 结果’ABC’</td></tr><tr><td style="text-align:left">(…)</td><td style="text-align:left">分组匹配，re.search(“(abc){2}a(123丨456)c”, “abcabca456c”).group() 结果 abcabca456c</td></tr><tr><td style="text-align:left">(?P\&lt;..&gt;)</td><td style="text-align:left">命名分组匹配 re.search(“(?P\<province>[0-9]{4})(?P\<city>[0-9]{2})(?P\<birthday>[0-9]{4})”,”371481199306143242”).groupdict(“city”) 结果{‘province’: ‘3714’, ‘city’: ‘81’, ‘birthday’: ‘1993’}</birthday></city></province></td></tr></tbody></table><h2 id="分组匹配-🍀"><a href="#分组匹配-🍀" class="headerlink" title="分组匹配 🍀"></a>分组匹配 🍀</h2><p>分组就是用一对圆括号“()”括起来的正则表达式，匹配出的内容就表示一个分组.用match方法 可以匹配一个分组,然后用group()来取出分组匹配到的内容.<br>分组匹配类似于shell里的sed分组()匹配.</p><p>注意:<br>1.正则表达式有一个隐含的全局分组0<br>2.match方法是从字符串起始位置开始匹配.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#例子1:</span><br><span class="line"></span><br><span class="line">str1 = &apos;010-12345&apos;</span><br><span class="line">r = re.compile(&apos;(\d&#123;3&#125;)-(\d&#123;5&#125;)&apos;)</span><br><span class="line">res = re.match(r,str1)</span><br><span class="line"></span><br><span class="line">print(res.group(0))  #打印全局匹配到的字符串</span><br><span class="line">print(res.group(1))  #打印第一个分组(\d&#123;3&#125;)匹配到的字符串</span><br><span class="line">print(res.group(2))  #打印第二个分组(\d&#123;5&#125;)匹配到的字符串</span><br><span class="line">print(res.groups())  #元祖形式返回分组1和2</span><br><span class="line"></span><br><span class="line">#例子2</span><br><span class="line">str3 = &apos;&lt;script src=&quot;https://ss1.bdstatic.com/&quot;&apos;</span><br><span class="line"></span><br><span class="line">#这里采用分组匹配,匹配到的是https://ss1.bdstatic.com/ URL地址</span><br><span class="line">print(re.findall(&apos;src=(&quot;.*?&quot;)&apos;,str3))</span><br><span class="line">res = re.match(&apos;&lt;script src=(&quot;.*?&quot;)&apos;,str3) #注意match方法是从起始位置开始匹配.所以直接写src=(&quot;.*?&quot;)是匹配不到的</span><br><span class="line">print(res.group(1))</span><br></pre></td></tr></table></figure><h2 id=""><a href="#" class="headerlink" title=""></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">匹配丨左或丨右的字符.</span><br></pre></td></tr></table></figure></h2><p>str1 = “company companies compan comp companiessss”<br>print(re.findall(“company|companies”,str1))</p><blockquote><blockquote><blockquote><p>[‘company’, ‘companies’, ‘companies’]</p></blockquote></blockquote></blockquote><p>#上面写的有点low.如果换个写法<br>print(re.findall(“compan(y|ies)”,str1))</p><p>#打印结果如下: 正则表达式将()作为了一个分组来匹配y和ies.而不是将compan(y|ies)作为一个整体</p><blockquote><blockquote><blockquote><p>[‘y’, ‘ies’, ‘ies’]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用```?:```的写法解决上面的问题</span><br></pre></td></tr></table></figure></p></blockquote></blockquote></blockquote><p>print(re.findall(“compan(?:y|ies)”,str1))</p><blockquote><blockquote><blockquote><p>[‘company’, ‘companies’, ‘companies’]<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## 贪婪和非贪婪匹配 🍀</span><br><span class="line"></span><br><span class="line">* 贪婪模式: 默认的匹配方式,意思是尽可能多的匹配字符</span><br></pre></td></tr></table></figure></p></blockquote></blockquote></blockquote><p>s = “this is a number 234-235-22-423”</p><p>r = re.match(“.+(\d+-\d+-\d+-\d+)”,s)<br>print(r.group(1))</p><blockquote><blockquote><blockquote><p>4-235-22-423<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">在上面这个例子中,前面的```.+``` 尽可能长的匹配,所以开头一直匹配到了&quot;this is a number 23&quot;. \d+ 只匹配到了最后一个数字4.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">* 非贪婪模式: 总是尝试匹配尽可能少的字符。在&quot;*&quot;,&quot;?&quot;,&quot;+&quot;,&quot;&#123;m,n&#125;&quot;后面加上？，使贪婪变成非贪婪。此时的```?```不再表示匹配前一个字符0次或者多次的意思,而是作为限制符.意思就是只要匹配到,就取出</span><br></pre></td></tr></table></figure></p></blockquote></blockquote></blockquote><p>s = “this is a number 234-235-22-423”</p><p>r = re.match(“.+?(\d+-\d+-\d+-\d+)”,s)<br>print(r.group(1))</p><blockquote><blockquote><blockquote><p>234-235-22-423<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">在上面这个例子中,```.+```只匹配到&apos;&apos;&apos;this is a number&apos;&apos;&apos;.234数字被\d+匹配到了</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 匹配方法补充  🍀</span><br><span class="line"></span><br><span class="line">补充方法</span><br><span class="line"></span><br><span class="line">&gt; `re.subn`(pattern, repl, string, count=0, flags=0) :  </span><br><span class="line"></span><br><span class="line">返回替换后的字符串和替换次数</span><br><span class="line"></span><br><span class="line">&gt; `re.escape`(pattern) :                                </span><br><span class="line"></span><br><span class="line">自动进行转义，除了ASCII字母、数字和&apos;_&apos;之外</span><br><span class="line"></span><br><span class="line">&gt; `re.compile`(pattern, flags=0) :                      </span><br><span class="line"></span><br><span class="line">生成一个_sre.SRE_Pattern对象，以便多次调用</span><br><span class="line"></span><br><span class="line">&gt; `re.finditer`(pattern, string, flags=0) :             </span><br><span class="line"></span><br><span class="line">返回一个匹配结果的迭代器，可迭代取值</span><br><span class="line"></span><br><span class="line">&gt; `re.fullmatch`(pattern, string, flags=0) :            </span><br><span class="line"></span><br><span class="line">完整匹配，不完整则返回None</span><br><span class="line"></span><br><span class="line">&gt; `re.template`(pattern, flags=0) :                     </span><br><span class="line"></span><br><span class="line">没人知道是干嘛的，跟compile差不多</span><br><span class="line"></span><br><span class="line">&gt; `re.purge()` :                              </span><br><span class="line"></span><br><span class="line">清除正则表达式缓存</span><br><span class="line"></span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">当你在程序中使用 re 模块，无论是先使用 compile 还是直接使用比如 findall 来使用正则表达式操作文本，re 模块都会将正则表达式先编译一下， 并且会将编译过后的正则表达式放到缓存中，这样下次使用同样的正则表达式的时候就不需要再次编译， 因为编译其实是很费时的，这样可以提升效率，而默认缓存的正则表达式的个数是 100, 当你需要频繁使用少量正则表达式的时候，缓存可以提升效率，而使用的正则表达式过多时，缓存带来的优势就不明显了</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">## 正则实例  🍀</span><br></pre></td></tr></table></figure></p></blockquote></blockquote></blockquote><p>str1 = “a1b atb aTb a3b a1b a-b a%b a!b a9b aYb a&amp;b”</p><p>#取出中间为特殊字符<br>print(re.findall(‘a[%!-&amp;]b’,str1))</p><p>#取出中间为数字的<br>print(re.findall(‘a[0-9]b’,str1))<br>print(re.findall(‘a[\d]b’,str1))</p><p>#取出中间为小数字母的<br>print(re.findall(‘a[a-z]b’,str1))</p><p>#取出中间为大写字母的的<br>print(re.findall(‘a[A-Z]b’,str1))</p><p>#取出字母或者数字的<br>print(re.findall(‘a[\w]b’,str1))</p><p>#取出中间不为数字的<br>print(re.findall(‘a[\D]b’,str1))<br>print(re.findall(‘a[^0-9]b’,str1))<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line">连续匹配</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"># 导入模块</span><br><span class="line">&gt;&gt;&gt; import re</span><br><span class="line"># 获取字符串</span><br><span class="line">&gt;&gt;&gt; source =&apos;192.168.0.1 25/Oct/2012:14:46:34 &quot;GET /api HTTP/1.1&quot; 200 44 &quot;http://abc.com/search&quot; &quot;Mozilla/5.0&quot;&apos;</span><br><span class="line"># 设置匹配格式</span><br><span class="line">&gt;&gt;&gt; res = re.match(&apos;^(?P&lt;remote_ip&gt;[^ ]*) (?P&lt;date&gt;[^ ]*) &quot;(?P&lt;request&gt;[^&quot;]*)&quot; (?P&lt;status&gt;[^ ]*) (?P&lt;size&gt;[^ ]*) &quot;(?P&lt;referrer&gt;[^&quot;]*)&quot; &quot;(?P&lt;user_agent&gt;[^&quot;]*)&quot;&apos;,source)</span><br><span class="line"># 返回一个字典，groupdict中的key为组名，value为值</span><br><span class="line">&gt;&gt;&gt; source_dic = res.groupdict()</span><br><span class="line"># for循环打印</span><br><span class="line">&gt;&gt;&gt; for k in source_dic:</span><br><span class="line">        #打印key和vaule</span><br><span class="line">...     print(k+&quot;: &quot;+source_dic[k])</span><br><span class="line">...</span><br><span class="line"># 打印结果</span><br><span class="line">date: 25/Oct/2012:14:46:34</span><br><span class="line">remote_ip: 192.168.0.1</span><br><span class="line">referrer: http://abc.com/search</span><br><span class="line">status: 200</span><br><span class="line">user_agent: Mozilla/5.0</span><br><span class="line">size: 44</span><br><span class="line">request: GET /api HTTP/1.1</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-正则表达式&quot;&gt;&lt;a href=&quot;#Python之路-正则表达式&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 正则表达式&quot;&gt;&lt;/a&gt;Python之路 - 正则表达式&lt;/h1&gt;&lt;h2 id=&quot;正则介绍-🍀&quot;&gt;&lt;a href=&quot;#正则介绍-🍀&quot; class=&quot;headerlink&quot; title=&quot;正则介绍  🍀&quot;&gt;&lt;/a&gt;正则介绍  🍀&lt;/h2&gt;&lt;p&gt;正则表达式并不是python的一部分，而是在各个编程语言都有的一种用于处理字符串的强大工具。&lt;/p&gt;
&lt;p&gt;使用正则处理字符串在效率上可能不如str自带的方法，但是它的功能十分强大。python中的正则封装在re模块中。&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Modules" scheme="https://jesse.top/categories/python/Modules/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>20.Python之路 - 时间和日期模块</title>
    <link href="https://jesse.top/2020/06/26/python/03-Modules/04-Python%E4%B9%8B%E8%B7%AF%20-%20%E6%97%B6%E9%97%B4%E5%92%8C%E6%97%A5%E6%9C%9F%E6%A8%A1%E5%9D%97/"/>
    <id>https://jesse.top/2020/06/26/python/03-Modules/04-Python之路 - 时间和日期模块/</id>
    <published>2020-06-26T01:20:58.000Z</published>
    <updated>2020-06-26T02:03:46.192Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-时间和日期模块"><a href="#Python之路-时间和日期模块" class="headerlink" title="Python之路 - 时间和日期模块"></a>Python之路 - 时间和日期模块</h1><h2 id="介绍-🍀"><a href="#介绍-🍀" class="headerlink" title="介绍  🍀"></a>介绍  🍀</h2><p>python提供了 time , datetimme 和 calendar 模块可以用于格式化如期和时间 ; 时间间隔是以秒为单位的浮点数 , 每个时间戳都以自从1970年1月1日午夜（历元）经过了多长时间来表示 , 所以1970年之前的日期就不能用时间戳来表示了 , 时间戳是最适合用来做日期运算的</p><p>python中时间的三种类型 : </p><ol><li>float   浮点数 , 即时间戳</li><li>struct tuple   时间元组</li><li>str    字符串 , 规定格式表示</li></ol><a id="more"></a><h2 id="time-🍀"><a href="#time-🍀" class="headerlink" title="time  🍀"></a>time  🍀</h2><h3 id="内置函数-🍀"><a href="#内置函数-🍀" class="headerlink" title="内置函数  🍀"></a>内置函数  🍀</h3><table><thead><tr><th>函数名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td>time.time()</td><td style="text-align:left">返回当前时间的时间戳(1970纪元后经过的浮点秒数)</td></tr><tr><td>time.localtime([secs])</td><td style="text-align:left">返回一个时间元组 , 默认返回当前时间戳的时间元组 , secs为秒数</td></tr><tr><td>time.sleep(secs)</td><td style="text-align:left">推迟调用线程的运行 , 即让程序’ 睡 ‘一会 , secs为秒数</td></tr><tr><td>time.strftime(fmt[,tupletime])</td><td style="text-align:left">将时间元组转换成字符串显示 , 默认为当前时间 , 格式由fmt决定</td></tr><tr><td>time.strptime(str,fmt=’%a %b %d %H:%M:%S %Y)</td><td style="text-align:left">将字符串转换成时间元组 , fmt为字符串格式</td></tr><tr><td>time.gmtime([secs])</td><td style="text-align:left">将时间戳转换成格林威治(本初子午线)天文时间下的时间元组</td></tr><tr><td>time.asctime([tupletime])</td><td style="text-align:left">将时间元组转换成字符串 , 格式如下 : Tue Aug  8 15:19:00 2016</td></tr><tr><td>time.ctime([secs])</td><td style="text-align:left">相当于asctime(localtime(secs)) , 不给参数相当于asctime()</td></tr><tr><td>time.mktime(tupletime)</td><td style="text-align:left">将时间元组转换成时间戳</td></tr><tr><td>time.clock()</td><td style="text-align:left">返回当前CPU时间戳 , 用来衡量不同程序的耗时 , 比time.time() 更有用</td></tr><tr><td>time.tzset()</td><td style="text-align:left">更改本地时区</td></tr><tr><td>time.altzone</td><td style="text-align:left">返回夏令时地区的偏移秒数 , 无需括号调用 ,   对需要夏令时地区才使用</td></tr></tbody></table><h3 id="格式化符号-🍀"><a href="#格式化符号-🍀" class="headerlink" title="格式化符号  🍀"></a>格式化符号  🍀</h3><table><thead><tr><th>符号</th><th>描述</th><th>符号</th><th>描述</th></tr></thead><tbody><tr><td>%y</td><td>两位数的年份表示 (00-99)</td><td>%a</td><td>本地简化星期名称</td></tr><tr><td>%Y</td><td>四位数的年份表示(000-9999)</td><td>%A</td><td>本地完整星期名称</td></tr><tr><td>%m</td><td>月份(01-12)</td><td>%b</td><td>本地简化的月份名称</td></tr><tr><td>%d</td><td>月内中的一天(0-31)</td><td>%B</td><td>本地完整的月份名称</td></tr><tr><td>%H</td><td>24小时制小时数(0-23)</td><td>%c</td><td>本地相应的日期表示和时间表示</td></tr><tr><td>%I</td><td>12小时制小时数(01-12)</td><td>%j</td><td>年内的一天(001-366)</td></tr><tr><td>%M</td><td>分钟数(00=59)</td><td>%p</td><td>本地A.M.或P.M.的等价符</td></tr><tr><td>%S</td><td>秒(00-59)</td><td>%U</td><td>一年中的星期数(00-53)星期天为星期的开始</td></tr><tr><td>%w</td><td>星期(0-6)，星期天为星期的开始</td><td>%x</td><td>本地相应的日期表示</td></tr><tr><td>%W</td><td>一年中的星期数(00-53)星期一为星期的开始</td><td>%X</td><td>本地相应的时间表示</td></tr><tr><td>%%</td><td>%号本身</td><td>%Z</td><td>当前时区的名称</td></tr></tbody></table><h3 id="时间元组说明-🍀"><a href="#时间元组说明-🍀" class="headerlink" title="时间元组说明  🍀"></a>时间元组说明  🍀</h3><table><thead><tr><th>下标</th><th>属性</th><th>值</th></tr></thead><tbody><tr><td>0</td><td>tm_year</td><td>2008</td></tr><tr><td>1</td><td>tm_mon</td><td>1 到 12</td></tr><tr><td>2</td><td>tm_mday</td><td>1 到 31</td></tr><tr><td>3</td><td>tm_hour</td><td>0 到 23</td></tr><tr><td>4</td><td>tm_min</td><td>0 到 59</td></tr><tr><td>5</td><td>tm_sec</td><td>0 到 61 (60或61 是闰秒)</td></tr><tr><td>6</td><td>tm_wday</td><td>0到6 (0是周一)</td></tr><tr><td>7</td><td>tm_yday</td><td>1 到 366(儒略历)</td></tr><tr><td>8</td><td>tm_isdst</td><td>-1, 0, 1, -1是决定是否为夏令时的旗帜</td></tr></tbody></table><h3 id="实例-🍀"><a href="#实例-🍀" class="headerlink" title="实例  🍀"></a>实例  🍀</h3><p>获取本地时间</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入time模块</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="comment"># 获取当前时间字符串</span></span><br><span class="line">now_time = time.strftime(<span class="string">"%Y-%m-%d %H:%M:%S"</span>)</span><br><span class="line"><span class="comment"># 获取当前时间戳</span></span><br><span class="line">now_timestamp = time.time()</span><br><span class="line"><span class="comment"># 获取当前时间元组</span></span><br><span class="line">now_timetuples = time.localtime()</span><br><span class="line"><span class="comment"># 打印当前时间字符串</span></span><br><span class="line">print(now_time)</span><br><span class="line"><span class="comment"># 2016-08-08 16:04:35</span></span><br><span class="line"><span class="comment"># 打印当前时间戳</span></span><br><span class="line">print(now_timestamp)</span><br><span class="line"><span class="comment"># 1470643278.0</span></span><br><span class="line"><span class="comment"># 打印当前时间元组</span></span><br><span class="line">print(now_timetuples)</span><br><span class="line"><span class="comment"># time.struct_time(tm_year=2016, tm_mon=8, tm_mday=8, tm_hour=16, tm_min=1, tm_sec=18, tm_wday=0, tm_yday=221, tm_isdst=-1)</span></span><br></pre></td></tr></table></figure><hr><p>几种格式时间的转换</p><p><img src="https://images2015.cnblogs.com/blog/827651/201707/827651-20170724144151992-1508626640.png" alt=""></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># 格式化时间 ----&gt;  结构化时间</span><br><span class="line">ft = time.strftime(&apos;%Y/%m/%d %H:%M:%S&apos;)</span><br><span class="line">st = time.strptime(ft,&apos;%Y/%m/%d %H:%M:%S&apos;)</span><br><span class="line">print(st)</span><br><span class="line"># 结构化时间 ---&gt; 时间戳</span><br><span class="line">t = time.mktime(st)</span><br><span class="line">print(t)</span><br><span class="line"></span><br><span class="line"># 时间戳 ----&gt; 结构化时间</span><br><span class="line">t = time.time()</span><br><span class="line">st = time.localtime(t)</span><br><span class="line">print(st)</span><br><span class="line"># 结构化时间 ---&gt; 格式化时间</span><br><span class="line">ft = time.strftime(&apos;%Y/%m/%d %H:%M:%S&apos;,st)</span><br><span class="line">print(ft)</span><br></pre></td></tr></table></figure><p>计算时间差</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">true_time=time.mktime(time.strptime(&apos;2017-09-11 08:30:00&apos;,&apos;%Y-%m-%d %H:%M:%S&apos;))</span><br><span class="line">time_now=time.mktime(time.strptime(&apos;2017-09-12 11:00:00&apos;,&apos;%Y-%m-%d %H:%M:%S&apos;))</span><br><span class="line">dif_time=time_now-true_time</span><br><span class="line">struct_time=time.gmtime(dif_time)</span><br><span class="line">print(&apos;过去了%d年%d月%d天%d小时%d分钟%d秒&apos;%(struct_time.tm_year-1970,struct_time.tm_mon-1,</span><br><span class="line">                                       struct_time.tm_mday-1,struct_time.tm_hour,</span><br><span class="line">                                       struct_time.tm_min,struct_time.tm_sec))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 过去了0年0月1天2小时30分钟0秒</span><br></pre></td></tr></table></figure><h2 id="calendar-🍀"><a href="#calendar-🍀" class="headerlink" title="calendar 🍀"></a>calendar 🍀</h2><p>此模块的函数都是日历相关的 , 例如打印某月的字符串月历</p><p>星期一是默认的每周第一天 , 星期天是默认的最后一天 ; 更改设置需要调用 calendar.setfirstweekday() 函数</p><h3 id="内置函数-🍀-1"><a href="#内置函数-🍀-1" class="headerlink" title="内置函数  🍀"></a>内置函数  🍀</h3><table><thead><tr><th>函数</th><th>描述</th></tr></thead><tbody><tr><td>calendar.calendar(year,w=2,l=1,c=6)</td><td>返回一个多行字符串格式的year年年历 , 3个月一行 , 间隔距离为c ; 每日宽度间隔为w字符 , 每行长度为21<em> W+18+2</em> C ; l是每星期行数</td></tr><tr><td>calendar.firstweekday( )</td><td>返回当前每周起始日期的设置 ; 默认情况下 , 首次载入caendar模块时返回0 , 即星期一</td></tr><tr><td>calendar.isleap(year)</td><td>是闰年返回True , 否则为false</td></tr><tr><td>calendar.leapdays(y1,y2)</td><td>返回在Y1 , Y2两年之间的闰年总数</td></tr><tr><td>calendar.month(year,month,w=2,l=1)</td><td>返回一个多行字符串格式的year年month月日历 , 两行标题 , 一周一行 ; 每日宽度间隔为w字符 , 每行的长度为7* w+6 , l是每星期的行数</td></tr><tr><td>calendar.monthcalendar(year,month)</td><td>返回一个整数的单层嵌套列表 , 每个子列表装载代表一个星期的整数 ; Year年month月外的日期都设为0 ; 范围内的日子都由该月第几日表示 , 从1开始</td></tr><tr><td>calendar.monthrange(year,month)</td><td>返回两个整数 , 第一个是该月的星期几的日期码 , 第二个是该月的日期码 , 日从0（星期一）到6（星期日）; 月从1到12</td></tr><tr><td>calendar.prcal(year,w=2,l=1,c=6)</td><td>相当于 print calendar.calendar(year , w , l , c)</td></tr><tr><td>calendar.prmonth(year,month,w=2,l=1)</td><td>相当于 print calendar.calendar（year , w , l , c）</td></tr><tr><td>calendar.setfirstweekday(weekday)</td><td>设置每周的起始日期码 , 0（星期一）到6（星期日）</td></tr><tr><td>calendar.timegm(tupletime)</td><td>和time.gmtime相反: 接受一个时间元组形式 , 返回该时刻的时间辍（1970纪元后经过的浮点秒数）</td></tr><tr><td>calendar.weekday(year,month,day)</td><td>返回给定日期的日期码 , 0（星期一）到6（星期日） , 月份为 1（一月） 到 12（12月）</td></tr></tbody></table><h3 id="实例-🍀-1"><a href="#实例-🍀-1" class="headerlink" title="实例  🍀"></a>实例  🍀</h3><p>打印指定日历</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="keyword">import</span> calendar</span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">cal = calendar.month(<span class="number">2016</span>,<span class="number">8</span>)</span><br><span class="line"><span class="comment"># 打印2016年8月的日历</span></span><br><span class="line">print(cal)</span><br><span class="line">------结果如下-------</span><br><span class="line">    August <span class="number">2016</span></span><br><span class="line">Mo Tu We Th Fr Sa Su</span><br><span class="line"> <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span></span><br><span class="line"> <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span> <span class="number">12</span> <span class="number">13</span> <span class="number">14</span></span><br><span class="line"><span class="number">15</span> <span class="number">16</span> <span class="number">17</span> <span class="number">18</span> <span class="number">19</span> <span class="number">20</span> <span class="number">21</span></span><br><span class="line"><span class="number">22</span> <span class="number">23</span> <span class="number">24</span> <span class="number">25</span> <span class="number">26</span> <span class="number">27</span> <span class="number">28</span></span><br><span class="line"><span class="number">29</span> <span class="number">30</span> <span class="number">31</span></span><br></pre></td></tr></table></figure><p>python中处理日期和时间的模块还有 pytz , datedutil , datetime</p><p>可以通过import module ; help(module) 来进行学习</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-时间和日期模块&quot;&gt;&lt;a href=&quot;#Python之路-时间和日期模块&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 时间和日期模块&quot;&gt;&lt;/a&gt;Python之路 - 时间和日期模块&lt;/h1&gt;&lt;h2 id=&quot;介绍-🍀&quot;&gt;&lt;a href=&quot;#介绍-🍀&quot; class=&quot;headerlink&quot; title=&quot;介绍  🍀&quot;&gt;&lt;/a&gt;介绍  🍀&lt;/h2&gt;&lt;p&gt;python提供了 time , datetimme 和 calendar 模块可以用于格式化如期和时间 ; 时间间隔是以秒为单位的浮点数 , 每个时间戳都以自从1970年1月1日午夜（历元）经过了多长时间来表示 , 所以1970年之前的日期就不能用时间戳来表示了 , 时间戳是最适合用来做日期运算的&lt;/p&gt;
&lt;p&gt;python中时间的三种类型 : &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;float   浮点数 , 即时间戳&lt;/li&gt;
&lt;li&gt;struct tuple   时间元组&lt;/li&gt;
&lt;li&gt;str    字符串 , 规定格式表示&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Modules" scheme="https://jesse.top/categories/python/Modules/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
</feed>
