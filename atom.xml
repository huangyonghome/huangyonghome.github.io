<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Jesse&#39;s home</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://jesse.top/"/>
  <updated>2020-06-07T09:19:28.136Z</updated>
  <id>https://jesse.top/</id>
  
  <author>
    <name>Jesse</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>16.Python之路 - Python递归函数</title>
    <link href="https://jesse.top/2020/06/07/python/02-Advanced/06-Python%E4%B9%8B%E8%B7%AF%20-%20%E9%80%92%E5%BD%92/"/>
    <id>https://jesse.top/2020/06/07/python/02-Advanced/06-Python之路 - 递归/</id>
    <published>2020-06-07T09:20:58.000Z</published>
    <updated>2020-06-07T09:19:28.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-递归"><a href="#Python之路-递归" class="headerlink" title="Python之路 - 递归"></a>Python之路 - 递归</h1><h2 id="递归算法-🍀"><a href="#递归算法-🍀" class="headerlink" title="递归算法 🍀"></a>递归算法 🍀</h2><p>递归算法是一种直接或者间接地调用自身算法的过程（递归函数就是一个体现）。在计算机编写程序中，递归算法对解决一大类问题是十分有效的，它往往使算法的描述简介而且易于理解。</p><p>特点：👈</p><ol><li>递归就是再过程或函数里调用自身</li><li>再使用递归策略时，必须有一个明确的递归结束条件，称为递归出口。递归算法解题通常显得很简洁，但递归算法解题的运行效率低</li><li>在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。所以一般不提倡用递归算法设计程序</li></ol><p>要求：👈</p><ol><li>每次调用在问题规模上都有所减少（通常是减半）</li><li>相邻两次重复之间有紧密的联系，前一次要为后一次做准备（通常前一次的输出就作为后一次的输入）</li><li>再问题的规模极小时必须要直接给出解答而不再进行递归调用，因而每次递归调用都是有条件的（以规模未达到直接解答的大小为条件），无条件递归条用将会称为死循环而不能正常结束</li></ol><a id="more"></a><h2 id="递归函数-🍀"><a href="#递归函数-🍀" class="headerlink" title="递归函数 🍀"></a>递归函数 🍀</h2><p>面向函数编程中，利用递归思想来解决一些简单的问题是非常简单便洁的</p><p>递归函数就是函数内部通过调用自己本身来实现功能的函数。既然是调用自身,那么每次调用，需要解决的问题就应该有所减少，不然这个函数就没有尽头的执行下去。</p><p>打印10-0</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">counter</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="comment"># 打印num</span></span><br><span class="line">    print(num)</span><br><span class="line">    <span class="comment"># 如果num小于等于0</span></span><br><span class="line">    <span class="keyword">if</span> num &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># 返回num</span></span><br><span class="line">        <span class="keyword">return</span> num</span><br><span class="line">    <span class="comment"># 必须相对上一次有所减少</span></span><br><span class="line">    num -= <span class="number">1</span></span><br><span class="line">    <span class="comment"># 反复调用，直到return将函数停止运行</span></span><br><span class="line">    counter(num)</span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">counter(<span class="number">10</span>)</span><br></pre></td></tr></table></figure><h2 id="递归应用-🍀"><a href="#递归应用-🍀" class="headerlink" title="递归应用  🍀"></a>递归应用  🍀</h2><p>用递归实现斐波那契数列</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">l = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n1,n2)</span>:</span></span><br><span class="line">    <span class="comment"># 大于1000后结束递归</span></span><br><span class="line">    <span class="keyword">if</span> n1 &gt; <span class="number">2000</span>:</span><br><span class="line">        <span class="comment"># 终止函数，并返回 "不搞了"</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"不搞了！"</span></span><br><span class="line">    <span class="comment"># 追加进列表</span></span><br><span class="line">    l.append(n1)</span><br><span class="line">    <span class="comment"># 前两个数之和</span></span><br><span class="line">    n3 = n1 + n2</span><br><span class="line">    <span class="comment"># 进行递归</span></span><br><span class="line">    fibonacci(n2, n3)</span><br><span class="line"><span class="comment"># 从0开始</span></span><br><span class="line">fibonacci(<span class="number">0</span>, <span class="number">1</span>)</span><br><span class="line">print(l)</span><br></pre></td></tr></table></figure><p>用递归实现三级菜单</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">menu = &#123;</span><br><span class="line">    <span class="string">'北京'</span>: &#123;</span><br><span class="line">        <span class="string">'海淀'</span>: &#123;</span><br><span class="line">            <span class="string">'五道口'</span>: &#123;</span><br><span class="line">                <span class="string">'soho'</span>: &#123;&#125;,</span><br><span class="line">                <span class="string">'网易'</span>: &#123;&#125;,</span><br><span class="line">                <span class="string">'google'</span>: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">'中关村'</span>: &#123;</span><br><span class="line">                <span class="string">'爱奇艺'</span>: &#123;&#125;,</span><br><span class="line">                <span class="string">'汽车之家'</span>: &#123;&#125;,</span><br><span class="line">                <span class="string">'youku'</span>: &#123;&#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">'上地'</span>: &#123;</span><br><span class="line">                <span class="string">'百度'</span>: &#123;&#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'昌平'</span>: &#123;</span><br><span class="line">            <span class="string">'沙河'</span>: &#123;</span><br><span class="line">                <span class="string">'老男孩'</span>: &#123;&#125;,</span><br><span class="line">                <span class="string">'北航'</span>: &#123;&#125;,</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">'天通苑'</span>: &#123;&#125;,</span><br><span class="line">            <span class="string">'回龙观'</span>: &#123;&#125;,</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'朝阳'</span>: &#123;&#125;,</span><br><span class="line">        <span class="string">'东城'</span>: &#123;&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'上海'</span>: &#123;</span><br><span class="line">        <span class="string">'闵行'</span>: &#123;</span><br><span class="line">            <span class="string">"人民广场"</span>: &#123;</span><br><span class="line">                <span class="string">'炸鸡店'</span>: &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'闸北'</span>: &#123;</span><br><span class="line">            <span class="string">'火车战'</span>: &#123;</span><br><span class="line">                <span class="string">'携程'</span>: &#123;&#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'浦东'</span>: &#123;&#125;,</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'山东'</span>: &#123;&#125;,</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">threeLM</span><span class="params">(menu)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># 打印本级菜单内容</span></span><br><span class="line">        <span class="keyword">for</span> key <span class="keyword">in</span> menu:</span><br><span class="line">            <span class="comment"># 打印字典的key</span></span><br><span class="line">            print(key)</span><br><span class="line">        <span class="comment"># 用户输入内容</span></span><br><span class="line">        chooice = input(<span class="string">"请输入菜单&gt;&gt;"</span>)</span><br><span class="line">        <span class="keyword">if</span> chooice == <span class="string">'back'</span>:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">elif</span> chooice == <span class="string">'quit'</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">'q'</span></span><br><span class="line">        <span class="keyword">if</span> chooice <span class="keyword">in</span> menu.keys():</span><br><span class="line">            <span class="comment"># 将新字典作为参数进行递归调用</span></span><br><span class="line">            ret = threeLM(menu[chooice])</span><br><span class="line">            <span class="keyword">if</span> ret == <span class="string">'q'</span>:<span class="keyword">return</span> <span class="string">'q'</span></span><br><span class="line">threeLM(menu)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-递归&quot;&gt;&lt;a href=&quot;#Python之路-递归&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 递归&quot;&gt;&lt;/a&gt;Python之路 - 递归&lt;/h1&gt;&lt;h2 id=&quot;递归算法-🍀&quot;&gt;&lt;a href=&quot;#递归算法-🍀&quot; class=&quot;headerlink&quot; title=&quot;递归算法 🍀&quot;&gt;&lt;/a&gt;递归算法 🍀&lt;/h2&gt;&lt;p&gt;递归算法是一种直接或者间接地调用自身算法的过程（递归函数就是一个体现）。在计算机编写程序中，递归算法对解决一大类问题是十分有效的，它往往使算法的描述简介而且易于理解。&lt;/p&gt;
&lt;p&gt;特点：👈&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;递归就是再过程或函数里调用自身&lt;/li&gt;
&lt;li&gt;再使用递归策略时，必须有一个明确的递归结束条件，称为递归出口。递归算法解题通常显得很简洁，但递归算法解题的运行效率低&lt;/li&gt;
&lt;li&gt;在递归调用的过程当中系统为每一层的返回点、局部量等开辟了栈来存储。递归次数过多容易造成栈溢出等。所以一般不提倡用递归算法设计程序&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;要求：👈&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;每次调用在问题规模上都有所减少（通常是减半）&lt;/li&gt;
&lt;li&gt;相邻两次重复之间有紧密的联系，前一次要为后一次做准备（通常前一次的输出就作为后一次的输入）&lt;/li&gt;
&lt;li&gt;再问题的规模极小时必须要直接给出解答而不再进行递归调用，因而每次递归调用都是有条件的（以规模未达到直接解答的大小为条件），无条件递归条用将会称为死循环而不能正常结束&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Advanced" scheme="https://jesse.top/categories/python/Advanced/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>11.Python之路 - Python函数</title>
    <link href="https://jesse.top/2020/06/07/python/02-Advanced/01-Python%E4%B9%8B%E8%B7%AF%20-%20%E5%87%BD%E6%95%B0/"/>
    <id>https://jesse.top/2020/06/07/python/02-Advanced/01-Python之路 - 函数/</id>
    <published>2020-06-07T09:20:58.000Z</published>
    <updated>2020-06-07T09:19:36.616Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-函数"><a href="#Python之路-函数" class="headerlink" title="Python之路 - 函数"></a>Python之路 - 函数</h1><h2 id="介绍-🍀"><a href="#介绍-🍀" class="headerlink" title="介绍  🍀"></a>介绍  🍀</h2><p>函数是组织好的 , 可重复使用的 , 用来实现单一 , 或相关联功能的代码段</p><p>函数能提高应用的模块性 , 和代码的重复利用率 , 比如我们一直使用的<code>print()</code>  , <code>input()</code>  等等 , 都是函数</p><p>如下我们写了一个用户认证程序 ; 而现在我们又需要写一个用户管理系统 , 管理系统中有很多的功能 , 比如添加用户 , 删除用户 , 查询用户 , 修改用户 ; 但是这些功能必须先通过用户认证程序才能使用 , 明显我们不可能在每一个功能前加上一段用户认证代码 , 因为这将大大增加我们的重复代码</p><p>那么为了解决这个问题我们就可以将用户认证功能封装到一个函数之中 , 而后续我们如果需要使用这个函数仅需调用即可 , 着就是函数的魅力所在 , 当然更多的还是通过下面进一步了解函数</p><h2 id="语法-🍀"><a href="#语法-🍀" class="headerlink" title="语法  🍀"></a>语法  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义函数,function_name为函数名</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">function_name</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""注释"""</span></span><br><span class="line">    </span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    功能代码块</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="comment"># 返回值,一般都具有返回值,当然也可以不设定</span></span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><a id="more"></a><p>简单实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Hello Lyon!"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">None</span></span><br></pre></td></tr></table></figure><p><strong>注意 :</strong> 上述仅为定义函数 , 函数并不会执行 , 只有当函数被调用时 , 函数内部代码才会执行</p><h2 id="函数调用-🍀"><a href="#函数调用-🍀" class="headerlink" title="函数调用  🍀"></a>函数调用  🍀</h2><p>函数调用通过<em>函数名</em>后加<code>()</code> 进行调用 , 如下 :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Hello Lyon!"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">hello()</span><br></pre></td></tr></table></figure><p>既然函数调用是通过函数名后加括号 , 在这个固定语法之中前者函数名又是什么? 如下 : </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hello</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"Hello Lyon!"</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line"><span class="comment"># 打印函数名</span></span><br><span class="line">print(hello)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">&lt;function func at 0x000001D7E3FF7F28&gt;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>我们可以发现 , 函数名打印出来的是一个内存地址 , 由此不难理解 : </p><p><strong>函数名相当于一个变量 , 而变量的值就是该函数本身所在的内存地址 ; 也就是说函数名实际上就是一个指针 , 它与函数本身存在一个映射关系</strong></p><h2 id="参数说明-🍀"><a href="#参数说明-🍀" class="headerlink" title="参数说明  🍀"></a>参数说明  🍀</h2><p><strong>形参:</strong> 变量只有在被调用时才分配内存单元 , 在调用结束时 , 即刻释放所分配的内存单元 ; 因此 , 形参只在函数内部有效 , 函数调用结束返回主调用函数后则不能再使用该形参变量</p><p><strong>实参:</strong> 可以是常量、变量、表达式、函数等 , 无论实参是何种类型的量 , 在进行函数调用时 , 它们都必须有确定的值 , 以便把这些值传送给形参 ; 因此应预先用赋值 , 输入等办法使参数获得确定值</p><p><strong>实参角度</strong></p><pre><code>1.位置参数: 位置参数要求从前至后一一对应2.关键字传参: 形参和实参的参数名要求一致,但是顺序不做要求..但是实参和形参的数量也必须要一一对应3.混合传参: 既有位置参数,又有关键字参数.但是关键字参数必须要在位置参数后面</code></pre><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义函数func</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(argument1,argument2)</span>:</span>    <span class="comment"># argument1与argument2都为形参,形式参数</span></span><br><span class="line">    print(argument1,argument2)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 调用函数func</span></span><br><span class="line">func(<span class="string">"Hello"</span>, <span class="string">"Lyon"</span>)             <span class="comment"># Hello和Lyon都是实参,实际参数</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">Hello Lyon</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p><strong>位置参数 :</strong> 即参数必须以正确的顺序传入函数 , 传入的数量必须和声明的一样 , 不一样就报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用户登录验证</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">login</span><span class="params">(username,password)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> username == <span class="string">"Lyon"</span> <span class="keyword">and</span> password == <span class="string">"123456"</span>:</span><br><span class="line">        print(<span class="string">"Login successfully!"</span>)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"Login failed!"</span>)</span><br><span class="line"><span class="comment"># 进行调用</span></span><br><span class="line">login(<span class="string">"Lyon"</span>,<span class="string">"123456"</span>)       </span><br><span class="line"><span class="comment"># 进行调用</span></span><br><span class="line">login(<span class="string">"Lyon"</span>,<span class="string">"78910JkQ"</span>)       </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">Login successfully!</span></span><br><span class="line"><span class="string">Login failed!</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h3 id="默认参数-🍀"><a href="#默认参数-🍀" class="headerlink" title="默认参数  🍀"></a>默认参数  🍀</h3><p>调用时不指定就以默认值传入 , 指定则按指定值传入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 同时定义位置参数和默认参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_userinfo</span><span class="params">(name,age,province=<span class="string">"北京"</span>)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> name,province</span><br><span class="line"><span class="comment"># 位置参数必填,默认参数可选</span></span><br><span class="line">add_userinfo(<span class="string">"Lyon"</span>,<span class="number">18</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">('Lyon', '北京')</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>注：通过默认参数，我们就算不传参数也不会报错 , 即<code>province</code> 默认为<code>&quot;北京&quot;</code> </p><h3 id="关键字参数-🍀"><a href="#关键字参数-🍀" class="headerlink" title="关键字参数  🍀"></a>关键字参数  🍀</h3><p>正常情况下 , 给函数传参数的时候要按照顺序传 , 如果不想按照顺序就可以使用关键参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_userinfo</span><span class="params">(name,age,province=<span class="string">"北京"</span>)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> name,province</span><br><span class="line">add_userinfo(<span class="string">"Lyon"</span>,province=<span class="string">"湖北"</span>,age=<span class="number">18</span>)</span><br><span class="line"><span class="comment"># 注意关键参数不用按照顺序传入,但是关键参数必须写在位置参数后面</span></span><br></pre></td></tr></table></figure><h3 id="非固定参数-混合参数-🍀"><a href="#非固定参数-混合参数-🍀" class="headerlink" title="非固定参数(混合参数)  🍀"></a>非固定参数(混合参数)  🍀</h3><p>当我们想要传入多个参数 , 但是我们又不确定的时候就可以使用非固定参数 ; 非固定参数有两个 , 一个 <code>*args (元组形式)</code>  以及 <code>**kwargs (字典形式)</code> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 设定两个非固定参数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line"><span class="comment"># 打印args,以及args的类型</span></span><br><span class="line">    print(args,type(args))</span><br><span class="line">    <span class="comment"># 打印kwargs,以及kwargs的类型</span></span><br><span class="line">    print(kwargs,type(kwargs))</span><br><span class="line"><span class="comment"># 调用</span></span><br><span class="line">main((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>),&#123;<span class="number">1</span>:<span class="number">2</span>,<span class="number">3</span>:<span class="number">4</span>&#125;)</span><br></pre></td></tr></table></figure><p>对于非固定参数 , 其主要在于<code>*</code> 号 , <code>*</code> 号的作用是进行打包与解包 :</p><ul><li><p>一个<code>*</code> 号 , 则表示打包成元组或者将元组进行解包 , 过程如下 : </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(n,*args)</span>:</span></span><br><span class="line"><span class="keyword">return</span> args</span><br><span class="line"><span class="comment"># 传递参数,第一个参数被认为是位置参数n,余后参数*号将会对其进行打包成元组,但参数形式必须符合元组规范</span></span><br><span class="line">result = main(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line">print(result)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">(2, 3, 4, 5)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">额外说明:</span></span><br><span class="line"><span class="string">传递参数时,*号将参数封装成一个元组,即元组args</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure></li><li><p>两个<code>**</code> 号 , 则表示打包成字典或者将字典进行解包 , 过程如下 : </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(**kwargs)</span>:</span></span><br><span class="line"><span class="keyword">return</span> kwargs</span><br><span class="line"><span class="comment"># 传递参数,**号将会对其进行打包成字典,但参数形式必须符合字典规范,即必须key-value</span></span><br><span class="line">result = main(n2=<span class="number">2</span>,n3=<span class="number">3</span>,n4=<span class="number">4</span>)</span><br><span class="line">print(result)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">&#123;'n4': 4, 'n2': 2, 'n3': 3&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">额外说明:</span></span><br><span class="line"><span class="string">传递参数时,**号将参数封装成一个字典,即字典kwargs</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure></li><li><p>两者的解包如下 :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 进行打包</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(*args,**kwargs)</span>:</span>      <span class="comment"># 参数状态:(1,2,3,4,5)&#123;'n1':1,'n2':2,'n3'=3&#125;</span></span><br><span class="line">    <span class="comment"># 进行解包</span></span><br><span class="line">    <span class="keyword">return</span> (*args),&#123;**kwargs&#125;  <span class="comment"># 参数状态:1,2,3,4,5,n1=1,n2=2,n3=3</span></span><br><span class="line">result = main(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,n1=<span class="number">1</span>,n2=<span class="number">2</span>,n3=<span class="number">3</span>)</span><br><span class="line">print(result)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">(1, 2, 3, 4, 5, &#123;'n2': 2, 'n3': 3, 'n1': 1&#125;)</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 解包补充</span></span><br><span class="line"><span class="string">'''只要是可迭代对象我们都可以对其进行解包,如下'''</span></span><br><span class="line">mytuple = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>)</span><br><span class="line"><span class="comment"># _为占位符,*c打包成列表</span></span><br><span class="line">a,_,b,*c,d = mytuple</span><br><span class="line">print(a)</span><br><span class="line">print(b)</span><br><span class="line">print(c)</span><br><span class="line">print(d)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">3</span></span><br><span class="line"><span class="string">[4, 5, 6]</span></span><br><span class="line"><span class="string">7</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure></li><li><p>形参中的*和** 表示聚合,将聚合后的值赋值给args和kwargs</p></li><li>实参中的*和** 表示打散,其中*表示将多个可迭代的对象拆分(l1,l2,l3),然后依次传递给形参的args.其中**表示将多个可迭代的字典拆分,然后依次传递给形参的**kwargs</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># 例子1:</span><br><span class="line"></span><br><span class="line">dic1 = &#123;&apos;name&apos;:&apos;jesse&apos;,&quot;age&quot;:22&#125;</span><br><span class="line">dic2 = &#123;&apos;job&apos;:&apos;it&apos;,&quot;company&quot;:&apos;dwd&apos;&#125;</span><br><span class="line"></span><br><span class="line">def func9(**kwargs):</span><br><span class="line">    print(kwargs) #kwargs并非将2个字典作为2个独立元素打印,而是将2个字典所有元素合并在一起打印</span><br><span class="line"></span><br><span class="line">func9(**dic1,**dic2)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; &#123;&apos;name&apos;: &apos;jesse&apos;, &apos;age&apos;: 22, &apos;job&apos;: &apos;it&apos;, &apos;company&apos;: &apos;dwd&apos;&#125;</span><br><span class="line"></span><br><span class="line"># 例子2:</span><br><span class="line">#将下列数据传入函数args参数,并且最终打印出来的是一个元祖.效果如下(1,2,3,4,11,22,33,44......555)</span><br><span class="line"></span><br><span class="line">l1 = [1,2,3,4]</span><br><span class="line">l2 = [11,22,33,44]</span><br><span class="line">l3 = (111,222,333,444,555)</span><br><span class="line"></span><br><span class="line">def func8(*args):</span><br><span class="line">    print(args)</span><br><span class="line">func8(*l1,*l2,*l3)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;(1, 2, 3, 4, 11, 22, 33, 44, 111, 222, 333, 444, 555)</span><br></pre></td></tr></table></figure><h3 id="参数顺序及组合-🍀"><a href="#参数顺序及组合-🍀" class="headerlink" title="参数顺序及组合  🍀"></a>参数顺序及组合  🍀</h3><p><strong>参数顺序</strong></p><p>在函数头部 (定义参数) :  一般参数 → 默认参数 →  非固定参数<code>*args</code> →  非固定参数<code>**kwargs</code> </p><p>在函数调用中 (传递参数) : 位置参数 → 关键字参数 →  默认参数 →  非固定参数<code>*args</code> →  非固定参数<code>**kwargs</code></p><p>顺序依次如下:位置参数,*args,关键字参数,**args</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def func9(a,b,*args,sex=&apos;male&apos;,**kwargs):</span><br><span class="line">    print(a,b)</span><br><span class="line">    print(args)</span><br><span class="line">    print(sex)</span><br><span class="line">    print(kwargs)</span><br><span class="line"></span><br><span class="line">func9(1,2,3,4,5,6,sex=&apos;female&apos;,name=&apos;jesse&apos;,age=24)</span><br><span class="line">func9(1,2,3,4,5,6,name=&apos;jesse&apos;,age=24,sex=&apos;female&apos;)</span><br></pre></td></tr></table></figure><p><strong>参数组合</strong> </p><p>在我们使用过程中 , 如果没有非固定参数 , 那么我们的关键参数或者默认参数可以用关键字进行传递 ; 如果有非固定参数 , 必须按照位置参数的方式进行传递</p><p>默认参数和非固定参数<code>*args</code>位置可以进行调换 , 调换后默认参数传递需要加上关键字</p><h2 id="全局与局部变量-🍀"><a href="#全局与局部变量-🍀" class="headerlink" title="全局与局部变量  🍀"></a>全局与局部变量  🍀</h2><p>局部变量：只在函数内部起作用的变量</p><p>全局变量：在整个程序中都起作用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局变量name</span></span><br><span class="line">name = <span class="string">"Lyon"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(name)</span><br><span class="line">    <span class="comment"># 局部变量name</span></span><br><span class="line">    name = <span class="string">"Kenneth"</span>  </span><br><span class="line">    print(name)</span><br><span class="line"><span class="comment"># 调用函数</span></span><br><span class="line">func(name)</span><br><span class="line">print(name)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">Lyon</span></span><br><span class="line"><span class="string">Kenneth</span></span><br><span class="line"><span class="string">Lyon</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>总结 : 全局变量<strong>作用域</strong>是整个程序 , 局部变量<strong>作用域</strong>是定义该变量的子程序 ; 当全局变量与局部变量同名时 : 在定义局部变量的子程序内 , 局部变量起作用 ; 在其他地方全局变量起作用</p><p><strong>global语句</strong> : 可以将局部变量变成全局变量 , 在函数内部变量前加上 global 即可如 : <code>global name</code>  </p><h2 id="return语句-🍀"><a href="#return语句-🍀" class="headerlink" title="return语句  🍀"></a>return语句  🍀</h2><p><code>return</code> 语句用于返回函数的执行结果 , 比如操作类函数一般都不需要返回值 , 当然可由我们的需要自己进行设定</p><p>不使用<code>return</code> 即返回None , 没有返回值</p><p>我们函数在执行过程中如果遇到return语句 , 就会结束并返回结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum</span><span class="params">( arg1, arg2 )</span>:</span></span><br><span class="line"><span class="comment"># 返回2个参数的和</span></span><br><span class="line">total = arg1 + arg2</span><br><span class="line">print(<span class="string">"两数之和:"</span>,total)</span><br><span class="line"><span class="keyword">return</span> total</span><br><span class="line"><span class="comment"># 上一步函数就已经结束,不会往下执行</span></span><br><span class="line">print(<span class="string">"已经返回!"</span>)</span><br><span class="line"><span class="comment"># 调用sum函数</span></span><br><span class="line">total = sum( <span class="number">10</span>, <span class="number">20</span> )</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">两数之和: 30</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>如果我们返回函数名</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I am Lyon"</span>)</span><br><span class="line">    <span class="comment"># 返回func,函数名 → 内存地址</span></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"><span class="comment"># result1接收返回值func函数名</span></span><br><span class="line">result1 = func()</span><br><span class="line"><span class="comment"># 返回一个函数对象</span></span><br><span class="line">print(result1)</span><br><span class="line"><span class="comment"># 可以继续调用</span></span><br><span class="line">result2 = result1()</span><br><span class="line">print(result2)</span><br><span class="line">result2()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">I am Lyon</span></span><br><span class="line"><span class="string">&lt;function func at 0x0000013C309B7F28&gt;</span></span><br><span class="line"><span class="string">I am Lyon</span></span><br><span class="line"><span class="string">&lt;function func at 0x0000013C309B7F28&gt;</span></span><br><span class="line"><span class="string">I am Lyon</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>这是一处妙用 , 当然在单层函数中作用不明显 , 下一章的《Python之路 - 函数进阶》中的闭包可以让你体会魅力之所在</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-函数&quot;&gt;&lt;a href=&quot;#Python之路-函数&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 函数&quot;&gt;&lt;/a&gt;Python之路 - 函数&lt;/h1&gt;&lt;h2 id=&quot;介绍-🍀&quot;&gt;&lt;a href=&quot;#介绍-🍀&quot; class=&quot;headerlink&quot; title=&quot;介绍  🍀&quot;&gt;&lt;/a&gt;介绍  🍀&lt;/h2&gt;&lt;p&gt;函数是组织好的 , 可重复使用的 , 用来实现单一 , 或相关联功能的代码段&lt;/p&gt;
&lt;p&gt;函数能提高应用的模块性 , 和代码的重复利用率 , 比如我们一直使用的&lt;code&gt;print()&lt;/code&gt;  , &lt;code&gt;input()&lt;/code&gt;  等等 , 都是函数&lt;/p&gt;
&lt;p&gt;如下我们写了一个用户认证程序 ; 而现在我们又需要写一个用户管理系统 , 管理系统中有很多的功能 , 比如添加用户 , 删除用户 , 查询用户 , 修改用户 ; 但是这些功能必须先通过用户认证程序才能使用 , 明显我们不可能在每一个功能前加上一段用户认证代码 , 因为这将大大增加我们的重复代码&lt;/p&gt;
&lt;p&gt;那么为了解决这个问题我们就可以将用户认证功能封装到一个函数之中 , 而后续我们如果需要使用这个函数仅需调用即可 , 着就是函数的魅力所在 , 当然更多的还是通过下面进一步了解函数&lt;/p&gt;
&lt;h2 id=&quot;语法-🍀&quot;&gt;&lt;a href=&quot;#语法-🍀&quot; class=&quot;headerlink&quot; title=&quot;语法  🍀&quot;&gt;&lt;/a&gt;语法  🍀&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 自定义函数,function_name为函数名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;function_name&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;注释&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    功能代码块&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    &#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 返回值,一般都具有返回值,当然也可以不设定&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; result&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Advanced" scheme="https://jesse.top/categories/python/Advanced/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>12.Python之路 - Python函数进阶</title>
    <link href="https://jesse.top/2020/06/07/python/02-Advanced/02-Python%E4%B9%8B%E8%B7%AF%20-%20%E5%87%BD%E6%95%B0%E8%BF%9B%E9%98%B6/"/>
    <id>https://jesse.top/2020/06/07/python/02-Advanced/02-Python之路 - 函数进阶/</id>
    <published>2020-06-07T09:20:58.000Z</published>
    <updated>2020-06-07T09:16:48.231Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-函数进阶"><a href="#Python之路-函数进阶" class="headerlink" title="Python之路 - 函数进阶"></a>Python之路 - 函数进阶</h1><h2 id="嵌套函数-🍀"><a href="#嵌套函数-🍀" class="headerlink" title="嵌套函数  🍀"></a>嵌套函数  🍀</h2><p>嵌套函数即函数里面再套一个函数 , 如下 : </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局变量name</span></span><br><span class="line">name = <span class="string">"Lyon_1"</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 第一层局部变量name</span></span><br><span class="line">    name = <span class="string">"Lyon_2"</span></span><br><span class="line">    print(<span class="string">"第1层打印"</span>,name)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">#嵌套</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="comment"># 第二层局部变量name</span></span><br><span class="line">        name = <span class="string">"Lyon_3"</span></span><br><span class="line">        print(<span class="string">"第2层打印"</span>, name)</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 嵌套</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">func3</span><span class="params">()</span>:</span></span><br><span class="line">            <span class="comment"># 第三层局部变量</span></span><br><span class="line">            name = <span class="string">"Lyon_4"</span></span><br><span class="line">            print(<span class="string">"第3层打印"</span>, name)</span><br><span class="line">        <span class="comment"># 调用内层函数</span></span><br><span class="line">        func3()     </span><br><span class="line">    <span class="comment"># 调用内层函数</span></span><br><span class="line">    func2()  </span><br><span class="line">func()</span><br><span class="line">print(<span class="string">"最外层打印"</span>, name)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">第1层打印 Lyon_2</span></span><br><span class="line"><span class="string">第2层打印 Lyon_3</span></span><br><span class="line"><span class="string">第3层打印 Lyon_4</span></span><br><span class="line"><span class="string">最外层打印 Lyon_1</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>嵌套函数不能越级调用 , 也就是说我们不能在<code>func2</code> 的外部去调用<code>func3</code> , 当然反过来我们的代码就进入无限递归了</p><p>当然我们有时需要的就是在嵌套函数中 , 使用上一层的变量 , 那么我们可以使用<code>nonlocal</code> 语句</p><p><code>nonlocal</code> 的作用就是改变变量的作用域 , 但是不会扩展到全局变量 , 即只能在函数内部改变 ; nonlocal声明之后 , 会从上层开始找并返回第一个变量,如果有修改变量,则会影响到引用层以及子层的值.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">#下面例子.表面nonlocal声明变量n后,对n的修改会影响到最外层的func函数声明的变量n的值</span><br><span class="line">def func(arg):</span><br><span class="line">    n = arg</span><br><span class="line">    def func1():</span><br><span class="line">        def func2():</span><br><span class="line">            nonlocal n      # n = 2</span><br><span class="line">            n += 1</span><br><span class="line">        func2()</span><br><span class="line">        print(n)        # n = 3</span><br><span class="line">    func1()</span><br><span class="line">    print(n)</span><br><span class="line">func(10)</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line">执行结果:</span><br><span class="line">11</span><br><span class="line">11</span><br><span class="line">&apos;&apos;&apos;</span><br><span class="line"></span><br><span class="line">#下面的例子,在func1中先声明n.然后func2函数中nonlocal声明变量.则影响func1中的引用层以及func1的子函数(func2)..但是并不影响最外层的变量n</span><br><span class="line"></span><br><span class="line">def func(arg):</span><br><span class="line">    n = arg</span><br><span class="line">    def func1():</span><br><span class="line">        n = 2</span><br><span class="line">        def func2():</span><br><span class="line">            nonlocal n      # n = 2</span><br><span class="line">            n += 1</span><br><span class="line">        func2()</span><br><span class="line">        print(n)        # n = 3</span><br><span class="line">    func1()</span><br><span class="line">    print(n)</span><br><span class="line">func(10)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 3</span><br><span class="line">10</span><br></pre></td></tr></table></figure><h2 id="高阶函数-🍀"><a href="#高阶函数-🍀" class="headerlink" title="高阶函数  🍀"></a>高阶函数  🍀</h2><p>高阶函数就是将一个函数以参数的形式传入另一个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个主函数,并设置一个参数func</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main_func</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="comment"># 返回func的值</span></span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个函数作为参数传入主函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 返回"Lyon"给func()</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Lyon"</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># res接收main_func的返回值,将func()的返回值作为参数传入main_func函数    </span></span><br><span class="line">res = main_func(func())</span><br><span class="line">print(res)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">Lyon</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="闭包-🍀"><a href="#闭包-🍀" class="headerlink" title="闭包  🍀"></a>闭包  🍀</h2><p>闭包必须是内部定义的函数 (嵌套函数) , 该函数包含对外部作用域而不是全局作用域名字的引用</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="comment"># 局部变量name</span></span><br><span class="line">    name = <span class="string">'Lyon'</span></span><br><span class="line">    <span class="comment"># 内部定义的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="comment"># 引用了外部定义的变量name,即内部函数使用外部函数变量,这一行为就叫闭包</span></span><br><span class="line">        print(<span class="string">"I am"</span>,name)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"In the bar"</span></span><br><span class="line">    <span class="comment"># 调用bar并打印结果</span></span><br><span class="line">    print(bar())</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"In the foo"</span></span><br><span class="line"><span class="comment"># 调用foo并打印结果</span></span><br><span class="line">print(foo())</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">I am Lyon</span></span><br><span class="line"><span class="string">In the bar</span></span><br><span class="line"><span class="string">In the foo</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>在嵌套函数中 , 我们可以将函数作为参数 (高阶函数) 或者返回值进行传递 , 函数作为一个值可以赋给变量 , 如下 : </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="string">"""func变量在inner函数外部"""</span></span><br><span class="line">    print(<span class="string">"I am decorator"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"I am inner"</span>)</span><br><span class="line">        <span class="comment"># 内部函数引用外部变量func,而func是一个函数对象,因此我们可以进行调用,此处闭包</span></span><br><span class="line">        func()</span><br><span class="line">    <span class="comment"># 内部调用inner函数</span></span><br><span class="line">    inner()</span><br><span class="line">    <span class="comment"># 返回inner,函数名 → 内存地址</span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="comment"># decorator函数的参数函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_arg</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I am decorator_arg"</span>)</span><br><span class="line">    <span class="comment"># 返回decorator_arg,函数名 → 内存地址</span></span><br><span class="line">    <span class="keyword">return</span> decorator_arg</span><br><span class="line"><span class="comment"># result接收的是inner函数名</span></span><br><span class="line">result = decorator(decorator_arg)</span><br><span class="line">print(<span class="string">'-------------------'</span>)</span><br><span class="line"><span class="comment"># 实际调用的是嵌套函数中内部的inner函数</span></span><br><span class="line">result()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">I am decorator</span></span><br><span class="line"><span class="string">I am inner</span></span><br><span class="line"><span class="string">I am decorator_arg</span></span><br><span class="line"><span class="string">-------------------</span></span><br><span class="line"><span class="string">I am inner</span></span><br><span class="line"><span class="string">I am decorator_arg</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">说明:</span></span><br><span class="line"><span class="string">从本例子可以看出我们利用闭包,</span></span><br><span class="line"><span class="string">打破了嵌套函数不能越级调用的规则,</span></span><br><span class="line"><span class="string">实现了从外部调用内部函数</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>所以利用闭包我们可以实现两种需求 :</p><ul><li>在不修改源代码的情况下给函数增加功能</li><li>为某个函数的参数进行提前赋值</li></ul><h3 id="添加功能-🍀"><a href="#添加功能-🍀" class="headerlink" title="添加功能  🍀"></a>添加功能  🍀</h3><p>如果我们以相同的变量名去覆盖函数名 , 修改上述代码 , 如下 : </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"I am decorator"</span>)</span><br><span class="line">        func()</span><br><span class="line">    <span class="comment"># 此处删去inner调用    </span></span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I am func"</span>)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line"><span class="comment"># func变量名覆盖了func()的函数名</span></span><br><span class="line">func = decorator(func)</span><br><span class="line"><span class="comment"># 实际调用inner()</span></span><br><span class="line">func()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">I am decorator</span></span><br><span class="line"><span class="string">I am func</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">说明:</span></span><br><span class="line"><span class="string">通过对函数名进行覆盖,使我们的func变成了inner,</span></span><br><span class="line"><span class="string">而原来的func已经成为了inner的一部分,</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>通过定义了变量<code>decorator</code>  , 使其原来的函数<code>decorator()</code> 被覆盖 , 也就是说我们实现了在不修改<code>func()</code> 函数的情况下 , 为<code>func()</code> 函数新添加了一个功能 , 当然上述例子中的功能仅仅是打印一句 “I am decorator”</p><p>当然我们还可以这样 : </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I am func"</span>)</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">"I am decorator"</span>)</span><br><span class="line">    func()</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line">func = decorator(func)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">I am decorator</span></span><br><span class="line"><span class="string">I am func</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment"># 此版本调用方式不同,所以一般不使用</span></span><br></pre></td></tr></table></figure><p>闭包方式加参数版 : </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="comment"># 此处将原始func参数进行打包</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        print(<span class="string">"I am decorator"</span>)</span><br><span class="line">        <span class="comment"># 此处将原始func参数进行拆包返还</span></span><br><span class="line">        func(*args,**kwargs)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">    print(<span class="string">"I am func"</span>)</span><br><span class="line">    print(args,kwargs)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line">func = decorator(func)</span><br><span class="line"><span class="comment"># inner(*args,**kwargs)</span></span><br><span class="line">func( )</span><br></pre></td></tr></table></figure><h3 id="数据存储-🍀"><a href="#数据存储-🍀" class="headerlink" title="数据存储  🍀"></a>数据存储  🍀</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    name = <span class="string">"Lyon"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(name)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line">func = func()</span><br><span class="line"><span class="comment"># 调用之前name的值已经传入inner中</span></span><br><span class="line">func()</span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">为什么要数据存储?</span></span><br><span class="line"><span class="string">因为如果我们将name定义到inner内部,那么只要inner一执行完毕,Python解释器就会把name释放</span></span><br><span class="line"><span class="string">如果我们要执行一万次这样的操作,那么Python解释器就需要如此申请和释放一万次,会造成内存浪费</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>一道面试题的翻译版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    l = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        <span class="comment"># inner函数并没有进行调用,但是for循环已经执行完毕,此时i=9</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(x)</span>:</span></span><br><span class="line">            <span class="keyword">return</span> i + x</span><br><span class="line">        l.append(inner)</span><br><span class="line">    <span class="keyword">return</span> l</span><br><span class="line">res = func()</span><br><span class="line">print(res[<span class="number">0</span>](<span class="number">10</span>))</span><br><span class="line">print(res[<span class="number">1</span>](<span class="number">10</span>))</span><br><span class="line">print(res[<span class="number">2</span>](<span class="number">10</span>))</span><br><span class="line">print(res[<span class="number">3</span>](<span class="number">10</span>))</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">19</span></span><br><span class="line"><span class="string">19</span></span><br><span class="line"><span class="string">19</span></span><br><span class="line"><span class="string">19</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">说明:</span></span><br><span class="line"><span class="string">这里虽然结果都为19,但是由for循环生成的10个函数却不是同一个函数,</span></span><br><span class="line"><span class="string">在执行时,i的值通过绑定的方式进入每一个函数,直到for循环执行完毕,</span></span><br><span class="line"><span class="string">i的值固定在9,等你再调用时就全为9了</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><p>面试题原版</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 知识点:列表生成式,匿名函数,闭包</span></span><br><span class="line">s = [<span class="keyword">lambda</span> x: x + i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line">print(s[<span class="number">0</span>](<span class="number">10</span>))</span><br><span class="line">print(s[<span class="number">1</span>](<span class="number">10</span>))</span><br><span class="line">print(s[<span class="number">2</span>](<span class="number">10</span>))</span><br><span class="line">print(s[<span class="number">3</span>](<span class="number">10</span>))</span><br></pre></td></tr></table></figure><p>对于闭包 , 我们可以使用<code>__closure__</code> 属性查看闭包函数中引用变量的取值 , <code>__closure__</code> 里包含了一个元组 , 这个元组中的每个元素是<code>cell</code> 类型的对象 , 默认为None</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    name = <span class="string">"Lyon"</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(name)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="comment"># 内部inner</span></span><br><span class="line">print(func().__closure__)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">(&lt;cell at 0x0000023A0F6BB888: str object at 0x0000023A0F1A8B20&gt;,)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="装饰器-🍀"><a href="#装饰器-🍀" class="headerlink" title="装饰器  🍀"></a>装饰器  🍀</h2><p>装饰器即给原来的函数进行装饰的工具</p><p>装饰器由函数去生成 , 用于装饰某个函数或者方法 (类中的说法) , 它可以让这个函数在执行之前或者执行之后做某些操作</p><p>装饰器其实就是上一节闭包中的添加功能实现 , 不过使用闭包太过麻烦 , 所以Python就创造出一个语法糖来方便我们使用</p><p>语法糖 : 指那些没有给计算机语言添加新功能 , 而只是对人类来说更”甜蜜”的语法 , 语法糖主要是为程序员提供更实用的编码方式 , 提高代码的可读性 , 并有益于更好的编码风格</p><p>语法糖如下 : </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 装饰器函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        func()</span><br><span class="line"><span class="keyword">return</span> inner</span><br><span class="line"><span class="comment"># 语法糖,@ 函数名</span></span><br><span class="line"><span class="meta">@decorator     </span></span><br><span class="line"><span class="comment"># 被装饰函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>该语法糖只是将我们闭包中最后自己处理的部分进行处理了 , 如下 : </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@decorator</span></span><br><span class="line">↓ 等价</span><br><span class="line">func = decorator(func)</span><br></pre></td></tr></table></figure><p>另一种一般不使用的方式 : </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 装饰器函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="keyword">return</span> func()</span><br><span class="line"><span class="comment"># 语法糖,@ 函数名</span></span><br><span class="line"><span class="meta">@decorator     </span></span><br><span class="line"><span class="comment"># 被装饰函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"I am decorator"</span>)</span><br><span class="line">        func()   </span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="meta">@decorator    # → func = decorator(func)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I am func"</span>)</span><br><span class="line">    <span class="keyword">return</span> func</span><br><span class="line">func()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">I am decorator</span></span><br><span class="line"><span class="string">I am func</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>多个装饰器装饰同一个函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator1</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator2</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator1</span></span><br><span class="line"><span class="meta">@decorator2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I am func"</span>)</span><br><span class="line">func()</span><br></pre></td></tr></table></figure><p>被装饰函数带有参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> func(*args,**kwargs)</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(name)</span>:</span></span><br><span class="line">    print(<span class="string">"my name is %s"</span> % name)</span><br><span class="line">func(<span class="string">"Lyon"</span>)</span><br></pre></td></tr></table></figure><p>带参数的装饰器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">F = <span class="keyword">False</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(flag)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(func)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args,**kwargs)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> flag:</span><br><span class="line">                print(<span class="string">'before'</span>)</span><br><span class="line">                ret = func(*args,**kwargs)</span><br><span class="line">                print(<span class="string">'after'</span>)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                ret = func(*args, **kwargs)</span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line">        <span class="keyword">return</span> inner</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="comment">#下面这个装饰器执行了2个步骤: 1.先执行outer(F),把参数传递给outer()函数. 2.然后执行func = decorator(func)</span></span><br><span class="line"><span class="meta">@outer(F)      # outer(F) = decorator(func)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'I am func'</span>)</span><br></pre></td></tr></table></figure><p>我们利用装饰器虽然功能达到了 , 但是注意原函数的元信息却没有赋值到装饰器函数内部 , 比如函数的注释信息 , 如果我们需要将元信息也赋值到装饰器函数内部 , 可以使用functools模块中的<code>wraps()</code>方法 , 如下 :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outer</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @functools.wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">inner</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(inner.__doc__)</span><br><span class="line">        <span class="keyword">return</span> func()</span><br><span class="line">    <span class="keyword">return</span> inner</span><br><span class="line"><span class="meta">@outer</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    I am func</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">func()</span><br></pre></td></tr></table></figure><h4 id="多个装饰器-装饰一个函数"><a href="#多个装饰器-装饰一个函数" class="headerlink" title="多个装饰器,装饰一个函数"></a>多个装饰器,装饰一个函数</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">def wrapper1(f): #这里接收的参数是inner2</span><br><span class="line">    def inner1():</span><br><span class="line">        print(&quot; i am wrapper1,before func&quot;)  #setp 1</span><br><span class="line">        f()  #这里是 inner2().调用inner2()</span><br><span class="line">        print(&quot; i am wrapper1,after func&quot;) #setp 5</span><br><span class="line">    return inner1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def wrapper2(f):</span><br><span class="line">    def inner2():</span><br><span class="line">        print(&quot; i am wrapper2,before func&quot;) #setp 2</span><br><span class="line">        f()  # 这里是func函数</span><br><span class="line">        print(&quot; i am wrapper2,after func&quot;) #setp 4</span><br><span class="line">    return inner2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@wrapper1   #然后再执行wrapper1的装饰器....此时func=wrapper1(func) 外面的func是wrapper1返回的inner1函数..里面的func是@wrapper2装饰器返回的inner2函数</span><br><span class="line">@wrapper2   #wrapper2的装饰器先执行...此时func=wrapper2(func)  外面的func是inner2函数.里面的func是func函数</span><br><span class="line">def func():</span><br><span class="line">    print(&quot;i am func&quot;)  #setp 3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func() #这里的func实际上是@wrapper1装饰器的inner1函数. 也就是inner1(inner2).</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;执行结果:</span><br><span class="line"> i am wrapper1,before func</span><br><span class="line"> i am wrapper2,before func</span><br><span class="line">i am func</span><br><span class="line"> i am wrapper2,after func</span><br><span class="line"> i am wrapper1,after func</span><br></pre></td></tr></table></figure><hr><p>此外,还可以通过以下这个例子还学习闭包和装饰器.</p><p>需求1.测试func1函数的执行时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">def func1():</span><br><span class="line">    time.sleep(0.5)</span><br><span class="line">    print(&quot;i am func1&quot;)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def timer():</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    func1()</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    print(&quot;it costs time: %f&quot; %(end_time-start_time))</span><br><span class="line"></span><br><span class="line">timer()</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; i am func1</span><br><span class="line">it costs time: 0.504291</span><br></pre></td></tr></table></figure><p>需求2.测试func1,func2这2个函数的执行时间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">def func1():</span><br><span class="line">    time.sleep(0.5)</span><br><span class="line">    print(&quot;i am func1&quot;)</span><br><span class="line"></span><br><span class="line">def func2():</span><br><span class="line">    time.sleep(0.5)</span><br><span class="line">    print(&quot;i am func2&quot;)</span><br><span class="line"></span><br><span class="line">def timer(f):</span><br><span class="line">    start_time = time.time()</span><br><span class="line">    f()</span><br><span class="line">    end_time = time.time()</span><br><span class="line">    print(&quot;it costs time: %f&quot; %(end_time-start_time))</span><br><span class="line"></span><br><span class="line">#将函数名作为参数,传递到timer函数.虽然可以实现多个函数的同时测试..但是函数(func1,func2)的本来的调用方式,已经发生了改变</span><br><span class="line">#func1()</span><br><span class="line">#func2()</span><br><span class="line"></span><br><span class="line">timer(func1)</span><br><span class="line">timer(func2)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; i am func1</span><br><span class="line">it costs time: 0.504057</span><br><span class="line">i am func2</span><br><span class="line">it costs time: 0.504562</span><br></pre></td></tr></table></figure><p>需求3.不能修改func1,func2函数本身,也不能修改调用方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">def func1():</span><br><span class="line">    time.sleep(0.5)</span><br><span class="line">    print(&quot;i am func1&quot;)</span><br><span class="line"></span><br><span class="line">def func2():</span><br><span class="line">    time.sleep(0.5)</span><br><span class="line">    print(&quot;i am func2&quot;)</span><br><span class="line"></span><br><span class="line">def timer(f):</span><br><span class="line">    def inner(): #使用函数闭包</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        f()</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        print(&quot;it costs time: %f&quot; %(end_time-start_time))</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">#定义一个func的变量名,同时将func函数名作为参数传递给timer函数.此时func1是变量名,而非函数名.实际上func1 = inner.</span><br><span class="line">func1 = timer(func1)</span><br><span class="line">func2 = timer(func2)</span><br><span class="line"></span><br><span class="line">#此时函数调用方式仍然为func1(),func2()..没有改变函数调用方式.</span><br><span class="line">func1()</span><br><span class="line">func2()</span><br></pre></td></tr></table></figure><p>需求4.精简代码.使用语法糖格式.这个语法糖格式就是装饰器.其中timer函数就是装饰函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line">def timer(f):</span><br><span class="line">    def inner(): #使用函数闭包</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        f()</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        print(&quot;it costs time: %f&quot; %(end_time-start_time))</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line">@timer  #@函数名,这个就是语法糖.实际上这一行等同于 func1 = timer(func1)</span><br><span class="line">def func1():</span><br><span class="line">    time.sleep(0.5)</span><br><span class="line">    print(&quot;i am func1&quot;)</span><br><span class="line"></span><br><span class="line">@timer #实际上这一行等同于 func2 = timer(func2)</span><br><span class="line">def func2():</span><br><span class="line">    time.sleep(0.5)</span><br><span class="line">    print(&quot;i am func2&quot;)</span><br><span class="line"></span><br><span class="line">func1()</span><br><span class="line">func2()</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; i am func1</span><br><span class="line">it costs time: 0.504823</span><br><span class="line">i am func2</span><br><span class="line">it costs time: 0.505066</span><br></pre></td></tr></table></figure><p>需求5.给装饰器传递参数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def timer(f):</span><br><span class="line">    print(&quot;i am timer&quot;)</span><br><span class="line">    def inner(*args,**kwargs): #使用函数闭包</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        f(*args,**kwargs)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        print(&quot;timer costs time: %f&quot; %(end_time-start_time))</span><br><span class="line">    return inner</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@timer #@函数名,这个就是语法糖.实际上这一行等同于 func1 = timer(func1)</span><br><span class="line">def func1(a):</span><br><span class="line">    time.sleep(0.5)</span><br><span class="line">    print(&quot;i am %s&quot; %a)</span><br><span class="line"></span><br><span class="line">@timer</span><br><span class="line">def func2(x,y):</span><br><span class="line">    time.sleep(0.5)</span><br><span class="line">    print(&quot;i am %s,another name is %s&quot; %(x,y))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func1(&apos;jesse&apos;)</span><br><span class="line">func2(&apos;jessehuang&apos;,&apos;jerry&apos;)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-函数进阶&quot;&gt;&lt;a href=&quot;#Python之路-函数进阶&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 函数进阶&quot;&gt;&lt;/a&gt;Python之路 - 函数进阶&lt;/h1&gt;&lt;h2 id=&quot;嵌套函数-🍀&quot;&gt;&lt;a href=&quot;#嵌套函数-🍀&quot; class=&quot;headerlink&quot; title=&quot;嵌套函数  🍀&quot;&gt;&lt;/a&gt;嵌套函数  🍀&lt;/h2&gt;&lt;p&gt;嵌套函数即函数里面再套一个函数 , 如下 : &lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 全局变量name&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;name = &lt;span class=&quot;string&quot;&gt;&quot;Lyon_1&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 第一层局部变量name&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    name = &lt;span class=&quot;string&quot;&gt;&quot;Lyon_2&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    print(&lt;span class=&quot;string&quot;&gt;&quot;第1层打印&quot;&lt;/span&gt;,name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;#嵌套&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;func2&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;# 第二层局部变量name&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        name = &lt;span class=&quot;string&quot;&gt;&quot;Lyon_3&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        print(&lt;span class=&quot;string&quot;&gt;&quot;第2层打印&quot;&lt;/span&gt;, name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;# 嵌套&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;func3&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;()&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            &lt;span class=&quot;comment&quot;&gt;# 第三层局部变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            name = &lt;span class=&quot;string&quot;&gt;&quot;Lyon_4&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            print(&lt;span class=&quot;string&quot;&gt;&quot;第3层打印&quot;&lt;/span&gt;, name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;comment&quot;&gt;# 调用内层函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        func3()     &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;comment&quot;&gt;# 调用内层函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    func2()  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;最外层打印&quot;&lt;/span&gt;, name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;执行结果:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;第1层打印 Lyon_2&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;第2层打印 Lyon_3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;第3层打印 Lyon_4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;最外层打印 Lyon_1&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Advanced" scheme="https://jesse.top/categories/python/Advanced/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>13.Python之路 - python匿名函数</title>
    <link href="https://jesse.top/2020/06/07/python/02-Advanced/03-Python%E4%B9%8B%E8%B7%AF%20-%20%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0/"/>
    <id>https://jesse.top/2020/06/07/python/02-Advanced/03-Python之路 - 匿名函数/</id>
    <published>2020-06-07T09:20:58.000Z</published>
    <updated>2020-06-07T09:17:57.757Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-匿名函数"><a href="#Python之路-匿名函数" class="headerlink" title="Python之路 - 匿名函数"></a>Python之路 - 匿名函数</h1><h2 id="匿名函数介绍-🍀"><a href="#匿名函数介绍-🍀" class="headerlink" title="匿名函数介绍 🍀"></a>匿名函数介绍 🍀</h2><p>lambda是一个表达式 , 而并非语句 , 所以可以出现在def语句所不能出现的位置 , 并且不需要指定函数名; lambda表达式还可以提高代码的可读性 , 简化代码</p><p>lambda表达式主要用于写一些简单的方法 , 对于复杂的还是用函数写的好 </p><p>示例:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 普通函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> x * x</span><br><span class="line">print(func(<span class="number">5</span>))</span><br><span class="line">-----------------------</span><br><span class="line"><span class="comment"># 匿名函数,自带return功能</span></span><br><span class="line">func = <span class="keyword">lambda</span> x : x * x</span><br><span class="line">print(func(<span class="number">5</span>))</span><br><span class="line">---------------------------------------------------</span><br><span class="line">func = <span class="keyword">lambda</span> arguments : expression using argument</span><br></pre></td></tr></table></figure><a id="more"></a><p>使用匿名函数可以减少命名空间使用内存 , 因为没有函数名</p><p>可直接后面传递参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="keyword">lambda</span> x,y : x <span class="keyword">if</span> x &gt; y <span class="keyword">else</span> y)(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><p>非固定参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>(<span class="keyword">lambda</span> *args : args)(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p><strong><em>PS : 匿名函数主要是与其他函数搭配使用</em></strong></p><h2 id="匿名函数运用-🍀"><a href="#匿名函数运用-🍀" class="headerlink" title="匿名函数运用  🍀"></a>匿名函数运用  🍀</h2><p><strong><em>结合使用</em></strong></p><p>map , 计算平方</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># map后返回的对象为map对象,所以利用list方法进行强转</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(map(<span class="keyword">lambda</span> x : x * x, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]))</span><br><span class="line">[<span class="number">1</span>,<span class="number">4</span>,<span class="number">9</span>,<span class="number">16</span>]</span><br></pre></td></tr></table></figure><p>filter , 筛选偶数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(filter(<span class="keyword">lambda</span> x : x % <span class="number">2</span> == <span class="number">0</span>,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]))</span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><p>reduce , 求和</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># python3中已经没有reduce方法了,调用需要导入</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"><span class="comment"># reduce(function, sequence, initial=None)</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reduce(<span class="keyword">lambda</span> x , y : x + y, [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>],<span class="number">100</span>)</span><br><span class="line"><span class="number">115</span></span><br></pre></td></tr></table></figure><p><strong><em>嵌套使用</em></strong></p><p>版本一</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> y : x + y</span><br><span class="line">f = func(<span class="number">2</span>)</span><br><span class="line">print(f(<span class="number">2</span>))</span><br><span class="line"><span class="comment"># output: 4</span></span><br></pre></td></tr></table></figure><p>版本二</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">func = <span class="keyword">lambda</span> x : (<span class="keyword">lambda</span> y: x + y)</span><br><span class="line">y = func(<span class="number">1</span>)</span><br><span class="line">y(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># output: 3</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-匿名函数&quot;&gt;&lt;a href=&quot;#Python之路-匿名函数&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 匿名函数&quot;&gt;&lt;/a&gt;Python之路 - 匿名函数&lt;/h1&gt;&lt;h2 id=&quot;匿名函数介绍-🍀&quot;&gt;&lt;a href=&quot;#匿名函数介绍-🍀&quot; class=&quot;headerlink&quot; title=&quot;匿名函数介绍 🍀&quot;&gt;&lt;/a&gt;匿名函数介绍 🍀&lt;/h2&gt;&lt;p&gt;lambda是一个表达式 , 而并非语句 , 所以可以出现在def语句所不能出现的位置 , 并且不需要指定函数名; lambda表达式还可以提高代码的可读性 , 简化代码&lt;/p&gt;
&lt;p&gt;lambda表达式主要用于写一些简单的方法 , 对于复杂的还是用函数写的好 &lt;/p&gt;
&lt;p&gt;示例:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 普通函数&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;func&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(x)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;return&lt;/span&gt; x * x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(func(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;-----------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 匿名函数,自带return功能&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func = &lt;span class=&quot;keyword&quot;&gt;lambda&lt;/span&gt; x : x * x&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(func(&lt;span class=&quot;number&quot;&gt;5&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;---------------------------------------------------&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;func = &lt;span class=&quot;keyword&quot;&gt;lambda&lt;/span&gt; arguments : expression using argument&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Advanced" scheme="https://jesse.top/categories/python/Advanced/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>15.Python之路 - Python迭代器和生成器</title>
    <link href="https://jesse.top/2020/06/07/python/02-Advanced/05-Python%E4%B9%8B%E8%B7%AF%20-%20%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <id>https://jesse.top/2020/06/07/python/02-Advanced/05-Python之路 - 迭代器和生成器/</id>
    <published>2020-06-07T09:20:58.000Z</published>
    <updated>2020-06-07T09:18:56.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-迭代器和生成器"><a href="#Python之路-迭代器和生成器" class="headerlink" title="Python之路 - 迭代器和生成器"></a>Python之路 - 迭代器和生成器</h1><h2 id="可迭代对象-🍀"><a href="#可迭代对象-🍀" class="headerlink" title="可迭代对象  🍀"></a>可迭代对象  🍀</h2><p>在Python中一切皆对象</p><p>迭代是重复反馈过程的活动 , 其目的通常是为了逼近所需目标或结果 </p><p>可迭代对象 , 即可以按照迭代的方式进行存取数据的对象 , 在python中我们可以理解为可以用for循环遍历的对象就是可迭代对象</p><p><strong>for循环做的那些事</strong> :  for循环是我们用来遍历一个数据集合的方法 , 其实就是根据一定的要求 (这个要求叫做’协议’ ) 进行一次次的迭代的效果 . 当我们用for循环去遍历时 , 它做的第一件事就是判断对象是否是可迭代对象 , 如果是 , 那么它就会将该对象转换成一个迭代器 , 最后利用<code>__next__()</code>方法将迭代器中的内容一个接一个的取出来</p><p>可迭代对象的标志是 , 它具有<code>__iter__()</code>方法</p><p>判断对象是否为可迭代对象方法如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入模块</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="string">'lyon'</span>,<span class="string">'oldboy'</span>]</span><br><span class="line"><span class="comment"># 判断是否为Iterable , 即可迭代对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(l,Iterable)</span><br><span class="line"><span class="comment"># 返回bool值</span></span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#或者下面这个方法也可以判断</span></span><br><span class="line">l = [<span class="string">'lyon'</span>,<span class="string">'oldboy'</span>]</span><br><span class="line">print(<span class="string">"__iter__"</span> <span class="keyword">in</span> dir(l))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">True</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="迭代器-🍀"><a href="#迭代器-🍀" class="headerlink" title="迭代器  🍀"></a>迭代器  🍀</h2><p>通过上面的内容已经知道<code>for循环</code>有一个生成迭代器的过程 , 迭代器是啥 ?</p><p>迭代器是访问集合元素的一种方式</p><p>特点:</p><ol><li>不依赖索引取值 , 访问者不需要关心迭代器内部的结构 , 仅需通过next()方法去访问</li><li>不能随机访问集合中的某个值 , 只能从头到尾依次访问 , 不可返回访问</li><li>惰性计算 , 只有在需要访问时才会生成值 , 节省内存</li></ol><p>在python中有一个<code>iter()</code>方法 , 作用就是将可迭代对象变成一个迭代器 , 实质上iter()是去调用了<code>__iter__()</code>方法 ,  看代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="string">'lyon'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l.__iter__()</span><br><span class="line"><span class="comment"># iterator即迭代器</span></span><br><span class="line">&lt;list_iterator object at <span class="number">0x0000026DA649D320</span>&gt;</span><br></pre></td></tr></table></figure><p>可迭代对象与迭代器的区别:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用dir方法查看对象中的所有方法</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir_list = dir([<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dir_iter = dir([<span class="number">1</span>,<span class="number">2</span>].__iter__())</span><br><span class="line"><span class="comment"># 筛选出不同点</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>set(dir_iter) - set(dir_list)</span><br><span class="line">&#123;<span class="string">'__length_hint__'</span>, <span class="string">'__setstate__'</span>, <span class="string">'__next__'</span>&#125;</span><br></pre></td></tr></table></figure><p>我们可以看出迭代器比可迭代对象多出了三个方法 , 所以我们可以根据这一点来判断一个对象到底是可迭代对象还是一个迭代器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个迭代器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i = iter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="comment"># 查看迭代器中元素的长度</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i.__length_hint__()</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="comment"># 根据索引指定迭代开始位置</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i.__setstate__(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 进行取值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>i.__next__()</span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure><p><em>判断方法:</em> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入Iterable类</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="comment"># 导入Iterator类</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterator</span><br><span class="line"><span class="comment"># 是否为可迭代对象</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(obj,Iterable)</span><br><span class="line"><span class="comment"># 是否为迭代器</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(obj,Iterator)</span><br><span class="line"><span class="comment"># 注意:迭代器也是可迭代对象</span></span><br></pre></td></tr></table></figure><p><strong><em> 在迭代时 ,  我们需要注意迭代器中是否有值的问题 ,  即当我们一直调用<code>__next__</code> 方法取值时 , 如果值都取完了 , 而此时我们再执行 <code>__next__</code> 方法 , 解释器就会抛出 StopIteration , 因为已经没有值可以取了 </em></strong></p><h2 id="生成器-🍀"><a href="#生成器-🍀" class="headerlink" title="生成器  🍀"></a>生成器  🍀</h2><p>自定义的一个能够实现迭代器功能的就是生成器</p><p>本质: 迭代器(所以自带了<code>__iter__</code> 方法和<code>__next__</code> 不需要我们去实现</p><p>特点: 惰性运算 , 开发者自定义</p><h3 id="生成器函数-🍀"><a href="#生成器函数-🍀" class="headerlink" title="生成器函数  🍀"></a>生成器函数  🍀</h3><p>一个函数调用时返回一个迭代器 , 那么这个函数就叫做生成器函数</p><p>利用生成器做一个range( 2.x中的xrange ) 的功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义函数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">range</span><span class="params">(n)</span>:</span></span><br><span class="line">...start = <span class="number">0</span></span><br><span class="line"><span class="meta">... </span><span class="keyword">while</span> start &lt; n:</span><br><span class="line"><span class="meta">... </span><span class="keyword">yield</span> start</span><br><span class="line">...start += <span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = range(<span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.__next__()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.__next__()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.__next__()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.__next__()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj.__next__()</span><br></pre></td></tr></table></figure><p>yield的作用 :  yield的作用是中断函数的执行并记录中断的位置 , 等下次重新调用这个函数时 , 就会接着上次继续执行</p><p>PS : 调用生成器函数时 , 仅仅会返回一个生成器 , 并不会执行函数的内容 , 生成器只能由next() 进行调用执行 , 实质上next()方法就是调用的<code>__next__()</code>  方法</p><p><strong><em>yield from</em></strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">'AB'</span>:</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">yield</span> j</span><br><span class="line">print(list(func()))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> <span class="string">'AB'</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="keyword">from</span> range(<span class="number">3</span>)</span><br><span class="line">    </span><br><span class="line">print(list(func2()))</span><br></pre></td></tr></table></figure><p><strong>生成器应用</strong></p><p>监听文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tail</span><span class="params">(filename)</span>:</span></span><br><span class="line">    <span class="comment"># 打开文件</span></span><br><span class="line">    f = open(filename,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line">    <span class="comment"># 从文件末尾算起</span></span><br><span class="line">    f.seek(<span class="number">0</span>, <span class="number">2</span>) </span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        <span class="comment"># 读取文件中新的文本行</span></span><br><span class="line">        line = f.readline()  </span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> line:</span><br><span class="line">            time.sleep(<span class="number">0.1</span>)</span><br><span class="line">            <span class="keyword">continue</span></span><br><span class="line">        <span class="keyword">yield</span> line</span><br><span class="line">tail_g = tail(<span class="string">'tmp'</span>)</span><br><span class="line"><span class="comment"># 生成器也是可迭代对象</span></span><br><span class="line"><span class="keyword">for</span> line <span class="keyword">in</span> tail_g:</span><br><span class="line">    print(line)</span><br></pre></td></tr></table></figure><p>计算动态平均值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">averager</span><span class="params">()</span>:</span></span><br><span class="line">total = <span class="number">0</span></span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line">    average = <span class="keyword">None</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">True</span>:</span><br><span class="line">        term = <span class="keyword">yield</span> average</span><br><span class="line">        total += term</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        average = total/count</span><br><span class="line"><span class="comment"># 生成生成器</span></span><br><span class="line">g_avg = averager()</span><br><span class="line"><span class="comment"># 激活生成器,不激活无法send</span></span><br><span class="line">next(g_avg)</span><br><span class="line"><span class="comment"># send相当于先传参,后调用next()</span></span><br><span class="line">print(g_avg.send(<span class="number">10</span>))</span><br><span class="line">print(g_avg.send(<span class="number">30</span>))</span><br><span class="line">print(g_avg.send(<span class="number">50</span>))</span><br></pre></td></tr></table></figure><h3 id="列表推导式和生成器表达式-🍀"><a href="#列表推导式和生成器表达式-🍀" class="headerlink" title="列表推导式和生成器表达式  🍀"></a>列表推导式和生成器表达式  🍀</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列表解析</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line"><span class="comment"># 生成器表达式</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num_iter = (i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num_iter</span><br><span class="line">&lt;generator object &lt;genexpr&gt; at <span class="number">0x0000021C41003258</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(num_iter)</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(num_iter)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(num_iter)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(num_iter)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(num_iter)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(num_iter)</span><br></pre></td></tr></table></figure><p>对于推导式会有另一篇专门来写</p><h4 id="列表推导式练习"><a href="#列表推导式练习" class="headerlink" title="列表推导式练习"></a>列表推导式练习</h4><p>10以内所有数的平方的列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l1=[i**2 for i in range(1,11)]</span><br><span class="line">print(l1)</span><br></pre></td></tr></table></figure><p>30以内能被3整除的数的平方</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">l2 = [i**2 for i in range(1,31) if i % 3 == 0]</span><br><span class="line">print(l2)</span><br></pre></td></tr></table></figure><p>3.下面是个列表.过滤掉长度小于3的字符串,并将剩下的转换成大写字母</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">l3 = [&apos;alex&apos;,&apos;jesse&apos;,&apos;taibai&apos;,&apos;re&apos;,&apos;ab&apos;]</span><br><span class="line">l4 = [i.upper() for i in l3 if len(i)&gt;= 3]</span><br><span class="line">print(l4)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-迭代器和生成器&quot;&gt;&lt;a href=&quot;#Python之路-迭代器和生成器&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 迭代器和生成器&quot;&gt;&lt;/a&gt;Python之路 - 迭代器和生成器&lt;/h1&gt;&lt;h2 id=&quot;可迭代对象-🍀&quot;&gt;&lt;a href=&quot;#可迭代对象-🍀&quot; class=&quot;headerlink&quot; title=&quot;可迭代对象  🍀&quot;&gt;&lt;/a&gt;可迭代对象  🍀&lt;/h2&gt;&lt;p&gt;在Python中一切皆对象&lt;/p&gt;
&lt;p&gt;迭代是重复反馈过程的活动 , 其目的通常是为了逼近所需目标或结果 &lt;/p&gt;
&lt;p&gt;可迭代对象 , 即可以按照迭代的方式进行存取数据的对象 , 在python中我们可以理解为可以用for循环遍历的对象就是可迭代对象&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;for循环做的那些事&lt;/strong&gt; :  for循环是我们用来遍历一个数据集合的方法 , 其实就是根据一定的要求 (这个要求叫做’协议’ ) 进行一次次的迭代的效果 . 当我们用for循环去遍历时 , 它做的第一件事就是判断对象是否是可迭代对象 , 如果是 , 那么它就会将该对象转换成一个迭代器 , 最后利用&lt;code&gt;__next__()&lt;/code&gt;方法将迭代器中的内容一个接一个的取出来&lt;/p&gt;
&lt;p&gt;可迭代对象的标志是 , 它具有&lt;code&gt;__iter__()&lt;/code&gt;方法&lt;/p&gt;
&lt;p&gt;判断对象是否为可迭代对象方法如下:&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 导入模块&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; collections &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; Iterable&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;l = [&lt;span class=&quot;string&quot;&gt;&#39;lyon&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;oldboy&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 判断是否为Iterable , 即可迭代对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;isinstance(l,Iterable)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 返回bool值&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;#或者下面这个方法也可以判断&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;l = [&lt;span class=&quot;string&quot;&gt;&#39;lyon&#39;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&#39;oldboy&#39;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;__iter__&quot;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;in&lt;/span&gt; dir(l))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Advanced" scheme="https://jesse.top/categories/python/Advanced/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>14.Python之路 - Python内置函数</title>
    <link href="https://jesse.top/2020/06/07/python/02-Advanced/04-Python%E4%B9%8B%E8%B7%AF%20-%20%E5%86%85%E7%BD%AE%E5%87%BD%E6%95%B0/"/>
    <id>https://jesse.top/2020/06/07/python/02-Advanced/04-Python之路 - 内置函数/</id>
    <published>2020-06-07T09:20:58.000Z</published>
    <updated>2020-06-07T09:18:31.274Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-内置函数"><a href="#Python之路-内置函数" class="headerlink" title="Python之路 - 内置函数"></a>Python之路 - 内置函数</h1><h2 id="str类型代码的执行-3个-🍀"><a href="#str类型代码的执行-3个-🍀" class="headerlink" title="str类型代码的执行(3个) 🍀"></a>str类型代码的执行(3个) 🍀</h2><blockquote><p><code>exec</code>(object[, globals[, locals]])  👈</p></blockquote><p>将字符串当做表达式去执行，没有返回值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 流程语句用exec</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exec(<span class="string">"print('123')"</span>)</span><br><span class="line"><span class="number">123</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exec(<span class="string">'1+2+3+4'</span>)</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = exec(<span class="string">'1+2+3+4'</span>)</span><br><span class="line"><span class="keyword">None</span></span><br></pre></td></tr></table></figure><blockquote><p><code>eval</code>(expression, globals=None, locals=None)   👈</p></blockquote><p>将字符串当做表达式去执行，并返回执行结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单求值表达式用eval</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res = eval(<span class="string">'1+2+3+4'</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>res</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><blockquote><p><code>compile</code>(source, filename, mode, flags=0, dont_inherit=False, optimize=-1)   👈</p></blockquote><a id="more"></a><p>把字符传编译成python可执行的代码，但是不会执行</p><p><em>filename</em> : 默认<code>sys.stout</code>，即默认打印在控制台，打印到指定文件</p><p><em>mode</em> : 指定compile后的对象的执行模式，注意有个<code>single</code>模式，当source带有变量赋值时，eval模式是解释不了的，所以需要用single模式或者exec模式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 交互语句用single</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>code3 = <span class="string">'name = input("please input your name:")'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>compile3 = compile(code3,<span class="string">''</span>,<span class="string">'single'</span>)</span><br><span class="line"><span class="comment"># 执行前name变量不存在</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name </span><br><span class="line"><span class="comment"># 报错说'name'变量没有定义</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;pyshell#29&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">    name</span><br><span class="line">NameError: name <span class="string">'name'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>exec(compile3) </span><br><span class="line"><span class="comment"># 执行时显示交互命令，提示输入</span></span><br><span class="line">please input your name:<span class="string">'pythoner'</span></span><br><span class="line"><span class="comment"># 执行后name变量有值    </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name </span><br><span class="line"><span class="string">"'pythoner'"</span></span><br></pre></td></tr></table></figure><h2 id="数据类型相关-38-🍀"><a href="#数据类型相关-38-🍀" class="headerlink" title="数据类型相关(38) 🍀"></a>数据类型相关(38) 🍀</h2><h3 id="数字相关-🍀"><a href="#数字相关-🍀" class="headerlink" title="数字相关  🍀"></a>数字相关  🍀</h3><h4 id="数据类型-🍀"><a href="#数据类型-🍀" class="headerlink" title="数据类型  🍀"></a>数据类型  🍀</h4><blockquote><p><code>bool</code>([<em>x</em>])   👈</p></blockquote><p>查看一个元素的布尔值</p><blockquote><p><code>int</code>(<em>x=0</em>)  /  <code>int</code>(<em>x</em>, <em>base=10</em>)   👈</p></blockquote><p>获取一个数的十进制或者进行进制转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'1'</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment"># 二进制转十进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>int(<span class="string">'0b11'</span>,base=<span class="number">2</span>)</span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure><blockquote><p><code>float</code>([<em>x</em>])   👈</p></blockquote><p>将整数和字符串转换成浮点数</p><blockquote><p><code>complex</code>([<em>real</em>[, <em>imag</em>]])  👈</p></blockquote><p>创建一个值为real + imag * j的复数或者转化一个字符串或数为复数。如果第一个参数为字符串，则不需要指定第二个参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>complex(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">(<span class="number">1</span>+<span class="number">2j</span>)</span><br><span class="line"><span class="comment"># 数字</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>complex(<span class="number">1</span>)</span><br><span class="line">(<span class="number">1</span>+<span class="number">0j</span>)</span><br><span class="line"><span class="comment"># 当做字符串处理</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>complex(<span class="string">"1"</span>)</span><br><span class="line">(<span class="number">1</span>+<span class="number">0j</span>)</span><br><span class="line"><span class="comment"># 注意：这个地方在“+”号两边不能有空格，也就是不能写成"1 + 2j"，应该是"1+2j"，否则会报错</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>complex(<span class="string">"1+2j"</span>)</span><br><span class="line">(<span class="number">1</span>+<span class="number">2j</span>)</span><br></pre></td></tr></table></figure><h4 id="进制转换-🍀"><a href="#进制转换-🍀" class="headerlink" title="进制转换  🍀"></a>进制转换  🍀</h4><blockquote><p><code>bin</code>(<em>x</em>)  👈</p></blockquote><p>将整数x转换为二进制字符串，如果x不为Python中int类型，x必须包含方法<code>__index__()</code>并且返回值为整数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回一个整数的二进制</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bin(<span class="number">999</span>)</span><br><span class="line"><span class="string">'0b1111100111'</span></span><br><span class="line"><span class="comment"># 非整型的情况，必须包含__index__()方法且返回值为integer的类型</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">myType</span>:</span></span><br><span class="line"><span class="meta">... </span>  <span class="function"><span class="keyword">def</span> <span class="title">__index__</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>      <span class="keyword">return</span> <span class="number">35</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>myvar = myType()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>bin(myvar)</span><br><span class="line"><span class="string">'0b100011'</span></span><br></pre></td></tr></table></figure><blockquote><p><code>oct</code>(<em>x</em>)   👈</p></blockquote><p>转换为八进制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>oct(<span class="number">8</span>)</span><br><span class="line"><span class="string">'0o10'</span></span><br></pre></td></tr></table></figure><blockquote><p><code>hex</code>(<em>x</em>)  👈</p></blockquote><p>转换为十六进制</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>oct(<span class="number">13</span>)</span><br><span class="line"><span class="string">'0o15'</span></span><br></pre></td></tr></table></figure><h4 id="数学运算-🍀"><a href="#数学运算-🍀" class="headerlink" title="数学运算  🍀"></a>数学运算  🍀</h4><blockquote><p><code>abs</code>(<em>x</em>)  👈</p></blockquote><p>返回一个数的绝对值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>num = <span class="number">-1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>abs(num)</span><br><span class="line"><span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p><code>divmod</code>(<em>a</em>, <em>b</em>)  👈</p></blockquote><p>返回两个数的除,余</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>divmod(<span class="number">5</span>,<span class="number">2</span>)</span><br><span class="line"><span class="comment"># 第一个数为整除,第二个为取余</span></span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><blockquote><p><code>min</code>(<em>iterable</em>, *<em>[, key, default]</em>)   👈</p><p><code>min</code>(<em>arg1</em>, <em>arg2</em>, *<em>args</em>[, <em>key</em>])   👈</p></blockquote><p>返回最小值,如果多个参数最小值一样,则返回第一个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>min([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="comment"># 返回第一个</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>min([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>],[<span class="number">1</span>,<span class="number">2</span>])</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><blockquote><p><code>max</code>(<em>iterable</em>, *<em>[, key, default]</em>)   👈</p><p><code>max</code>(<em>arg1</em> , <em>arg2</em>, *<em>args</em>[, <em>key</em>])  👈</p></blockquote><p>返回最大值,如果多个参数最大值,则返回第一个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>max([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>max([<span class="number">2</span>,<span class="number">3</span>],[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">[<span class="number">2</span>, <span class="number">3</span>]</span><br></pre></td></tr></table></figure><blockquote><p><code>sum</code>(<em>iterable</em>[, <em>start</em>])  👈</p></blockquote><p>求和,参数为可迭代对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>sum((<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure><blockquote><p><code>round</code>(<em>number[, ndigits]</em>)  👈</p></blockquote><p>小数精确</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 保留两位小数,四舍五入</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>round(<span class="number">1.235</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">1.24</span></span><br></pre></td></tr></table></figure><blockquote><p><code>pow</code>(<em>x</em>, <em>y</em>[, <em>z</em>])  👈</p></blockquote><p>幂运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pow(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="comment"># 参数z相当余  x**y % z</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>pow(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"><span class="number">0</span></span><br></pre></td></tr></table></figure><h3 id="数据结构相关-🍀"><a href="#数据结构相关-🍀" class="headerlink" title="数据结构相关  🍀"></a>数据结构相关  🍀</h3><h4 id="序列-🍀"><a href="#序列-🍀" class="headerlink" title="序列  🍀"></a>序列  🍀</h4><p>列表和元组</p><blockquote><p><code>list</code>([<em>iterable</em>])  👈</p></blockquote><p>将可迭代对象转换成list对象,实际上我们创建一个空list时,python解释器自动为我们调用了该方法</p><blockquote><p><code>tuple</code>([<em>iterable</em>])  👈</p></blockquote><p>将可迭代对象转换成tuple对象,与list类似</p><p>相关内置函数</p><blockquote><p><code>reversed</code>(<em>seq</em>)  👈</p></blockquote><p>顺序翻转,与list中reverse的区别在于,该翻转为新生成了一个对象,而不是在原对象上操作</p><blockquote><p><code>slice</code>(<em>stop</em>)   👈</p><p><code>slice</code>(<em>start</em>, <em>stop</em>[, <em>step</em>])   👈</p></blockquote><p>返回切片操作的三个参数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 相当于[0:2:],注意最后一个参数不能为0而是None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>op = slice(<span class="number">0</span>,<span class="number">2</span>,<span class="keyword">None</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l[op]</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>字符串</p><blockquote><p><code>str</code>(<em>object=’’</em>)   👈</p><p><code>str</code>(<em>object=b’’</em>, <em>encoding=’utf-8’</em>, <em>errors=’strict’</em>)  👈</p></blockquote><p>返回一个字符串对象,创建字符串时python解释器为我们调用了该方法进行创建</p><blockquote><p><code>repr</code>(<em>object</em>)   👈</p></blockquote><p>返回一个可打印的字符串对象</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>repr(<span class="number">123</span>)</span><br></pre></td></tr></table></figure><p>repr还有另外一种用法就是格式化输出的时候,%r表示法 .</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(&quot;my name is %s,I am %r&quot; %(&apos;alex&apos;,&apos;sb&apos;))</span><br></pre></td></tr></table></figure><blockquote><p><code>format</code>(<em>value</em>[, <em>format_spec</em>]) 👈</p></blockquote><p>格式化字符串</p><blockquote><p><code>bytes</code>([<em>source</em>[, <em>encoding</em>[, <em>errors</em>]]])   👈</p></blockquote><p>将字符串转成bytes类型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>bytes(<span class="string">'lyon'</span>,encoding=<span class="string">'utf-8'</span>)</span><br><span class="line"><span class="string">b'lyon'</span></span><br></pre></td></tr></table></figure><blockquote><p><code>bytearray</code>([<em>source</em>[, <em>encoding</em>[, <em>errors</em>]]])  👈</p></blockquote><p>返回一个byte数组,Bytearray类型是一个可变的序列,并且序列中的元素的取值范围为[0,255]</p><p><em>source</em> : </p><ol><li>如果source为整数,则返回一个长度为source的初始化数组;</li><li>如果source为字符串,则按照指定的encoding将字符串转换为字节序列;</li><li>如果source为可迭代类型,则元素必须为[0,255]中的整数;</li><li>如果source为与buffer接口一致的对象,则此对象也可以被用于初始化bytearray</li></ol><blockquote><p><code>memoryview</code>(<em>obj</em>)   👈</p></blockquote><p>函数返回给定参数的内存查看对象(Momory view)</p><p>所谓内存查看对象，是指对支持缓冲区协议的数据进行包装，在不需要复制对象基础上允许Python代码访问</p><blockquote><p><code>ord</code>(<em>c</em>)  👈</p></blockquote><p>把一个字符转换成ASCII表中对应的数字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>ord(<span class="string">'a'</span>)</span><br><span class="line"><span class="number">97</span></span><br></pre></td></tr></table></figure><blockquote><p> <code>chr</code>(<em>i</em>)  👈</p></blockquote><p>返回一个数字在ASCII编码中对应的字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>chr(<span class="number">66</span>)</span><br><span class="line"><span class="string">'B'</span></span><br></pre></td></tr></table></figure><blockquote><p><code>ascii</code>(<em>object</em>)  👈</p></blockquote><p>在对象的类中寻找<code>__repr__</code>方法,获取返回值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>:</span></span><br><span class="line"><span class="meta">... </span> <span class="function"><span class="keyword">def</span> <span class="title">__repr_</span><span class="params">(self)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> <span class="string">"hello"</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = Foo()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = ascii(obj)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(r)</span><br><span class="line"><span class="comment"># 返回的是一个可迭代的对象</span></span><br><span class="line">&lt;__main__.Foo object at <span class="number">0x000001FDEE13D320</span>&gt;</span><br></pre></td></tr></table></figure><h4 id="数据集合-🍀"><a href="#数据集合-🍀" class="headerlink" title="数据集合  🍀"></a>数据集合  🍀</h4><p>字典</p><blockquote><p><code>dict</code>(*<em>\</em>kwarg*)</p><p><code>dict</code>(<em>mapping</em>, *<em>\</em>kwarg*)</p><p><code>dict</code>(<em>iterable</em>, *<em>\</em>kwarg*) </p></blockquote><p>转换成字典类型,创建一个字典时python解释器会自动帮我们调用该方法</p><p>集合</p><blockquote><p><code>set</code>([<em>iterable</em>])  👈</p></blockquote><p>转换成集合类型,创建集合时,事实上就是通过该方法进行创建的</p><blockquote><p><code>frozenset</code>([<em>iterable</em>])   👈</p></blockquote><p>定义冻结集合,即不可变集合,存在hash值</p><p>好处是它可以作为字典的key，也可以作为其它集合的元素。缺点是一旦创建便不能更改，没有add，remove方法</p><h4 id="相关内置函数-🍀"><a href="#相关内置函数-🍀" class="headerlink" title="相关内置函数  🍀"></a>相关内置函数  🍀</h4><blockquote><p><code>len</code>(<em>s</em>)   👈</p></blockquote><p>返回一个对象的长度</p><blockquote><p><code>enumerate</code>(<em>iterable</em>, <em>start=0</em>)   👈</p></blockquote><p>为元素生成序号,可以定义序号的初始值,默认从0开始</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">for</span> i,k <span class="keyword">in</span> enumerate(l,<span class="number">0</span>):</span><br><span class="line"><span class="meta">... </span>     print(i,k)</span><br><span class="line"><span class="meta">... </span>   </span><br><span class="line"><span class="number">0</span> a</span><br><span class="line"><span class="number">1</span> b</span><br><span class="line"><span class="number">2</span> c</span><br></pre></td></tr></table></figure><blockquote><p><code>all</code>(<em>iterable</em>)   👈</p></blockquote><p>判断一个可迭代对象中的元素是否都为空,返回bool值</p><blockquote><p><code>any</code>(<em>iterable</em>)   👈</p></blockquote><p>判断一个可迭代对象中是否有真元素,返回bool值</p><blockquote><p><code>zip</code>(*<em>iterables</em>)   👈</p></blockquote><p>将两个长度相同的序列整合成键值对,返回一个zip对象可以用dict方法转换查看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l1 = [<span class="string">'k1'</span>,<span class="string">'k2'</span>,<span class="string">'k3'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l2 = [<span class="string">'v1'</span>,<span class="string">'v2'</span>,<span class="string">'v3'</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ret = zip(l1,l2)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>dict(ret)</span><br><span class="line">&#123;<span class="string">'k1'</span>:<span class="string">'v1'</span>,<span class="string">'k2'</span>:<span class="string">'v2'</span>,<span class="string">'k3'</span>:<span class="string">'v3'</span>&#125;</span><br></pre></td></tr></table></figure><blockquote><p><code>filter</code>(<em>function</em>, <em>iterable</em>)  👈</p></blockquote><p>筛选过滤,把可迭代对象中的元素一一传入function中进行过滤</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 筛选出偶数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x)</span>:</span></span><br><span class="line">...<span class="keyword">return</span> x % <span class="number">2</span> == <span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>f = filter(func,[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">&lt;filter object at <span class="number">0x0000026DA649D160</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ret = list(f)</span><br><span class="line">[<span class="number">2</span>,<span class="number">4</span>]</span><br></pre></td></tr></table></figure><blockquote><p><code>map</code>(<em>function</em>, <em>iterable</em>, <em>…</em>)  👈</p></blockquote><p>将可迭代对象中的元素一一传入function中执行并返回结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(s)</span>:</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> s + <span class="string">' hello'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m = map(func,[<span class="string">'alex'</span>,<span class="string">'egon'</span>,<span class="string">'lyon'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>m</span><br><span class="line">&lt;map object at <span class="number">0x0000026DA649D2E8</span>&gt;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ret = list(m)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ret</span><br><span class="line">[<span class="string">'alex hello'</span>, <span class="string">'egon hello'</span>, <span class="string">'lyon hello'</span>]</span><br></pre></td></tr></table></figure><blockquote><p><code>sorted</code>(<em>iterable</em>, <em>**, </em>key=None<em>, </em>reverse=False*)  👈</p></blockquote><p>为一个对象进行排序,在list中有个sort方法;区别:sort会改变原list,而sorted则不会改变原list</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>l = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sorted(l)</span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>l</span><br></pre></td></tr></table></figure><p>sorted排序还支持像函数传参,接收函数返回值,从而对返回值进行排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">l_sort = [(&apos;alex&apos;,2),(&apos;wusir&apos;,3),(&apos;jesse&apos;,4),(&apos;david&apos;,9)]</span><br><span class="line"></span><br><span class="line">l_sort1 = sorted(l_sort) #默认按照列表的每个元素的首字母进行排序</span><br><span class="line">print(l_sort1)</span><br></pre></td></tr></table></figure><p>使用函数来返回列表中每个子元素的第二个元素,对第二个元素(也就是数字)来进行排序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def f_sort(x): #函数指定形参,接收sorted方法传递的参数</span><br><span class="line">    return x[1]</span><br><span class="line"></span><br><span class="line">l_sort2 = sorted(l_sort,key=f_sort) #key关键字指定一个函数名(只是函数名,不是函数调用)</span><br><span class="line">print(l_sort2)</span><br></pre></td></tr></table></figure><h2 id="迭代器-生成器相关-3个-🍀"><a href="#迭代器-生成器相关-3个-🍀" class="headerlink" title="迭代器/生成器相关(3个) 🍀"></a>迭代器/生成器相关(3个) 🍀</h2><blockquote><p><code>range</code>(<em>stop</em>)  👈</p><p><code>range</code>(<em>start</em>, <em>stop</em>[, <em>step</em>])   👈</p></blockquote><p>返回一个序列,为一个可迭代对象,并可用下标取值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r = range(<span class="number">10</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>r[<span class="number">0</span>]</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>isinstance(r,Iterable)</span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>list(r)</span><br><span class="line">[<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br></pre></td></tr></table></figure><blockquote><p><code>next</code>(<em>iterator</em>[, <em>default</em>])  👈</p></blockquote><p>拿取迭代器中的元素,一次只拿一个</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>Iter = iter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(Iter)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(Iter)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(Iter)</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(Iter)</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="comment"># 没有元素就会进行报错</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>next(Iter)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">StopIteration</span><br></pre></td></tr></table></figure><blockquote><p><code>iter</code>(<em>object</em>[, <em>sentinel</em>])   👈</p></blockquote><p>创建一个迭代器</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj = iter([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>obj</span><br><span class="line">&lt;list_iterator object at <span class="number">0x0000026DA649D278</span>&gt;</span><br></pre></td></tr></table></figure><h2 id="作用域相关-2个-🍀"><a href="#作用域相关-2个-🍀" class="headerlink" title="作用域相关(2个)  🍀"></a>作用域相关(2个)  🍀</h2><blockquote><p><code>locals</code>()  👈</p></blockquote><p>打印函数局部命名空间</p><blockquote><p><code>globals</code>()   👈</p></blockquote><p>打印函数的全局命名空间</p><h2 id="面向对象相关-8个-🍀"><a href="#面向对象相关-8个-🍀" class="headerlink" title="面向对象相关(8个)  🍀"></a>面向对象相关(8个)  🍀</h2><h3 id="定义类方法-🍀"><a href="#定义类方法-🍀" class="headerlink" title="定义类方法  🍀"></a>定义类方法  🍀</h3><blockquote><p><code>classmethod</code>(<em>function</em>)  👈</p></blockquote><p>返回一个函数的类方法</p><blockquote><p><code>staticmethod</code>(<em>function</em>)   👈</p></blockquote><p>返回一个函数的属性方法</p><blockquote><p><code>property</code>(<em>fget=None</em>, <em>fset=None</em>, <em>fdel=None</em>, <em>doc=None</em>)   👈</p></blockquote><p>返回一个静态属性</p><h3 id="判断类之间的关系-🍀"><a href="#判断类之间的关系-🍀" class="headerlink" title="判断类之间的关系  🍀"></a>判断类之间的关系  🍀</h3><blockquote><p><code>isinstance</code>(<em>object</em>, <em>classinfo</em>)  👈</p></blockquote><p>判断对象的类型,返回bool值,主要用于判断类之间的关心,因为type无法判断类之间的关心</p><blockquote><p><code>issubclass</code>(<em>class</em>, <em>classinfo</em>)   👈</p></blockquote><p>判断一个类是否为另一个类的子类,返回bool值</p><h3 id="所有类的基类-🍀"><a href="#所有类的基类-🍀" class="headerlink" title="所有类的基类  🍀"></a>所有类的基类  🍀</h3><blockquote><p><em>class</em><code>object</code>   👈</p></blockquote><p>返回一个基类,不接收任何参数</p><h3 id="类的继承-🍀"><a href="#类的继承-🍀" class="headerlink" title="类的继承  🍀"></a>类的继承  🍀</h3><blockquote><p><code>super</code>([<em>type</em>[, <em>object-or-type</em>]])  👈</p></blockquote><p>用于继承父类</p><h3 id="封装-🍀"><a href="#封装-🍀" class="headerlink" title="封装  🍀"></a>封装  🍀</h3><blockquote><p><code>vars</code>([<em>object</em>])  👈</p></blockquote><p>返回一个对象中包含的属性</p><h2 id="反射相关-4个-🍀"><a href="#反射相关-4个-🍀" class="headerlink" title="反射相关(4个) 🍀"></a>反射相关(4个) 🍀</h2><blockquote><p><code>hasattr</code>(<em>object</em>, <em>name</em>)  &gt; <code>vars</code>([<em>object</em>])  👈</p></blockquote><p>参数是一个对象和一个字符串。如果字符串是对象的一个属性的名称，则结果为True,否则为False</p><blockquote><p><code>getattr</code>(<em>object</em>, <em>name</em>[, <em>default</em>])   &gt; <code>vars</code>([<em>object</em>])  👈</p></blockquote><p>返回对象的命名属性的值,name必须是字符串,如果字符串是对象属性之一的名称,则返回该属性的值</p><blockquote><p><code>setattr</code>(<em>object</em>, <em>name</em>, <em>value</em>)   &gt; <code>vars</code>([<em>object</em>])  👈</p></blockquote><p>为某个对象设置一个属性</p><blockquote><p><code>delattr</code>(<em>object</em>, <em>name</em>)   &gt; <code>vars</code>([<em>object</em>])  👈</p></blockquote><p>删除对象中的属性值</p><h2 id="其他-10个-🍀"><a href="#其他-10个-🍀" class="headerlink" title="其他(10个) 🍀"></a>其他(10个) 🍀</h2><blockquote><p><code>input</code>([<em>prompt</em>])   &gt; <code>vars</code>([<em>object</em>])  👈</p></blockquote><p>交互式输入</p><blockquote><p><code>print</code>(*<em>objects</em>, <em>sep=’ ‘</em>, <em>end=’\n’</em>, <em>file=sys.stdout</em>, <em>flush=False</em>)  &gt; <code>vars</code>([<em>object</em>])  👈</p></blockquote><p>交互式输出</p><blockquote><p><code>open</code>(<em>file</em>, <em>mode=’r’</em>, <em>buffering=-1</em>, <em>encoding=None</em>, <em>errors=None</em>, <em>newline=None</em>, <em>closefd=True</em>, <em>opener=None</em>)   &gt; <code>vars</code>([<em>object</em>])  👈</p></blockquote><p>打开文件</p><blockquote><p><code>help</code>([<em>object</em>])  &gt; <code>vars</code>([<em>object</em>])  👈</p></blockquote><p>查找官方说明</p><blockquote><p><code>hash</code>(<em>object</em>)  &gt; <code>vars</code>([<em>object</em>])  👈</p></blockquote><p>返回一个hash地址</p><blockquote><p><code>callable</code>(<em>object</em>)   &gt; <code>vars</code>([<em>object</em>])  👈</p></blockquote><p>判断一个对象是否可以被调用执行</p><blockquote><p><code>dir</code>([<em>object</em>])  👈</p></blockquote><p>返回一个对象中的所有方法</p><blockquote><p><code>id</code>(<em>object</em>)   👈</p></blockquote><p>返回一个对象的内存地址</p><blockquote><p><code>type</code>(<em>object</em>)</p><p><code>type</code>(<em>name</em>, <em>bases</em>, <em>dict</em>)   👈</p></blockquote><p>查看一个对象的数据类型</p><blockquote><p><code>__import__</code>(<em>name</em>, <em>globals=None</em>, <em>locals=None</em>, <em>fromlist=()</em>, <em>level=0</em>)   👈</p></blockquote><p>该函数是由import进行调用的,我们一般不用</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-内置函数&quot;&gt;&lt;a href=&quot;#Python之路-内置函数&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 内置函数&quot;&gt;&lt;/a&gt;Python之路 - 内置函数&lt;/h1&gt;&lt;h2 id=&quot;str类型代码的执行-3个-🍀&quot;&gt;&lt;a href=&quot;#str类型代码的执行-3个-🍀&quot; class=&quot;headerlink&quot; title=&quot;str类型代码的执行(3个) 🍀&quot;&gt;&lt;/a&gt;str类型代码的执行(3个) 🍀&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;exec&lt;/code&gt;(object[, globals[, locals]])  👈&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将字符串当做表达式去执行，没有返回值&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 流程语句用exec&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;exec(&lt;span class=&quot;string&quot;&gt;&quot;print(&#39;123&#39;)&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;123&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;exec(&lt;span class=&quot;string&quot;&gt;&#39;1+2+3+4&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;res = exec(&lt;span class=&quot;string&quot;&gt;&#39;1+2+3+4&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;eval&lt;/code&gt;(expression, globals=None, locals=None)   👈&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;将字符串当做表达式去执行，并返回执行结果&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 简单求值表达式用eval&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;res = eval(&lt;span class=&quot;string&quot;&gt;&#39;1+2+3+4&#39;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;res&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;10&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;compile&lt;/code&gt;(source, filename, mode, flags=0, dont_inherit=False, optimize=-1)   👈&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="Advanced" scheme="https://jesse.top/categories/python/Advanced/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>08.Python之路 - 集合</title>
    <link href="https://jesse.top/2020/05/27/python/01-basic/08-Python%E4%B9%8B%E8%B7%AF%20-%20%E9%9B%86%E5%90%88/"/>
    <id>https://jesse.top/2020/05/27/python/01-basic/08-Python之路 - 集合/</id>
    <published>2020-05-27T14:59:58.000Z</published>
    <updated>2020-05-27T15:19:45.529Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-集合"><a href="#Python之路-集合" class="headerlink" title="Python之路 - 集合"></a>Python之路 - 集合</h1><h2 id="介绍-🍀"><a href="#介绍-🍀" class="headerlink" title="介绍  🍀"></a>介绍  🍀</h2><p>集合是一个无序的 , 不重复的数据组合 , 它的主要作用如下 : </p><ul><li>去重 , 把一个列表变成集合 , 就自动去重了</li><li>关系测试 , 测试两组数据之间的交集 , 差集 , 并集关系</li></ul><p>在Python 2.7中集合表示如下 : </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br></pre></td></tr></table></figure><p>在Python 3.x 中则是如下 : </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">s1 = &#123;1,2,3,4&#125;</span><br><span class="line">print(s1)</span><br><span class="line">print(type(s1))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; &#123;1, 2, 3, 4&#125;</span><br><span class="line">&lt;class &apos;set&apos;&gt;</span><br></pre></td></tr></table></figure><p>集合支持一系列标准操作 , 包括并集 , 交集 , 差集 , 对称差集</p><h2 id="创建-🍀"><a href="#创建-🍀" class="headerlink" title="创建  🍀"></a>创建  🍀</h2><p>与字符串等数据类型一样 , 集合支持如下方式创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建空集合只能用这种方式,参数为一个可迭代对象</span></span><br><span class="line">s = set()</span><br><span class="line"><span class="comment"># 注意集合是单个元素,字典是键值对</span></span><br><span class="line">s = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="添加-🍀"><a href="#添加-🍀" class="headerlink" title="添加  🍀"></a>添加  🍀</h2><p>为集合添加元素</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义集合</span></span><br><span class="line">s = &#123;<span class="string">'lyon'</span>,<span class="string">'kenneth'</span>&#125;</span><br><span class="line"><span class="comment"># 添加一项</span></span><br><span class="line">s.add(<span class="string">'geek'</span>)</span><br></pre></td></tr></table></figure><p>注意 : 集合不支持 “+”</p><h2 id="更新-🍀"><a href="#更新-🍀" class="headerlink" title="更新  🍀"></a>更新  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义集合</span></span><br><span class="line">s = &#123;<span class="string">'lyon'</span>,<span class="string">'kenneth'</span>&#125;</span><br><span class="line"><span class="comment"># 添加多项,参数为可迭代对象</span></span><br><span class="line">s.update([<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>])</span><br></pre></td></tr></table></figure><h2 id="删除-🍀"><a href="#删除-🍀" class="headerlink" title="删除  🍀"></a>删除  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义集合</span></span><br><span class="line">s = &#123;<span class="string">'lyon'</span>,<span class="string">'kenneth'</span>&#125;</span><br><span class="line"><span class="comment"># 删除一项</span></span><br><span class="line">s.remove(<span class="string">'kenneth'</span>)</span><br><span class="line"><span class="comment"># 清空集合</span></span><br><span class="line">s.clear()</span><br></pre></td></tr></table></figure><h2 id="测试-🍀"><a href="#测试-🍀" class="headerlink" title="测试  🍀"></a>测试  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;</span><br><span class="line">b = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line"><span class="comment"># 测试是否b中的每一个元素都在a中,即 b&lt;=a ,返回bool值</span></span><br><span class="line">b.issubset(a)</span><br><span class="line"><span class="comment"># 测试是否a中的每一个元素都在b中,即 b&gt;=a ,返回bool值</span></span><br><span class="line">b.issuperset(a)</span><br></pre></td></tr></table></figure><h2 id="集合操作-🍀"><a href="#集合操作-🍀" class="headerlink" title="集合操作  🍀"></a>集合操作  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt;a = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">&gt;&gt;&gt;b = &#123;<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;</span><br><span class="line"><span class="comment"># 求并集</span></span><br><span class="line">&gt;&gt;&gt;a.union(b)</span><br><span class="line"><span class="comment"># 同上,求并集</span></span><br><span class="line">&gt;&gt;&gt;a | b</span><br><span class="line"><span class="comment"># 求交集</span></span><br><span class="line">&gt;&gt;&gt;a.intersection(b)</span><br><span class="line"><span class="comment"># 同上,求交集</span></span><br><span class="line">&gt;&gt;&gt;a &amp; b</span><br><span class="line"><span class="comment"># 求差集</span></span><br><span class="line">&gt;&gt;&gt;a.difference(b)</span><br><span class="line"><span class="comment"># 同上,求差集</span></span><br><span class="line">&gt;&gt;&gt;a - b</span><br><span class="line"><span class="comment"># 求对称差集</span></span><br><span class="line">&gt;&gt;&gt;a.symmetric_difference(b)</span><br><span class="line"><span class="comment"># 同上,求对称差集</span></span><br><span class="line">&gt;&gt;&gt;a ^ b</span><br></pre></td></tr></table></figure><p>集合对象所有方法 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">|  add(...)</span><br><span class="line">|      Add an element to a set.</span><br><span class="line">|</span><br><span class="line">|      This has no effect <span class="keyword">if</span> the element <span class="keyword">is</span> already present.</span><br><span class="line">|</span><br><span class="line">|  clear(...)</span><br><span class="line">|      Remove all elements <span class="keyword">from</span> this set.</span><br><span class="line">|</span><br><span class="line">|  copy(...)</span><br><span class="line">|      Return a shallow copy of a set.</span><br><span class="line">|</span><br><span class="line">|  difference(...)</span><br><span class="line">|      Return the difference of two <span class="keyword">or</span> more sets <span class="keyword">as</span> a new set.</span><br><span class="line">|</span><br><span class="line">|      (i.e. all elements that are <span class="keyword">in</span> this set but <span class="keyword">not</span> the others.)</span><br><span class="line">|</span><br><span class="line">|  difference_update(...)</span><br><span class="line">|      Remove all elements of another set <span class="keyword">from</span> this set.</span><br><span class="line">|</span><br><span class="line">|  discard(...)</span><br><span class="line">|      Remove an element <span class="keyword">from</span> a set <span class="keyword">if</span> it <span class="keyword">is</span> a member.</span><br><span class="line">|</span><br><span class="line">|      If the element <span class="keyword">is</span> <span class="keyword">not</span> a member, do nothing.</span><br><span class="line">|</span><br><span class="line">|  intersection(...)</span><br><span class="line">|      Return the intersection of two sets <span class="keyword">as</span> a new set.</span><br><span class="line">|</span><br><span class="line">|      (i.e. all elements that are <span class="keyword">in</span> both sets.)</span><br><span class="line">|</span><br><span class="line">|  intersection_update(...)</span><br><span class="line">|      Update a set <span class="keyword">with</span> the intersection of itself <span class="keyword">and</span> another.</span><br><span class="line">|</span><br><span class="line">|  isdisjoint(...)</span><br><span class="line">|      Return <span class="keyword">True</span> <span class="keyword">if</span> two sets have a null intersection.</span><br><span class="line">|</span><br><span class="line">|  issubset(...)</span><br><span class="line">|      Report whether another set contains this set.</span><br><span class="line">|</span><br><span class="line">|  issuperset(...)</span><br><span class="line">|      Report whether this set contains another set.</span><br><span class="line">|</span><br><span class="line">|  pop(...)</span><br><span class="line">|      Remove <span class="keyword">and</span> <span class="keyword">return</span> an arbitrary set element.</span><br><span class="line">|      Raises KeyError <span class="keyword">if</span> the set <span class="keyword">is</span> empty.</span><br><span class="line">|</span><br><span class="line">|  remove(...)</span><br><span class="line">|      Remove an element <span class="keyword">from</span> a set; it must be a member.</span><br><span class="line">|</span><br><span class="line">|      If the element <span class="keyword">is</span> <span class="keyword">not</span> a member, <span class="keyword">raise</span> a KeyError.</span><br><span class="line">|</span><br><span class="line">|  symmetric_difference(...)</span><br><span class="line">|      Return the symmetric difference of two sets <span class="keyword">as</span> a new set.</span><br><span class="line">|</span><br><span class="line">|      (i.e. all elements that are <span class="keyword">in</span> exactly one of the sets.)</span><br><span class="line">|</span><br><span class="line">|  symmetric_difference_update(...)</span><br><span class="line">|      Update a set <span class="keyword">with</span> the symmetric difference of itself <span class="keyword">and</span> another.</span><br><span class="line">|</span><br><span class="line">|  union(...)</span><br><span class="line">|      Return the union of sets <span class="keyword">as</span> a new set.</span><br><span class="line">|</span><br><span class="line">|      (i.e. all elements that are <span class="keyword">in</span> either set.)</span><br><span class="line">|</span><br><span class="line">|  update(...)</span><br><span class="line">|      Update a set <span class="keyword">with</span> the union of itself <span class="keyword">and</span> others.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-集合&quot;&gt;&lt;a href=&quot;#Python之路-集合&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 集合&quot;&gt;&lt;/a&gt;Python之路 - 集合&lt;/h1&gt;&lt;h2 id=&quot;介绍-🍀&quot;&gt;&lt;a href=&quot;#介绍-🍀&quot; class=&quot;headerlink&quot; title=&quot;介绍  🍀&quot;&gt;&lt;/a&gt;介绍  🍀&lt;/h2&gt;&lt;p&gt;集合是一个无序的 , 不重复的数据组合 , 它的主要作用如下 : &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;去重 , 把一个列表变成集合 , 就自动去重了&lt;/li&gt;
&lt;li&gt;关系测试 , 测试两组数据之间的交集 , 差集 , 并集关系&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Python 2.7中集合表示如下 : &lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;set([&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;])&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在Python 3.x 中则是如下 : &lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;s1 = &amp;#123;1,2,3,4&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(s1)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;print(type(s1))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &amp;#123;1, 2, 3, 4&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;class &amp;apos;set&amp;apos;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;集合支持一系列标准操作 , 包括并集 , 交集 , 差集 , 对称差集&lt;/p&gt;
&lt;h2 id=&quot;创建-🍀&quot;&gt;&lt;a href=&quot;#创建-🍀&quot; class=&quot;headerlink&quot; title=&quot;创建  🍀&quot;&gt;&lt;/a&gt;创建  🍀&lt;/h2&gt;&lt;p&gt;与字符串等数据类型一样 , 集合支持如下方式创建&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 创建空集合只能用这种方式,参数为一个可迭代对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s = set()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 注意集合是单个元素,字典是键值对&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;s = &amp;#123;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;,&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="basic" scheme="https://jesse.top/categories/python/basic/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>03.Python之路 - Python运算符</title>
    <link href="https://jesse.top/2020/05/27/python/01-basic/03-Python%E4%B9%8B%E8%B7%AF-%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <id>https://jesse.top/2020/05/27/python/01-basic/03-Python之路-运算符/</id>
    <published>2020-05-27T14:59:58.000Z</published>
    <updated>2020-05-27T15:18:45.502Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Python运算符"><a href="#Python运算符" class="headerlink" title="Python运算符"></a>Python运算符</h2><h3 id="Python支持以下运算符"><a href="#Python支持以下运算符" class="headerlink" title="Python支持以下运算符"></a>Python支持以下运算符</h3><h3 id="算数运算符"><a href="#算数运算符" class="headerlink" title="算数运算符"></a>算数运算符</h3><p>以下假设变量： <strong>a=10，b=20</strong>：</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>+</td><td>加 - 两个对象相加</td><td>a + b 输出结果 30</td></tr><tr><td>-</td><td>减 - 得到负数或是一个数减去另一个数</td><td>a - b 输出结果 -10</td></tr><tr><td>*</td><td>乘 - 两个数相乘或是返回一个被重复若干次的字符串</td><td>a * b 输出结果 200</td></tr><tr><td>/</td><td>除 - x除以y</td><td>b / a 输出结果 2</td></tr><tr><td>%</td><td>取模 - 返回除法的余数</td><td>b % a 输出结果 0</td></tr><tr><td>**</td><td>幂 - 返回x的y次幂</td><td>a**b 为10的20次方， 输出结果 100000000000000000000</td></tr></tbody></table><a id="more"></a><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>==</td><td>等于</td><td>(10 == 20)返回Flase</td></tr><tr><td>!=</td><td>不等于</td><td>(10 != 20)返回True</td></tr><tr><td>&gt;</td><td>大于</td><td>(10 &gt; 20)返回Flase</td></tr><tr><td>&lt;</td><td>小于</td><td>(10 &lt; 20)返回True</td></tr><tr><td>&gt;=</td><td>大于等于</td><td>(10 &gt;= 20)返回Flase</td></tr><tr><td>&lt;=</td><td>小于等于</td><td>(10 &lt;= 20)返回True</td></tr></tbody></table><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">a = 10</span><br><span class="line">b = 20</span><br><span class="line"></span><br><span class="line">print(a == b)</span><br><span class="line">print(a &lt; b)</span><br><span class="line">print(a &gt; b)</span><br><span class="line">print(a != b)</span><br><span class="line">print(a &gt;= b)</span><br><span class="line">print(a &lt;= b)</span><br></pre></td></tr></table></figure><p>执行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">False</span><br><span class="line">True</span><br><span class="line">False</span><br><span class="line">True</span><br><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure><hr><h3 id="python赋值运算符"><a href="#python赋值运算符" class="headerlink" title="python赋值运算符"></a>python赋值运算符</h3><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>=</td><td>简单的赋值运算符</td><td>c = a + b 将 a + b 的运算结果赋值为 c</td></tr><tr><td>+=</td><td>加法赋值运算符</td><td>c += a 等效于 c = c + a</td></tr><tr><td>-=</td><td>减法赋值运算符</td><td>c -= a 等效于 c = c - a</td></tr><tr><td>*=</td><td>乘法赋值运算符</td><td>c <em>= a 等效于 c = c </em> a</td></tr><tr><td>/=</td><td>除法赋值运算符</td><td>c /= a 等效于 c = c / a</td></tr><tr><td>%=</td><td>取模赋值运算符</td><td>c %= a 等效于 c = c % a</td></tr><tr><td>**=</td><td>幂赋值运算符</td><td>c <strong>= a 等效于 c = c </strong> a</td></tr><tr><td>//=</td><td>取整除赋值运算符</td><td>c //= a 等效于 c = c // a</td></tr></tbody></table><hr><h3 id="Python逻辑运算符"><a href="#Python逻辑运算符" class="headerlink" title="Python逻辑运算符"></a>Python逻辑运算符</h3><p>Python语言支持逻辑运算符，以下假设变量 a 为 10, b为 20:</p><table><thead><tr><th>运算符</th><th>逻辑表达式</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>and</td><td>x and y</td><td>布尔”与” - 如果 x 为 False，x and y 返回 False，否则它返回 y 的计算值。</td><td>(a and b) 返回 20。</td></tr><tr><td>or</td><td>x or y</td><td>布尔”或”    - 如果 x 是非 0，它返回 x 的值，否则它返回 y 的计算值。</td><td>(a or b) 返回 10。</td></tr><tr><td>not</td><td>not x</td><td>布尔”非” - 如果 x 为 True，返回 False 。如果 x 为 False，它返回 True。</td><td>not(a and b) 返回 False</td></tr></tbody></table><p>代码示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">a = 10</span><br><span class="line">b = 20</span><br><span class="line"></span><br><span class="line">print(a and b)</span><br><span class="line">print(a or b)</span><br><span class="line">print(not a)</span><br><span class="line">print(not (a and b))</span><br><span class="line">print(not (a or b))</span><br><span class="line"></span><br><span class="line">a=0</span><br><span class="line">print(&quot;#######################&quot;)</span><br><span class="line">print(a and b)</span><br><span class="line">print(a or b)</span><br><span class="line">print(not a)</span><br><span class="line">print(not (a and b))</span><br><span class="line">print(not (a or b))</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">20  #由于a为tru.则返回y</span><br><span class="line">10  # 由于a为true, 则返回a</span><br><span class="line">False #a为true,返回false</span><br><span class="line">False #a and b的结果是20,为true.所以返回false</span><br><span class="line">False #a or b的结果是10,为true.所以返回false</span><br><span class="line">#######################</span><br><span class="line">0</span><br><span class="line">20</span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure><hr><h2 id="Python成员运算符"><a href="#Python成员运算符" class="headerlink" title="Python成员运算符"></a>Python成员运算符</h2><p>除了以上的一些运算符之外，Python还支持成员运算符，测试实例中包含了一系列的成员，包括字符串，列表或元组。</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>in</td><td>如果在指定的序列中找到值返回 True，否则返回 False。</td><td>x 在 y 序列中 , 如果 x 在 y 序列中返回 True。</td></tr><tr><td>not in</td><td>如果在指定的序列中没有找到值返回 True，否则返回 False。</td><td>x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True。</td></tr></tbody></table><p>代码示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#成员运算符</span><br><span class="line"></span><br><span class="line">a=&quot;abc&quot;</span><br><span class="line">b=&quot;abcdsdfwe&quot;</span><br><span class="line"></span><br><span class="line">print(a in b)</span><br><span class="line"></span><br><span class="line">a=&quot;abd&quot;</span><br><span class="line">b=&quot;abcdefg&quot;</span><br><span class="line">print(a in b)</span><br></pre></td></tr></table></figure><p>执行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure><hr><h2 id="Python身份运算符"><a href="#Python身份运算符" class="headerlink" title="Python身份运算符"></a>Python身份运算符</h2><p>身份运算符用于比较两个对象的存储单元</p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">描述</th><th style="text-align:left">实例</th></tr></thead><tbody><tr><td style="text-align:left">is</td><td style="text-align:left">is 是判断两个标识符是不是引用自一个对象</td><td style="text-align:left"><strong>x is y</strong>, 类似 <strong>id(x) == id(y)</strong> , 如果引用的是同一个对象则返回 True，否则返回 False</td></tr><tr><td style="text-align:left">is not</td><td style="text-align:left">is not 是判断两个标识符是不是引用自不同对象</td><td style="text-align:left"><strong>x is not y</strong> ， 类似 <strong>id(a) != id(b)</strong>。如果引用的不是同一个对象则返回结果 True，否则返回 False。</td></tr></tbody></table><blockquote><p><a href="http://www.runoob.com/python/python-func-id.html" target="_blank" rel="noopener">id()</a> 函数用于获取对象内存地址。</p></blockquote><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a = 10</span><br><span class="line">b = 20</span><br><span class="line"></span><br><span class="line">print (a is b)</span><br><span class="line"></span><br><span class="line">b = 10</span><br><span class="line"></span><br><span class="line">print (a is b)</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>通过id函数可以看到a和b变量的内存地址</p><p>代码示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = 10</span><br><span class="line">b = 10</span><br><span class="line"></span><br><span class="line">print(id(a))</span><br><span class="line">print(id(b))</span><br></pre></td></tr></table></figure><p>执行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">140190848944752</span><br><span class="line">140190848944752</span><br></pre></td></tr></table></figure><blockquote><p>is 与 == 区别：</p><p>is 用于判断两个变量引用对象是否为同一个(同一块内存空间)， == 用于判断引用变量的值是否相等。</p></blockquote><p>代码示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># is 和 ==的区别</span><br><span class="line"></span><br><span class="line">print &quot;#####下面这个情况,b和a指向同样的内存地址空间#########&quot;</span><br><span class="line">a = [1,2,3]</span><br><span class="line">b = a</span><br><span class="line">print (a == b)</span><br><span class="line">print(a is b)</span><br><span class="line"></span><br><span class="line">print &quot;#########下面这2种情况,虽然b和a的值完全一样,但是不是同一个内存地址空间########&quot;</span><br><span class="line">a = [1,2,3]</span><br><span class="line">b = [1,2,3]</span><br><span class="line"></span><br><span class="line">print (a == b)</span><br><span class="line">print(a is b)</span><br><span class="line"></span><br><span class="line">print &quot;#########下面这种情况也是一样########&quot;</span><br><span class="line">b=a[:]</span><br><span class="line">print b</span><br><span class="line">print(a == b)</span><br><span class="line">print(a is b)</span><br></pre></td></tr></table></figure><p>执行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#####下面这个情况,b和a指向同样的内存地址空间#########</span><br><span class="line">True</span><br><span class="line">True</span><br><span class="line">#########下面这2种情况,虽然b和a的值完全一样,但是不是同一个内存地址空间########</span><br><span class="line">True</span><br><span class="line">False</span><br><span class="line">#########下面这种情况也是一样########</span><br><span class="line">[1, 2, 3]</span><br><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Python运算符&quot;&gt;&lt;a href=&quot;#Python运算符&quot; class=&quot;headerlink&quot; title=&quot;Python运算符&quot;&gt;&lt;/a&gt;Python运算符&lt;/h2&gt;&lt;h3 id=&quot;Python支持以下运算符&quot;&gt;&lt;a href=&quot;#Python支持以下运算符&quot; class=&quot;headerlink&quot; title=&quot;Python支持以下运算符&quot;&gt;&lt;/a&gt;Python支持以下运算符&lt;/h3&gt;&lt;h3 id=&quot;算数运算符&quot;&gt;&lt;a href=&quot;#算数运算符&quot; class=&quot;headerlink&quot; title=&quot;算数运算符&quot;&gt;&lt;/a&gt;算数运算符&lt;/h3&gt;&lt;p&gt;以下假设变量： &lt;strong&gt;a=10，b=20&lt;/strong&gt;：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;运算符&lt;/th&gt;
&lt;th&gt;描述&lt;/th&gt;
&lt;th&gt;实例&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;加 - 两个对象相加&lt;/td&gt;
&lt;td&gt;a + b 输出结果 30&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;-&lt;/td&gt;
&lt;td&gt;减 - 得到负数或是一个数减去另一个数&lt;/td&gt;
&lt;td&gt;a - b 输出结果 -10&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;乘 - 两个数相乘或是返回一个被重复若干次的字符串&lt;/td&gt;
&lt;td&gt;a * b 输出结果 200&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;/&lt;/td&gt;
&lt;td&gt;除 - x除以y&lt;/td&gt;
&lt;td&gt;b / a 输出结果 2&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;%&lt;/td&gt;
&lt;td&gt;取模 - 返回除法的余数&lt;/td&gt;
&lt;td&gt;b % a 输出结果 0&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;**&lt;/td&gt;
&lt;td&gt;幂 - 返回x的y次幂&lt;/td&gt;
&lt;td&gt;a**b 为10的20次方， 输出结果 100000000000000000000&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="basic" scheme="https://jesse.top/categories/python/basic/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>09.Python之路 - 字符编码</title>
    <link href="https://jesse.top/2020/05/27/python/01-basic/09-Python%E4%B9%8B%E8%B7%AF%20-%20%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81/"/>
    <id>https://jesse.top/2020/05/27/python/01-basic/09-Python之路 - 字符编码/</id>
    <published>2020-05-27T14:59:58.000Z</published>
    <updated>2020-05-27T15:19:56.297Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-字符编码"><a href="#Python之路-字符编码" class="headerlink" title="Python之路 - 字符编码"></a>Python之路 - 字符编码</h1><h2 id="介绍-🍀"><a href="#介绍-🍀" class="headerlink" title="介绍  🍀"></a>介绍  🍀</h2><p><strong>字符编码</strong></p><p>字符编码 (Character encoding) 也称字集码 , 它是一套<strong>法则</strong> , 使用该法则能够对自然语言的字符的一个集合 (如字母表或音节表) , 与其他东西的一个集合 (如号码或电脉冲) 进行配对 , 即在符号集合与数字系统之间建立对应关系</p><p>再简单一点说其实就是一张具有对应关系的表格 , 如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+----+-----------+</span><br><span class="line">| id | character | </span><br><span class="line">+----+-----------+</span><br><span class="line">| 65 |     A     | </span><br><span class="line">| 66 |     B     | </span><br><span class="line">| 67 |     C     | </span><br><span class="line">+----+-----------+</span><br></pre></td></tr></table></figure><p>如上表所示 , 这就是一套法则 , 使我们用数字成功的表示了字符</p><blockquote><p><em>为什么要一套这样的法则 ?</em></p></blockquote><p>众所周知 , 计算机只认识机器码 , 也就是一堆0101之类的二进制数字 , 计算机并不认识我们的 “A” , “B” ,”C” , 我们为了使其友好的显示 , 就需要一套这样的法则 , 来完成这些转换 , 于是两个名词诞生了</p><p><strong>编码</strong> </p><p>通俗的说 , 就是按照何种规则将字符存储在计算机中 . 比如 “A” 用65表示 , 也就是把字符”A”以二进制的方式存储在计算机中</p><p><strong>解码</strong> </p><p> 反之 , 将存储在计算机中的二进制数解析显示出来 , 这就是解码</p><p>在Python中</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''既然是对于字符,那么自然对应着Python中的字符串了'''</span></span><br><span class="line"><span class="string">'''Python中提供了两个函数来完成编码和解码'''</span></span><br><span class="line"><span class="comment"># 编码函数encode()</span></span><br><span class="line">encode()  </span><br><span class="line">character  →  byte</span><br><span class="line"><span class="comment"># 解码函数decode()</span></span><br><span class="line">byte  →  character</span><br></pre></td></tr></table></figure><p><strong>PS : 必须采用相对应的法则 , 否则就会出错 , 也就是我们常说的乱码</strong></p><p>最后还有一个名词 , 字符集</p><p><strong>字符集</strong></p><p>是一个系统支持的所有抽象字符的集合 , 字符是各种文字和符号的总称 , 包括各国家文字、标点符号、图形符号、数字等</p><p>字符编码就是在字符集与数字系统之间建立的对应关系</p><a id="more"></a><h2 id="ASCII-🍀"><a href="#ASCII-🍀" class="headerlink" title="ASCII  🍀"></a>ASCII  🍀</h2><p>ASCII (American Standard Code for Information Interchange , 美国信息交换标准码) , 是基于拉丁字母的一套电脑编码系统 , 主要用于显示现代英语</p><p>ASCII字符集 : 主要包括控制字符 (回车键 , 退格 , 换行键等) , 可显示字符 (英文大小写字符 , 阿拉伯数字和西文符号)</p><p>ASCII编码 : 将ASCII字符集转换为计算机可以接收的数字系统的数的规则 , 使用7位(Bit)表示一个字符 , <code>1 Byte = 8 Bit</code>  , 一共可以表示128(2的7次方)个字符</p><p>具体ASCII字符集映射到数字编码规则可以自行查询</p><h2 id="ANSI-🍀"><a href="#ANSI-🍀" class="headerlink" title="ANSI  🍀"></a>ANSI  🍀</h2><p>ANSI编码为在ASCII编码(7位)的基础上 , 将其最后一位也使用上 , 即使用8位</p><p>ANSI使使计算机支持更多语言 , 通常对于没超过128的即用ASCII编码 , 超过的即用扩展的ASCII编码ANSI </p><p>当然不同的国家和地区指定了不同的标准 , 由此产生了GB2312、GBK、GB18030、Big5、Shift_JIS 等各自的编码标准</p><p>在简体中文Windows操作系统中 , ANSI 编码代表 GBK 编码 ; 在繁体中文Windows操作系统中 , ANSI编码代表Big5 ; 在日文Windows操作系统中 , ANSI 编码代表 Shift_JIS 编码</p><h2 id="GBXXX-🍀"><a href="#GBXXX-🍀" class="headerlink" title="GBXXX  🍀"></a>GBXXX  🍀</h2><p><strong>GB2312编码</strong></p><p>计算机发明之初及后面很长一段时间 , 只应用于美国及西方一些发达国家 , 于是到中国时 , 一个字节8位 , 256个字符是远远不能满足的 , 要想想中国有多少汉字 , 于是聪明的中国人这样规定 : </p><p><strong>一个小于127的字符的意义与原来相同 , 但是两个大于127的字符连在一起时 , 就表示一个汉字</strong> , 前面的一个字节称为高字节 , 后面的为低字节 , 这样就组合出了大约7000多个简体汉字了 , 这就是<code>GB2312</code> ,全称 <code>信息交换用汉字编码字符集 ▪ 基本集</code> </p><p><strong>GB18030</strong></p><p>由于7000多个汉字还是不够用 , 于是继续改进 , 每个汉字可以由1个 , 2个或4个字节组成 , 于是庞大的编码空间形成了 , 最多可以定义161万个字符 , 这就是<code>GB18030</code> , 全称 <code>信息技术中文编码字符集</code> </p><h2 id="Unicode-🍀"><a href="#Unicode-🍀" class="headerlink" title="Unicode  🍀"></a>Unicode  🍀</h2><p>各种各样的字符编码都出来了 , 大家各用各的 , 那么问题就来了 , 一旦出现在网络上 , 由于不兼容 , 互相访问就出现了乱码现象 , 为了解决这个问题 , Unicode编码系统应运而生</p><p>Unicode编码系统为表达任意语言的任意字符而设计 , 它使用2字节的数字来表达每个字母 , 符号 , 或者表意文字 , 每个数字代表唯一的至少在某种语言中使用的符号 (并不是所有的数字都用上了 , 但是总数已经超过了65535  所以2个字节的数字是不够用的)</p><p>总而言之 , Unicode是业界的一种标准 , 也叫做统一码 , 万国码 , 单一码 , 标准万国码</p><p>所以Unicode编码也成为了一个编码转换的基础 , 因为大家都支持他 , 从一种编码到另一中编码 , 只需要Unicode在中间搭桥就能简单的实现了</p><p><strong>UTF - 8</strong></p><p>对于Unicode来讲 , 任何字符都使用2个字节来存储 , 这明显是很浪费内存的 , 因为我们编写代码时 , 用到中文毕竟极少 , 所以为了节省内存 , 就有了<code>UTF-8</code> , UTF - 8规定 , 英文只使用1个字节 , 中文使用3个字节</p><p>虽然说UTF - 8具有良好的国际兼容性 , 但中文需要比GBK/BIG5版本多占用50%的数据库存储空间 , 因此并不推荐使用</p><h2 id="Python编码处理-🍀"><a href="#Python编码处理-🍀" class="headerlink" title="Python编码处理  🍀"></a>Python编码处理  🍀</h2><p>在Python3中 , 源代码读取进行语法校验时 , 会将源代码中的字符串从声明的编码转换成Unicode类型 , 等到语法校验通过后 , 再将这些字符换回初始的编码 , 这也就是说 , Python3中 , 字符串默认编码就是Unicode , 这也是Python受欢迎的原因之一</p><p>查看默认编码</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> sys</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>sys.getdefaultencoding()</span><br></pre></td></tr></table></figure><p><strong>PS : Windows下命令行的字符编码默认是GBK ; 并且Python2中 , 字符串是有两种类型的 , 这里不多说明</strong></p><p>关于Python 2.x 与Python 3.x中乱码处理见后续文章</p><h2 id="编码-解码练习"><a href="#编码-解码练习" class="headerlink" title="编码,解码练习"></a>编码,解码练习</h2>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-字符编码&quot;&gt;&lt;a href=&quot;#Python之路-字符编码&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 字符编码&quot;&gt;&lt;/a&gt;Python之路 - 字符编码&lt;/h1&gt;&lt;h2 id=&quot;介绍-🍀&quot;&gt;&lt;a href=&quot;#介绍-🍀&quot; class=&quot;headerlink&quot; title=&quot;介绍  🍀&quot;&gt;&lt;/a&gt;介绍  🍀&lt;/h2&gt;&lt;p&gt;&lt;strong&gt;字符编码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;字符编码 (Character encoding) 也称字集码 , 它是一套&lt;strong&gt;法则&lt;/strong&gt; , 使用该法则能够对自然语言的字符的一个集合 (如字母表或音节表) , 与其他东西的一个集合 (如号码或电脉冲) 进行配对 , 即在符号集合与数字系统之间建立对应关系&lt;/p&gt;
&lt;p&gt;再简单一点说其实就是一张具有对应关系的表格 , 如下&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;+----+-----------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| id | character | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+----+-----------+&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| 65 |     A     | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| 66 |     B     | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;| 67 |     C     | &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;+----+-----------+&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如上表所示 , 这就是一套法则 , 使我们用数字成功的表示了字符&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;为什么要一套这样的法则 ?&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;众所周知 , 计算机只认识机器码 , 也就是一堆0101之类的二进制数字 , 计算机并不认识我们的 “A” , “B” ,”C” , 我们为了使其友好的显示 , 就需要一套这样的法则 , 来完成这些转换 , 于是两个名词诞生了&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;编码&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt;通俗的说 , 就是按照何种规则将字符存储在计算机中 . 比如 “A” 用65表示 , 也就是把字符”A”以二进制的方式存储在计算机中&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;解码&lt;/strong&gt; &lt;/p&gt;
&lt;p&gt; 反之 , 将存储在计算机中的二进制数解析显示出来 , 这就是解码&lt;/p&gt;
&lt;p&gt;在Python中&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;既然是对于字符,那么自然对应着Python中的字符串了&#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;Python中提供了两个函数来完成编码和解码&#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 编码函数encode()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;encode()  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;character  →  byte&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 解码函数decode()&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;byte  →  character&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;strong&gt;PS : 必须采用相对应的法则 , 否则就会出错 , 也就是我们常说的乱码&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;最后还有一个名词 , 字符集&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字符集&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;是一个系统支持的所有抽象字符的集合 , 字符是各种文字和符号的总称 , 包括各国家文字、标点符号、图形符号、数字等&lt;/p&gt;
&lt;p&gt;字符编码就是在字符集与数字系统之间建立的对应关系&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="basic" scheme="https://jesse.top/categories/python/basic/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>05.Python之路 - 元组</title>
    <link href="https://jesse.top/2020/05/27/python/01-basic/05-Python%E4%B9%8B%E8%B7%AF%20-%20%E5%85%83%E7%BB%84/"/>
    <id>https://jesse.top/2020/05/27/python/01-basic/05-Python之路 - 元组/</id>
    <published>2020-05-27T14:59:58.000Z</published>
    <updated>2020-05-27T15:19:16.299Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-元组"><a href="#Python之路-元组" class="headerlink" title="Python之路 - 元组"></a>Python之路 - 元组</h1><h2 id="介绍-🍀"><a href="#介绍-🍀" class="headerlink" title="介绍  🍀"></a>介绍  🍀</h2><p>元组和字符串一样 , 元组也是不可修改的 , 元组使用小括号</p><p>元组的创建很简单 , 只需要在括号中添加元素 , 并使用逗号隔开即可</p><p>元组需要掌握的分别有<strong>创建、访问、修改、切片、删除、检测等</strong></p><h2 id="创建-🍀"><a href="#创建-🍀" class="headerlink" title="创建  🍀"></a>创建  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个带有元素的元组</span></span><br><span class="line">mytuple = (<span class="string">"Lyon"</span>, <span class="string">"Alex"</span>, <span class="string">"Leon"</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 也可以不加括号,但是一定要加引号</span></span><br><span class="line">mytuple = <span class="string">"Lyon"</span>, <span class="string">"Alex"</span>, <span class="string">"Leon"</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line"><span class="comment"># 创建一个空元组</span></span><br><span class="line">mytuple = ()</span><br><span class="line"><span class="comment"># 当元组中只有一个元素,加逗号来消除歧义哟,这是一个好习惯,因为()既可以表示tuple又可以表示数学公式中的小括号</span></span><br><span class="line">only_one = (<span class="string">"Lyon"</span>,)</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="访问-🍀"><a href="#访问-🍀" class="headerlink" title="访问  🍀"></a>访问  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个元组</span></span><br><span class="line">names = (<span class="string">"Lyon"</span>, <span class="string">"Alex"</span>, <span class="string">"Leon"</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 访问元组中的第一个元素并打印结果,下标索也是从0开始</span></span><br><span class="line">print(names[<span class="number">0</span>]) </span><br><span class="line"><span class="comment"># 访问元组中第一和第二个元素并打印结果</span></span><br><span class="line">print(names[<span class="number">0</span>:<span class="number">2</span>])</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">打印结果:</span></span><br><span class="line"><span class="string">Lyon</span></span><br><span class="line"><span class="string">('Lyon', 'Alex')</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>注意 : 结果发现访问单个元素结果是字符串类型 , 而多个则是元组类型</p><p>字符串中每个字符就是一个元素 , 而元组中则是一个数字或者一个字符串就是一个元素</p><h2 id="修改-🍀"><a href="#修改-🍀" class="headerlink" title="修改  🍀"></a>修改  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个元组</span></span><br><span class="line">tuple_name = (<span class="string">"Lyon"</span>, <span class="string">"Alex"</span>, <span class="string">"Leon"</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment"># 创建另一个元组</span></span><br><span class="line">tuple_num = (<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment"># 生成一个新的元组</span></span><br><span class="line">tuple_total = tuple_name + tuple_num</span><br><span class="line"><span class="comment"># 打印tuple_total</span></span><br><span class="line">print(tuple_total) </span><br><span class="line"><span class="comment"># 复制元组内元素一次</span></span><br><span class="line">tuple_total = tuple_name * <span class="number">2</span></span><br><span class="line"><span class="comment"># 打印tuple_total看结果</span></span><br><span class="line">print(tuple_total)     </span><br><span class="line"><span class="comment"># 在列表中可以通过索引取值后进行修改,但是元组里面是非法的哦</span></span><br><span class="line">tuple_name[<span class="number">0</span>] = <span class="string">"lyon"</span>      <span class="comment"># 这里直接就报错</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">打印结果:</span></span><br><span class="line"><span class="string">('Lyon', 'Alex', 'Leon', 1, 2, 3, 1, 2, 3, 4, 5)</span></span><br><span class="line"><span class="string">('Lyon', 'Alex', 'Leon', 1, 2, 3, 'Lyon', 'Alex', 'Leon', 1, 2, 3)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>注意 : 元组是不可变的 , 所以对于所有的修改操作 , 都是在根据原元组生成了一个新的元组</p><h2 id="删除-🍀"><a href="#删除-🍀" class="headerlink" title="删除  🍀"></a>删除  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建一个元组</span></span><br><span class="line">names = (<span class="string">"Lyon"</span>, <span class="string">"Alex"</span>, <span class="string">"Leon"</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">#元祖可以被整个删除,但是不能删除元祖的元素</span></span><br><span class="line"><span class="keyword">del</span> names</span><br><span class="line"><span class="keyword">del</span> names[<span class="number">0</span>] </span><br><span class="line"><span class="comment"># TypeError: 'tuple' object doesn't support item deletion</span></span><br></pre></td></tr></table></figure><h2 id="切片-🍀"><a href="#切片-🍀" class="headerlink" title="切片  🍀"></a>切片  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">names = (<span class="string">"Lyon"</span>, <span class="string">"Kenneth"</span>, <span class="string">"Leon"</span>, <span class="string">"Charlie"</span>)</span><br><span class="line"><span class="comment"># 打印子集,第二个至第三个</span></span><br><span class="line">print(names[<span class="number">1</span>:<span class="number">2</span>])</span><br><span class="line"><span class="comment"># 打印子集,倒数第三个(即第二个)至第三个</span></span><br><span class="line">print(names[<span class="number">-3</span>:<span class="number">3</span>])</span><br><span class="line"><span class="comment"># 打印子集,第一个至第三个,隔一个取一个</span></span><br><span class="line">print(names[<span class="number">0</span>:<span class="number">2</span>:<span class="number">1</span>])</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">打印结果:</span></span><br><span class="line"><span class="string">('Kenneth', 'Leon')</span></span><br><span class="line"><span class="string">('Kenneth', 'Leon')</span></span><br><span class="line"><span class="string">('Leon',)</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="检测-🍀"><a href="#检测-🍀" class="headerlink" title="检测  🍀"></a>检测  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个元组</span></span><br><span class="line">tuple_name = (<span class="string">"Lyon"</span>,<span class="string">"Alex"</span>,<span class="string">"Leon"</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># "Lyon"是否在tuple_name中，打印结果</span></span><br><span class="line">print(<span class="string">"Lyon"</span> <span class="keyword">in</span> tuple_name)</span><br><span class="line"><span class="comment"># 打印结果:True</span></span><br></pre></td></tr></table></figure><h2 id="更多-🍀"><a href="#更多-🍀" class="headerlink" title="更多  🍀"></a>更多  🍀</h2><p>实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个元组</span></span><br><span class="line">tuple_name = (<span class="string">"Lyon"</span>,<span class="string">"Alex"</span>,<span class="string">"Leon"</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"><span class="comment"># 计算元组长度</span></span><br><span class="line">tuple_len = len(tuple_name)     </span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line">print(tuple_len)     </span><br><span class="line"><span class="comment"># 创建一个元素全为数字的元组</span></span><br><span class="line">tuple_num = (<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="comment"># 返回元组中的最大值</span></span><br><span class="line">print(max(tuple_num))      </span><br><span class="line"><span class="comment"># 返回元组中的最小值</span></span><br><span class="line">print(min(tuple_num))     </span><br><span class="line"><span class="comment"># 创建一个列表</span></span><br><span class="line">list_name = [<span class="string">"Lyon"</span>,<span class="string">"Alex"</span>,<span class="string">"Leon"</span>]</span><br><span class="line"><span class="comment"># 将列表转换为元组</span></span><br><span class="line">tuple_names = tuple(list_name)</span><br><span class="line"><span class="comment"># 打印tuple_names</span></span><br><span class="line">print(tuple_names)     </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">打印结果:</span></span><br><span class="line"><span class="string">6</span></span><br><span class="line"><span class="string">5</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">('Lyon', 'Alex', 'Leon')</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">|  count(...)</span><br><span class="line">|      T.count(value) -&gt; integer -- return number of occurrences of value</span><br><span class="line">|</span><br><span class="line">|  index(...)</span><br><span class="line">|      T.index(value, [start, [stop]]) -&gt; integer -- return first index of value.</span><br><span class="line">|      Raises ValueError <span class="keyword">if</span> the value <span class="keyword">is</span> <span class="keyword">not</span> present.</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-元组&quot;&gt;&lt;a href=&quot;#Python之路-元组&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 元组&quot;&gt;&lt;/a&gt;Python之路 - 元组&lt;/h1&gt;&lt;h2 id=&quot;介绍-🍀&quot;&gt;&lt;a href=&quot;#介绍-🍀&quot; class=&quot;headerlink&quot; title=&quot;介绍  🍀&quot;&gt;&lt;/a&gt;介绍  🍀&lt;/h2&gt;&lt;p&gt;元组和字符串一样 , 元组也是不可修改的 , 元组使用小括号&lt;/p&gt;
&lt;p&gt;元组的创建很简单 , 只需要在括号中添加元素 , 并使用逗号隔开即可&lt;/p&gt;
&lt;p&gt;元组需要掌握的分别有&lt;strong&gt;创建、访问、修改、切片、删除、检测等&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;创建-🍀&quot;&gt;&lt;a href=&quot;#创建-🍀&quot; class=&quot;headerlink&quot; title=&quot;创建  🍀&quot;&gt;&lt;/a&gt;创建  🍀&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 创建一个带有元素的元组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mytuple = (&lt;span class=&quot;string&quot;&gt;&quot;Lyon&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Alex&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Leon&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 也可以不加括号,但是一定要加引号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mytuple = &lt;span class=&quot;string&quot;&gt;&quot;Lyon&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Alex&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;Leon&quot;&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 创建一个空元组&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;mytuple = ()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 当元组中只有一个元素,加逗号来消除歧义哟,这是一个好习惯,因为()既可以表示tuple又可以表示数学公式中的小括号&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;only_one = (&lt;span class=&quot;string&quot;&gt;&quot;Lyon&quot;&lt;/span&gt;,)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="basic" scheme="https://jesse.top/categories/python/basic/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>06.Python之路 - 列表</title>
    <link href="https://jesse.top/2020/05/27/python/01-basic/06-Python%E4%B9%8B%E8%B7%AF-%20%E5%88%97%E8%A1%A8/"/>
    <id>https://jesse.top/2020/05/27/python/01-basic/06-Python之路- 列表/</id>
    <published>2020-05-27T14:59:58.000Z</published>
    <updated>2020-05-27T15:19:24.160Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-列表"><a href="#Python之路-列表" class="headerlink" title="Python之路 - 列表"></a>Python之路 - 列表</h1><h2 id="介绍-🍀"><a href="#介绍-🍀" class="headerlink" title="介绍  🍀"></a>介绍  🍀</h2><p>列表是我们以后最常用的数据类型之一 , 通过列表可以对数据实现最方便的存储、修改等操作</p><p><strong>列表是可变的、有序的 </strong> , 基本操作有 : 创建、访问、切片、追加、插入、修改、删除、扩展、拷贝、排序、翻转、等</p><p>列表相当于其他语言中的数组</p><h2 id="创建-🍀"><a href="#创建-🍀" class="headerlink" title="创建  🍀"></a>创建  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个列表</span></span><br><span class="line">names = [<span class="string">"Alex"</span>,<span class="string">"Lyon"</span>,<span class="string">"Leon"</span>]</span><br><span class="line"><span class="comment"># 创建一个空列表</span></span><br><span class="line">names = []</span><br><span class="line"><span class="comment"># 也可通过list方法</span></span><br><span class="line">names = list()</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="访问-🍀"><a href="#访问-🍀" class="headerlink" title="访问  🍀"></a>访问  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#1.通过索引查找元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个列表</span></span><br><span class="line">names = [<span class="string">"Alex"</span>,<span class="string">"Lyon"</span>,<span class="string">"Leon"</span>]</span><br><span class="line"><span class="comment"># 与字符串的索引一样,列表索引从0开始,访问列表中的第一个元素</span></span><br><span class="line">fristname = names[<span class="number">0</span>]</span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line">print(fristname)</span><br><span class="line"><span class="comment"># 访问列表中第三个元素</span></span><br><span class="line">threename = names[<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line">print(threename)</span><br><span class="line"><span class="comment"># 访问列表中最后一个元素</span></span><br><span class="line">endname = names[<span class="number">-1</span>]</span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line">print(endname)</span><br><span class="line"><span class="comment"># 访问倒数第二个元素</span></span><br><span class="line">penultimate = names[<span class="number">-2</span>]</span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line">print(penultimate)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">Alex</span></span><br><span class="line"><span class="string">Leon</span></span><br><span class="line"><span class="string">Leon</span></span><br><span class="line"><span class="string">Lyon</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.通过元素查找索引.index()方法</span></span><br><span class="line">print(name.index(<span class="string">'jesse'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#3.#len函数查找列表的长度</span></span><br><span class="line">print(len(name))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#4.count函数,查找某个元素在列表里出现的次数</span></span><br><span class="line">print(name.count(<span class="string">'jesse'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">1</span></span><br></pre></td></tr></table></figure><p><strong>获取下标</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个列表</span></span><br><span class="line">names = [<span class="string">'Alex'</span>, <span class="string">'Lyon'</span>, <span class="string">'Leon'</span>, <span class="string">'CTO'</span>,<span class="string">'Lyon'</span>]</span><br><span class="line"><span class="comment"># 获取下标并打印</span></span><br><span class="line">print(names.index(<span class="string">'Lyon'</span>)) </span><br><span class="line"><span class="comment"># 注:只返回找到的第一个下标</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p><strong>统计</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个列表</span></span><br><span class="line">names = [<span class="string">'Alex'</span>, <span class="string">'Lyon'</span>, <span class="string">'Leon'</span>, <span class="string">'CTO'</span>, <span class="string">'BeiJing'</span>,<span class="string">"IT"</span>,<span class="number">21</span>,<span class="string">"man"</span>]</span><br><span class="line"><span class="comment"># 统计 "Lyon" 的个数,并打印</span></span><br><span class="line">print(names.count(<span class="string">"Lyon"</span>))   </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">1</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="切片-🍀"><a href="#切片-🍀" class="headerlink" title="切片  🍀"></a>切片  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个列表</span></span><br><span class="line">names = [<span class="string">"Alex"</span>,<span class="string">"Lyon"</span>,<span class="string">"Leon"</span>,<span class="string">"CTO"</span>,<span class="string">"WuHan"</span>]</span><br><span class="line"><span class="comment"># 取下标为1至下标3之间的值,包括1,不包括4</span></span><br><span class="line">cutnames1 = names[<span class="number">1</span>:<span class="number">3</span>]</span><br><span class="line"><span class="comment"># 打印cutnames1</span></span><br><span class="line">print(cutnames1) </span><br><span class="line"><span class="comment"># 取下标为1至-1的值,不包括-1（-1就是最后一个）</span></span><br><span class="line">cutnames2 = names[<span class="number">1</span>:<span class="number">-1</span>]</span><br><span class="line"><span class="comment"># 打印cutnames2</span></span><br><span class="line">print(cutnames2)  </span><br><span class="line"><span class="comment"># 从第一个到第三个</span></span><br><span class="line">cutnames3 = names[<span class="number">0</span>:<span class="number">3</span>]</span><br><span class="line"><span class="comment"># 从头开始取,0可以省略,跟上面的效果一样</span></span><br><span class="line">cutnames4 = names[:<span class="number">3</span>]</span><br><span class="line"><span class="comment"># 打印cutnames3,cutnames4</span></span><br><span class="line">print(cutnames3,cutnames4) </span><br><span class="line"><span class="comment"># 想取最后一个,只能这样写,切片是不包含后一个参数的</span></span><br><span class="line">cutnames5 = names[<span class="number">3</span>:]</span><br><span class="line"><span class="comment"># 后面的2是代表,每隔一个元素,就取一个</span></span><br><span class="line">cutnames6 = names[<span class="number">0</span>::<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 或者这样</span></span><br><span class="line">cutnames7 = names[::<span class="number">2</span>]</span><br><span class="line"><span class="comment"># 打印cutnames6,cutnames7</span></span><br><span class="line">print(cutnames6,cutnames7) </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">['Lyon', 'Leon']</span></span><br><span class="line"><span class="string">['Lyon', 'Leon', 'CTO']</span></span><br><span class="line"><span class="string">['Alex', 'Lyon', 'Leon'] ['Alex', 'Lyon', 'Leon']</span></span><br><span class="line"><span class="string">['Alex', 'Leon', 'WuHan'] ['Alex', 'Leon', 'WuHan']</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="追加-🍀"><a href="#追加-🍀" class="headerlink" title="追加  🍀"></a>追加  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个列表</span></span><br><span class="line">names = [<span class="string">"Alex"</span>,<span class="string">"Lyon"</span>,<span class="string">"Leon"</span>,<span class="string">"CTO"</span>,<span class="string">"WuHan"</span>]</span><br><span class="line"><span class="comment"># 追加一个元素</span></span><br><span class="line">names.append(<span class="string">"New"</span>)</span><br><span class="line"><span class="comment"># 打印names</span></span><br><span class="line">print(names)</span><br><span class="line"><span class="comment"># 注：append 方法只能追加到列表的最后一位</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">['Alex', 'Lyon', 'Leon', 'CTO', 'WuHan', 'New']</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><blockquote><p>注意,对列表的任何修改都是在原列表上进行的.而且所有方法都不会返回任何值.所以下面的例子返回None:</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; name = [&apos;jesse&apos;,&apos;Lyon&apos;,&apos;alex&apos;,&apos;jerry&apos;]</span><br><span class="line">&gt;&gt;&gt; name1=name.append(&apos;new&apos;)</span><br><span class="line">&gt;&gt;&gt; print(name1)</span><br><span class="line">None</span><br></pre></td></tr></table></figure><h2 id="插入-🍀"><a href="#插入-🍀" class="headerlink" title="插入  🍀"></a>插入  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name = [<span class="string">'jesse'</span>,<span class="string">'Lyon'</span>,<span class="string">'alex'</span>,<span class="string">'jerry'</span>]</span><br><span class="line"><span class="comment">#insert需要指定下标.</span></span><br><span class="line">name.insert(<span class="number">1</span>,<span class="string">'insert'</span>)</span><br><span class="line">print(name)</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果下标不存在就插入到最后一个</span></span><br><span class="line">name.insert(<span class="number">111</span>,<span class="string">'no one'</span>)</span><br><span class="line">print(name)</span><br></pre></td></tr></table></figure><h2 id="修改-🍀"><a href="#修改-🍀" class="headerlink" title="修改  🍀"></a>修改  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个列表</span></span><br><span class="line">names = [<span class="string">'Alex'</span>, <span class="string">'Insert'</span>, <span class="string">'Lyon'</span>, <span class="string">'Leon'</span>, <span class="string">'CTO'</span>, <span class="string">'WuHan'</span>, <span class="string">'New'</span>, <span class="string">'NoIndex'</span>]</span><br><span class="line"><span class="comment"># 把 'WuHan' 改成 'BeiJing'</span></span><br><span class="line">names[<span class="number">5</span>] = <span class="string">'BeiJing'</span></span><br><span class="line"><span class="comment"># 打印names</span></span><br><span class="line">print(names)</span><br><span class="line"><span class="comment"># 注：就是通过下标直接改变list本身</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">['Alex', 'Insert', 'Lyon', 'Leon', 'CTO', 'BeiJing', 'New', 'NoIndex']</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="comment">#切片修改</span></span><br><span class="line">name[:<span class="number">2</span>] = <span class="string">"huang"</span></span><br><span class="line">print(name)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'h'</span>, <span class="string">'u'</span>, <span class="string">'a'</span>, <span class="string">'n'</span>, <span class="string">'g'</span>, <span class="string">'alex'</span>, <span class="string">'jerry'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#分别赋值,将3个元素分别赋值.</span></span><br><span class="line">name[:<span class="number">3</span>] = <span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span></span><br><span class="line">print(name)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'Lyon'</span>, <span class="string">'alex'</span>, <span class="string">'jerry'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#也可以用元祖的3个元素分别赋值</span></span><br><span class="line">name[:<span class="number">3</span>] = (<span class="string">"x"</span>,<span class="string">"y"</span>,<span class="string">"z"</span>)</span><br><span class="line">print(name)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'x'</span>, <span class="string">'y'</span>, <span class="string">'z'</span>, <span class="string">'Lyon'</span>, <span class="string">'alex'</span>, <span class="string">'jerry</span></span><br></pre></td></tr></table></figure><h2 id="删除-🍀"><a href="#删除-🍀" class="headerlink" title="删除  🍀"></a>删除  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">name = [<span class="string">'jesse'</span>,<span class="string">'Lyon'</span>,<span class="string">'alex'</span>,<span class="string">'jerry'</span>]</span><br><span class="line"><span class="comment">#1.按照索引删除.pop()方法</span></span><br><span class="line">name.pop(<span class="number">1</span>)</span><br><span class="line">print(name)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'jesse'</span>, <span class="string">'alex'</span>, <span class="string">'jerry'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#注意pop方法有返回值,返回的是删除的那个元素.例如</span></span><br><span class="line">print(name.pop(<span class="number">1</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>Lyon</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果不指定索引,则删除最后一个</span></span><br><span class="line">name.pop()</span><br><span class="line">print(name)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'jesse'</span>, <span class="string">'Lyon'</span>, <span class="string">'alex'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#2.删除一个指定的真实元素.remove()方法</span></span><br><span class="line">name.remove(<span class="string">'jesse'</span>)</span><br><span class="line">print(name)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'Lyon'</span>, <span class="string">'alex'</span>, <span class="string">'jerry'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">##3.支持切片删除方法</span></span><br><span class="line"><span class="comment">#删除单个索引</span></span><br><span class="line"><span class="keyword">del</span> name[<span class="number">1</span>]</span><br><span class="line">print(name)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'jesse'</span>, <span class="string">'alex'</span>, <span class="string">'jerry'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#删除切片</span></span><br><span class="line"><span class="keyword">del</span> name[<span class="number">1</span>:]</span><br><span class="line">print(name)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>[<span class="string">'jesse'</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">#4.清空列表.clear()方法</span></span><br><span class="line">name.clear()</span><br><span class="line">print(name)</span><br><span class="line">&gt;&gt;&gt;[]</span><br></pre></td></tr></table></figure><h2 id="扩展-🍀"><a href="#扩展-🍀" class="headerlink" title="扩展  🍀"></a>扩展  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个列表</span></span><br><span class="line">names = [<span class="string">'Alex'</span>, <span class="string">'Lyon'</span>, <span class="string">'Leon'</span>, <span class="string">'CTO'</span>, <span class="string">'BeiJing'</span>]</span><br><span class="line"><span class="comment"># 创建另一个列表</span></span><br><span class="line">name = [<span class="string">"IT"</span>,<span class="number">21</span>,<span class="string">"man"</span>]</span><br><span class="line"><span class="comment"># 将name扩展到names</span></span><br><span class="line">names.extend(name)</span><br><span class="line"><span class="comment"># 打印names</span></span><br><span class="line">print(names)  </span><br><span class="line"><span class="comment"># 这里还有一个"万恶的'+' "也是可以的</span></span><br><span class="line">print(names + name) </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">['Alex', 'Lyon', 'Leon', 'CTO', 'BeiJing', 'IT', 21, 'man']</span></span><br><span class="line"><span class="string">['Alex', 'Lyon', 'Leon', 'CTO', 'BeiJing', 'IT', 21, 'man']</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="拷贝-🍀"><a href="#拷贝-🍀" class="headerlink" title="拷贝  🍀"></a>拷贝  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个列表</span></span><br><span class="line">names = [<span class="string">'Alex'</span>, <span class="string">'Lyon'</span>, <span class="string">'Leon'</span>, <span class="string">'CTO'</span>, <span class="string">'BeiJing'</span>,<span class="string">"IT"</span>,<span class="number">21</span>,<span class="string">"man"</span>]</span><br><span class="line"><span class="comment"># 拷贝names,这只是浅copy</span></span><br><span class="line">names_copy = names.copy()  </span><br><span class="line"><span class="comment"># 打印names_copy</span></span><br><span class="line">print(names_copy)   </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">['Alex', 'Lyon', 'Leon', 'CTO', 'BeiJing', 'IT', 21, 'man']</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>注意 : 在python2.7中列表的内置方法是没有copy这个方法的 , 这是在python3后加的 , 并且python3也只有有copy (浅copy) 这一个方法 , 用深copy需要我们导入copy模块 , 即 import copy </p><h2 id="深浅拷贝-🍀"><a href="#深浅拷贝-🍀" class="headerlink" title="深浅拷贝  🍀"></a>深浅拷贝  🍀</h2><h4 id="以下情况为浅copy"><a href="#以下情况为浅copy" class="headerlink" title="以下情况为浅copy"></a>以下情况为浅copy</h4><ul><li>赋值法: l2 = l1</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">l1 = [&apos;jesse&apos;,&apos;huang&apos;,&apos;alex&apos;,[ &apos;name&apos;,&apos;age&apos;,1,2],&#123;&quot;job&quot;:&apos;IT&apos;,&quot;company&quot;:&apos;dwd&apos;&#125;]</span><br><span class="line"></span><br><span class="line">l2 = l1.copy()</span><br><span class="line"></span><br><span class="line">l1[-1][&apos;industry&apos;] = &apos;internet&apos;</span><br><span class="line">l1.append(&apos;new&apos;)</span><br><span class="line">l1[0] = &apos;jessehuang&apos;</span><br><span class="line">l1[-3].append(&apos;newlist&apos;)</span><br><span class="line"></span><br><span class="line">print(l1, id(l1),id(l1[-2]),id(l1[-3]))</span><br><span class="line">print(l2, id(l2),id(l2[-2]),id(l2[-3]))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [&apos;jessehuang&apos;, &apos;huang&apos;, &apos;alex&apos;, [&apos;name&apos;, &apos;age&apos;, 1, 2, &apos;newlist&apos;], &#123;&apos;job&apos;: &apos;IT&apos;, &apos;company&apos;: &apos;dwd&apos;, &apos;industry&apos;: &apos;internet&apos;&#125;, &apos;new&apos;] 4307202568 4307174384 4306493320</span><br><span class="line">[&apos;jessehuang&apos;, &apos;huang&apos;, &apos;alex&apos;, [&apos;name&apos;, &apos;age&apos;, 1, 2, &apos;newlist&apos;], &#123;&apos;job&apos;: &apos;IT&apos;, &apos;company&apos;: &apos;dwd&apos;, &apos;industry&apos;: &apos;internet&apos;&#125;, &apos;new&apos;] 4307202568 4307174384 4306493320</span><br></pre></td></tr></table></figure><h4 id="以下情况为中等copy"><a href="#以下情况为中等copy" class="headerlink" title="以下情况为中等copy"></a>以下情况为中等copy</h4><ol><li>copy()方法: l2 = l1.copy()</li><li>分片法: l2 = l1[:]</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">l1 = [&apos;jesse&apos;,&apos;huang&apos;,&apos;alex&apos;,[ &apos;name&apos;,&apos;age&apos;,1,2],&#123;&quot;job&quot;:&apos;IT&apos;,&quot;company&quot;:&apos;dwd&apos;&#125;]</span><br><span class="line"></span><br><span class="line">l2 = l1.copy()</span><br><span class="line"></span><br><span class="line">l1[-1][&apos;industry&apos;] = &apos;internet&apos;</span><br><span class="line">l1.insert(0,&apos;new&apos;)</span><br><span class="line">l1[1] = &apos;jessehuang&apos;</span><br><span class="line">l1[-2].append(&apos;newlist&apos;)</span><br><span class="line"></span><br><span class="line">print(l1, id(l1),id(l1[-1]),id(l1[-2]))</span><br><span class="line">print(l2, id(l2),id(l2[-1]),id(l2[-2]))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [&apos;new&apos;, &apos;jessehuang&apos;, &apos;huang&apos;, &apos;alex&apos;, [&apos;name&apos;, &apos;age&apos;, 1, 2, &apos;newlist&apos;], &#123;&apos;job&apos;: &apos;IT&apos;, &apos;company&apos;: &apos;dwd&apos;, &apos;industry&apos;: &apos;internet&apos;&#125;] 4399804936 4399776752 4399095688</span><br><span class="line">[&apos;jesse&apos;, &apos;huang&apos;, &apos;alex&apos;, [&apos;name&apos;, &apos;age&apos;, 1, 2, &apos;newlist&apos;], &#123;&apos;job&apos;: &apos;IT&apos;, &apos;company&apos;: &apos;dwd&apos;, &apos;industry&apos;: &apos;internet&apos;&#125;] 4399806792 4399776752 4399095688</span><br></pre></td></tr></table></figure><h4 id="以下情况为深copy"><a href="#以下情况为深copy" class="headerlink" title="以下情况为深copy"></a>以下情况为深copy</h4><p>**用copy模块的deepcopy方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import copy</span><br><span class="line">l1 = [&apos;jesse&apos;,&apos;huang&apos;,&apos;alex&apos;,[ &apos;name&apos;,&apos;age&apos;,1,2],&#123;&quot;job&quot;:&apos;IT&apos;,&quot;company&quot;:&apos;dwd&apos;&#125;]</span><br><span class="line"></span><br><span class="line">l2 = copy.deepcopy(l1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">l1[-1][&apos;industry&apos;] = &apos;internet&apos;</span><br><span class="line">l1.insert(0,&apos;new&apos;)</span><br><span class="line">l1[1] = &apos;jessehuang&apos;</span><br><span class="line">l1[-2].append(&apos;newlist&apos;)</span><br><span class="line"></span><br><span class="line">print(l1, id(l1),id(l1[-1]),id(l1[-2]))</span><br><span class="line">print(l2, id(l2),id(l2[-1]),id(l2[-2]))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; [&apos;new&apos;, &apos;jessehuang&apos;, &apos;huang&apos;, &apos;alex&apos;, [&apos;name&apos;, &apos;age&apos;, 1, 2, &apos;newlist&apos;], &#123;&apos;job&apos;: &apos;IT&apos;, &apos;company&apos;: &apos;dwd&apos;, &apos;industry&apos;: &apos;internet&apos;&#125;] 4552839240 4552418288 4552840456</span><br><span class="line">[&apos;jesse&apos;, &apos;huang&apos;, &apos;alex&apos;, [&apos;name&apos;, &apos;age&apos;, 1, 2], &#123;&apos;job&apos;: &apos;IT&apos;, &apos;company&apos;: &apos;dwd&apos;&#125;] 4552951304 4552732888 4552951368</span><br></pre></td></tr></table></figure><p><strong>从以上结果,总结这3种的区别:</strong></p><ul><li><p>对于浅copy:</p><ul><li>1.修改原列表的任何元素,都会影响新列表.</li><li>2.源列表和新列表关联到同一个内存地址空间</li></ul></li><li><p>对于中等copy:</p><ul><li>1.修改原列表内的可变元素(例如原列表本身,原列表的子列表,字典等可变元素)则会影响新列表.</li><li>2.修改原列表内的不可变元素(例如字符串),则不会影响到新列表</li><li>3.个列表本身拥有不同的内存地址空间,但是,列表内的可变子元素(子列表,字典等)还是会关联到同一个内存地址.</li></ul></li><li><p>对于深copy:</p><ul><li>1.修改原列表内的任何元素,都不会影响到新列表</li><li>2.列表本身,以及列表内的所有子元素,都关联到不同的内存地址</li></ul></li></ul><h2 id="排序-amp-翻转-🍀"><a href="#排序-amp-翻转-🍀" class="headerlink" title="排序&amp;翻转  🍀"></a>排序&amp;翻转  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个列表</span></span><br><span class="line">names = [<span class="string">'Alex'</span>, <span class="string">'Lyon'</span>, <span class="string">'Leon'</span>, <span class="string">'CTO'</span>, <span class="string">'BeiJing'</span>,<span class="string">"IT"</span>,<span class="number">21</span>,<span class="string">"man"</span>]</span><br><span class="line"><span class="comment"># 在python3中不同的数据类型不能一起排序,换成str</span></span><br><span class="line">names[<span class="number">-2</span>] = <span class="string">"21"</span></span><br><span class="line"><span class="comment"># 排序,顺序为数字&gt;大写&gt;小写</span></span><br><span class="line">names.sort()</span><br><span class="line"><span class="comment"># 打印names</span></span><br><span class="line">print(names)    </span><br><span class="line"><span class="comment"># 翻转</span></span><br><span class="line">names.reverse()</span><br><span class="line"><span class="comment"># 打印names</span></span><br><span class="line">print(names)      </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">['21', 'Alex', 'BeiJing', 'CTO', 'IT', 'Leon', 'Lyon', 'man']</span></span><br><span class="line"><span class="string">['man', 'Lyon', 'Leon', 'IT', 'CTO', 'BeiJing', 'Alex', '21']</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>所有方法如下 : </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">|  append(...)</span><br><span class="line">|      L.append(object) -&gt; None -- append object to end</span><br><span class="line">|</span><br><span class="line">|  clear(...)</span><br><span class="line">|      L.clear() -&gt; None -- remove all items from L</span><br><span class="line">|</span><br><span class="line">|  copy(...)</span><br><span class="line">|      L.copy() -&gt; list -- a shallow copy of L</span><br><span class="line">|</span><br><span class="line">|  count(...)</span><br><span class="line">|      L.count(value) -&gt; integer -- return number of occurrences of value</span><br><span class="line">|</span><br><span class="line">|  extend(...)</span><br><span class="line">|      L.extend(iterable) -&gt; None -- extend list by appending elements from the iterable</span><br><span class="line">|</span><br><span class="line">|  index(...)</span><br><span class="line">|      L.index(value, [start, [stop]]) -&gt; integer -- return first index of value.</span><br><span class="line">|      Raises ValueError <span class="keyword">if</span> the value <span class="keyword">is</span> <span class="keyword">not</span> present.</span><br><span class="line">|</span><br><span class="line">|  insert(...)</span><br><span class="line">|      L.insert(index, object) -- insert object before index</span><br><span class="line">|</span><br><span class="line">|  pop(...)</span><br><span class="line">|      L.pop([index]) -&gt; item -- remove and return item at index (default last).</span><br><span class="line">|      Raises IndexError <span class="keyword">if</span> list <span class="keyword">is</span> empty <span class="keyword">or</span> index <span class="keyword">is</span> out of range.</span><br><span class="line">|</span><br><span class="line">|  remove(...)</span><br><span class="line">|      L.remove(value) -&gt; None -- remove first occurrence of value.</span><br><span class="line">|      Raises ValueError <span class="keyword">if</span> the value <span class="keyword">is</span> <span class="keyword">not</span> present.</span><br><span class="line">|</span><br><span class="line">|  reverse(...)</span><br><span class="line">|      L.reverse() -- reverse *IN PLACE*</span><br><span class="line">|</span><br><span class="line">|  sort(...)</span><br><span class="line">|      L.sort(key=None, reverse=False) -&gt; None -- stable sort *IN PLACE*</span><br></pre></td></tr></table></figure><hr><h2 id="练习题-🍀"><a href="#练习题-🍀" class="headerlink" title="练习题  🍀"></a>练习题  🍀</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">name = [&apos;jesse&apos;,&apos;Lyon&apos;,&apos;alex&apos;,&apos;jerry&apos;,[1,&apos;tony&apos;]]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#1.将jesse变成大写</span><br><span class="line">name[0] = name[0].upper()</span><br><span class="line">print(name)</span><br><span class="line"></span><br><span class="line">#2.将tony变成首字母大写</span><br><span class="line">str = name[-1][-1].capitalize()</span><br><span class="line">name[-1][-1] = str</span><br><span class="line">print(name)</span><br></pre></td></tr></table></figure><ul><li>3.将下列列表中奇数索引的元素删除</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">l1 = [00,11,22,33,44,55,66]</span><br><span class="line"></span><br><span class="line">#方法一.采取步长方式.这也是最简单有效的方式</span><br><span class="line"></span><br><span class="line">print(l1[::2])</span><br><span class="line">&gt;&gt;&gt; [0, 22, 44, 66]</span><br><span class="line"></span><br><span class="line">#方法二.判断是否能被2整除..因为列表是可变的,对列表的任何修改都会得到预期之外的结果.所以不能对列表进行直接操作</span><br><span class="line"></span><br><span class="line">#新建一个空列表</span><br><span class="line"></span><br><span class="line">l2 = []</span><br><span class="line"></span><br><span class="line">#循环l1的索引,偶数元素加入到l2.</span><br><span class="line"></span><br><span class="line">for num in range(len(l1)):</span><br><span class="line">     if num % 2 == 0:</span><br><span class="line">         l2.append(l1[num])</span><br><span class="line"></span><br><span class="line">#打印l2</span><br><span class="line">print(l2)</span><br><span class="line">&gt;&gt;&gt; [0, 22, 44, 66]</span><br><span class="line"></span><br><span class="line">#方法三..倒序循环列表,可以直接修改.因为修改列表(删除列表元素)对循环的索引没有影响.</span><br><span class="line"></span><br><span class="line">#注意,起始索引是列表长度-1,然后截止索引是-1,而不是0,步长是-1</span><br><span class="line">for num in range(len(l1)-1,-1,-1):</span><br><span class="line">    if num % 2 == 1:</span><br><span class="line">        del l1[num]</span><br><span class="line"></span><br><span class="line">print(l1)</span><br><span class="line">&gt;&gt;&gt; [0, 22, 44, 66]</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-列表&quot;&gt;&lt;a href=&quot;#Python之路-列表&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 列表&quot;&gt;&lt;/a&gt;Python之路 - 列表&lt;/h1&gt;&lt;h2 id=&quot;介绍-🍀&quot;&gt;&lt;a href=&quot;#介绍-🍀&quot; class=&quot;headerlink&quot; title=&quot;介绍  🍀&quot;&gt;&lt;/a&gt;介绍  🍀&lt;/h2&gt;&lt;p&gt;列表是我们以后最常用的数据类型之一 , 通过列表可以对数据实现最方便的存储、修改等操作&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;列表是可变的、有序的 &lt;/strong&gt; , 基本操作有 : 创建、访问、切片、追加、插入、修改、删除、扩展、拷贝、排序、翻转、等&lt;/p&gt;
&lt;p&gt;列表相当于其他语言中的数组&lt;/p&gt;
&lt;h2 id=&quot;创建-🍀&quot;&gt;&lt;a href=&quot;#创建-🍀&quot; class=&quot;headerlink&quot; title=&quot;创建  🍀&quot;&gt;&lt;/a&gt;创建  🍀&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 创建一个列表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;names = [&lt;span class=&quot;string&quot;&gt;&quot;Alex&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;Lyon&quot;&lt;/span&gt;,&lt;span class=&quot;string&quot;&gt;&quot;Leon&quot;&lt;/span&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 创建一个空列表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;names = []&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 也可通过list方法&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;names = list()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="basic" scheme="https://jesse.top/categories/python/basic/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>04.Python之路 - 字符串</title>
    <link href="https://jesse.top/2020/05/27/python/01-basic/04-Python%E4%B9%8B%E8%B7%AF-%20%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>https://jesse.top/2020/05/27/python/01-basic/04-Python之路- 字符串/</id>
    <published>2020-05-27T14:59:58.000Z</published>
    <updated>2020-05-27T15:19:00.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-字符串"><a href="#Python之路-字符串" class="headerlink" title="Python之路 - 字符串"></a>Python之路 - 字符串</h1><h2 id="介绍-🍀"><a href="#介绍-🍀" class="headerlink" title="介绍  🍀"></a>介绍  🍀</h2><p>字符串是Python中最基本的数据类型之一 </p><p>字符串的使用需要用引号括起来 , 例如 : <code>name = &quot;Lyon&quot;</code> ; 这里name就是一个变量名 , 而引号里面的<code>Lyon</code> 则就是该变量绑定的值 , 该值的类型为 “ str” 类型 , 我们可以利用<code>type()</code> 函数进行查看 : </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">"Lyon"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>type(name)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> '<span class="title">str</span>'&gt;</span></span><br><span class="line"><span class="class">&gt;&gt;&gt;</span></span><br></pre></td></tr></table></figure><p>这就是字符串类型 , 当然如上使用的是双引号 , 这里其实还可以使用单引号<code>&#39;Lyon&#39;</code>以及三引号<code>&#39;&#39;&#39;Lyon&#39;&#39;&#39;</code>(或者是<code>&quot;&quot;&quot;Lyon&quot;&quot;&quot;</code>  , 单引号双引号都可以) , 不过对于三引号 , 我们通常是表示多行字符串 , 这样我们就不需要利用 “ \n “ （换行符）来进行每一行的换行了</p><p>对于嵌套引号的时候要注意 , 需要用不同的引号来避免歧义 , 比如 : <code>&#39;I am &quot;Lyon&quot;&#39;</code>  , 也可以 <code>&quot;I am &#39;Lyon&#39;&quot;</code> </p><p>对于所有的基本数据类型 , 我们都应该熟悉其特性以及操作</p><p>字符串操作主要有 <strong>拷贝（复制）、拼接、查找、统计、切片、测试、大小写,字符串列表转换等</strong></p><p>在开始详细了解这些操作之前 , 我们需要记住一个特性 : <strong>字符串是不可变的</strong> , 既然是不可变的 , 那么我们对其进行的增删改查就都不是对本身进行操作的 , 而是创建了一个新的字符串</p><a id="more"></a><h2 id="拷贝-🍀"><a href="#拷贝-🍀" class="headerlink" title="拷贝  🍀"></a>拷贝  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"Lyon"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = a</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a,b)</span><br><span class="line">Lyon Lyon</span><br></pre></td></tr></table></figure><h2 id="拼接-🍀"><a href="#拼接-🍀" class="headerlink" title="拼接  🍀"></a>拼接  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"Hello"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">"Lyon"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a+b)</span><br><span class="line">HelloLyon</span><br></pre></td></tr></table></figure><p>注 : 这个方法要特别说明一下 , “+”是一个坑 , 因为使用加号连接2个字符串会调用静态函数<code>string_concat(register PyStringObject *a,register PyObject *b)</code>  , 这个函数大致的作用 , 就是首先开辟一块<code>a+b</code>大小的内存的和的存储单元 , 然后把a和b都拷贝进去 ; 所以一旦我们的 “+” 操作过多将会造成大量内存的浪费</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = <span class="string">"Lyon"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>b = <span class="string">"Hello"</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(a.join(b)) </span><br><span class="line">HLyoneLyonlLyonlLyono  <span class="comment">#HLyon eLyon lLyon lLyon o</span></span><br></pre></td></tr></table></figure><p>可以用join来将list中的元素进行拼接成字符串 : <code>&#39;&#39;.join( list )</code> 即以空字符串连接列表中的每一个元素</p><p>下面2个例子演示了.默认用空格,以及用逗号来拼接字符串的效果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b = &apos;jesse&apos;</span><br><span class="line">print(&quot;&quot;.join(b)) #用空格拼接,字符串不变</span><br><span class="line">print(&quot;,&quot;.join(b)) #将字符串b的每个元素用逗号进行拼接</span><br><span class="line"></span><br><span class="line">执行结果</span><br><span class="line">jesse</span><br><span class="line">j,e,s,s,e</span><br></pre></td></tr></table></figure><p>字符串拼接还有个方法是用格式化输出.下面是这3个方法的具体案例.可以看到格式化输出是最简单的拼接方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#join方法要求先生成一个列表,而且要将整数型转换成字符串</span><br><span class="line"></span><br><span class="line">a = &apos;world&apos;</span><br><span class="line">b = 1</span><br><span class="line">while b &lt; 10:</span><br><span class="line">    l1 = [a,str(b)]</span><br><span class="line">    print(&apos;&apos;.join(l1))</span><br><span class="line">    b+=1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#格式化输出可以直接打印拼接字符串</span><br><span class="line">a = &apos;hello&apos;</span><br><span class="line">b = 1</span><br><span class="line"></span><br><span class="line">while b &lt; 10:</span><br><span class="line">    print(&quot;%s%d&quot; %(a,b))</span><br><span class="line">    b+=1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#+方法需要2个变量都是字符串.要将整数型转换成字符串</span><br><span class="line">a = &apos;hello&apos;</span><br><span class="line">b = 1</span><br><span class="line"></span><br><span class="line">while b &lt; 5:</span><br><span class="line">    print(a+str(b))</span><br><span class="line">    b+=1</span><br></pre></td></tr></table></figure><h2 id="查找-🍀"><a href="#查找-🍀" class="headerlink" title="查找  🍀"></a>查找  🍀</h2><ul><li>index()</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">"Lyon"</span></span><br><span class="line"><span class="comment"># 返回L字符所在的下标,下标是从0开始的整数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.index(<span class="string">'L'</span>)</span><br><span class="line"><span class="number">0</span> </span><br><span class="line"><span class="comment"># 如果不存在就会报错</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.index(<span class="string">'N'</span>) </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">ValueError: substring <span class="keyword">not</span> found  </span><br><span class="line"><span class="comment"># 也可以用in,not in来进行判断</span></span><br><span class="line">&gt;&gt;&gt;<span class="string">'L'</span> <span class="keyword">in</span> name</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><ul><li>find()</li></ul><p>find的函数和index类似,都是返回字符的下标.而且都是如果字符串中有多个相同的元素,则返回第一个匹配的元素下标</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">b = &apos;jesse&apos;</span><br><span class="line">print(b.find(&apos;e))</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; 1</span><br><span class="line">#和index区别是,find如果没有找到匹配的字符,会返回-1</span><br><span class="line">print(b.find(&apos;a&apos;))</span><br><span class="line">&gt;&gt;&gt; -1</span><br><span class="line"></span><br><span class="line">#当然,两者都支持定义起始位置,即从某个起始位置开始查找.</span><br><span class="line"></span><br><span class="line">print(b.find(&apos;e&apos;,2)) #从第二个位置开始查找</span><br><span class="line">&gt;&gt;&gt; 4</span><br><span class="line">print(b.find(&apos;e&apos;,2,3)) #从第二个位置开始查找,但是只查找到第三个结束,所以没有找到e字符串</span><br><span class="line">&gt;&gt;&gt; -1</span><br><span class="line"></span><br><span class="line">print(b.index(&apos;e&apos;,2)) #从第二个位置开始查找</span><br><span class="line">&gt;&gt;&gt; 4</span><br><span class="line"></span><br><span class="line">print(b.index(&apos;e&apos;,2,3)) </span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">4</span><br><span class="line">  File &quot;/Users/huangyong/Desktop/python-learning/day1/python字符串.py&quot;, line 43, in &lt;module&gt;</span><br><span class="line">    print(b.index(&apos;e&apos;,2,3))</span><br><span class="line">ValueError: substring not found</span><br></pre></td></tr></table></figure><hr><h2 id="统计-🍀"><a href="#统计-🍀" class="headerlink" title="统计  🍀"></a>统计  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#count表示统计字符串中某个元素的个数</span></span><br><span class="line">b = <span class="string">'jesse'</span></span><br><span class="line">print(b.count(<span class="string">'e'</span>)) </span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">2</span></span><br><span class="line"><span class="comment">#len表示字符串的长度</span></span><br><span class="line">print(len(b))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="number">5</span></span><br></pre></td></tr></table></figure><hr><h2 id="切片-🍀"><a href="#切片-🍀" class="headerlink" title="切片  🍀"></a>切片  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#切片就是通过索引（索引：索引：步长）截取字符串的一段，形成新的字符串（原则就是顾头不顾腚).</span></span><br><span class="line"></span><br><span class="line">b = <span class="string">'jesse'</span></span><br><span class="line">print(b[<span class="number">0</span>:<span class="number">3</span>]) <span class="comment">#从第0个下标开始截取到第3个..如果起始位置为0.则0可以不用写</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>jes</span><br><span class="line"><span class="comment">#等同于</span></span><br><span class="line">print(b[:<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">"i like Lyon"</span></span><br><span class="line"><span class="comment"># 切取第7个到第9个字符,注意空格也是一个字符</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name[<span class="number">7</span>:<span class="number">10</span>]     </span><br><span class="line"><span class="string">'Lyo'</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">"i like Lyon"</span></span><br><span class="line"><span class="comment"># 第7到第10各,顾头不顾尾</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name[<span class="number">7</span>:<span class="number">11</span>]</span><br><span class="line"><span class="string">'Lyon'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#如果是全部截取,则不需要加起始值和截止值</span></span><br><span class="line">print(b[:])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>jesse</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果是反向,从最末尾开始倒着截取,则用负数下标</span></span><br><span class="line">print(b[<span class="number">-1</span>:]) <span class="comment">#输出最后一个字符</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>e</span><br><span class="line">print(b[<span class="number">-1</span>:<span class="number">-3</span>:<span class="number">-1</span>]) <span class="comment">#输出最后一个字符到倒数第三个字符,注意这里要用-1表示步长,因为是倒序匹配,所以步长也是倒序</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>es</span><br><span class="line">print(b[::<span class="number">-1</span>]) <span class="comment">#倒序打印,也就是字符串翻转</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>essej</span><br><span class="line"></span><br><span class="line"><span class="comment">#步长表示每隔多少个间隔截取字符串</span></span><br><span class="line">print(b[::<span class="number">-2</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>esj</span><br></pre></td></tr></table></figure><h2 id="检测-🍀"><a href="#检测-🍀" class="headerlink" title="检测  🍀"></a>检测  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">"Lyon"</span></span><br><span class="line"><span class="comment"># 检测"L"是否在name中,返回bool值</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="string">"L"</span> <span class="keyword">in</span> name     </span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num = <span class="string">"3412313"</span></span><br><span class="line"><span class="comment"># 检测num里面是否全都是整数</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>num.isdigit()    </span><br><span class="line"><span class="keyword">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">"Lyon"</span></span><br><span class="line"><span class="comment"># 检测name是否可以被当作标标志符,即是否符合变量命名规则 </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.isidentifier()</span><br><span class="line"><span class="keyword">True</span></span><br></pre></td></tr></table></figure><p>检测相关</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#两个判断字符串是否以某字符开头(结尾)的方法</span></span><br><span class="line">str.startswith(prefix[,start[,end]]) <span class="comment"># 是否以prefix开头 </span></span><br><span class="line">str.endswith(suffix[,start[,end]])   <span class="comment"># 以suffix结尾 </span></span><br><span class="line"></span><br><span class="line">print(b.startswith(<span class="string">'j'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">True</span></span><br><span class="line">print(b.endswith(<span class="string">'e'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 还有其他一些检测相关的判断函数</span></span><br><span class="line">str.isalnum()    <span class="comment"># 是否全是字母和数字,并至少有一个字符 </span></span><br><span class="line">str.isalpha()    <span class="comment"># 是否全是字母,并至少有一个字符 </span></span><br><span class="line">str.isdigit()    <span class="comment"># 是否全是数字,并至少有一个字符 </span></span><br><span class="line">str.isspace()    <span class="comment"># 是否全是空白字符,并至少有一个字符 </span></span><br><span class="line">str.islower()    <span class="comment"># 是否全是小写 </span></span><br><span class="line">str.isupper()    <span class="comment"># 是否便是大写 </span></span><br><span class="line">str.istitle()    <span class="comment"># 是否是首字母大写的</span></span><br></pre></td></tr></table></figure><p>注 : 结果全是bool值</p><h2 id="大小写-🍀"><a href="#大小写-🍀" class="headerlink" title="大小写  🍀"></a>大小写  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>name = <span class="string">"I am Lyon"</span></span><br><span class="line"><span class="comment"># 大小写互换</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.swapcase()   </span><br><span class="line"><span class="string">'i AM lYON'</span></span><br><span class="line"><span class="comment"># 首字母大写,其它都小写</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.capitalize()     </span><br><span class="line"><span class="string">'I am lyon'</span></span><br><span class="line"><span class="comment"># 转换为大写</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.upper()          </span><br><span class="line"><span class="string">'I AM LYON'</span></span><br><span class="line"><span class="comment"># 转换为小写</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>name.lower()           </span><br><span class="line"><span class="string">'i am lyon'</span></span><br></pre></td></tr></table></figure><h2 id="split-🍀"><a href="#split-🍀" class="headerlink" title="split()  🍀"></a>split()  🍀</h2><p>split表示将一串字符串以列表形式返回.默认分隔符为空格.注意最终返回的列表中,不包含分隔字符</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b = &apos;jeese hello world&apos;</span><br><span class="line">print(b.split())</span><br><span class="line">&gt;&gt;&gt; [&apos;jeese&apos;, &apos;hello&apos;, &apos;world&apos;]</span><br><span class="line"></span><br><span class="line">b = &apos;/usr/bin:/usr/sbin:/usr/local/bin:/bin:/sbin&apos;</span><br><span class="line">print(b.split(&apos;:&apos;))</span><br><span class="line">&gt;&gt;&gt; [&apos;/usr/bin&apos;, &apos;/usr/sbin&apos;, &apos;/usr/local/bin&apos;, &apos;/bin&apos;, &apos;/sbin&apos;]</span><br></pre></td></tr></table></figure><h2 id="strip-🍀"><a href="#strip-🍀" class="headerlink" title="strip()  🍀"></a>strip()  🍀</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#strip表示截去首尾的所有空格.</span><br><span class="line">b= &apos;    jesse     &apos;</span><br><span class="line">print(b.strip())</span><br><span class="line">&gt;&gt;&gt; jesse</span><br><span class="line">#lstrip表示截去首部所有空格</span><br><span class="line">print(b.lstrip())</span><br><span class="line">#rstrip表示截去尾部所有空格</span><br><span class="line">print(b.rstrip())</span><br></pre></td></tr></table></figure><hr><h2 id="replace-🍀"><a href="#replace-🍀" class="headerlink" title="replace()  🍀"></a>replace()  🍀</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#指定要替换的字符串,用指定的新字符串替换</span><br><span class="line">b = &apos;jesse&apos;</span><br><span class="line">print(b.replace(&apos;s&apos;,&apos;a&apos;))</span><br><span class="line">&gt;&gt;&gt; jeaae</span><br></pre></td></tr></table></figure><hr><h2 id="更多-🍀"><a href="#更多-🍀" class="headerlink" title="更多  🍀"></a>更多  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br></pre></td><td class="code"><pre><span class="line">|  capitalize(...)</span><br><span class="line">|      S.capitalize() -&gt; str</span><br><span class="line">|</span><br><span class="line">|      Return a capitalized version of S, i.e. make the first character</span><br><span class="line">|      have upper case <span class="keyword">and</span> the rest lower case.</span><br><span class="line">|</span><br><span class="line">|  casefold(...)</span><br><span class="line">|      S.casefold() -&gt; str</span><br><span class="line">|</span><br><span class="line">|      Return a version of S suitable <span class="keyword">for</span> caseless comparisons.</span><br><span class="line">|</span><br><span class="line">|  center(...)</span><br><span class="line">|      S.center(width[, fillchar]) -&gt; str</span><br><span class="line">|</span><br><span class="line">|      Return S centered <span class="keyword">in</span> a string of length width. Padding <span class="keyword">is</span></span><br><span class="line">|      done using the specified fill character (default <span class="keyword">is</span> a space)</span><br><span class="line">|</span><br><span class="line">|  count(...)</span><br><span class="line">|      S.count(sub[, start[, end]]) -&gt; int</span><br><span class="line">|</span><br><span class="line">|      Return the number of non-overlapping occurrences of substring sub <span class="keyword">in</span></span><br><span class="line">|      string S[start:end].  Optional arguments start <span class="keyword">and</span> end are</span><br><span class="line">|      interpreted <span class="keyword">as</span> <span class="keyword">in</span> slice notation.</span><br><span class="line">|</span><br><span class="line">|  encode(...)</span><br><span class="line">|      S.encode(encoding='utf-8', errors='strict') -&gt; bytes</span><br><span class="line">|</span><br><span class="line">|      Encode S using the codec registered <span class="keyword">for</span> encoding. Default encoding</span><br><span class="line">|      <span class="keyword">is</span> <span class="string">'utf-8'</span>. errors may be given to set a different error</span><br><span class="line">|      handling scheme. Default <span class="keyword">is</span> <span class="string">'strict'</span> meaning that encoding errors <span class="keyword">raise</span></span><br><span class="line">|      a UnicodeEncodeError. Other possible values are <span class="string">'ignore'</span>, <span class="string">'replace'</span> <span class="keyword">and</span></span><br><span class="line">|      <span class="string">'xmlcharrefreplace'</span> <span class="keyword">as</span> well <span class="keyword">as</span> any other name registered <span class="keyword">with</span></span><br><span class="line">|      codecs.register_error that can handle UnicodeEncodeErrors.</span><br><span class="line">|</span><br><span class="line">|  endswith(...)</span><br><span class="line">|      S.endswith(suffix[, start[, end]]) -&gt; bool</span><br><span class="line">|</span><br><span class="line">|      Return <span class="keyword">True</span> <span class="keyword">if</span> S ends <span class="keyword">with</span> the specified suffix, <span class="keyword">False</span> otherwise.</span><br><span class="line">|      With optional start, test S beginning at that position.</span><br><span class="line">|      With optional end, stop comparing S at that position.</span><br><span class="line">|      suffix can also be a tuple of strings to <span class="keyword">try</span>.</span><br><span class="line">|</span><br><span class="line">|  expandtabs(...)</span><br><span class="line">|      S.expandtabs(tabsize=8) -&gt; str</span><br><span class="line">|</span><br><span class="line">|      Return a copy of S where all tab characters are expanded using spaces.</span><br><span class="line">|      If tabsize <span class="keyword">is</span> <span class="keyword">not</span> given, a tab size of <span class="number">8</span> characters <span class="keyword">is</span> assumed.</span><br><span class="line">|</span><br><span class="line">|  find(...)</span><br><span class="line">|      S.find(sub[, start[, end]]) -&gt; int</span><br><span class="line">|</span><br><span class="line">|      Return the lowest index <span class="keyword">in</span> S where substring sub <span class="keyword">is</span> found,</span><br><span class="line">|      such that sub <span class="keyword">is</span> contained within S[start:end].  Optional</span><br><span class="line">|      arguments start <span class="keyword">and</span> end are interpreted <span class="keyword">as</span> <span class="keyword">in</span> slice notation.</span><br><span class="line">|</span><br><span class="line">|      Return <span class="number">-1</span> on failure.</span><br><span class="line">|</span><br><span class="line">|  format(...)</span><br><span class="line">|      S.format(*args, **kwargs) -&gt; str</span><br><span class="line">|</span><br><span class="line">|      Return a formatted version of S, using substitutions <span class="keyword">from</span> args <span class="keyword">and</span> kwargs.</span><br><span class="line">|      The substitutions are identified by braces (<span class="string">'&#123;'</span> <span class="keyword">and</span> <span class="string">'&#125;'</span>).</span><br><span class="line">|</span><br><span class="line">|  format_map(...)</span><br><span class="line">|      S.format_map(mapping) -&gt; str</span><br><span class="line">|</span><br><span class="line">|      Return a formatted version of S, using substitutions <span class="keyword">from</span> mapping.</span><br><span class="line">|      The substitutions are identified by braces (<span class="string">'&#123;'</span> <span class="keyword">and</span> <span class="string">'&#125;'</span>).</span><br><span class="line">|</span><br><span class="line">|  index(...)</span><br><span class="line">|      S.index(sub[, start[, end]]) -&gt; int</span><br><span class="line">|</span><br><span class="line">|      Like S.find() but <span class="keyword">raise</span> ValueError when the substring <span class="keyword">is</span> <span class="keyword">not</span> found.</span><br><span class="line">|</span><br><span class="line">|  isalnum(...)</span><br><span class="line">|      S.isalnum() -&gt; bool</span><br><span class="line">|</span><br><span class="line">|      Return <span class="keyword">True</span> <span class="keyword">if</span> all characters <span class="keyword">in</span> S are alphanumeric</span><br><span class="line">|      <span class="keyword">and</span> there <span class="keyword">is</span> at least one character <span class="keyword">in</span> S, <span class="keyword">False</span> otherwise.</span><br><span class="line">|</span><br><span class="line">|  isalpha(...)</span><br><span class="line">|      S.isalpha() -&gt; bool</span><br><span class="line">|</span><br><span class="line">|      Return <span class="keyword">True</span> <span class="keyword">if</span> all characters <span class="keyword">in</span> S are alphabetic</span><br><span class="line">|      <span class="keyword">and</span> there <span class="keyword">is</span> at least one character <span class="keyword">in</span> S, <span class="keyword">False</span> otherwise.</span><br><span class="line">|</span><br><span class="line">|  isdecimal(...)</span><br><span class="line">|      S.isdecimal() -&gt; bool</span><br><span class="line">|</span><br><span class="line">|      Return <span class="keyword">True</span> <span class="keyword">if</span> there are only decimal characters <span class="keyword">in</span> S,</span><br><span class="line">|      <span class="keyword">False</span> otherwise.</span><br><span class="line">|</span><br><span class="line">|  isdigit(...)</span><br><span class="line">|      S.isdigit() -&gt; bool</span><br><span class="line">|</span><br><span class="line">|      Return <span class="keyword">True</span> <span class="keyword">if</span> all characters <span class="keyword">in</span> S are digits</span><br><span class="line">|      <span class="keyword">and</span> there <span class="keyword">is</span> at least one character <span class="keyword">in</span> S, <span class="keyword">False</span> otherwise.</span><br><span class="line">|</span><br><span class="line">|  isidentifier(...)</span><br><span class="line">|      S.isidentifier() -&gt; bool</span><br><span class="line">|</span><br><span class="line">|      Return <span class="keyword">True</span> <span class="keyword">if</span> S <span class="keyword">is</span> a valid identifier according</span><br><span class="line">|      to the language definition.</span><br><span class="line">|</span><br><span class="line">|      Use keyword.iskeyword() to test <span class="keyword">for</span> reserved identifiers</span><br><span class="line">|      such <span class="keyword">as</span> <span class="string">"def"</span> <span class="keyword">and</span> <span class="string">"class"</span>.</span><br><span class="line">|</span><br><span class="line">|  islower(...)</span><br><span class="line">|      S.islower() -&gt; bool</span><br><span class="line">|</span><br><span class="line">|      Return <span class="keyword">True</span> <span class="keyword">if</span> all cased characters <span class="keyword">in</span> S are lowercase <span class="keyword">and</span> there <span class="keyword">is</span></span><br><span class="line">|      at least one cased character <span class="keyword">in</span> S, <span class="keyword">False</span> otherwise.</span><br><span class="line">|</span><br><span class="line">|  isnumeric(...)</span><br><span class="line">|      S.isnumeric() -&gt; bool</span><br><span class="line">|</span><br><span class="line">|      Return <span class="keyword">True</span> <span class="keyword">if</span> there are only numeric characters <span class="keyword">in</span> S,</span><br><span class="line">|      <span class="keyword">False</span> otherwise.</span><br><span class="line">|</span><br><span class="line">|  isprintable(...)</span><br><span class="line">|      S.isprintable() -&gt; bool</span><br><span class="line">|</span><br><span class="line">|      Return <span class="keyword">True</span> <span class="keyword">if</span> all characters <span class="keyword">in</span> S are considered</span><br><span class="line">|      printable <span class="keyword">in</span> repr() <span class="keyword">or</span> S <span class="keyword">is</span> empty, <span class="keyword">False</span> otherwise.</span><br><span class="line">|</span><br><span class="line">|  isspace(...)</span><br><span class="line">|      S.isspace() -&gt; bool</span><br><span class="line">|</span><br><span class="line">|      Return <span class="keyword">True</span> <span class="keyword">if</span> all characters <span class="keyword">in</span> S are whitespace</span><br><span class="line">|      <span class="keyword">and</span> there <span class="keyword">is</span> at least one character <span class="keyword">in</span> S, <span class="keyword">False</span> otherwise.</span><br><span class="line">|</span><br><span class="line">|  istitle(...)</span><br><span class="line">|      S.istitle() -&gt; bool</span><br><span class="line">|</span><br><span class="line">|      Return <span class="keyword">True</span> <span class="keyword">if</span> S <span class="keyword">is</span> a titlecased string <span class="keyword">and</span> there <span class="keyword">is</span> at least one</span><br><span class="line">|      character <span class="keyword">in</span> S, i.e. upper- <span class="keyword">and</span> titlecase characters may only</span><br><span class="line">|      follow uncased characters <span class="keyword">and</span> lowercase characters only cased ones.</span><br><span class="line">|      Return <span class="keyword">False</span> otherwise.</span><br><span class="line">|</span><br><span class="line">|  isupper(...)</span><br><span class="line">|      S.isupper() -&gt; bool</span><br><span class="line">|</span><br><span class="line">|      Return <span class="keyword">True</span> <span class="keyword">if</span> all cased characters <span class="keyword">in</span> S are uppercase <span class="keyword">and</span> there <span class="keyword">is</span></span><br><span class="line">|      at least one cased character <span class="keyword">in</span> S, <span class="keyword">False</span> otherwise.</span><br><span class="line">|</span><br><span class="line">|  join(...)</span><br><span class="line">|      S.join(iterable) -&gt; str</span><br><span class="line">|</span><br><span class="line">|      Return a string which <span class="keyword">is</span> the concatenation of the strings <span class="keyword">in</span> the</span><br><span class="line">|      iterable.  The separator between elements <span class="keyword">is</span> S.</span><br><span class="line">|</span><br><span class="line">|  ljust(...)</span><br><span class="line">|      S.ljust(width[, fillchar]) -&gt; str</span><br><span class="line">|</span><br><span class="line">|      Return S left-justified <span class="keyword">in</span> a Unicode string of length width. Padding <span class="keyword">is</span></span><br><span class="line">|      done using the specified fill character (default <span class="keyword">is</span> a space).</span><br><span class="line">|</span><br><span class="line">|  lower(...)</span><br><span class="line">|      S.lower() -&gt; str</span><br><span class="line">|</span><br><span class="line">|      Return a copy of the string S converted to lowercase.</span><br><span class="line">|</span><br><span class="line">|  lstrip(...)</span><br><span class="line">|      S.lstrip([chars]) -&gt; str</span><br><span class="line">|</span><br><span class="line">|      Return a copy of the string S <span class="keyword">with</span> leading whitespace removed.</span><br><span class="line">|      If chars <span class="keyword">is</span> given <span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">None</span>, remove characters <span class="keyword">in</span> chars instead.</span><br><span class="line">|</span><br><span class="line">|  partition(...)</span><br><span class="line">|      S.partition(sep) -&gt; (head, sep, tail)</span><br><span class="line">|</span><br><span class="line">|      Search <span class="keyword">for</span> the separator sep <span class="keyword">in</span> S, <span class="keyword">and</span> <span class="keyword">return</span> the part before it,</span><br><span class="line">|      the separator itself, <span class="keyword">and</span> the part after it.  If the separator <span class="keyword">is</span> <span class="keyword">not</span></span><br><span class="line">|      found, <span class="keyword">return</span> S <span class="keyword">and</span> two empty strings.</span><br><span class="line">|</span><br><span class="line">|  replace(...)</span><br><span class="line">|      S.replace(old, new[, count]) -&gt; str</span><br><span class="line">|</span><br><span class="line">|      Return a copy of S <span class="keyword">with</span> all occurrences of substring</span><br><span class="line">|      old replaced by new.  If the optional argument count <span class="keyword">is</span></span><br><span class="line">|      given, only the first count occurrences are replaced.</span><br><span class="line">|</span><br><span class="line">|  rfind(...)</span><br><span class="line">|      S.rfind(sub[, start[, end]]) -&gt; int</span><br><span class="line">|</span><br><span class="line">|      Return the highest index <span class="keyword">in</span> S where substring sub <span class="keyword">is</span> found,</span><br><span class="line">|      such that sub <span class="keyword">is</span> contained within S[start:end].  Optional</span><br><span class="line">|      arguments start <span class="keyword">and</span> end are interpreted <span class="keyword">as</span> <span class="keyword">in</span> slice notation.</span><br><span class="line">|</span><br><span class="line">|      Return <span class="number">-1</span> on failure.</span><br><span class="line">|</span><br><span class="line">|  rindex(...)</span><br><span class="line">|      S.rindex(sub[, start[, end]]) -&gt; int</span><br><span class="line">|</span><br><span class="line">|      Like S.rfind() but <span class="keyword">raise</span> ValueError when the substring <span class="keyword">is</span> <span class="keyword">not</span> found.</span><br><span class="line">|</span><br><span class="line">|  rjust(...)</span><br><span class="line">|      S.rjust(width[, fillchar]) -&gt; str</span><br><span class="line">|</span><br><span class="line">|      Return S right-justified <span class="keyword">in</span> a string of length width. Padding <span class="keyword">is</span></span><br><span class="line">|      done using the specified fill character (default <span class="keyword">is</span> a space).</span><br><span class="line">|</span><br><span class="line">|  rpartition(...)</span><br><span class="line">|      S.rpartition(sep) -&gt; (head, sep, tail)</span><br><span class="line">|</span><br><span class="line">|      Search <span class="keyword">for</span> the separator sep <span class="keyword">in</span> S, starting at the end of S, <span class="keyword">and</span> <span class="keyword">return</span></span><br><span class="line">|      the part before it, the separator itself, <span class="keyword">and</span> the part after it.  If the</span><br><span class="line">|      separator <span class="keyword">is</span> <span class="keyword">not</span> found, <span class="keyword">return</span> two empty strings <span class="keyword">and</span> S.</span><br><span class="line">|</span><br><span class="line">|  rsplit(...)</span><br><span class="line">|      S.rsplit(sep=None, maxsplit=-1) -&gt; list of strings</span><br><span class="line">|</span><br><span class="line">|      Return a list of the words <span class="keyword">in</span> S, using sep <span class="keyword">as</span> the</span><br><span class="line">|      delimiter string, starting at the end of the string <span class="keyword">and</span></span><br><span class="line">|      working to the front.  If maxsplit <span class="keyword">is</span> given, at most maxsplit</span><br><span class="line">|      splits are done. If sep <span class="keyword">is</span> <span class="keyword">not</span> specified, any whitespace string</span><br><span class="line">|      <span class="keyword">is</span> a separator.</span><br><span class="line">|</span><br><span class="line">|  rstrip(...)</span><br><span class="line">|      S.rstrip([chars]) -&gt; str</span><br><span class="line">|</span><br><span class="line">|      Return a copy of the string S <span class="keyword">with</span> trailing whitespace removed.</span><br><span class="line">|      If chars <span class="keyword">is</span> given <span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">None</span>, remove characters <span class="keyword">in</span> chars instead.</span><br><span class="line">|</span><br><span class="line">|  split(...)</span><br><span class="line">|      S.split(sep=None, maxsplit=-1) -&gt; list of strings</span><br><span class="line">|</span><br><span class="line">|      Return a list of the words <span class="keyword">in</span> S, using sep <span class="keyword">as</span> the</span><br><span class="line">|      delimiter string.  If maxsplit <span class="keyword">is</span> given, at most maxsplit</span><br><span class="line">|      splits are done. If sep <span class="keyword">is</span> <span class="keyword">not</span> specified <span class="keyword">or</span> <span class="keyword">is</span> <span class="keyword">None</span>, any</span><br><span class="line">|      whitespace string <span class="keyword">is</span> a separator <span class="keyword">and</span> empty strings are</span><br><span class="line">|      removed <span class="keyword">from</span> the result.</span><br><span class="line">|</span><br><span class="line">|  splitlines(...)</span><br><span class="line">|      S.splitlines([keepends]) -&gt; list of strings</span><br><span class="line">|</span><br><span class="line">|      Return a list of the lines <span class="keyword">in</span> S, breaking at line boundaries.</span><br><span class="line">|      Line breaks are <span class="keyword">not</span> included <span class="keyword">in</span> the resulting list unless keepends</span><br><span class="line">|      <span class="keyword">is</span> given <span class="keyword">and</span> true.</span><br><span class="line">|</span><br><span class="line">|  startswith(...)</span><br><span class="line">|      S.startswith(prefix[, start[, end]]) -&gt; bool</span><br><span class="line">|</span><br><span class="line">|      Return <span class="keyword">True</span> <span class="keyword">if</span> S starts <span class="keyword">with</span> the specified prefix, <span class="keyword">False</span> otherwise.</span><br><span class="line">|      With optional start, test S beginning at that position.</span><br><span class="line">|      With optional end, stop comparing S at that position.</span><br><span class="line">|      prefix can also be a tuple of strings to <span class="keyword">try</span>.</span><br><span class="line">|</span><br><span class="line">|  strip(...)</span><br><span class="line">|      S.strip([chars]) -&gt; str</span><br><span class="line">|</span><br><span class="line">|      Return a copy of the string S <span class="keyword">with</span> leading <span class="keyword">and</span> trailing</span><br><span class="line">|      whitespace removed.</span><br><span class="line">|      If chars <span class="keyword">is</span> given <span class="keyword">and</span> <span class="keyword">not</span> <span class="keyword">None</span>, remove characters <span class="keyword">in</span> chars instead.</span><br><span class="line">|</span><br><span class="line">|  swapcase(...)</span><br><span class="line">|      S.swapcase() -&gt; str</span><br><span class="line">|</span><br><span class="line">|      Return a copy of S <span class="keyword">with</span> uppercase characters converted to lowercase</span><br><span class="line">|      <span class="keyword">and</span> vice versa.</span><br><span class="line">|</span><br><span class="line">|  title(...)</span><br><span class="line">|      S.title() -&gt; str</span><br><span class="line">|</span><br><span class="line">|      Return a titlecased version of S, i.e. words start <span class="keyword">with</span> title case</span><br><span class="line">|      characters, all remaining cased characters have lower case.</span><br><span class="line">|</span><br><span class="line">|  translate(...)</span><br><span class="line">|      S.translate(table) -&gt; str</span><br><span class="line">|</span><br><span class="line">|      Return a copy of the string S <span class="keyword">in</span> which each character has been mapped</span><br><span class="line">|      through the given translation table. The table must implement</span><br><span class="line">|      lookup/indexing via __getitem__, <span class="keyword">for</span> instance a dictionary <span class="keyword">or</span> list,</span><br><span class="line">|      mapping Unicode ordinals to Unicode ordinals, strings, <span class="keyword">or</span> <span class="keyword">None</span>. If</span><br><span class="line">|      this operation raises LookupError, the character <span class="keyword">is</span> left untouched.</span><br><span class="line">|      Characters mapped to <span class="keyword">None</span> are deleted.</span><br><span class="line">|</span><br><span class="line">|  upper(...)</span><br><span class="line">|      S.upper() -&gt; str</span><br><span class="line">|</span><br><span class="line">|      Return a copy of S converted to uppercase.</span><br><span class="line">|</span><br><span class="line">|  zfill(...)</span><br><span class="line">|      S.zfill(width) -&gt; str</span><br><span class="line">|</span><br><span class="line">|      Pad a numeric string S <span class="keyword">with</span> zeros on the left, to fill a field</span><br><span class="line">|      of the specified width. The string S <span class="keyword">is</span> never truncated.</span><br><span class="line">|</span><br><span class="line">|  ----------------------------------------------------------------------</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-字符串&quot;&gt;&lt;a href=&quot;#Python之路-字符串&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 字符串&quot;&gt;&lt;/a&gt;Python之路 - 字符串&lt;/h1&gt;&lt;h2 id=&quot;介绍-🍀&quot;&gt;&lt;a href=&quot;#介绍-🍀&quot; class=&quot;headerlink&quot; title=&quot;介绍  🍀&quot;&gt;&lt;/a&gt;介绍  🍀&lt;/h2&gt;&lt;p&gt;字符串是Python中最基本的数据类型之一 &lt;/p&gt;
&lt;p&gt;字符串的使用需要用引号括起来 , 例如 : &lt;code&gt;name = &amp;quot;Lyon&amp;quot;&lt;/code&gt; ; 这里name就是一个变量名 , 而引号里面的&lt;code&gt;Lyon&lt;/code&gt; 则就是该变量绑定的值 , 该值的类型为 “ str” 类型 , 我们可以利用&lt;code&gt;type()&lt;/code&gt; 函数进行查看 : &lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;name = &lt;span class=&quot;string&quot;&gt;&quot;Lyon&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;type(name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &#39;&lt;span class=&quot;title&quot;&gt;str&lt;/span&gt;&#39;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这就是字符串类型 , 当然如上使用的是双引号 , 这里其实还可以使用单引号&lt;code&gt;&amp;#39;Lyon&amp;#39;&lt;/code&gt;以及三引号&lt;code&gt;&amp;#39;&amp;#39;&amp;#39;Lyon&amp;#39;&amp;#39;&amp;#39;&lt;/code&gt;(或者是&lt;code&gt;&amp;quot;&amp;quot;&amp;quot;Lyon&amp;quot;&amp;quot;&amp;quot;&lt;/code&gt;  , 单引号双引号都可以) , 不过对于三引号 , 我们通常是表示多行字符串 , 这样我们就不需要利用 “ \n “ （换行符）来进行每一行的换行了&lt;/p&gt;
&lt;p&gt;对于嵌套引号的时候要注意 , 需要用不同的引号来避免歧义 , 比如 : &lt;code&gt;&amp;#39;I am &amp;quot;Lyon&amp;quot;&amp;#39;&lt;/code&gt;  , 也可以 &lt;code&gt;&amp;quot;I am &amp;#39;Lyon&amp;#39;&amp;quot;&lt;/code&gt; &lt;/p&gt;
&lt;p&gt;对于所有的基本数据类型 , 我们都应该熟悉其特性以及操作&lt;/p&gt;
&lt;p&gt;字符串操作主要有 &lt;strong&gt;拷贝（复制）、拼接、查找、统计、切片、测试、大小写,字符串列表转换等&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在开始详细了解这些操作之前 , 我们需要记住一个特性 : &lt;strong&gt;字符串是不可变的&lt;/strong&gt; , 既然是不可变的 , 那么我们对其进行的增删改查就都不是对本身进行操作的 , 而是创建了一个新的字符串&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="basic" scheme="https://jesse.top/categories/python/basic/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>07.Python之路-字典</title>
    <link href="https://jesse.top/2020/05/27/python/01-basic/07-Python%E4%B9%8B%E8%B7%AF-%E5%AD%97%E5%85%B8/"/>
    <id>https://jesse.top/2020/05/27/python/01-basic/07-Python之路-字典/</id>
    <published>2020-05-27T14:59:58.000Z</published>
    <updated>2020-05-27T15:19:32.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-字典"><a href="#Python之路-字典" class="headerlink" title="Python之路 - 字典"></a>Python之路 - 字典</h1><h2 id="介绍-🍀"><a href="#介绍-🍀" class="headerlink" title="介绍  🍀"></a>介绍  🍀</h2><p>字典是一种key - value 的数据类型 , 用 冒号 (“ : “) 来分割 , 每个对象之间用逗号(“ , “)分割 , 整个字典包括在花括号(“{ }”)中</p><p>字典中的键(key)是唯一的 , 但值(value)则不必</p><p><strong>字典是可变的数据类型 , 并且是无序的</strong></p><blockquote><p>从python3.6版本开始.字典是有序的</p></blockquote><p>基本操作如下 : <strong>创建、增加、修改、删除、查找、遍历、多级嵌套</strong>等</p><p>注意 : 字典中key是唯一的 , 如果出现多个相同的key被赋值 , 那么值为最后一个赋的值 ; key是不可变的 , 所以可变的数据类型是不能用的 , 如 : list , 对于不可变的数据类型则可以 , 如 : str、int、tuple</p><p>2）key是不可变的 , 所以可变的数据类型是不能用的 , 如 : list , 对于不可变的数据类型则可以 , 如 : str、int、tuple</p><a id="more"></a><h2 id="创建-🍀"><a href="#创建-🍀" class="headerlink" title="创建  🍀"></a>创建  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个空字典</span></span><br><span class="line">empty_info = &#123;&#125;</span><br><span class="line"><span class="comment"># 创建一个字典</span></span><br><span class="line">info = &#123;<span class="string">"name"</span>:<span class="string">"Lyon"</span>,<span class="string">"age"</span>:<span class="number">21</span>&#125;</span><br><span class="line"><span class="comment"># 也可调用dict()方法</span></span><br><span class="line">info = dict()</span><br></pre></td></tr></table></figure><h2 id="增加-🍀"><a href="#增加-🍀" class="headerlink" title="增加  🍀"></a>增加  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#创建字典</span></span><br><span class="line">dic = &#123;<span class="string">"name"</span>:<span class="string">"jesse"</span>,<span class="string">"age"</span>:<span class="number">33</span>,<span class="string">"job"</span>:<span class="string">"it"</span>,<span class="string">"sex"</span>:<span class="string">"male"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 增加键值对</span></span><br><span class="line"><span class="comment">#给字典增加一个新的键值对.如果键不存在,则添加</span></span><br><span class="line">dic[<span class="string">'company'</span>] = <span class="string">'dwd'</span></span><br><span class="line">print(dic)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">'name'</span>: <span class="string">'jesse'</span>, <span class="string">'age'</span>: <span class="number">33</span>, <span class="string">'job'</span>: <span class="string">'it'</span>, <span class="string">'sex'</span>: <span class="string">'male'</span>, <span class="string">'company'</span>: <span class="string">'dwd'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果字典已经存在了这个键.则用新的值替代</span></span><br><span class="line">dic[<span class="string">'company'</span>] = <span class="string">'hsq'</span></span><br><span class="line">print(dic)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">'name'</span>: <span class="string">'jesse'</span>, <span class="string">'age'</span>: <span class="number">33</span>, <span class="string">'job'</span>: <span class="string">'it'</span>, <span class="string">'sex'</span>: <span class="string">'male'</span>, <span class="string">'company'</span>: <span class="string">'hsq'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#通过setdefault方法也可以增加一个值</span></span><br><span class="line">dic.setdefault(<span class="string">'school'</span>,<span class="string">"college"</span>)</span><br><span class="line">print(dic)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&#123;<span class="string">'name'</span>: <span class="string">'jesse'</span>, <span class="string">'age'</span>: <span class="number">33</span>, <span class="string">'job'</span>: <span class="string">'it'</span>, <span class="string">'sex'</span>: <span class="string">'male'</span>, <span class="string">'company'</span>: <span class="string">'hsq'</span>, <span class="string">'school'</span>: <span class="string">'college'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#和刚才相反.如果键已经存在,则新值不会生效.</span></span><br><span class="line">dic.setdefault(<span class="string">'school'</span>,<span class="string">'primary'</span>)</span><br><span class="line">print(dic)</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&#123;<span class="string">'name'</span>: <span class="string">'jesse'</span>, <span class="string">'age'</span>: <span class="number">33</span>, <span class="string">'job'</span>: <span class="string">'it'</span>, <span class="string">'sex'</span>: <span class="string">'male'</span>, <span class="string">'company'</span>: <span class="string">'hsq'</span>, <span class="string">'school'</span>: <span class="string">'college'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#update方法也可以修改字典键值对.如果键已经存在,则修改值,如果不存在,则添加</span></span><br><span class="line">dic.update(&#123;<span class="string">"name"</span>:<span class="string">"Lyon"</span>,<span class="string">"company"</span>:<span class="string">"internet"</span>&#125;)</span><br></pre></td></tr></table></figure><h2 id="修改-🍀"><a href="#修改-🍀" class="headerlink" title="修改  🍀"></a>修改  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个字典</span></span><br><span class="line">info = &#123;<span class="string">"name"</span>:<span class="string">"Lyon"</span>,<span class="string">"age"</span>:<span class="number">21</span>,<span class="string">"school"</span>:<span class="string">"university"</span>&#125;</span><br><span class="line"><span class="comment"># 修改age</span></span><br><span class="line">info[<span class="string">"age"</span>] = <span class="number">18</span></span><br><span class="line"><span class="comment"># 打印info</span></span><br><span class="line">print(info)     </span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">&#123;'age': 18, 'school': 'university', 'name': 'Lyon'&#125;</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="删除-🍀"><a href="#删除-🍀" class="headerlink" title="删除  🍀"></a>删除  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个字典</span></span><br><span class="line">dic = &#123;<span class="string">"name"</span>:<span class="string">"jesse"</span>,<span class="string">"age"</span>:<span class="number">33</span>,<span class="string">"job"</span>:<span class="string">"it"</span>,<span class="string">"sex"</span>:<span class="string">"male"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1.pop()删除法</span></span><br><span class="line">dic.pop(<span class="string">'name'</span>)</span><br><span class="line">print(dic)</span><br><span class="line"><span class="comment"># 注意pop方法有返回值</span></span><br><span class="line">print(dic.pop(<span class="string">'name'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>jesse</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span><span class="keyword">del</span>删除方法</span><br><span class="line"><span class="keyword">del</span> dic[<span class="string">'name'</span>]</span><br><span class="line">print(dic)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">'age'</span>: <span class="number">33</span>, <span class="string">'job'</span>: <span class="string">'it'</span>, <span class="string">'sex'</span>: <span class="string">'male'</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># popitem删除法.(默认只删除最后一个)</span></span><br><span class="line">dic.popitem()</span><br><span class="line">print(dic)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>&#123;<span class="string">'name'</span>: <span class="string">'jesse'</span>, <span class="string">'age'</span>: <span class="number">33</span>, <span class="string">'job'</span>: <span class="string">'it'</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="查找-🍀"><a href="#查找-🍀" class="headerlink" title="查找  🍀"></a>查找  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个字典</span></span><br><span class="line">info = &#123;<span class="string">"name"</span>:<span class="string">"Lyon"</span>,<span class="string">"age"</span>:<span class="number">21</span>,<span class="string">"school"</span>:<span class="string">"university"</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">#1.查找键是否存在于字典中</span></span><br><span class="line">print(<span class="string">'name'</span> <span class="keyword">in</span> dic)</span><br><span class="line">print(<span class="string">'jesse'</span> <span class="keyword">in</span> dic)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">True</span></span><br><span class="line"><span class="keyword">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#2.获取键的值</span></span><br><span class="line">print(dic[<span class="string">'name'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>jesse</span><br><span class="line"><span class="comment">#注意.如果字典中没有这个键,程序会报错</span></span><br><span class="line">print(dic[<span class="string">'jesse'</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>KeyError: <span class="string">'jesse'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># get方法优雅的获取字典中某个键的值</span></span><br><span class="line">print(dic.get(<span class="string">'name'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>jesse</span><br><span class="line"></span><br><span class="line"><span class="comment">#如果没有这个键,则返回none.但是程序不会报错</span></span><br><span class="line">print(dic.get(<span class="string">'jesse'</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">None</span></span><br></pre></td></tr></table></figure><h2 id="遍历-🍀"><a href="#遍历-🍀" class="headerlink" title="遍历  🍀"></a>遍历  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个字典</span></span><br><span class="line">info = &#123;<span class="string">"name"</span>:<span class="string">"Lyon"</span>,<span class="string">"age"</span>:<span class="number">21</span>,<span class="string">"school"</span>:<span class="string">"university"</span>&#125;</span><br><span class="line"><span class="comment"># 方法1,推荐</span></span><br><span class="line"><span class="keyword">for</span> key <span class="keyword">in</span> info:</span><br><span class="line">  print(key,info[key])</span><br><span class="line">  </span><br><span class="line"><span class="comment"># 方法2</span></span><br><span class="line"><span class="keyword">for</span> k,v <span class="keyword">in</span> info.items():</span><br><span class="line">  print(k,v)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">school university</span></span><br><span class="line"><span class="string">name Lyon</span></span><br><span class="line"><span class="string">age 21</span></span><br><span class="line"><span class="string">school university</span></span><br><span class="line"><span class="string">name Lyon</span></span><br><span class="line"><span class="string">age 21</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="嵌套-🍀"><a href="#嵌套-🍀" class="headerlink" title="嵌套  🍀"></a>嵌套  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个多级嵌套字典</span></span><br><span class="line">dics = &#123;</span><br><span class="line">    <span class="string">'name'</span>:&#123;</span><br><span class="line">        <span class="string">'jesse'</span>:&#123;</span><br><span class="line">            <span class="string">'age'</span>:<span class="number">22</span>,</span><br><span class="line">            <span class="string">'job'</span>:<span class="string">'it'</span>,</span><br><span class="line">            <span class="string">'sex'</span>:<span class="string">'male'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'jerry'</span>:&#123;</span><br><span class="line">            <span class="string">'age'</span>:<span class="number">23</span>,</span><br><span class="line">            <span class="string">'job'</span>:<span class="string">'it'</span>,</span><br><span class="line">            <span class="string">'sex'</span>:<span class="string">'female'</span></span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'home'</span>: &#123;</span><br><span class="line">        <span class="string">'jesse'</span>:&#123;</span><br><span class="line">            <span class="string">'live'</span>:<span class="string">'shanghai'</span>,</span><br><span class="line">            <span class="string">'hometown'</span>:<span class="string">'jiangxi'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'jerry'</span>:&#123;</span><br><span class="line">            <span class="string">'live'</span>:<span class="string">'beijing'</span>,</span><br><span class="line">            <span class="string">'hometown'</span>:<span class="string">'wuhan'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">'company'</span>:&#123;</span><br><span class="line">        <span class="string">'jesse'</span>:&#123;</span><br><span class="line">            <span class="string">'name'</span>:<span class="string">'dwd'</span>,</span><br><span class="line">            <span class="string">'industry'</span>: <span class="string">'internet'</span></span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">'jerry'</span>:&#123;</span><br><span class="line">            <span class="string">'name'</span>: <span class="string">'bat'</span>,</span><br><span class="line">            <span class="string">'industry'</span>: <span class="string">'internet'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment"># 修改最里层的value</span></span><br><span class="line">dics[<span class="string">'name'</span>][<span class="string">'jesse'</span>][<span class="string">'age'</span>] = <span class="number">33</span></span><br><span class="line">print(dics[<span class="string">'name'</span>][<span class="string">'jesse'</span>])</span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt;&#123;<span class="string">'age'</span>: <span class="number">33</span>, <span class="string">'job'</span>: <span class="string">'it'</span>, <span class="string">'sex'</span>: <span class="string">'male'</span>&#125;</span><br></pre></td></tr></table></figure><h2 id="更多-🍀"><a href="#更多-🍀" class="headerlink" title="更多  🍀"></a>更多  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">len(dict)        <span class="comment"># 计算字典元素个数</span></span><br><span class="line">dict.clear()     <span class="comment"># 清空词典所有条目</span></span><br><span class="line">dict.fromkeys(seq, val))  <span class="comment"># 创建一个新字典,以列表 seq 中元素做字典的键,val 为字典所有键对应的初始值</span></span><br><span class="line">dict.has_key(key)  <span class="comment"># 如果键在字典dict里返回true,否则返回false</span></span><br><span class="line">dict.items()       <span class="comment"># 以列表返回可遍历的(键, 值) 元组数组</span></span><br><span class="line">dict.keys()        <span class="comment"># 以列表返回一个字典所有的键</span></span><br><span class="line">dict.values()      <span class="comment"># 以列表返回字典中的所有值</span></span><br><span class="line">dict.setdefault(key, default=<span class="keyword">None</span>) <span class="comment"># 和get()类似, 但如果键不存在于字典中,将会添加键并将值设为default</span></span><br><span class="line">dict.update(dict2)                 <span class="comment"># 把字典dict2的键/值对更新到dict里</span></span><br></pre></td></tr></table></figure><p>方法合集</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">|  clear(...)</span><br><span class="line">|      D.clear() -&gt; None.  Remove all items from D.</span><br><span class="line">|</span><br><span class="line">|  copy(...)</span><br><span class="line">|      D.copy() -&gt; a shallow copy of D</span><br><span class="line">|</span><br><span class="line">|  fromkeys(iterable, value=<span class="keyword">None</span>, /) <span class="keyword">from</span> builtins.type</span><br><span class="line">|      Returns a new dict <span class="keyword">with</span> keys <span class="keyword">from</span> iterable <span class="keyword">and</span> values equal to value.</span><br><span class="line">|</span><br><span class="line">|  get(...)</span><br><span class="line">|      D.get(k[,d]) -&gt; D[k] if k in D, else d.  d defaults to None.</span><br><span class="line">|</span><br><span class="line">|  items(...)</span><br><span class="line">|      D.items() -&gt; a set-like object providing a view on D's items</span><br><span class="line">|</span><br><span class="line">|  keys(...)</span><br><span class="line">|      D.keys() -&gt; a set-like object providing a view on D's keys</span><br><span class="line">|</span><br><span class="line">|  pop(...)</span><br><span class="line">|      D.pop(k[,d]) -&gt; v, remove specified key and return the corresponding value.</span><br><span class="line">|      If key <span class="keyword">is</span> <span class="keyword">not</span> found, d <span class="keyword">is</span> returned <span class="keyword">if</span> given, otherwise KeyError <span class="keyword">is</span> raised</span><br><span class="line">|</span><br><span class="line">|  popitem(...)</span><br><span class="line">|      D.popitem() -&gt; (k, v), remove and return some (key, value) pair as a</span><br><span class="line">|      <span class="number">2</span>-tuple; but <span class="keyword">raise</span> KeyError <span class="keyword">if</span> D <span class="keyword">is</span> empty.</span><br><span class="line">|</span><br><span class="line">|  setdefault(...)</span><br><span class="line">|      D.setdefault(k[,d]) -&gt; D.get(k,d), also set D[k]=d if k not in D</span><br><span class="line">|</span><br><span class="line">|  update(...)</span><br><span class="line">|      D.update([E, ]**F) -&gt; None.  Update D from dict/iterable E and F.</span><br><span class="line">|      If E <span class="keyword">is</span> present <span class="keyword">and</span> has a .keys() method, then does:  <span class="keyword">for</span> k <span class="keyword">in</span> E: D[k] = E[k]</span><br><span class="line">|      If E <span class="keyword">is</span> present <span class="keyword">and</span> lacks a .keys() method, then does:  <span class="keyword">for</span> k, v <span class="keyword">in</span> E: D[k] = v</span><br><span class="line">|      In either case, this <span class="keyword">is</span> followed by: <span class="keyword">for</span> k <span class="keyword">in</span> F:  D[k] = F[k]</span><br><span class="line">|</span><br><span class="line">|  values(...)</span><br><span class="line">|      D.values() -&gt; an object providing a view on D's values</span><br></pre></td></tr></table></figure><hr><h3 id="作业"><a href="#作业" class="headerlink" title="作业"></a>作业</h3><h5 id="1-将下列字典中的key键含有’k’元素的所有键值对删除"><a href="#1-将下列字典中的key键含有’k’元素的所有键值对删除" class="headerlink" title="1.将下列字典中的key键含有’k’元素的所有键值对删除"></a>1.将下列字典中的key键含有’k’元素的所有键值对删除</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#下面的方法报错...&quot;RuntimeError: dictionary changed size during iteration&quot;</span><br><span class="line">#注意,字典在循环或者迭代的时候,不能修改该字典的内容.</span><br><span class="line"></span><br><span class="line">dic = &#123;&apos;k1&apos;:&apos;v1&apos;,&quot;k2&quot;:&apos;v2&apos;,&quot;k3&quot;:&apos;v3&apos;,&apos;name&apos;:&apos;jesse&apos;&#125;</span><br><span class="line"></span><br><span class="line">for k in dic:</span><br><span class="line">    if &apos;k&apos; in k:</span><br><span class="line">        del dic[k]</span><br><span class="line"></span><br><span class="line">print(dic)</span><br><span class="line"></span><br><span class="line">#但是可以在循环一个列表的时候修改该字典</span><br><span class="line"></span><br><span class="line">#新建一个空列表</span><br><span class="line">l1 = []</span><br><span class="line"></span><br><span class="line">#循环列表,将满足要求的key键添加进一个列表</span><br><span class="line">for k in dic:</span><br><span class="line">    if &apos;k&apos; in k:</span><br><span class="line">        l1.append(k)</span><br><span class="line"></span><br><span class="line">#循环列表,这里就是循环字典的KEY..然后删除dic的键</span><br><span class="line">for keys in l1:</span><br><span class="line">    del dic[keys]</span><br><span class="line"></span><br><span class="line">print(dic)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-字典&quot;&gt;&lt;a href=&quot;#Python之路-字典&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 字典&quot;&gt;&lt;/a&gt;Python之路 - 字典&lt;/h1&gt;&lt;h2 id=&quot;介绍-🍀&quot;&gt;&lt;a href=&quot;#介绍-🍀&quot; class=&quot;headerlink&quot; title=&quot;介绍  🍀&quot;&gt;&lt;/a&gt;介绍  🍀&lt;/h2&gt;&lt;p&gt;字典是一种key - value 的数据类型 , 用 冒号 (“ : “) 来分割 , 每个对象之间用逗号(“ , “)分割 , 整个字典包括在花括号(“{ }”)中&lt;/p&gt;
&lt;p&gt;字典中的键(key)是唯一的 , 但值(value)则不必&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;字典是可变的数据类型 , 并且是无序的&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;从python3.6版本开始.字典是有序的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;基本操作如下 : &lt;strong&gt;创建、增加、修改、删除、查找、遍历、多级嵌套&lt;/strong&gt;等&lt;/p&gt;
&lt;p&gt;注意 : 字典中key是唯一的 , 如果出现多个相同的key被赋值 , 那么值为最后一个赋的值 ; key是不可变的 , 所以可变的数据类型是不能用的 , 如 : list , 对于不可变的数据类型则可以 , 如 : str、int、tuple&lt;/p&gt;
&lt;p&gt;2）key是不可变的 , 所以可变的数据类型是不能用的 , 如 : list , 对于不可变的数据类型则可以 , 如 : str、int、tuple&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="basic" scheme="https://jesse.top/categories/python/basic/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>10.Python之路 - 文件操作</title>
    <link href="https://jesse.top/2020/05/27/python/01-basic/10-Python%E4%B9%8B%E8%B7%AF%20-%20%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <id>https://jesse.top/2020/05/27/python/01-basic/10-Python之路 - 文件操作/</id>
    <published>2020-05-27T14:59:58.000Z</published>
    <updated>2020-05-27T15:20:04.390Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-文件操作"><a href="#Python之路-文件操作" class="headerlink" title="Python之路 - 文件操作"></a>Python之路 - 文件操作</h1><h2 id="介绍-🍀"><a href="#介绍-🍀" class="headerlink" title="介绍  🍀"></a>介绍  🍀</h2><p>在磁盘上读写文件的功能都是由操作系统提供的 , 现代操作系统不允许普通的程序直接操作磁盘 , 所以 , 读写文件就是请求操作系统打开一个文件对象 (通常称为文件描述符) ; 然后 , 通过操作系统提供的接口从这个文件对象中读取数据 (读文件) , 或者把数据写入这个文件对象 (写文件) </p><p>在Python中我们进行文件操作需要首先利用<code>open()</code> 函数获取一个文件流来操作文件</p><p>这个流就是我们所使用的文件描述符 , 是一个I/O通道</p><h2 id="open-🍀"><a href="#open-🍀" class="headerlink" title="open()  🍀"></a>open()  🍀</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">open(file, mode=<span class="string">'r'</span>, buffering=<span class="number">-1</span>, encoding=<span class="keyword">None</span>, errors=<span class="keyword">None</span>, newline=<span class="keyword">None</span>, closefd=<span class="keyword">True</span>, opener=<span class="keyword">None</span>):</span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    file:文件名</span></span><br><span class="line"><span class="string">    mode:模式</span></span><br><span class="line"><span class="string">    buffering:设置缓冲策略</span></span><br><span class="line"><span class="string">    encoding:指定使用编码</span></span><br><span class="line"><span class="string">    errors:指定处理编码和解码错误的方式</span></span><br><span class="line"><span class="string">    newline:控制通用换行模式的工作方式(只适用文本模式)</span></span><br><span class="line"><span class="string">    closefd:如果为False并且给出了文件描述符而不是文件名,则文件关闭时,文件描述符将保持打开;如果给定文件名,则closefd必须为True,否则将抛出异常</span></span><br><span class="line"><span class="string">    opener:自定义开启器</span></span><br><span class="line"><span class="string">    """</span></span><br></pre></td></tr></table></figure><p>对于上述参数中 , 我们主要需要了解的就是<code>file</code> , <code>mode</code> , <code>encoding</code> 这三个</p><a id="more"></a><p>对于mode , 有以下模式 : </p><table><thead><tr><th>Character</th><th>Meaning</th></tr></thead><tbody><tr><td><code>&#39;r&#39;</code></td><td>open for reading (default)</td></tr><tr><td><code>&#39;w&#39;</code></td><td>open for writing, truncating the file first</td></tr><tr><td><code>&#39;x&#39;</code></td><td>open for exclusive creation, failing if the file already exists</td></tr><tr><td><code>&#39;a&#39;</code></td><td>open for writing, appending to the end of the file if it exists</td></tr><tr><td><code>&#39;b&#39;</code></td><td>binary mode</td></tr><tr><td><code>&#39;t&#39;</code></td><td>text mode (default)</td></tr><tr><td><code>&#39;+&#39;</code></td><td>open a disk file for updating (reading and writing)</td></tr><tr><td><code>&#39;U&#39;</code></td><td><a href="https://docs.python.org/3.5/glossary.html#term-universal-newlines" target="_blank" rel="noopener">universal newlines</a> mode (deprecated)</td></tr></tbody></table><p>常使用的就是<code>&#39;r&#39;</code> , <code>&#39;w&#39;</code> , <code>&#39;a&#39;</code> , <code>&#39;+&#39;</code> , <code>&#39;b&#39;</code> , 当然还可以组合使用 , 下面进行详细介绍 : </p><ul><li>r , 只读模式 , 文件必须已经存在</li><li>r+ , 可读可写模式 , 文件必须已经存在</li><li>w , 只写模式 , 会重新创建 , 意味着文件如果已存在会被空文件覆盖</li><li>w+ , 可写可读模式 , 同样会创建文件</li><li>a , 追写模式 , 文件不存在参考’w’</li><li>a+ , 追写并可读模式 , 文件不存在参考’w’</li><li>b , 以二进制的模式进行处理 (Linux可忽略 , Windows处理二进制文件时需标注)  , 可以用该模式来读取图片 , 视频等等<ul><li>rb , 同r</li><li>wb , 同w </li><li>ab , 同a</li></ul></li></ul><p>简单实例</p><p>file.txt</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">A man is not old until his regrets take place of his dreams.  </span><br><span class="line"></span><br><span class="line">Nothing can help us endure dark times better than our faith.</span><br><span class="line"></span><br><span class="line">No one but ourselves can degrade us.</span><br></pre></td></tr></table></figure><p>实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'file.txt'</span>,<span class="string">'r'</span>)</span><br><span class="line">contents = f.read</span><br><span class="line">print(contents)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">A man is not old until his regrets take place of his dreams.  </span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Nothing can help us endure dark times better than our faith.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">No one but ourselves can degrade us. </span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="file-like-object-🍀"><a href="#file-like-object-🍀" class="headerlink" title="file-like object  🍀"></a>file-like object  🍀</h2><p>io模块提供了Python处理各种类型I/O的主要工具 , 有三种主要类型 , 即<code>文本I/O</code> , <code>二进 制I/O</code>和<code>原始I/O</code> , 这些是通用类别 , 并且可以为它们中的每一个使用各种后备存储</p><p>三种主要类型详细见 :  <a href="https://docs.python.org/3.5/library/io.html?highlight=io#io.TextIOBase" target="_blank" rel="noopener"><code>TextIOBase</code></a> ,  <a href="https://docs.python.org/3.5/library/io.html?highlight=io#io.BufferedIOBase" target="_blank" rel="noopener"><code>BufferedIOBase</code></a> ,  <a href="https://docs.python.org/3.5/library/io.html?highlight=io#io.RawIOBase" target="_blank" rel="noopener"><code>RawIOBase</code></a> </p><p>属于这些类别中的任何一个的具体对象称为<code>file-like object</code> </p><p>创建这些类别的具体对象最简单的方法就是使用内置的<code>open()</code> 函数 , 其也被定义在io模块中 , 下面仅介绍一些这些类别对象常用的方法 :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line">detach()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Separate the underlying binary buffer from the TextIOBase and return it.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">After the underlying buffer has been detached, the TextIOBase is in an unusable state.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Some TextIOBase implementations, like StringIO,</span></span><br><span class="line"><span class="string"> may not have the concept of an underlying buffer and calling this method will raise UnsupportedOperation.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">New in version 3.1.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">read(size)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Read and return at most size characters from the stream as a single str. </span></span><br><span class="line"><span class="string">If size is negative or None, reads until EOF.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">readline(size=<span class="number">-1</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Read until newline or EOF and return a single str. </span></span><br><span class="line"><span class="string">If the stream is already at EOF, an empty string is returned.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">If size is specified, at most size characters will be read.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">readlines(hint=<span class="number">-1</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Read and return a list of lines from the stream. hint can be specified to control the number of lines read: no more lines will be read if the total size (in bytes/characters) of all lines so far exceeds hint.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Note that it’s already possible to iterate on file objects using for line in file: ... without calling file.readlines().</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">readable()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Return True if the stream can be read from. </span></span><br><span class="line"><span class="string">If False, read() will raise OSError.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">write(s)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Write the string s to the stream and return the number of characters written.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">writable()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Return True if the stream supports writing. </span></span><br><span class="line"><span class="string">If False, write() and truncate() will raise OSError.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">writelines(lines)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Write a list of lines to the stream.</span></span><br><span class="line"><span class="string">Line separators are not added, </span></span><br><span class="line"><span class="string">so it is usual for each of the lines provided to have a line separator at the end.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">seek(offset[, whence])</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Change the stream position to the given offset. </span></span><br><span class="line"><span class="string">Behaviour depends on the whence parameter. </span></span><br><span class="line"><span class="string">The default value for whence is SEEK_SET.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">SEEK_SET or 0: seek from the start of the stream (the default); </span></span><br><span class="line"><span class="string">offset must either be a number returned by TextIOBase.tell(), or zero. </span></span><br><span class="line"><span class="string">Any other offset value produces undefined behaviour.</span></span><br><span class="line"><span class="string">SEEK_CUR or 1: “seek” to the current position; </span></span><br><span class="line"><span class="string">offset must be zero, which is a no-operation (all other values are unsupported).</span></span><br><span class="line"><span class="string">SEEK_END or 2: seek to the end of the stream; </span></span><br><span class="line"><span class="string">offset must be zero (all other values are unsupported).</span></span><br><span class="line"><span class="string">Return the new absolute position as an opaque number.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">New in version 3.1: The SEEK_* constants.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">tell()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Return the current stream position as an opaque number. </span></span><br><span class="line"><span class="string">The number does not usually represent a number of bytes in the underlying binary storage.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">close()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Flush and close this stream. </span></span><br><span class="line"><span class="string">This method has no effect if the file is already closed. </span></span><br><span class="line"><span class="string">Once the file is closed, </span></span><br><span class="line"><span class="string">any operation on the file (e.g. reading or writing) will raise a ValueError.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">As a convenience, it is allowed to call this method more than once; </span></span><br><span class="line"><span class="string">only the first call, however, will have an effect.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">fileno()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Return the underlying file descriptor (an integer) of the stream if it exists. An OSError is raised if the IO object does not use a file descriptor.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">flush()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Flush the write buffers of the stream if applicable. </span></span><br><span class="line"><span class="string">This does nothing for read-only and non-blocking streams.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">isatty()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Return True if the stream is interactive (i.e., connected to a terminal/tty device).</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">seek(offset[, whence])</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Change the stream position to the given byte offset. </span></span><br><span class="line"><span class="string">offset is interpreted relative to the position indicated by whence. </span></span><br><span class="line"><span class="string">The default value for whence is SEEK_SET. Values for whence are:</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">SEEK_SET or 0 – start of the stream (the default); </span></span><br><span class="line"><span class="string">offset should be zero or positive</span></span><br><span class="line"><span class="string">SEEK_CUR or 1 – current stream position; </span></span><br><span class="line"><span class="string">offset may be negative</span></span><br><span class="line"><span class="string">SEEK_END or 2 – end of the stream; </span></span><br><span class="line"><span class="string">offset is usually negative</span></span><br><span class="line"><span class="string">Return the new absolute position.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">New in version 3.1: The SEEK_* constants.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">New in version 3.3: Some operating systems could support additional values, </span></span><br><span class="line"><span class="string">like os.SEEK_HOLE or os.SEEK_DATA. </span></span><br><span class="line"><span class="string">The valid values for a file could depend on it being open in text or binary mode.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">seekable()</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Return True if the stream supports random access. </span></span><br><span class="line"><span class="string">If False, seek(), tell() and truncate() will raise OSError.</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"></span><br><span class="line">truncate(size=<span class="keyword">None</span>)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">Resize the stream to the given size in bytes (or the current position if size is not specified). </span></span><br><span class="line"><span class="string">The current stream position isn’t changed. </span></span><br><span class="line"><span class="string">This resizing can extend or reduce the current file size. </span></span><br><span class="line"><span class="string">In case of extension, the contents of the new file area depend on the platform (on most systems, additional bytes are zero-filled). </span></span><br><span class="line"><span class="string">The new file size is returned.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">Changed in version 3.5: Windows will now zero-fill files when extending.</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>注意 : 当使用完文件后一定要记得使用<code>close()</code> 方法将其关闭 ; 其次在进行文件操作时要注意文件描述符所在的位置</p><h2 id="with-🍀"><a href="#with-🍀" class="headerlink" title="with  🍀"></a>with  🍀</h2><p>为了避免打开文件后忘记手动关闭 , 可以通过管理上下文 , 即使用<code>with</code>语句 , 如下 :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'filepath'</span>,<span class="string">'mode'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>在Python 2.7以上的版本 , 支持同时对多个文件同时进行上下文管理 , 如下 : </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'filepath1'</span>,<span class="string">'mode'</span>) <span class="keyword">as</span> f1,open(<span class="string">'filepath2'</span>,<span class="string">'mode'</span>) <span class="keyword">as</span> f2:</span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>更多文档资料 : <a href="https://docs.python.org/3.5/library/io.html?highlight=io#module-io" target="_blank" rel="noopener">https://docs.python.org/3.5/library/io.html?highlight=io#module-io</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-文件操作&quot;&gt;&lt;a href=&quot;#Python之路-文件操作&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - 文件操作&quot;&gt;&lt;/a&gt;Python之路 - 文件操作&lt;/h1&gt;&lt;h2 id=&quot;介绍-🍀&quot;&gt;&lt;a href=&quot;#介绍-🍀&quot; class=&quot;headerlink&quot; title=&quot;介绍  🍀&quot;&gt;&lt;/a&gt;介绍  🍀&lt;/h2&gt;&lt;p&gt;在磁盘上读写文件的功能都是由操作系统提供的 , 现代操作系统不允许普通的程序直接操作磁盘 , 所以 , 读写文件就是请求操作系统打开一个文件对象 (通常称为文件描述符) ; 然后 , 通过操作系统提供的接口从这个文件对象中读取数据 (读文件) , 或者把数据写入这个文件对象 (写文件) &lt;/p&gt;
&lt;p&gt;在Python中我们进行文件操作需要首先利用&lt;code&gt;open()&lt;/code&gt; 函数获取一个文件流来操作文件&lt;/p&gt;
&lt;p&gt;这个流就是我们所使用的文件描述符 , 是一个I/O通道&lt;/p&gt;
&lt;h2 id=&quot;open-🍀&quot;&gt;&lt;a href=&quot;#open-🍀&quot; class=&quot;headerlink&quot; title=&quot;open()  🍀&quot;&gt;&lt;/a&gt;open()  🍀&lt;/h2&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;open(file, mode=&lt;span class=&quot;string&quot;&gt;&#39;r&#39;&lt;/span&gt;, buffering=&lt;span class=&quot;number&quot;&gt;-1&lt;/span&gt;, encoding=&lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;, errors=&lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;, newline=&lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;, closefd=&lt;span class=&quot;keyword&quot;&gt;True&lt;/span&gt;, opener=&lt;span class=&quot;keyword&quot;&gt;None&lt;/span&gt;):&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;string&quot;&gt;&quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    file:文件名&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    mode:模式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    buffering:设置缓冲策略&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    encoding:指定使用编码&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    errors:指定处理编码和解码错误的方式&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    newline:控制通用换行模式的工作方式(只适用文本模式)&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    closefd:如果为False并且给出了文件描述符而不是文件名,则文件关闭时,文件描述符将保持打开;如果给定文件名,则closefd必须为True,否则将抛出异常&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    opener:自定义开启器&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;    &quot;&quot;&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;对于上述参数中 , 我们主要需要了解的就是&lt;code&gt;file&lt;/code&gt; , &lt;code&gt;mode&lt;/code&gt; , &lt;code&gt;encoding&lt;/code&gt; 这三个&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="basic" scheme="https://jesse.top/categories/python/basic/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>02.Python之路 - python数据类型和变量</title>
    <link href="https://jesse.top/2020/05/26/python/01-basic/02-Python%E4%B9%8B%E8%B7%AF-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E6%A6%82%E8%BF%B0/"/>
    <id>https://jesse.top/2020/05/26/python/01-basic/02-Python之路-数据类型概述/</id>
    <published>2020-05-26T14:59:58.000Z</published>
    <updated>2020-05-27T15:06:07.496Z</updated>
    
    <content type="html"><![CDATA[<h3 id="python数据类型和变量"><a href="#python数据类型和变量" class="headerlink" title="python数据类型和变量"></a>python数据类型和变量</h3><h4 id="整数"><a href="#整数" class="headerlink" title="整数"></a>整数</h4><p>表示数字,包括负数,例如: <code>1</code>，<code>100</code>，<code>-8080</code>，<code>0</code>，等等。</p><h4 id="浮点数"><a href="#浮点数" class="headerlink" title="浮点数"></a>浮点数</h4><p>浮点数也就是小数,可以用数字写法,例如<code>1.23</code>，<code>3.14</code>，<code>-9.01</code>，等等.要注意的是在Python中,除法的结果都是浮点数,即使是被整除,例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 9/3</span><br><span class="line">3.0</span><br><span class="line">&gt;&gt;&gt; type(9/3)</span><br><span class="line">&lt;class &apos;float&apos;&gt;</span><br></pre></td></tr></table></figure><p>在python中,还有一种除法是<code>//</code>，称为地板除，两个整数的除法仍然是整数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 / 3</span><br><span class="line">3.3333333333333335</span><br><span class="line">&gt;&gt;&gt; 10 // 3</span><br><span class="line">3</span><br><span class="line">&gt;&gt;&gt; type(10 // 3)</span><br><span class="line">&lt;class &apos;int&apos;&gt;</span><br></pre></td></tr></table></figure><p><code>//</code>除法只取结果的整数部分，%则表示取余，可以得到两个整数相除的余数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; 10 % 3</span><br><span class="line">1</span><br></pre></td></tr></table></figure><hr><a id="more"></a><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>字符串是以单引号<code>&#39;</code>或双引号<code>&quot;</code>括起来的任意文本，比如<code>&#39;abc&#39;</code>，<code>&quot;xyz&quot;</code>等等。请注意，<code>&#39;&#39;</code>或<code>&quot;&quot;</code>本身只是一种表示方式，不是字符串的一部分，因此，字符串<code>&#39;abc&#39;</code>只有<code>a</code>，<code>b</code>，<code>c</code>这3个字符。如果<code>&#39;</code>本身也是一个字符，那就可以用<code>&quot;&quot;</code>括起来，比如<code>&quot;I&#39;m OK&quot;</code>包含的字符是<code>I</code>，<code>&#39;</code>，<code>m</code>，空格，<code>O</code>，<code>K</code>这6个字符。</p><p>转义字符<code>\</code>可以转义很多字符，比如<code>\n</code>表示换行，<code>\t</code>表示制表符，字符<code>\</code>本身也要转义，所以<code>\\</code>表示的字符就是<code>\</code>，可以在Python的交互式命令行用<code>print()</code>打印字符串看看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&apos;I\&apos;m ok.&apos;)</span><br><span class="line">I&apos;m ok.</span><br><span class="line">&gt;&gt;&gt; print(&apos;I\&apos;m learning\nPython.&apos;)</span><br><span class="line">I&apos;m learning</span><br><span class="line">Python.</span><br><span class="line">&gt;&gt;&gt; print(&apos;\\\n\\&apos;)</span><br><span class="line">\</span><br><span class="line">\</span><br></pre></td></tr></table></figure><p>Python还允许用<code>r&#39;&#39;</code>表示<code>&#39;&#39;</code>内部的字符串默认不转义，可以自己试试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&apos;\\\t\\&apos;)</span><br><span class="line">\       \</span><br><span class="line">&gt;&gt;&gt; print(r&apos;\\\t\\&apos;)</span><br><span class="line">\\\t\\</span><br></pre></td></tr></table></figure><p>如果字符串内部有很多换行，用<code>\n</code>写在一行里不好阅读，为了简化，Python允许用<code>&#39;&#39;&#39;...&#39;&#39;&#39;</code>的格式表示多行内容，可以自己试试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; print(&apos;&apos;&apos;line1</span><br><span class="line">... line2</span><br><span class="line">... line3&apos;&apos;&apos;)</span><br><span class="line">line1</span><br><span class="line">line2</span><br><span class="line">line3</span><br></pre></td></tr></table></figure><hr><h4 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h4><p>布尔值和布尔代数的表示完全一致，一个布尔值只有<code>True</code>、<code>False</code>两种值，要么是<code>True</code>，要么是<code>False</code>，在Python中，可以直接用<code>True</code>、<code>False</code>表示布尔值（请注意大小写），也可以通过布尔运算计算出来：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">print(3 &gt; 2)</span><br><span class="line">print(3 &gt; 5)</span><br><span class="line"></span><br><span class="line">执行结果:</span><br><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p>布尔值可以用<code>and</code>、<code>or</code>和<code>not</code>运算。</p><p><code>and</code>运算是与运算，只有所有都为<code>True</code>，<code>and</code>运算结果才是<code>True</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">代码示例:</span><br><span class="line">print(3 &gt; 2 and 3 &lt; 5)</span><br><span class="line">print(3 &gt; 1 and 3 &lt; 1)</span><br><span class="line"></span><br><span class="line">执行结果</span><br><span class="line">True</span><br><span class="line">False</span><br></pre></td></tr></table></figure><p><code>or</code>运算是或运算，只要其中有一个为<code>True</code>，<code>or</code>运算结果就是<code>True</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">代码示例:</span><br><span class="line"></span><br><span class="line"># 布尔值的or运算</span><br><span class="line">print (True or False)</span><br><span class="line">print (3 &gt; 9 or 3 &lt; 5)</span><br><span class="line"></span><br><span class="line">执行结果:</span><br><span class="line">True</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p><code>not</code>运算是非运算，它是一个单目运算符，把<code>True</code>变成<code>False</code>，<code>False</code>变成<code>True</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#布尔值的Not运算</span><br><span class="line"></span><br><span class="line">print(not True)</span><br><span class="line">print(not 3 &gt; 9)</span><br><span class="line"></span><br><span class="line">执行结果:</span><br><span class="line">False</span><br><span class="line">True</span><br></pre></td></tr></table></figure><p>空值不为True，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">代码示例:</span><br><span class="line"></span><br><span class="line">a = &quot;&quot;</span><br><span class="line">b = None</span><br><span class="line"></span><br><span class="line">if a:</span><br><span class="line">    print(&quot;a is True&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;a is False&quot;)</span><br><span class="line"></span><br><span class="line">if b:</span><br><span class="line">    print(&quot;b is True&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;b is False&quot;)</span><br><span class="line">    </span><br><span class="line">执行结果:</span><br><span class="line"></span><br><span class="line">a is False</span><br><span class="line">b is False</span><br></pre></td></tr></table></figure><hr><h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>关于变量其实非常简单,用过shell或者其他任何脚本语言,编程语言的都已经非常熟悉了,.但是这里想说一下python中变量和内存地址空间的关系.</p><p>例如.当我们给一个变量赋值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = &apos;ABC</span><br></pre></td></tr></table></figure><p>时,Python解释器干了两件事情:</p><ol><li>在内存中创建了一个<code>&#39;ABC&#39;</code>的字符串；</li><li>在内存中创建了一个名为<code>a</code>的变量，并把它指向<code>&#39;ABC&#39;</code>。</li></ol><p>也可以把一个变量<code>a</code>赋值给另一个变量<code>b</code>，这个操作实际上是把变量<code>b</code>指向变量<code>a</code>所指向的数据，例如下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a = &apos;ABC&apos;</span><br><span class="line">b = a</span><br><span class="line">a = &apos;XYZ&apos;</span><br><span class="line">print(b)</span><br></pre></td></tr></table></figure><p>最后一行打印出变量<code>b</code>的内容到底是<code>&#39;ABC&#39;</code>呢还是<code>&#39;XYZ&#39;</code>？如果从数学意义上理解，就会错误地得出<code>b</code>和<code>a</code>相同，也应该是<code>&#39;XYZ&#39;</code>，但实际上<code>b</code>的值是<code>&#39;ABC&#39;</code>，让我们一行一行地执行代码，就可以看到到底发生了什么事：</p><p>执行<code>a = &#39;ABC&#39;</code>，解释器创建了字符串<code>&#39;ABC&#39;</code>和变量<code>a</code>，并把<code>a</code>指向<code>&#39;ABC&#39;</code>：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/923791878255456/0" alt="py-var-code-1"></p><p>执行<code>b = a</code>，解释器创建了变量<code>b</code>，并把<code>b</code>指向<code>a</code>指向的字符串<code>&#39;ABC&#39;</code>：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/923792058613440/0" alt=""></p><p>执行<code>a = &#39;XYZ&#39;</code>，解释器创建了字符串’XYZ’，并把<code>a</code>的指向改为<code>&#39;XYZ&#39;</code>，但<code>b</code>并没有更改：</p><p><img src="https://www.liaoxuefeng.com/files/attachments/923792191637760/0" alt=""></p><p>所以，最后打印变量<code>b</code>的结果自然是<code>&#39;ABC&#39;</code>了。</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;python数据类型和变量&quot;&gt;&lt;a href=&quot;#python数据类型和变量&quot; class=&quot;headerlink&quot; title=&quot;python数据类型和变量&quot;&gt;&lt;/a&gt;python数据类型和变量&lt;/h3&gt;&lt;h4 id=&quot;整数&quot;&gt;&lt;a href=&quot;#整数&quot; class=&quot;headerlink&quot; title=&quot;整数&quot;&gt;&lt;/a&gt;整数&lt;/h4&gt;&lt;p&gt;表示数字,包括负数,例如: &lt;code&gt;1&lt;/code&gt;，&lt;code&gt;100&lt;/code&gt;，&lt;code&gt;-8080&lt;/code&gt;，&lt;code&gt;0&lt;/code&gt;，等等。&lt;/p&gt;
&lt;h4 id=&quot;浮点数&quot;&gt;&lt;a href=&quot;#浮点数&quot; class=&quot;headerlink&quot; title=&quot;浮点数&quot;&gt;&lt;/a&gt;浮点数&lt;/h4&gt;&lt;p&gt;浮点数也就是小数,可以用数字写法,例如&lt;code&gt;1.23&lt;/code&gt;，&lt;code&gt;3.14&lt;/code&gt;，&lt;code&gt;-9.01&lt;/code&gt;，等等.要注意的是在Python中,除法的结果都是浮点数,即使是被整除,例如:&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; 9/3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; type(9/3)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;class &amp;apos;float&amp;apos;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;在python中,还有一种除法是&lt;code&gt;//&lt;/code&gt;，称为地板除，两个整数的除法仍然是整数：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; 10 / 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3.3333333333333335&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; 10 // 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; type(10 // 3)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;class &amp;apos;int&amp;apos;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;&lt;code&gt;//&lt;/code&gt;除法只取结果的整数部分，%则表示取余，可以得到两个整数相除的余数：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt; 10 % 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;hr&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="basic" scheme="https://jesse.top/categories/python/basic/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>01.Python之路 - Python基础</title>
    <link href="https://jesse.top/2020/05/26/python/01-basic/01-Python%E4%B9%8B%E8%B7%AF-Python%E5%9F%BA%E7%A1%80/"/>
    <id>https://jesse.top/2020/05/26/python/01-basic/01-Python之路-Python基础/</id>
    <published>2020-05-26T14:59:58.000Z</published>
    <updated>2020-05-26T15:34:04.241Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python之路-Python基础"><a href="#Python之路-Python基础" class="headerlink" title="Python之路 - Python基础"></a>Python之路 - Python基础</h1><h2 id="Hello-World-🍀"><a href="#Hello-World-🍀" class="headerlink" title="Hello World  🍀"></a>Hello World  🍀</h2><p>学一门语言基本都是从Hello World开始的 , 如下一个最简单的Hello World程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Python <span class="number">3.5</span><span class="number">.2</span> (v3<span class="number">.5</span><span class="number">.2</span>:<span class="number">4</span>def2a2901a5, Jun <span class="number">25</span> <span class="number">2016</span>, <span class="number">22</span>:<span class="number">18</span>:<span class="number">55</span>) [MSC v<span class="number">.1900</span> <span class="number">64</span> bit (AMD64)] on win32</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">"Hello World"</span>)</span><br><span class="line">Hello World</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>此为Python 3.5.2版本 , 上述代码为在Windows环境命令行中执行 , 即以管理员身份运行 “命令提示符”</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 已添加环境变量</span></span><br><span class="line">C:\Windows\system32&gt;python</span><br></pre></td></tr></table></figure><p>Python 2.7.x 版本的Hello World程序</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Python <span class="number">2.7</span><span class="number">.13</span> (v2<span class="number">.7</span><span class="number">.13</span>:a06454b1afa1, Dec <span class="number">17</span> <span class="number">2016</span>, <span class="number">20</span>:<span class="number">53</span>:<span class="number">40</span>) [MSC v<span class="number">.1500</span> <span class="number">64</span> bit (AMD64)] on win32</span><br><span class="line">Type <span class="string">"help"</span>, <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">print</span> <span class="string">"Hello World"</span></span><br><span class="line">Hello World</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure><p>当然使用<code>Python shell</code> 仅仅适合处理一些非常简单的小程序 , 对于比较复杂 , 代码量稍微大一点的就不适合了</p><a id="more"></a><h2 id="变量-🍀"><a href="#变量-🍀" class="headerlink" title="变量  🍀"></a>变量  🍀</h2><p>变量用于存储在计算机程序中被引用和操作的信息</p><p>变量可能被明确为是能表示可变状态、具有存储空间的抽象(如在Java和Visual Basic中) , 变量的唯一目的是在内存中标记和存储数据 , 这些数据可以在整个程序中使用</p><p>声明变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 声明一个变量name,并绑定值"Lyon"</span></span><br><span class="line">name = <span class="string">"Lyon"</span></span><br><span class="line"><span class="comment"># 同时为多个变量赋值</span></span><br><span class="line">a = b = c = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>Python变量定义的规则 : </p><ol><li><p>变量名只能是 字母、数字或者下划线的任意组合</p></li><li><p>变量名的第一个字符不能是数字</p></li><li><p>以下关键字不能声明为变量名 , 属于Python中的保留字and</p></li></ol><table><thead><tr><th>and</th><th>exec</th><th>not</th></tr></thead><tbody><tr><td>assert</td><td>finally</td><td>or</td></tr><tr><td>break</td><td>for</td><td>pass</td></tr><tr><td>class</td><td>from</td><td>print</td></tr><tr><td>continue</td><td>global</td><td>raise</td></tr><tr><td>def</td><td>if</td><td>return</td></tr><tr><td>del</td><td>import</td><td>try</td></tr><tr><td>elif</td><td>in</td><td>while</td></tr><tr><td>else</td><td>is</td><td>with</td></tr><tr><td>except</td><td>lambda</td><td>yield</td></tr></tbody></table><h2 id="行和缩进-🍀"><a href="#行和缩进-🍀" class="headerlink" title="行和缩进  🍀"></a>行和缩进  🍀</h2><p>Python 与其他语言最大的区别就是 , Python 的代码块不使用大括号 <code>{}</code> 来控制类 , 函数以及其他逻辑判断 ,  Python 最具特色的就是用缩进来写模块</p><p>缩进的空白数量是可变的 , 但是所有代码块语句必须包含相同的缩进空白数量 , 这个必须严格执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="keyword">True</span>:</span><br><span class="line">    <span class="keyword">print</span> <span class="string">"True"</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">  <span class="keyword">print</span> <span class="string">"False"</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行会出现错误提醒:</span></span><br><span class="line"><span class="string">IndentationError: unexpected indent</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p><code>IndentationError: unexpected indent</code> 错误是Python编译器在告诉你 , 你的文件里格式有问题 , 可能是tab和空格没对齐的问题</p><p>还有<code>IndentationError: unindent does not match any outer indentation level</code> 错误表明 , 你使用的缩进方式不一致 , 有的是 tab 键缩进 , 有的是空格缩进 , 改为一致即可。</p><p>因此 , 在 Python 的代码块中必须使用相同数目的行首缩进空格数</p><p>建议你在每个缩进层次使用 <strong>单个制表符</strong> 或 <strong>两个空格</strong> 或 <strong>四个空格</strong> , 切记不能混用</p><h2 id="多行语句-🍀"><a href="#多行语句-🍀" class="headerlink" title="多行语句  🍀"></a>多行语句  🍀</h2><p>Python语句中一般以新作为为语句的结束符</p><p>但是我们可以使用斜杠 <code>\</code> 将一行的语句分为多行显示 , 如下 :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">total = item_one + \</span><br><span class="line">        item_two + \</span><br><span class="line">        item_three</span><br></pre></td></tr></table></figure><p>语句中包含 [], {} 或 () 括号就不需要使用多行连接符 , 如下实例 : </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">days = [<span class="string">'Monday'</span>, <span class="string">'Tuesday'</span>, <span class="string">'Wednesday'</span>,</span><br><span class="line">        <span class="string">'Thursday'</span>, <span class="string">'Friday'</span>]</span><br></pre></td></tr></table></figure><p><strong>同一行使用多条语句</strong></p><p>Python可以在同一行中使用多条语句 , 语句之间使用分号 <code>;</code>  分割 , 如下 :</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="keyword">import</span> sys; x = <span class="string">'runoob'</span>; sys.stdout.write(x + <span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure><h2 id="字符串-🍀"><a href="#字符串-🍀" class="headerlink" title="字符串  🍀"></a>字符串  🍀</h2><p>Python 可以使用引号( <strong>‘</strong> )、双引号( <strong>“</strong> )、三引号( <strong>‘’’</strong> 或 <strong>“””</strong> ) 来表示字符串 , 引号的开始与结束必须的相同类型的</p><p>其中三引号可以由多行组成 , 编写多行文本的快捷语法 , 常用于文档字符串 , 在文件的特定地点 , 被当做注释</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">word = <span class="string">'word'</span></span><br><span class="line">sentence = <span class="string">"This is a sentence"</span></span><br><span class="line">paragraph = <span class="string">"""This is a paragraph</span></span><br><span class="line"><span class="string">   Contains multiple statements"""</span></span><br></pre></td></tr></table></figure><h2 id="注释-🍀"><a href="#注释-🍀" class="headerlink" title="注释  🍀"></a>注释  🍀</h2><p>Python中单行注释采用 <code>#</code> 开头</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 第一个注释</span></span><br><span class="line">print(<span class="string">"Hello,Python"</span>)  <span class="comment"># 第二个注释</span></span><br></pre></td></tr></table></figure><p>Python中多行注释采用三个单引号 <code>&#39;&#39;&#39;</code> 或三个双引号 <code>&quot;&quot;&quot;</code> </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">这是多行注释，使用单引号。</span></span><br><span class="line"><span class="string">这是多行注释，使用单引号。</span></span><br><span class="line"><span class="string">这是多行注释，使用单引号。</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">这是多行注释，使用双引号。</span></span><br><span class="line"><span class="string">这是多行注释，使用双引号。</span></span><br><span class="line"><span class="string">这是多行注释，使用双引号。</span></span><br><span class="line"><span class="string">"""</span></span><br></pre></td></tr></table></figure><h2 id="字符编码-🍀"><a href="#字符编码-🍀" class="headerlink" title="字符编码  🍀"></a>字符编码  🍀</h2><p>Python解释器在加载 <code>.py</code> 文件中的代码时 , 会对内容进行编码 (默认ASCII)</p><p>然而ASCII是无法处理中文的 , 所以如果我们的代码中出现了中文 , 那么需要在代码的顶端加上一句声明</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># -*- coding:utf-8 -*-</span></span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">第一行,为脚本语言指定解释器</span></span><br><span class="line"><span class="string">第二行,告诉Python解释器,用utf-8编码来进行编码</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="用户输入-🍀"><a href="#用户输入-🍀" class="headerlink" title="用户输入  🍀"></a>用户输入  🍀</h2><p>当我们需要用户自己输入信息时 , 就可以使用<code>input</code> 语句 , 如下 : </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 让用户进行输入,并用变量name接收用户输入的值</span></span><br><span class="line">name = input(<span class="string">"Please input your name:"</span>)</span><br></pre></td></tr></table></figure><p>上述代码 , 会一直等待用户输入 , 直到用户按回车键后才会退出</p><h2 id="输出-🍀"><a href="#输出-🍀" class="headerlink" title="输出  🍀"></a>输出  🍀</h2><p>当我们需要让控制台输出一些我们想要的信息时 , 可以使用<code>print</code> 语句 , 在Hello World里我们已经见到了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python</span></span><br><span class="line"><span class="comment"># -*- coding: UTF-8 -*-</span></span><br><span class="line"><span class="comment"># Author:Lyon</span></span><br><span class="line">x = <span class="string">"a"</span></span><br><span class="line">y = <span class="string">"b"</span></span><br><span class="line"><span class="comment"># 换行输出</span></span><br><span class="line">print(x)</span><br><span class="line">print(y)</span><br><span class="line">print(<span class="string">'---------'</span>)</span><br><span class="line"><span class="comment"># 不换行输出</span></span><br><span class="line">print(x,)</span><br><span class="line">print(y,)</span><br><span class="line"><span class="comment"># 不换行输出</span></span><br><span class="line">print(x, y)</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">a</span></span><br><span class="line"><span class="string">b</span></span><br><span class="line"><span class="string">---------</span></span><br><span class="line"><span class="string">a b a b</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><h2 id="数据类型-🍀"><a href="#数据类型-🍀" class="headerlink" title="数据类型  🍀"></a>数据类型  🍀</h2><p>我们知道在变量创建时 , 会在内存中开辟一个空间 , 用来存放变量的值 , 而这些变量的值可以是各种各样的类型 ,  如 : 数字 , 字符串 , 列表 , 元组 , 字典 , 集合等等</p><p><strong>数字类型</strong></p><ol><li><p>int (整型)</p><p>整数的大小范围由计算机字长确定</p></li><li><p>long (长整型)</p><p>跟C语言不同 , Python的长整数没有指定位宽 , 即 : Python没有限制长整数数值的大小 , 但实际上由于机器内存有限 , 我们使用的长整数数值不可能无限大</p><p>注意 , 自从Python 2.2 起 , 如果整数发生溢出 , Python会自动将整数数据转换为长整数 , 所以如今在长整数数据后面不加字母 L 也不会导致严重后果了</p></li><li><p>float (浮点型)</p><p>浮点数用来处理实数 , 即带有小数的数字 , 类似于C语言中的double类型 , 占8个字节(64位) , 其中52位表示底 , 11位表示指数 , 剩下的一位表示符号</p></li><li><p>complex (复数)</p><p>复数由实数部分和虚数部分组成，一般形式为x+yh，其中的x是复数的实数部分，y是复数的虚数部分，这里的x和y都是实数</p></li></ol><p>注 : Python中存在整数小数字池 : -5~257 , 在此范围的整数数字共享</p><p><strong>布尔值</strong></p><p>即真或假 , 1或0</p><p>更多数据类型 , 后续文章中详细整理</p><h2 id="数据运算-🍀"><a href="#数据运算-🍀" class="headerlink" title="数据运算  🍀"></a>数据运算  🍀</h2><p>算术运算符</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>+</td><td>加 - 两个对象相加</td><td>a + b 输出结果 30</td></tr><tr><td>-</td><td>减 - 得到负数或是一个数减去另一个数</td><td>a - b 输出结果 -10</td></tr><tr><td>*</td><td>乘 - 两个数相乘或是返回一个被重复若干次的字符串</td><td>a * b 输出结果 200</td></tr><tr><td>/</td><td>除 - x除以y</td><td>b / a 输出结果 2</td></tr><tr><td>%</td><td>取模 - 返回除法的余数</td><td>b % a 输出结果 0</td></tr><tr><td>**</td><td>幂 - 返回x的y次幂</td><td>a**b 为10的20次方 ,  输出结果 100000000000000000000</td></tr><tr><td>//</td><td>取整除 - 返回商的整数部分</td><td>9//2 输出结果 4 , 9.0//2.0 输出结果 4.0</td></tr></tbody></table><p>比较运算符</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>==</td><td>等于 - 比较对象是否相等</td><td>(a == b) 返回 False</td></tr><tr><td>!=</td><td>不等于 - 比较两个对象是否不相等</td><td>(a != b) 返回 True</td></tr><tr><td>&lt;&gt;</td><td>不等于 - 比较两个对象是否不相等</td><td>(a &lt;&gt; b) 返回 True这个运算符类似 !=</td></tr><tr><td>&gt;</td><td>大于 - 返回x是否大于y</td><td>(a &gt; b) 返回 False</td></tr><tr><td>&lt;</td><td>小于 - 返回x是否小于y , 所有比较运算符返回1表示真 , 返回0表示假<br>这分别与特殊的变量True和False等价 , 注意 , 这些变量名的大写</td><td>(a &lt; b) 返回 True</td></tr><tr><td>&gt;=</td><td>大于等于    - 返回x是否大于等于y。</td><td>(a &gt;= b) 返回 False</td></tr><tr><td>&lt;=</td><td>小于等于 - 返回x是否小于等于y。</td><td>(a &lt;= b) 返回 True</td></tr></tbody></table><p>赋值运算符</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>=</td><td>简单的赋值运算符</td><td>c = a + b 将 a + b 的运算结果赋值为 c</td></tr><tr><td>+=</td><td>加法赋值运算符</td><td>c += a 等效于 c = c + a</td></tr><tr><td>-=</td><td>减法赋值运算符</td><td>c -= a 等效于 c = c - a</td></tr><tr><td>*=</td><td>乘法赋值运算符</td><td>c <em>= a 等效于 c = c </em> a</td></tr><tr><td>/=</td><td>除法赋值运算符</td><td>c /= a 等效于 c = c / a</td></tr><tr><td>%=</td><td>取模赋值运算符</td><td>c %= a 等效于 c = c % a</td></tr><tr><td>**=</td><td>幂赋值运算符</td><td>c **= a 等效于 c = c ** a</td></tr><tr><td>//=</td><td>取整除赋值运算符</td><td>c //= a 等效于 c = c // a</td></tr></tbody></table><p>位运算符</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>&amp;</td><td>按位与运算符 : 参与运算的两个值 , 如果两个相应位都为1 , 则该位的结果为1 , 否则为0</td><td>(a &amp; b) 输出结果 12  , 二进制解释 :  0000 1100</td></tr><tr><td>\</td><td>按位或运算符 : 只要对应的二个二进位有一个为1时 , 结果位就为1</td><td>(a  丨 b) 输出结果 61  , 二进制解释 :  0011 1101</td></tr><tr><td>^</td><td>按位异或运算符 : 当两对应的二进位相异时 , 结果为1</td><td>(a ^ b) 输出结果 49  , 二进制解释 :  0011 0001</td></tr><tr><td>~</td><td>按位取反运算符 : 对数据的每个二进制位取反 , 即把1变为0 , 把0变为1  , ~x 类似于 -x-1</td><td>(~a ) 输出结果 -61  , 二进制解释 :  1100 0011 , 在一个有符号二进制数的补码形式</td></tr><tr><td>&lt;&lt;</td><td>左移动运算符 : 运算数的各二进位全部左移若干位 , 由 &lt;&lt; 右边的数字指定了移动的位数 , 高位丢弃 , 低位补0</td><td>a &lt;&lt; 2 输出结果 240 , 二进制解释 :  1111 0000</td></tr><tr><td>&gt;&gt;</td><td>右移动运算符 : 把”&gt;&gt;”左边的运算数的各二进位全部右移若干位 , &gt;&gt; 右边的数字指定了移动的位数</td><td>a &gt;&gt; 2 输出结果 15  , 二进制解释 :  0000 1111</td></tr></tbody></table><p>逻辑运算符</p><table><thead><tr><th>运算符</th><th>逻辑表达式</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>and</td><td>x and y</td><td>布尔”与” - 如果 x 为 False , x and y 返回 False , 否则它返回 y 的计算值</td><td>(a and b) 返回 20</td></tr><tr><td>or</td><td>x or y</td><td>布尔”或”    - 如果 x 是非 0 , 它返回 x 的值 , 否则它返回 y 的计算值</td><td>(a or b) 返回 10</td></tr><tr><td>not</td><td>not x</td><td>布尔”非” - 如果 x 为 True , 返回 False  , 如果 x 为 False , 它返回 True</td><td>not(a and b) 返回 False</td></tr></tbody></table><p>成员运算符</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>in</td><td>如果在指定的序列中找到值返回 True , 否则返回 False</td><td>x 在 y 序列中 , 如果 x 在 y 序列中返回 True</td></tr><tr><td>not in</td><td>如果在指定的序列中没有找到值返回 True , 否则返回 False</td><td>x 不在 y 序列中 , 如果 x 不在 y 序列中返回 True</td></tr></tbody></table><p>身份运算符</p><table><thead><tr><th>运算符</th><th>描述</th><th>实例</th></tr></thead><tbody><tr><td>is</td><td>is 是判断两个标识符是不是引用自一个对象</td><td><strong>x is y </strong> , 类似 <strong>id(x) == id(y)</strong> , 如果引用的是同一个对象则返回 True , 否则返回 False</td></tr><tr><td>is not</td><td>is not 是判断两个标识符是不是引用自不同对象</td><td><strong>x is not y</strong>  ,  类似 **id(a) != id(b) , 如果引用的不是同一个对象则返回结果 True , 否则返回 False</td></tr></tbody></table><p>运算符优先级表 , 从上到下优先级依次增高</p><table><thead><tr><th>Operator</th><th>Description</th></tr></thead><tbody><tr><td><a href="https://docs.python.org/3/reference/expressions.html?highlight=operator%20precedence#lambda" target="_blank" rel="noopener"><code>lambda</code></a></td><td>Lambda expression</td></tr><tr><td><a href="https://docs.python.org/3/reference/compound_stmts.html#if" target="_blank" rel="noopener"><code>if</code></a> – <a href="https://docs.python.org/3/reference/compound_stmts.html#else" target="_blank" rel="noopener"><code>else</code></a></td><td>Conditional expression</td></tr><tr><td><a href="https://docs.python.org/3/reference/expressions.html?highlight=operator%20precedence#or" target="_blank" rel="noopener"><code>or</code></a></td><td>Boolean OR</td></tr><tr><td><a href="https://docs.python.org/3/reference/expressions.html?highlight=operator%20precedence#and" target="_blank" rel="noopener"><code>and</code></a></td><td>Boolean AND</td></tr><tr><td><a href="https://docs.python.org/3/reference/expressions.html?highlight=operator%20precedence#not" target="_blank" rel="noopener"><code>not</code></a> <code>x</code></td><td>Boolean NOT</td></tr><tr><td><a href="https://docs.python.org/3/reference/expressions.html?highlight=operator%20precedence#in" target="_blank" rel="noopener"><code>in</code></a>, <a href="https://docs.python.org/3/reference/expressions.html?highlight=operator%20precedence#not-in" target="_blank" rel="noopener"><code>not in</code></a>, <a href="https://docs.python.org/3/reference/expressions.html?highlight=operator%20precedence#is" target="_blank" rel="noopener"><code>is</code></a>, <a href="https://docs.python.org/3/reference/expressions.html?highlight=operator%20precedence#is-not" target="_blank" rel="noopener"><code>is not</code></a>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>, <code>!=</code>, <code>==</code></td><td>Comparisons, including membership tests and identity tests</td></tr><tr><td><code>丨</code></td><td>Bitwise OR</td></tr><tr><td><code>^</code></td><td>Bitwise XOR</td></tr><tr><td><code>&amp;</code></td><td>Bitwise AND</td></tr><tr><td><code>&lt;&lt;</code>, <code>&gt;&gt;</code></td><td>Shifts</td></tr><tr><td><code>+</code>, <code>-</code></td><td>Addition and subtraction</td></tr><tr><td><code>*</code>, <code>@</code>, <code>/</code>, <code>//</code>, <code>%</code></td><td>Multiplication, matrix multiplication, division, floor division, remainder <a href="https://docs.python.org/3/reference/expressions.html?highlight=operator%20precedence#id21" target="_blank" rel="noopener">[5]</a></td></tr><tr><td><code>+x</code>, <code>-x</code>, <code>~x</code></td><td>Positive, negative, bitwise NOT</td></tr><tr><td><code>**</code></td><td>Exponentiation <a href="https://docs.python.org/3/reference/expressions.html?highlight=operator%20precedence#id22" target="_blank" rel="noopener">[6]</a></td></tr><tr><td><code>await</code> <code>x</code></td><td>Await expression</td></tr><tr><td><code>x[index]</code>, <code>x[index:index]</code>, <code>x(arguments...)</code>, <code>x.attribute</code></td><td>Subscription, slicing, call, attribute reference</td></tr><tr><td><code>(expressions...)</code>, <code>[expressions...]</code>, <code>{key: value...}</code>, <code>{expressions...}</code></td><td>Binding or tuple display, list display, dictionary display, set display</td></tr></tbody></table><h2 id="if-…-else-🍀"><a href="#if-…-else-🍀" class="headerlink" title="if … else  🍀"></a>if … else  🍀</h2><p>场景一 : 用户登录验证</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 导入getpass模块</span></span><br><span class="line"><span class="keyword">import</span> getpass</span><br><span class="line"><span class="comment"># 等待用户输入</span></span><br><span class="line">name = input(<span class="string">"请输入用户名："</span>)</span><br><span class="line"><span class="comment"># 等待用户输入密码,密码不可见</span></span><br><span class="line">password = getpass.getpass(<span class="string">"请输入密码："</span>)</span><br><span class="line"><span class="comment"># 如果用户密码正确,执行如下</span></span><br><span class="line"><span class="keyword">if</span> name ==<span class="string">"Lyon"</span> <span class="keyword">and</span> password ==<span class="string">"yang"</span>:</span><br><span class="line">    print(<span class="string">"欢迎你!"</span>)</span><br><span class="line"><span class="comment"># 否则执行如下</span></span><br><span class="line"><span class="keyword">else</span>：</span><br><span class="line">    print(<span class="string">"用户名或密码错误"</span>)</span><br></pre></td></tr></table></figure><p>场景二 : 猜年龄游戏</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个年龄</span></span><br><span class="line">age =<span class="number">21</span> </span><br><span class="line"><span class="comment"># 用户输入</span></span><br><span class="line">user_input = int(input(<span class="string">"input your guess num:"</span>))</span><br><span class="line"><span class="keyword">if</span> user_input == age:</span><br><span class="line">    print(<span class="string">"Congratulations, you got it !"</span>)</span><br><span class="line"><span class="keyword">elif</span> user_input &lt; age:</span><br><span class="line">    print(<span class="string">"Oops,think bigger!"</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">"think smaller!"</span>)</span><br></pre></td></tr></table></figure><h2 id="for循环-🍀"><a href="#for循环-🍀" class="headerlink" title="for循环  🍀"></a>for循环  🍀</h2><p>循环10次</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    print(<span class="string">"loop:"</span>, i )</span><br><span class="line"><span class="string">'''</span></span><br><span class="line"><span class="string">执行结果:</span></span><br><span class="line"><span class="string">loop: 0</span></span><br><span class="line"><span class="string">loop: 1</span></span><br><span class="line"><span class="string">loop: 2</span></span><br><span class="line"><span class="string">loop: 3</span></span><br><span class="line"><span class="string">loop: 4</span></span><br><span class="line"><span class="string">loop: 5</span></span><br><span class="line"><span class="string">loop: 6</span></span><br><span class="line"><span class="string">loop: 7</span></span><br><span class="line"><span class="string">loop: 8</span></span><br><span class="line"><span class="string">loop: 9</span></span><br><span class="line"><span class="string">'''</span></span><br></pre></td></tr></table></figure><p>小于5就跳入下一次循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    <span class="keyword">if</span> i&lt;<span class="number">5</span>:</span><br><span class="line">        <span class="keyword">continue</span></span><br><span class="line">    print(<span class="string">"loop:"</span>, i)</span><br></pre></td></tr></table></figure><h2 id="while循环-🍀"><a href="#while循环-🍀" class="headerlink" title="while循环  🍀"></a>while循环  🍀</h2><p>写一个死循环</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> <span class="keyword">True</span>：</span><br><span class="line">    print(<span class="string">"你是风儿我是沙，缠缠绵绵走天涯"</span>, count)</span><br><span class="line">    count += <span class="number">1</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python之路-Python基础&quot;&gt;&lt;a href=&quot;#Python之路-Python基础&quot; class=&quot;headerlink&quot; title=&quot;Python之路 - Python基础&quot;&gt;&lt;/a&gt;Python之路 - Python基础&lt;/h1&gt;&lt;h2 id=&quot;Hello-World-🍀&quot;&gt;&lt;a href=&quot;#Hello-World-🍀&quot; class=&quot;headerlink&quot; title=&quot;Hello World  🍀&quot;&gt;&lt;/a&gt;Hello World  🍀&lt;/h2&gt;&lt;p&gt;学一门语言基本都是从Hello World开始的 , 如下一个最简单的Hello World程序&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Python &lt;span class=&quot;number&quot;&gt;3.5&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.2&lt;/span&gt; (v3&lt;span class=&quot;number&quot;&gt;.5&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.2&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;def2a2901a5, Jun &lt;span class=&quot;number&quot;&gt;25&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2016&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;22&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;18&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;55&lt;/span&gt;) [MSC v&lt;span class=&quot;number&quot;&gt;.1900&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;64&lt;/span&gt; bit (AMD64)] on win32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Type &lt;span class=&quot;string&quot;&gt;&quot;help&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;copyright&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;credits&quot;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;license&quot;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; more information.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;print(&lt;span class=&quot;string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Hello World&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;此为Python 3.5.2版本 , 上述代码为在Windows环境命令行中执行 , 即以管理员身份运行 “命令提示符”&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;# 已添加环境变量&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;C:\Windows\system32&amp;gt;python&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;Python 2.7.x 版本的Hello World程序&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Python &lt;span class=&quot;number&quot;&gt;2.7&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.13&lt;/span&gt; (v2&lt;span class=&quot;number&quot;&gt;.7&lt;/span&gt;&lt;span class=&quot;number&quot;&gt;.13&lt;/span&gt;:a06454b1afa1, Dec &lt;span class=&quot;number&quot;&gt;17&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2016&lt;/span&gt;, &lt;span class=&quot;number&quot;&gt;20&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;53&lt;/span&gt;:&lt;span class=&quot;number&quot;&gt;40&lt;/span&gt;) [MSC v&lt;span class=&quot;number&quot;&gt;.1500&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;64&lt;/span&gt; bit (AMD64)] on win32&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Type &lt;span class=&quot;string&quot;&gt;&quot;help&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;copyright&quot;&lt;/span&gt;, &lt;span class=&quot;string&quot;&gt;&quot;credits&quot;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;or&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;license&quot;&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; more information.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;&amp;gt;&amp;gt;&amp;gt; &lt;/span&gt;&lt;span class=&quot;keyword&quot;&gt;print&lt;/span&gt; &lt;span class=&quot;string&quot;&gt;&quot;Hello World&quot;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Hello World&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;gt;&amp;gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;当然使用&lt;code&gt;Python shell&lt;/code&gt; 仅仅适合处理一些非常简单的小程序 , 对于比较复杂 , 代码量稍微大一点的就不适合了&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://jesse.top/categories/python/"/>
    
      <category term="basic" scheme="https://jesse.top/categories/python/basic/"/>
    
    
      <category term="python" scheme="https://jesse.top/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>ES集群优化</title>
    <link href="https://jesse.top/2019/01/07/elasticsearch/ES%E9%9B%86%E7%BE%A4%E4%BC%98%E5%8C%96%E6%96%87%E6%A1%A3/"/>
    <id>https://jesse.top/2019/01/07/elasticsearch/ES集群优化文档/</id>
    <published>2019-01-07T01:59:58.000Z</published>
    <updated>2019-02-17T09:31:38.017Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ES集群优化"><a href="#ES集群优化" class="headerlink" title="ES集群优化"></a>ES集群优化</h3><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>时间:2019年01月3号</p><p>支付宝五福活动压测期间</p><hr><h4 id="ES集群架构"><a href="#ES集群架构" class="headerlink" title="ES集群架构"></a>ES集群架构</h4><p>elasticsearch版本:2.4.6</p><p>ES集群服务器: 8台.其中5台16c32g.3台8c16g</p><p>服务器节点: mq-master,mq-slave,hsq-es1,hsq-es2,hsq-es3,hsq-es4,hsq-es5,hsq-es6</p><a id="more"></a><hr><h4 id="资料参考"><a href="#资料参考" class="headerlink" title="资料参考"></a>资料参考</h4><p>官方资料:<a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.4/modules-threadpool.html" target="_blank" rel="noopener">thread pool</a></p><p>官方资料:<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/system-config.html" target="_blank" rel="noopener">系统优化</a></p><hr><h4 id="优化步骤"><a href="#优化步骤" class="headerlink" title="优化步骤"></a>优化步骤</h4><ul><li><strong>系统内核优化</strong></li></ul><p><strong>最大文件打开数</strong>设置为65535还是有点小.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[work@hsq-es1 elasticsearch]$ grep &quot;65536&quot; hsq_elasticsearch.log.2019-01-02</span><br><span class="line">[2019-01-02 14:17:14,740][WARN ][env                      ] [hsq-es1] max file descriptors [65535] for elasticsearch process likely too low, consider increasing to at least [65536]</span><br></pre></td></tr></table></figure><p>修改为102400.修改方式如下:</p><p>1.编辑 /etc/security/limits.conf:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">* soft noproc  65535</span><br><span class="line">* hard noproc 65535</span><br><span class="line">* soft nofile 102400</span><br><span class="line">* hard nofile 102400</span><br></pre></td></tr></table></figure><p>然后退出,重新登录shell</p><p>2.如果是supervisor方式启动的进程.还需要修改supervisord.conf文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#修改下面一行</span><br><span class="line">minfds=102400                 ; (min. avail startup file descriptors;default 1024)</span><br></pre></td></tr></table></figure><ul><li><strong>虚拟内存</strong>定义了进程能拥有的最多内存区域.这个是ES官方文档推荐的配置</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@hsq-es1 elasticsearch]$ tail -3 /etc/sysctl.conf</span><br><span class="line">fs.file-max=102400</span><br><span class="line"></span><br><span class="line">vm.max_map_count = 262144  #这一行配置</span><br></pre></td></tr></table></figure><ul><li><strong>memlock</strong>最大锁定内存地址空间 </li></ul><blockquote><p>memlock这步优化实际中没做,当时没将pam_limits.so文件加入启动文件中</p></blockquote><p>在 /etc/security/limits.conf中加入如下内容</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">* soft memlock unlimited</span><br><span class="line">* hard memlock unlimited</span><br></pre></td></tr></table></figure><blockquote><p>要使limits.conf文件配置生效，必须要确保pam_limits.so文件被加入到启动文件中。</p></blockquote><p>确保/etc/pam.d/login文件中有如下内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">session required /lib/security/pam_limits.so</span><br></pre></td></tr></table></figure><p>验证是否生效</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl localhost:9200/_nodes/stats/process?pretty</span><br></pre></td></tr></table></figure><hr><ul><li><strong>内存优化</strong></li></ul><p>由于新加入的es服务器节点都是16c32g的配置,内存分配总物理内存的70%.大概是22G左右.</p><p><strong>1.编辑环境变量</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/profile</span><br><span class="line"></span><br><span class="line">#定义如下环境变量</span><br><span class="line">export ES_HEAP_SIZE=11g</span><br><span class="line"></span><br><span class="line">source /etc/profile</span><br></pre></td></tr></table></figure><ol start="2"><li>如果是supervisor方式启动的进程,还需要定义supervisor配置文件</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[work@hsq-es1 elasticsearch]$ vim /etc/supervisord/conf.d/elasticsearch.conf</span><br><span class="line"></span><br><span class="line">#加入如下一行:</span><br><span class="line">environment=ES_HEAP_SIZE=22g</span><br><span class="line">environment=MAX_OPEN_FILES=102400</span><br></pre></td></tr></table></figure><p>通过ps命令可以看到elasticsearch进程的最大内存数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[work@hsq-es2 ~]$ ps aux | grep elasticsearch</span><br><span class="line">work       782 68.6 62.1 50121636 20372716 ?   Sl   Jan03 925:22 /bin/java -Xms24g -Xmx24g -Djava.awt.headless=true -XX:+UseParNewGC -XX:+UseConcMarkSweepGC -XX:CMSInitiatingOccupancyFraction=75 -XX:+UseCMSInitiatingOccupancyOnly -XX:+HeapDumpOnOutOfMemoryError -XX:+DisableExplicitGC -Dfile.encoding=UTF-8 -Djna.nosys=true -Des.path.home=/data/app/elasticsearch-2.4.6 -cp /data/app/elasticsearch-2.4.6/lib/elasticsearch-2.4.6.jar:/data/app/elasticsearch-2.4.6/lib/* org.elasticsearch.bootstrap.Elasticsearch start</span><br></pre></td></tr></table></figure><hr><ul><li><strong>elasticsearch程序优化</strong></li></ul><p>编辑elasticsearch.conf配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">#线程池的配置###</span><br><span class="line">#fixed 索引线程池类型</span><br><span class="line">threadpool.index.type: fixed</span><br><span class="line">#线程池大小,建议等同于CPU核心数</span><br><span class="line">threadpool.index.size: 16</span><br><span class="line">#队列大小</span><br><span class="line">threadpool.index.queue_size: 6000</span><br><span class="line"></span><br><span class="line">#搜索 线程池类型</span><br><span class="line"></span><br><span class="line">#搜索线程池大小,建议2倍的CPU核心数</span><br><span class="line">threadpool.search.size: 32</span><br><span class="line"># 搜索线程池类型</span><br><span class="line">threadpool.search.type: fixed</span><br><span class="line">#队列大小</span><br><span class="line">threadpool.search.queue_size: 6000</span><br><span class="line"></span><br><span class="line">processors: 16</span><br><span class="line"></span><br><span class="line"># # 缓存类型设置为Soft Reference，只有当内存不够时才会进行回收</span><br><span class="line">index.cache.field.max_size: 50000</span><br><span class="line">index.cache.field.expire: 10m</span><br><span class="line">index.cache.field.type: soft</span><br><span class="line">#</span><br><span class="line"># 查询缓存</span><br><span class="line">indices.queries.cache.size: 20%</span><br><span class="line">index.queries.cache.enabled: true</span><br><span class="line"></span><br><span class="line">indices.requests.cache.size: 10%</span><br><span class="line">index.requests.cache.enable: true</span><br><span class="line"></span><br><span class="line">indices.fielddata.cache.size: 20%</span><br><span class="line"></span><br><span class="line"># #适当增大写入buffer和bulk队列长度</span><br><span class="line">indices.memory.index_buffer_size: 15%</span><br><span class="line">thread_pool.bulk.queue_size: 1024</span><br></pre></td></tr></table></figure><hr><ul><li><strong>es集群节点优化</strong></li></ul><p>参考官方文档: <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.4/modules-node.html" target="_blank" rel="noopener">Node</a></p><p>关于ES的节点介绍:</p><p>Elasticsearch集群的每个elasticsearch实例都是一个node节点.多个node节点组成了一个cluster.</p><p>集群的每个节点默认都能处理http和传输层流量.传输层专门用于节点之间以及节点和Java TransportClient之间的通信; HTTP层仅由外部REST客户端使用。</p><p>所有节点都可以转发客户端请求到合适的其他节点,除此之外,每个节点服务器还可以承担如下角色:</p><ul><li>Master node</li></ul><p>默认情况下,每个节点都是Master.master节点不代表这个节点就是master角色,而是代表这个节点有参加master选举的资格.master节点控制整个集群</p><p>通过如下方式设置为仅为master节点:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node.master: true</span><br><span class="line">node.data: false</span><br><span class="line">node.client: false</span><br></pre></td></tr></table></figure><p>master节点不会存储数据，有成为主节点的资格，可以参与选举，有可能成为真正的主节点。普通服务器即可(CPU、内存消耗一般)。</p><ul><li>Data node</li></ul><p>默认情况下,每个节点都是Data节点,Date节点保存数据,并且执行与数据相关的操作,例如搜索,聚合.</p><p>节点没有成为主节点的资格，不参与选举，只会存储数据。在集群中需要单独设置几个这样的节点负责存储数据，后期提供存储和查询服务。主要消耗磁盘，内存。</p><p>通过如下方式设置为仅为数据节点:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">node.master: false</span><br><span class="line">node.data: true</span><br><span class="line">node.client: false</span><br></pre></td></tr></table></figure><ul><li>Client node</li></ul><p>client节点不会保存数据,也不会成为master角色,client节点用来转发客户端的请求到master节点, 转发数据相关的操作请求(例如搜索)到data节点,</p><p>通过如下方式设置为仅为client节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">node.master: false</span><br><span class="line">node.data: false</span><br></pre></td></tr></table></figure><p>不会成为主节点，也不会存储数据，主要是针对海量请求的时候可以进行负载均衡。普通服务器即可（如果要进行分组聚合操作的话，建议这个节点内存也分配多一点）</p><hr><ul><li><strong>节点规划</strong></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">master 节点 （管理集群作用）</span><br><span class="line"></span><br><span class="line">hsq-es2</span><br><span class="line">hsq-es2-mqslave</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data 数据节点 数据落地查询</span><br><span class="line"></span><br><span class="line">hsq-es2 该节点也作为master节点 </span><br><span class="line">hsq-es3</span><br><span class="line">hsq-es4</span><br><span class="line">hsq-es5</span><br><span class="line">hsq-es6</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">client节点（不作为master节点 也不作为data 节点） 负载和聚合</span><br><span class="line"></span><br><span class="line">hsq-es2-mqmaster</span><br><span class="line">hsq-es1</span><br></pre></td></tr></table></figure><p>附上hsq-es6的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vim elasticsearch.yml</span><br><span class="line"></span><br><span class="line">node.name: hsq-es6</span><br><span class="line">node.master: false</span><br><span class="line">node.data: true</span><br><span class="line">node.client: false</span><br></pre></td></tr></table></figure><hr><ul><li><strong>主分片优化</strong></li></ul><p>访问<a href="http://es.haoshiqi.net/_plugin/kopf/#!/nodes" target="_blank" rel="noopener">http://es.haoshiqi.net/_plugin/kopf/#!/nodes</a> 可以看到集群所有节点</p><p><img src="/Users/huangyong/Desktop/es-1.png" alt=""></p><p>其中可以看到有2台master节点,2台client节点,4台data节点</p><p>将主分片平均分担到各个date节点,如下所示</p><p><img src="/Users/huangyong/Desktop/es-2.png" alt=""></p><p>高亮显示的为主分片</p><p>调整主分片方法如下:</p><p>1.左键点击高亮主分片.点击”select for relocation”</p><p><img src="/Users/huangyong/Desktop/es-3.png" alt=""></p><p>2.点击需要调整后的位置</p><p><img src="/Users/huangyong/Desktop/es-4.png" alt=""></p><p>3.调整后结果如下</p><p><img src="/Users/huangyong/Desktop/es-5.png" alt=""></p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ES集群优化&quot;&gt;&lt;a href=&quot;#ES集群优化&quot; class=&quot;headerlink&quot; title=&quot;ES集群优化&quot;&gt;&lt;/a&gt;ES集群优化&lt;/h3&gt;&lt;h4 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h4&gt;&lt;p&gt;时间:2019年01月3号&lt;/p&gt;
&lt;p&gt;支付宝五福活动压测期间&lt;/p&gt;
&lt;hr&gt;
&lt;h4 id=&quot;ES集群架构&quot;&gt;&lt;a href=&quot;#ES集群架构&quot; class=&quot;headerlink&quot; title=&quot;ES集群架构&quot;&gt;&lt;/a&gt;ES集群架构&lt;/h4&gt;&lt;p&gt;elasticsearch版本:2.4.6&lt;/p&gt;
&lt;p&gt;ES集群服务器: 8台.其中5台16c32g.3台8c16g&lt;/p&gt;
&lt;p&gt;服务器节点: mq-master,mq-slave,hsq-es1,hsq-es2,hsq-es3,hsq-es4,hsq-es5,hsq-es6&lt;/p&gt;
    
    </summary>
    
      <category term="elasticsearch" scheme="https://jesse.top/categories/elasticsearch/"/>
    
    
      <category term="elasticsearch" scheme="https://jesse.top/tags/elasticsearch/"/>
    
  </entry>
  
  <entry>
    <title>线上MQ宕机复盘</title>
    <link href="https://jesse.top/2018/11/21/Linux-%E5%88%86%E5%B8%83%E5%BC%8F&amp;%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/mq/%E7%BA%BF%E4%B8%8AMQ%E5%AE%95%E6%9C%BA%E5%A4%8D%E7%9B%98/"/>
    <id>https://jesse.top/2018/11/21/Linux-分布式&amp;消息队列/mq/线上MQ宕机复盘/</id>
    <published>2018-11-21T09:59:58.000Z</published>
    <updated>2018-12-01T15:07:13.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线上MQ宕机复盘"><a href="#线上MQ宕机复盘" class="headerlink" title="线上MQ宕机复盘"></a>线上MQ宕机复盘</h2><hr><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>时间:2018年11月20号晚上10点40</p><p>服务器:mq-slave</p><p>故障现象: 钉钉收到报警MQ服务器的rabbitmq进程挂了.手动启动后,过一会超时退出</p><a id="more"></a><hr><p>1.查看日志.提示delayed_message插件超时.无法启动.</p><p>联系开发.可能是白天修改了延时队列机制的缘故</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">less /var/log/rabbitmq/rabbit@node2</span><br><span class="line"></span><br><span class="line">Error: &#123;&#123;case_clause,&#123;timeout,[rabbit_delayed_messagerabbit@node2]&#125;&#125;, [&#123;rabbit_boot_steps,&apos;-run_step/2-lc$^1/1-1-&apos;,1, [&#123;file,&quot;src/rabbit_boot_steps.erl&quot;&#125;,&#123;line,49&#125;]&#125;, &#123;rabbit_boot_steps,run_step,2, [&#123;file,&quot;src/rabbit_boot_steps.erl&quot;&#125;,&#123;line,49&#125;]&#125;, &#123;rabbit_boot_steps,&apos;-run_boot_steps/1-lc$^0/1-0-&apos;,1, [&#123;file,&quot;src/rabbit_boot_steps.erl&quot;&#125;,&#123;line,26&#125;]&#125;, &#123;rabbit_boot_steps,run_boot_steps,1, [&#123;file,&quot;src/rabbit_boot_steps.erl&quot;&#125;,&#123;line,26&#125;]&#125;, &#123;rabbit,start_apps,1,[&#123;file,&quot;src/rabbit.erl&quot;&#125;,&#123;line,447&#125;]&#125;, &#123;rabbit_plugins,ensure,1,[&#123;file,&quot;src/rabbit_plugins.erl&quot;&#125;,&#123;line,49&#125;]&#125;, &#123;rpc,&apos;-handle_call_call/6-fun-0-&apos;,5,[&#123;file,&quot;rpc.erl&quot;&#125;,&#123;line,206&#125;]&#125;]&#125;</span><br></pre></td></tr></table></figure><p>2.关闭该插件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@node2:~# rabbitmq-plugins disable rabbitmq_delayed_message_exchange</span><br><span class="line">he following plugins have been disabled: </span><br><span class="line">rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure><p>3.再次启动.可以成功启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@node2:~# service rabbitmq-server start</span><br></pre></td></tr></table></figure><p>4.尝试手动启动该插件.仍然超时失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">root@node2:~# rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br><span class="line"></span><br><span class="line">The following plugins have been enabled:</span><br><span class="line">rabbitmq_delayed_message_exchange</span><br><span class="line"></span><br><span class="line">Applying plugin configuration to rabbit@node2... failed. Error: &#123;&#123;case_clause,&#123;timeout,[rabbit_delayed_messagerabbit@node2]&#125;&#125;, [&#123;rabbit_boot_steps,&apos;-run_step/2-lc$^1/1-1-&apos;,1, [&#123;file,&quot;src/rabbit_boot_steps.erl&quot;&#125;,&#123;line,49&#125;]&#125;, &#123;rabbit_boot_steps,run_step,2, [&#123;file,&quot;src/rabbit_boot_steps.erl&quot;&#125;,&#123;line,49&#125;]&#125;, &#123;rabbit_boot_steps,&apos;-run_boot_steps/1-lc$^0/1-0-&apos;,1, [&#123;file,&quot;src/rabbit_boot_steps.erl&quot;&#125;,&#123;line,26&#125;]&#125;, &#123;rabbit_boot_steps,run_boot_steps,1, [&#123;file,&quot;src/rabbit_boot_steps.erl&quot;&#125;,&#123;line,26&#125;]&#125;, &#123;rabbit,start_apps,1,[&#123;file,&quot;src/rabbit.erl&quot;&#125;,&#123;line,447&#125;]&#125;, &#123;rabbit_plugins,ensure,1,[&#123;file,&quot;src/rabbit_plugins.erl&quot;&#125;,&#123;line,49&#125;]&#125;, &#123;rpc,&apos;-handle_call_call/6-fun-0-&apos;,5,[&#123;file,&quot;rpc.erl&quot;&#125;,&#123;line,206&#125;]&#125;]&#125;</span><br></pre></td></tr></table></figure><p>5.停止rabbitmq服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@node2:~# service rabbitmq-server stop</span><br></pre></td></tr></table></figure><hr><p>联系开发.可能是延迟队列消息太多,将服务器的MQ程序卡死,导致插件无响应.从而无法启动.由于MQ使用了2台服务器座位集群,而且使用了镜像队列方式.所以清洗mq-slave服务器这台服务器的数据.重新启动.</p><p>确定是否使用镜像队列方式可以通过以下命令查看.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">root@node2:~# rabbitmqctl list_policies</span><br><span class="line">Listing policies ...</span><br><span class="line">/ha-allall^&#123;&quot;ha-mode&quot;:&quot;all&quot;,&quot;ha-sync-mode&quot;:&quot;automatic&quot;&#125;0</span><br></pre></td></tr></table></figure><p>ha-mode: 代表使用镜像队列.</p><p>ha-sync-mode:表示自动同步数据</p><p>更多信息请网上搜索</p><hr><p>1.关闭插件,重新启动rabbitmq进程.(因为清除数据需要先启动rabbitmq进程)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@node2:~# service rabbitmq-server start</span><br></pre></td></tr></table></figure><p>2.将这台服务器从集群节点拿掉.不然清楚数据会影响现有的生产环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@node2:~# rabbitmqctl stop_app</span><br><span class="line">Stopping node rabbit@node2 ...</span><br></pre></td></tr></table></figure><p>3.数据删除完毕后,重新启动rabbitmq节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@node2:~# rabbitmqctl start_app Starting node rabbit@node2 ...</span><br></pre></td></tr></table></figure><p>4.启动插件.显示已经启动了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">oot@node2:~# rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br><span class="line">Plugin configuration unchanged.</span><br><span class="line">Applying plugin configuration to rabbit@node2... nothing to do.</span><br></pre></td></tr></table></figure><p>5.显示插件,查看确实已经成功启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@node2:~# rabbitmq-plugins list -E</span><br><span class="line"></span><br><span class="line">Configured: E = explicitly enabled; e = implicitly enabled</span><br><span class="line"> | Status:   * = running on rabbit@node2</span><br><span class="line"> |/</span><br><span class="line">[E*] rabbitmq_delayed_message_exchange 0.0.1</span><br><span class="line">[E*] rabbitmq_management               3.6.3</span><br></pre></td></tr></table></figure><p>6.查看节点状态</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rabbitmqctl status</span><br></pre></td></tr></table></figure><p>7.查看集群状态.可以看到只识别到本身这台的节点,没有加入到集群</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">root@node2:~# rabbitmqctl cluster_status </span><br><span class="line"></span><br><span class="line">Cluster status of node rabbit@node2 ... </span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@node2]&#125;]&#125;, </span><br><span class="line">&#123;running_nodes,[rabbit@node2]&#125;,</span><br><span class="line">&#123;cluster_name,&lt;&lt;&quot;rabbit@node2&quot;&gt;&gt;&#125;, </span><br><span class="line">&#123;partitions,[]&#125;, &#123;alarms,[&#123;rabbit@node2,[]&#125;]&#125;]</span><br></pre></td></tr></table></figure><p>8.关闭这台服务器节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@node2:~# rabbitmqctl stop_app Stopping node rabbit@node2 ...</span><br></pre></td></tr></table></figure><p>9.加入另外一台node1的集群</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@node2:~# rabbitmqctl join_cluster rabbit@node1 </span><br><span class="line">Clustering node rabbit@node2 with rabbit@node1 ...</span><br></pre></td></tr></table></figure><p>10.启动节点</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root@node2:~# rabbitmqctl start_app </span><br><span class="line">Starting node rabbit@node2 ...</span><br></pre></td></tr></table></figure><p>11.查看集群状态.可以看到2个节点都识别到了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">root@node2:~# rabbitmqctl cluster_status</span><br><span class="line">Cluster status of node rabbit@node2 ...</span><br><span class="line">[&#123;nodes,[&#123;disc,[rabbit@node1,rabbit@node2]&#125;]&#125;,</span><br><span class="line"> &#123;running_nodes,[rabbit@node1,rabbit@node2]&#125;,</span><br><span class="line"> &#123;cluster_name,&lt;&lt;&quot;rabbit@node1&quot;&gt;&gt;&#125;,</span><br><span class="line"> &#123;partitions,[]&#125;,</span><br><span class="line"> &#123;alarms,[&#123;rabbit@node1,[]&#125;,&#123;rabbit@node2,[]&#125;]&#125;]</span><br><span class="line">root@node2:~#</span><br></pre></td></tr></table></figure><p>12.查看日志,可以看到集群正在往该节点上同步数据</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">=WARNING REPORT==== 21-Nov-2018::00:39:47 === msg_store_persistent: rebuilding indices from scratch</span><br><span class="line"></span><br><span class="line">=INFO REPORT==== 21-Nov-2018::00:39:48 === Mirrored queue &apos;hsq.marketingcenter.finish_pin_event&apos; in vhost &apos;/&apos;: Adding mirror on node rabbit@node2: &lt;0.11440.0&gt;</span><br><span class="line"></span><br><span class="line">=INFO REPORT==== 21-Nov-2018::00:39:48 === Mirrored queue &apos;hsq.msgcenter.app_push_notification&apos; in vhost &apos;/&apos;: Adding mirror on node rabbit@node2: &lt;0.11444.0&gt;</span><br><span class="line"></span><br><span class="line">=INFO REPORT==== 21-Nov-2018::00:39:48 === Mirrored queue &apos;hsq.msgcenter.lottery_push_notification&apos; in vhost &apos;/&apos;: Adding mirror on node rabbit@node2: &lt;0.11448.0&gt;</span><br><span class="line"></span><br><span class="line">=INFO REPORT==== 21-Nov-2018::00:39:48 === Mirrored queue &apos;push_robot&apos; in vhost &apos;/&apos;: Adding mirror on node rabbit@node2: &lt;0.11452.0&gt;</span><br><span class="line"></span><br><span class="line">=INFO REPORT==== 21-Nov-2018::00:39:48 === Mirrored queue &apos;hsq.tradecenter.refund_point&apos; in vhost &apos;/&apos;: Adding mirror on node rabbit@node2: &lt;0.11456.0&gt;</span><br></pre></td></tr></table></figure><p>13.在本节点上查看队列.可以看到队列已经同步过来了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@node2:~# rabbitmqctl list_queues</span><br></pre></td></tr></table></figure><p>另外在web控制台上还能看到更详细的信息.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;线上MQ宕机复盘&quot;&gt;&lt;a href=&quot;#线上MQ宕机复盘&quot; class=&quot;headerlink&quot; title=&quot;线上MQ宕机复盘&quot;&gt;&lt;/a&gt;线上MQ宕机复盘&lt;/h2&gt;&lt;hr&gt;
&lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;时间:2018年11月20号晚上10点40&lt;/p&gt;
&lt;p&gt;服务器:mq-slave&lt;/p&gt;
&lt;p&gt;故障现象: 钉钉收到报警MQ服务器的rabbitmq进程挂了.手动启动后,过一会超时退出&lt;/p&gt;
    
    </summary>
    
      <category term="Linux-分布式&amp;消息队列" scheme="https://jesse.top/categories/Linux-%E5%88%86%E5%B8%83%E5%BC%8F-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="MQ" scheme="https://jesse.top/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>vim使用技巧</title>
    <link href="https://jesse.top/2018/11/21/Linux-Basic/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/vim%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>https://jesse.top/2018/11/21/Linux-Basic/文本处理/vim使用技巧/</id>
    <published>2018-11-21T04:59:58.000Z</published>
    <updated>2018-12-01T14:27:37.287Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vim使用技巧"><a href="#vim使用技巧" class="headerlink" title="vim使用技巧"></a>vim使用技巧</h2><h3 id="移动光标"><a href="#移动光标" class="headerlink" title="移动光标"></a>移动光标</h3><hr><ul><li>单行移动</li></ul><table><thead><tr><th>w</th><th>移动光标到下一个单词开头</th></tr></thead><tbody><tr><td>W</td><td>移动光标到下一个单词开头，长跳．比如／etc/letsencryt 被认为是一个单词</td></tr><tr><td>e</td><td>移动光标到下一个单词结尾</td></tr><tr><td>E</td><td>移动光标到下一个单词结尾,长跳</td></tr><tr><td>b</td><td>移动光标到上一个单词</td></tr><tr><td>B</td><td>移动光标到上一个单词,长跳</td></tr><tr><td>nw</td><td>n代表数字,比如移动到下5个单词的头部,5w</td></tr><tr><td>ne</td><td>n代表数字,比如移动到下5个单词的尾部,5e</td></tr></tbody></table><a id="more"></a><ul><li>行首行尾移动</li></ul><table><thead><tr><th>0</th><th>数字0,表示移动到本行最开头,不管有没有缩进都跳到最开头,作用等用于Home键</th></tr></thead><tbody><tr><td>^</td><td>移动光标到本行最开头的字符处</td></tr><tr><td>$</td><td>移动到本行结尾处.作用等同于End键</td></tr></tbody></table><ul><li>屏幕中移动</li></ul><table><thead><tr><th>H</th><th>移动光标到屏幕的首行.注意是当前屏幕窗口,而不是整个文件.</th></tr></thead><tbody><tr><td>M</td><td>移动光标到屏幕的中间一行.</td></tr><tr><td>L</td><td>移动光标到屏幕的尾行.</td></tr></tbody></table><ul><li>文件范围移动</li></ul><table><thead><tr><th>gg</th><th>移动光标到文件首行.这个是移动到整个文件的第一行</th></tr></thead><tbody><tr><td>G</td><td>移动光标到文件的最后一行. 这个是移动到整个文件的最后一行</td></tr><tr><td>:n</td><td>跳到第n行.比如跳到第5行,可以输入:5</td></tr><tr><td>nG或ngg</td><td>也是跳到n行,比如跳到第10行,输入10G,或者10gg</td></tr><tr><td>:n</td><td>n代表数字,比如移动到100行,输入:100</td></tr></tbody></table><ul><li>翻页</li></ul><table><thead><tr><th>ctrl+f</th><th>向下翻页,等同于page down</th></tr></thead><tbody><tr><td>ctrl+b</td><td>向上翻页,等同于page up</td></tr><tr><td>ctrl+d</td><td>向下翻半页</td></tr><tr><td>ctrl+u</td><td>向上翻半页</td></tr></tbody></table><ul><li>特殊移动技巧</li></ul><table><thead><tr><th>{</th><th>跳到上一个空行</th></tr></thead><tbody><tr><td>}</td><td>跳到下一个空行</td></tr><tr><td>*</td><td>将光标停留在某个单词上，按下＊键，会搜索该单词，并跳到下一个这个单词处</td></tr><tr><td>#</td><td>将光标停留在某个单词上，按下#键，会搜索该单词，并跳到上一个这个单词处</td></tr><tr><td>‘’</td><td>两个单引号,移动光标到上一个标记处.比如跳转到他处后,输入此命令回到上一次光标停留的位置</td></tr><tr><td>‘.</td><td>一个单引号一个点，移动光标到上一次的修改行</td></tr><tr><td>`.</td><td>一个倒引号一个点．移动光标到上一次的修改点</td></tr></tbody></table><hr><h3 id="删除复制—结合光标"><a href="#删除复制—结合光标" class="headerlink" title="删除复制—结合光标"></a>删除复制—结合光标</h3><p>在vim中,y表示拷贝,d表示删除,p表示粘贴.其中拷贝和删除和光标移动命令可以结合使用</p><ul><li>删除</li></ul><table><thead><tr><th>dw</th><th>w是移动到下一个单词开头．dw表示删除从当前光标到光标所在单词结尾的内容</th></tr></thead><tbody><tr><td>dW</td><td>同上，不过是长删除, /etc/letsencrypt被认为是一个单词</td></tr><tr><td>daw</td><td>删除光标所在的单词,无论光标是停留在哪里.例如/etc/letsencrypt/.如果光标停留在letsencrypt中的t字母上,则会删除letsencrypt这个单词.如果是dw则只删除tsencrypt,保留le</td></tr><tr><td>daW</td><td>同上，长删除</td></tr><tr><td>d0</td><td>数字0,删除从当前光标到光标所在行首的内容</td></tr><tr><td>d$或dD</td><td>删除从当前光标到光标所在行尾的内容</td></tr></tbody></table><ul><li>复制</li></ul><table><thead><tr><th>yw</th><th>同理,复制从光标所在字母到单词结尾的内容</th></tr></thead><tbody><tr><td>yW</td><td>同上,长复制</td></tr><tr><td>yaw/yaW</td><td>同理，复制单词，无论光标停留在单词的哪个字母</td></tr><tr><td>y0</td><td>拷贝从当前光标到光标所在行首的内容，如果该行缩进，那么连行首的空格也一起复制</td></tr><tr><td>ｙ^</td><td>拷贝从当前光标到光标所在行首的内容，如果该行缩进，不包括行首空格，</td></tr><tr><td>y$</td><td>拷贝从当前光标到光标所在行尾的内容</td></tr></tbody></table><ul><li>整行复制删除</li></ul><table><thead><tr><th>yy</th><th>复制光标所在整行内容</th></tr></thead><tbody><tr><td>dd</td><td>删除光标所在整行内容</td></tr><tr><td>D</td><td>删除从当前光标到光标所在行尾的内容</td></tr><tr><td>J</td><td>表示光标所在行和下一行合并</td></tr><tr><td>:.,$d</td><td>删除当前行到文件末尾,</td></tr><tr><td>dG</td><td>删除当前行到文件末尾,</td></tr><tr><td>:/str1/,/str2/d</td><td>删除从字符串str1到str2的所有行</td></tr></tbody></table><hr><h3 id="删除复制—结合数字"><a href="#删除复制—结合数字" class="headerlink" title="删除复制—结合数字"></a>删除复制—结合数字</h3><table><thead><tr><th>5yy或者y5y</th><th>拷贝光标以下5行,包含光标所在行本身</th></tr></thead><tbody><tr><td>:n1,n2y</td><td>n表示数字,例如:12,24y表示拷贝第12行到第24行的内容.</td></tr><tr><td>:n,y</td><td>n表示数字,例如:12,y表示拷贝第12行到光标所在行之间的内容.</td></tr><tr><td>:,ny</td><td>n表示数字,例如:,24y表示拷贝光标所在行到第24行之间的内容.</td></tr></tbody></table><table><thead><tr><th>5dd或者d5d</th><th>删除光标以下5行,包含光标所在行本身</th></tr></thead><tbody><tr><td>:n1,n2d</td><td>n表示数字,例如:12,24d表示删除第12行到第24行的内容.</td></tr><tr><td>:n,d</td><td>n表示数字,例如:12,d表示删除第12行到光标所在行之间的内容.</td></tr><tr><td>:,nd</td><td>n表示数字,例如:,24d表示删除光标所在行到第24行之间的内容.</td></tr><tr><td>:nd</td><td>n表示数字,例如:3d表示删除3行.注意和上个命令区分</td></tr></tbody></table><hr><h3 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h3><table><thead><tr><th>/xxx或者?xxx</th><th>在整篇文档中搜索匹配xxx的字符串, / 表示向下查找, ? 表示向上查找.支持正则表达式.输入 n 查找下一个匹配处, 输入 N 反方向查找.注意查找字符串默认区分大小写</th></tr></thead><tbody><tr><td>*或者#</td><td>光标停留在某个单词上时, 输入这条命令表示查找与该单词匹配的下(上)一个单词,同样,输入n查找下一个匹配,输入N反方向查找</td></tr><tr><td>g*或者g#</td><td>和上条相似,但是这个命令不完全匹配光标所在处的单词,而是匹配包含该单词的所有字符串</td></tr><tr><td>gd</td><td>查找与光标所在单词相匹配的单词, 并将光标停留在文档的非注释段中第一次出现这个单词的地方. 用于查找局部变量等</td></tr><tr><td>%</td><td>查找与光标所在处相匹配的反括号, 包括 () [] { }</td></tr></tbody></table><hr><h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><p>一般结合s和g命令进行替换.一般格式为:  </p><p>:%s/匹配模式/替换后的字符串/g.其中模式可以是正则表达式,以下是几个例子</p><table><thead><tr><th>:s/aa/bb/g</th><th>将光标所在行出现的所有包含 aa 的字符串中的 aa 替换为 bb.注意是光标所在行,不是全文件</th></tr></thead><tbody><tr><td>:%s/aa/bb/g</td><td>将文档中出现的所有包含 aa 的字符串中的 aa 替换为 bb.文件全局生效</td></tr><tr><td>:12,23s/aa/bb/g</td><td>将从12行到23行中出现的所有包含 aa 的字符串中的 aa 替换为 bb</td></tr><tr><td>:12,23s/^/#/</td><td>将从12行到23行的行首加入 # 字符</td></tr><tr><td>:s/^/#/g</td><td>全局所有行首插入#字符</td></tr></tbody></table><blockquote><p>还有一个方法可以批量在行首插入字符:</p></blockquote><p>1.ctrl+v批量选中要插入的行</p><p>2.按大写字母I,输入要插入的字符</p><p>3.连续按两次ESC键</p><table><thead><tr><th>:%s/\s+$//</th><th>将所有行尾多余的空格删除.等同于”:%s= *$==”</th></tr></thead><tbody><tr><td>:g/^\s*$/d</td><td>将所有空行删除</td></tr><tr><td>:g/^\/\//d</td><td>将所有//开头的行整行删除.(不仅仅是删除//)</td></tr></tbody></table><blockquote><p>s配合g一般用来做替换,g单独使用一般用来删除匹配的行</p></blockquote><hr><h3 id="编辑"><a href="#编辑" class="headerlink" title="编辑"></a>编辑</h3><table><thead><tr><th>cc</th><th>删除当前行并进入编辑模式</th></tr></thead><tbody><tr><td>cw</td><td>删除当前字，并进入编辑模式</td></tr><tr><td>c$</td><td>擦除从当前位置至行末的内容，并进入编辑模式</td></tr><tr><td>S</td><td>删除光标所在行并进入编辑模式</td></tr><tr><td>s</td><td>删除当前字符并进入编辑模式</td></tr><tr><td>u</td><td>撤销</td></tr><tr><td>ctrl+r</td><td>撤销上一个撤销.</td></tr><tr><td>~</td><td>将光标当前选中的字符切换大小写</td></tr><tr><td>&gt;&gt;</td><td>当前行右移一个tab</td></tr><tr><td>&lt;&lt;</td><td>当前行左移一个 tab</td></tr><tr><td>5&gt;&gt;</td><td>当前光标后5 行向右移动一个 tab.</td></tr><tr><td>:12,24&gt;</td><td>将12行到14行的数据都向右移动一个 tab</td></tr><tr><td>:12,24&gt;&gt;</td><td>将12行到14行的数据都向右移动两个 tab</td></tr><tr><td>:w filename</td><td>将当前文件所有内容写入新文件</td></tr><tr><td>:5w filenmame</td><td>将当前文件第5行内容写入新文件</td></tr><tr><td>:1,10w filename</td><td>将当前文件第1到第10行内容写入新文件</td></tr><tr><td>:f filename</td><td>将当前文件重命名为新文件</td></tr></tbody></table><hr><h3 id="多文件编辑"><a href="#多文件编辑" class="headerlink" title="多文件编辑"></a>多文件编辑</h3><table><thead><tr><th>vim file1 file2 …</th><th>同时打开多个文件进行编辑</th></tr></thead><tbody><tr><td>:n\:N (等同于:next\:prev)</td><td>进入下一个文件(上一个文件)编辑.这个命令要求先保存当前编辑文件</td></tr><tr><td>:n!\:N!</td><td>不保存当前编辑文件,并且切换到下(上)文件编辑.</td></tr><tr><td>:wn\wN</td><td>保存当前编辑文件,并且切换到下(上)文件编辑</td></tr><tr><td>ctrl+^</td><td>在最近打开的2个文件之间快速切换</td></tr><tr><td>:e 文件名</td><td>指定对某个文件进行编辑</td></tr><tr><td>:sp [file]</td><td>把当前文件或者指定文件水平分隔</td></tr><tr><td>:vsp [file]</td><td>把当前文件或者指定文件垂直分隔</td></tr><tr><td>:q\:close</td><td>关闭当前文件窗口</td></tr><tr><td>:only</td><td>只保留当前文件窗口,关闭其他所有窗口</td></tr><tr><td>:[q\</td><td>wq]all</td><td>对所有窗口执行q或者wq操作</td></tr><tr><td>:[q\</td><td>wq]all!</td><td>对所有窗口执行q!或者wq!操作</td></tr><tr><td>:vertical all</td><td>打开所有窗口,垂直打开</td></tr><tr><td>ctrl+w  w</td><td>vim分隔了多个窗口后,光标循环定位到各个窗口中</td></tr><tr><td>ctrl+w h/i</td><td>vim分隔了多个窗口后,光标跳转到左边(右边)的窗口</td></tr><tr><td>ctrl+w j/k</td><td>vim分隔了多个窗口后,光标跳转到上边(下边)的窗口</td></tr><tr><td>ctrl+W =</td><td>让所有vim分隔后的多个窗口高度保持一样</td></tr><tr><td>ctrl+W +/-</td><td>增加/减少vim当前窗口高度</td></tr></tbody></table><hr><h3 id="执行外部shell命令"><a href="#执行外部shell命令" class="headerlink" title="执行外部shell命令"></a>执行外部shell命令</h3><table><thead><tr><th>:! command</th><th>这是比较常用的执行命令方式,比如 :!ls 显示当前目录下的文件.执行完命令后按回车返回vim编辑窗口</th></tr></thead><tbody><tr><td>:r! command</td><td>比如:r!ls.和上面的命令类似,但是执行完的结果会保存在vim的缓存中,一直显示在当前vim编辑窗口</td></tr></tbody></table><hr><h3 id="常用功能选项"><a href="#常用功能选项" class="headerlink" title="常用功能选项"></a>常用功能选项</h3><p>在启动的时候vim会读取 /etc/vimrc 和 ~/.vimrc ( 全局设置的vimrc 和用户设置).下面这些常见的功能选项可以直接定义在vimrc文件里,也可以在vim编辑窗口中输入: set xxx执行.</p><p>常见的功能选项有:</p><table><thead><tr><th>:set nu/:set nonu</th><th>显示/取消行号.nu是number的缩写</th></tr></thead><tbody><tr><td>:set ic/set noic</td><td>显示/忽略大小写.ic是ignorecace的缩写</td></tr><tr><td>:set ai/set noai</td><td>自动/不自动缩进.ai是aotuindent缩写</td></tr><tr><td>:set hlsearch/:set nohlsearch</td><td>显示/不显示高亮.</td></tr><tr><td>:syntax on / :syntax off</td><td>语法高亮/关闭语法高亮</td></tr><tr><td>set tabstop=4</td><td>设置tab键为4个空格</td></tr><tr><td>set ruler</td><td>在右下角显示光标位置的状态行</td></tr><tr><td>set incsearch</td><td>查询的时候非常方便.比如搜索book单词.输入/bo时,就已经自动开始查找.</td></tr><tr><td>set noswapfile</td><td>不要交换文件</td></tr></tbody></table><hr><h3 id="粘贴避免缩进"><a href="#粘贴避免缩进" class="headerlink" title="粘贴避免缩进"></a>粘贴避免缩进</h3><p>1.在粘贴之前,vim窗口中输入:set paste #vim就不会自动缩进,而是纯拷贝粘贴<br>2.在粘贴之后,vim窗口中输入:set nopaste #关闭paste</p><p>还有一种方法是,即使粘贴后代码格式变的非常慢,只要执行gg=G就能自动编排格式.</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;vim使用技巧&quot;&gt;&lt;a href=&quot;#vim使用技巧&quot; class=&quot;headerlink&quot; title=&quot;vim使用技巧&quot;&gt;&lt;/a&gt;vim使用技巧&lt;/h2&gt;&lt;h3 id=&quot;移动光标&quot;&gt;&lt;a href=&quot;#移动光标&quot; class=&quot;headerlink&quot; title=&quot;移动光标&quot;&gt;&lt;/a&gt;移动光标&lt;/h3&gt;&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;单行移动&lt;/li&gt;
&lt;/ul&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;w&lt;/th&gt;
&lt;th&gt;移动光标到下一个单词开头&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;W&lt;/td&gt;
&lt;td&gt;移动光标到下一个单词开头，长跳．比如／etc/letsencryt 被认为是一个单词&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;e&lt;/td&gt;
&lt;td&gt;移动光标到下一个单词结尾&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;E&lt;/td&gt;
&lt;td&gt;移动光标到下一个单词结尾,长跳&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;b&lt;/td&gt;
&lt;td&gt;移动光标到上一个单词&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;B&lt;/td&gt;
&lt;td&gt;移动光标到上一个单词,长跳&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;nw&lt;/td&gt;
&lt;td&gt;n代表数字,比如移动到下5个单词的头部,5w&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;ne&lt;/td&gt;
&lt;td&gt;n代表数字,比如移动到下5个单词的尾部,5e&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
    
    </summary>
    
      <category term="Linux-Basic" scheme="https://jesse.top/categories/Linux-Basic/"/>
    
      <category term="文本处理" scheme="https://jesse.top/categories/Linux-Basic/%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/"/>
    
    
      <category term="vim" scheme="https://jesse.top/tags/vim/"/>
    
  </entry>
  
  <entry>
    <title>kong+casssandra集群环境部署</title>
    <link href="https://jesse.top/2018/11/21/Linux-%E5%88%86%E5%B8%83%E5%BC%8F&amp;%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/kong/kong+casssandra%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
    <id>https://jesse.top/2018/11/21/Linux-分布式&amp;消息队列/kong/kong+casssandra集群环境部署/</id>
    <published>2018-11-20T21:22:58.000Z</published>
    <updated>2019-02-17T09:31:38.016Z</updated>
    
    <content type="html"><![CDATA[<h2 id="kong-casssandra集群环境部署"><a href="#kong-casssandra集群环境部署" class="headerlink" title="kong+casssandra集群环境部署"></a>kong+casssandra集群环境部署</h2><h3 id="kong简介"><a href="#kong简介" class="headerlink" title="kong简介"></a>kong简介</h3><p>Kong是Mashape开源的一款API网关，起初是用来管理 Mashape 公司15000个微服务的，后来在2015年开源,现在已经在很多创业公司、大型企业和政府机构中广泛使用。基于nginx,Lua和Cassandra或PostgreSQL，支持分布式操作，有很强的可移植性和可扩展性。可以在任何一种基础设施上运行,作为应用和API之间的中间层，加上众多功能强大的插件，可以实现认证授权、访问控制等功能。并且提供易于使用的RESTful API来操作和配置系统。</p><p>有关kong的详细介绍请参考官网.</p><a id="more"></a><p>–</p><h3 id="cassandra简介"><a href="#cassandra简介" class="headerlink" title="cassandra简介"></a>cassandra简介</h3><p>Cassandra 是一个来自 Apache 的分布式数据库，具有高度可扩展性，可用于管理大量的结构化数据。它提供了高可用性，没有单点故障。kong支持PostgreSQL或者Cassandra两种数据库.这里我们选择了cassandra.</p><p>有关cassandra的详细介绍和使用方法.请参考官网</p><p>–</p><h3 id="集群架构"><a href="#集群架构" class="headerlink" title="集群架构"></a>集群架构</h3><ul><li><strong>kong cluster</strong></li></ul><p>kong 集群并不意味着客户端请求将会负载均衡到kong集群中的每个节点上，kong集群并不是开箱即用，仍然需要在kong集群多节点上层搭建负载均衡，以便分发请求。 一个kong集群只是意味着集群内的节点，都共享同样的配置。</p><p>有关Kong cluster集群的详细介绍请参考官网:<a href="https://docs.konghq.com/0.14.x/clustering/" target="_blank" rel="noopener">Kong cluser document</a></p><p>为了提高冗余性和健壮性.我们对kong的每个环节都进行了冗余设计.一个基本的kong集群架构大概如下图所示:</p><p><img src="http://pabkmteb4.bkt.clouddn.com/kong-flow.png" alt=""></p><p>–</p><h3 id="部署步骤"><a href="#部署步骤" class="headerlink" title="部署步骤"></a>部署步骤</h3><p><strong>环境</strong>: </p><p>阿里云ECS Centos7.4操作系统<br>Kong: 0.14 最新版<br>Cassandra: 3.11 最新版</p><p>–</p><h4 id="安装Cassandra"><a href="#安装Cassandra" class="headerlink" title="安装Cassandra"></a>安装Cassandra</h4><p>安装方式官网参考: <a href="http://cassandra.apache.org/doc/latest/getting_started/installing.html#installation-from-binary-tarball-files" target="_blank" rel="noopener">Installing Cassandra</a></p><p><strong>安装前提条件</strong></p><p>1.安装JDK 8版本<br>2.安装2.7以上版本的Python.(cassandra管理工具:cqlsh 需要python2.7以上环境)</p><p><strong>安装步骤</strong></p><p>1.下载cassandra二进制文件.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget http://mirrors.tuna.tsinghua.edu.cn/apache/cassandra/3.11.3/apache-cassandra-3.11.3-bin.tar.gz</span><br></pre></td></tr></table></figure><p>2.将cassandra目录添加进环境变量.用work用户运行cassandra</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir /usr/local/cassandra</span><br><span class="line">sudo chown -R work:work /usr/local/cassandra</span><br><span class="line">sudo tar -xvf apache-cassandra-3.11.3-bin.tar.gz -C /usr/local/cassandra</span><br><span class="line"></span><br><span class="line">cd /usr/local/cassandra</span><br><span class="line">sudo mv apache-cassandra-3.11.3/* .</span><br><span class="line">sudo rm apache-cassandra-3.11.3/ -rf</span><br></pre></td></tr></table></figure><p>添加进环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">sudo vim /etc/profile</span><br><span class="line"></span><br><span class="line">export JAVA_HOME=/usr/local/java</span><br><span class="line">export CASSANDRA_HOME=/usr/local/cassandra</span><br><span class="line">export PATH=$PATH:$JAVA_HOME/bin:$CASSANDRA_HOME/bin</span><br></pre></td></tr></table></figure><p>–</p><h4 id="配置Cassandra-以及cassandra集群"><a href="#配置Cassandra-以及cassandra集群" class="headerlink" title="配置Cassandra,以及cassandra集群"></a>配置Cassandra,以及cassandra集群</h4><p>1.编辑cassandra的cassandra.yml配置文件.修改下列配置:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 kong]$ vim /usr/local/cassandra/conf/cassandra.yaml</span><br><span class="line"></span><br><span class="line">#定义Cassandra集群名</span><br><span class="line">cluster_name: &apos;dwd_cassandra&apos;</span><br><span class="line">#定义hints路径.可以使用默认路径</span><br><span class="line">hints_directory: /data/cassandra/hints</span><br><span class="line"></span><br><span class="line">#采用密码方式连接数据库.默认情况下不需要任何用户密码就可以登录数据库</span><br><span class="line">authenticator: PasswordAuthenticator</span><br><span class="line"></span><br><span class="line">#定义数据库文件路径.可以使用默认/var/lib路径</span><br><span class="line">data_file_directories:</span><br><span class="line">      - /data/cassandra</span><br><span class="line"></span><br><span class="line">#定义commit日志路径.可以使用默认路径</span><br><span class="line">commitlog_directory: /data/cassandra/commitlog</span><br><span class="line"></span><br><span class="line">#缓存文件路径</span><br><span class="line">saved_caches_directory: /data/cassandra/saved_caches</span><br><span class="line"></span><br><span class="line">#关键配置,定义集群种子服务器地址.这里定义服务器的内网地址.不能使用0.0.0.0或者127的本机地址,可以加入多个集群节点的地址,IP地址之间用逗号分隔</span><br><span class="line">- seeds: &quot;10.25.87.159&quot;</span><br><span class="line"></span><br><span class="line">#listen地址</span><br><span class="line">listen_address: 10.25.87.159</span><br><span class="line"></span><br><span class="line">#rpc地址</span><br><span class="line">rpc_address: 10.25.87.159</span><br></pre></td></tr></table></figure><p>2.创建刚才定义的路径目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo mkdir -pv /data/cassandra </span><br><span class="line">sudo chown -R work.work /data/</span><br></pre></td></tr></table></figure><p>3.启动cassandra.直接在命令行执行cassandra</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 kong]$ cassandra </span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">[work@kong-node1 kong]$ /usr/local/cassandra/bin/cassandra</span><br></pre></td></tr></table></figure><ol start="4"><li>使用cqlsh工具登陆cassandra数据库.创建cassandra用户密码,以及创建键空间</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">#注意由于cassandra只侦听了内网的地址,因此要指定IP地址.</span><br><span class="line">#默认账号密码都是cassandra</span><br><span class="line">[work@kong-node1 kong]$ cqlsh 10.25.87.159  -ucassandra -pcassandra </span><br><span class="line"></span><br><span class="line">#创建一个kong用户.并且为超级用户</span><br><span class="line">cassandra@cqlsh&gt; create user kong with password &apos;kong&apos; superuser;</span><br><span class="line"></span><br><span class="line">#创建一个keyspace.命名为kong</span><br><span class="line">cassandra@cqlsh&gt; CREATE KEYSPACE kong WITH REPLICATION = &#123; &apos;class&apos; : &apos;SimpleStrategy&apos;, &apos;replication_factor&apos; : 1&#125;;</span><br><span class="line"></span><br><span class="line">cassandra@cqlsh&gt; exit</span><br></pre></td></tr></table></figure><p>5.删除自带的cassandra用户</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 cassandra]$ cqlsh 10.25.87.159  -ukong -pkong</span><br><span class="line">kong@cqlsh&gt; desc kong;</span><br><span class="line"></span><br><span class="line">CREATE KEYSPACE kong WITH replication = &#123;&apos;class&apos;: &apos;SimpleStrategy&apos;, &apos;replication_factor&apos;: &apos;1&apos;&#125;  AND durable_writes = true;</span><br><span class="line"></span><br><span class="line">kong@cqlsh&gt; drop user cassandra;</span><br></pre></td></tr></table></figure><p>–</p><h4 id="安装Kong"><a href="#安装Kong" class="headerlink" title="安装Kong"></a>安装Kong</h4><p>安装方法可以参考官网:<a href="https://docs.konghq.com/install/centos/?_ga=2.110797315.728319704.1539597667-917309945.1539077269#packages" target="_blank" rel="noopener">Install Kong</a></p><p>1.下载,安装rpm安装包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">wget -O kong-community-edition-0.14.1.el7.noarch.rpm  https://bintray.com/kong/kong-community-edition-rpm/download_file?file_path=centos/7/kong-community-edition-0.14.1.el7.noarch.rpm</span><br><span class="line"></span><br><span class="line">sudo yum install epel-release</span><br><span class="line">sudo yum install kong-community-edition-0.14.1.el7.noarch.rpm</span><br></pre></td></tr></table></figure><p>2.修改配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">cd /etc/kong</span><br><span class="line">sudo cp kong.conf.default kong.conf</span><br><span class="line"></span><br><span class="line">sudo vim kong.conf</span><br><span class="line"></span><br><span class="line">#修改日志文件路径</span><br><span class="line">prefix = /data/kong/</span><br><span class="line"></span><br><span class="line">#由于磁盘空间有限,关闭kong的代理日志.后端真实服务器会记录nginx访问日志</span><br><span class="line">proxy_access_log = off</span><br><span class="line">proxy_error_log = off</span><br><span class="line"></span><br><span class="line">#在所有地址侦听管理端口,当然只侦听127地址会更安全.</span><br><span class="line">admin_listen = 0.0.0.0:8001, 0.0.0.0:8444 ssl</span><br><span class="line"></span><br><span class="line">#指定使用cassandra数据库</span><br><span class="line">database = cassandra</span><br><span class="line">#数据库地址,端口</span><br><span class="line">cassandra_contact_points = 10.25.87.159</span><br><span class="line">cassandra_port = 9042</span><br><span class="line"></span><br><span class="line">#上文定义的cassandra数据库的用户密码和键空间</span><br><span class="line">cassandra_keyspace = kong</span><br><span class="line">cassandra_username = kong</span><br><span class="line">cassandra_password = kong</span><br><span class="line"></span><br><span class="line">#kong官方建议的cassandra一致性机制</span><br><span class="line">cassandra_consistency = QUORUM</span><br><span class="line"></span><br><span class="line">#以下是集群的数据库和缓存方面的配置.详细介绍请参考官网</span><br><span class="line">db_update_frequency = 5</span><br><span class="line">db_update_propagation = 2</span><br></pre></td></tr></table></figure><p>3.创建kong目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /data/kong</span><br></pre></td></tr></table></figure><p>4.准备启动工作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kong migrations up -c /etc/kong/kong.conf</span><br></pre></td></tr></table></figure><p>5.启动kong</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kong start -c /etc/kong/kong.conf</span><br></pre></td></tr></table></figure><p>查看端口.可以看到cassandra和kong的侦听端口都已经成功启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">work@kong-node1 kong]$ netstat -tulnp</span><br><span class="line">Proto Recv-Q Send-Q Local Address           Foreign Address         State       PID/Program name</span><br><span class="line">tcp        0      0 0.0.0.0:8443            0.0.0.0:*               LISTEN      29342/nginx: master</span><br><span class="line">tcp        0      0 0.0.0.0:8444            0.0.0.0:*               LISTEN      29342/nginx: master</span><br><span class="line">tcp        0      0 127.0.0.1:7199          0.0.0.0:*               LISTEN      28598/java</span><br><span class="line">tcp        0      0 0.0.0.0:8000            0.0.0.0:*               LISTEN      29342/nginx: master</span><br><span class="line">tcp        0      0 0.0.0.0:8001            0.0.0.0:*               LISTEN      29342/nginx: master</span><br><span class="line">tcp        0      0 127.0.0.1:35503         0.0.0.0:*               LISTEN      28598/java</span><br><span class="line">tcp        0      0 10.25.87.159:9042       0.0.0.0:*               LISTEN      28598/java</span><br><span class="line">tcp        0      0 10.25.87.159:7000       0.0.0.0:*               LISTEN      28598/java</span><br></pre></td></tr></table></figure><hr><h3 id="部署另外一台kong和cassandra"><a href="#部署另外一台kong和cassandra" class="headerlink" title="部署另外一台kong和cassandra"></a>部署另外一台kong和cassandra</h3><p>今天在阿里云镜像了kong-node1的服务器.新的服务器名字为kong-node2.<br>软件已经安装,只需要修改部分配置</p><h5 id="修改node1和node2上的cassandra配置"><a href="#修改node1和node2上的cassandra配置" class="headerlink" title="修改node1和node2上的cassandra配置"></a>修改node1和node2上的cassandra配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">在node1和node2上:</span><br><span class="line">[work@kong-node2 ~]$ vim /usr/local/cassandra/conf/cassandra.yaml</span><br><span class="line">#修改seeds配置.添加2台服务器的内网IP地址</span><br><span class="line">- seeds: &quot;10.25.87.159, 10.80.229.244&quot; </span><br><span class="line"></span><br><span class="line">在node2上修改侦听地址</span><br><span class="line">[work@kong-node2 ~]$ vim /usr/local/cassandra/conf/cassandra.yaml</span><br><span class="line">#将下列地址改成node2内网地址</span><br><span class="line">listen_address: 10.80.229.244</span><br><span class="line">rpc_address: 10.80.229.244</span><br></pre></td></tr></table></figure><h5 id="在node2上修改kong的配置文件"><a href="#在node2上修改kong的配置文件" class="headerlink" title="在node2上修改kong的配置文件:"></a>在node2上修改kong的配置文件:</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">work@kong-node2 ~]$ vim /etc/kong/kong.conf</span><br><span class="line">#连接本机的cassandra数据库地址</span><br><span class="line">cassandra_contact_points = 10.80.229.244</span><br></pre></td></tr></table></figure><blockquote><p>note:千万不要启动node2上的cassandra.因为node2是从node1镜像过去的.所以数据库的token是一模一样的.</p></blockquote><h5 id="在node2上删除cassandra的数据库-这一步非常重要-因为这是从node1镜像过来的-所以node2上的数据库是node1的数据"><a href="#在node2上删除cassandra的数据库-这一步非常重要-因为这是从node1镜像过来的-所以node2上的数据库是node1的数据" class="headerlink" title="在node2上删除cassandra的数据库.这一步非常重要.因为这是从node1镜像过来的.所以node2上的数据库是node1的数据"></a>在node2上删除cassandra的数据库.这一步非常重要.因为这是从node1镜像过来的.所以node2上的数据库是node1的数据</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rm -rf /data/cassandra/*</span><br></pre></td></tr></table></figure><h5 id="启动node2上的数据库"><a href="#启动node2上的数据库" class="headerlink" title="启动node2上的数据库"></a>启动node2上的数据库</h5><p>直接在命令行执行:cassandra</p><h5 id="查看cassandra的单台服务器状态"><a href="#查看cassandra的单台服务器状态" class="headerlink" title="查看cassandra的单台服务器状态"></a>查看cassandra的单台服务器状态</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 bin]$ nodetool info</span><br><span class="line">ID                     : 4fe1df37-e69e-4a25-acdc-4b2d73a92225</span><br><span class="line">Gossip active          : true</span><br><span class="line">Thrift active          : false</span><br><span class="line">Native Transport active: true</span><br><span class="line">Load                   : 522.87 KiB</span><br><span class="line">Generation No          : 1540372001</span><br><span class="line">Uptime (seconds)       : 63895</span><br><span class="line">Heap Memory (MB)       : 404.89 / 1004.00</span><br><span class="line">Off Heap Memory (MB)   : 0.00</span><br><span class="line">Data Center            : datacenter1</span><br><span class="line">Rack                   : rack1</span><br><span class="line">Exceptions             : 0</span><br><span class="line">Key Cache              : entries 59, size 5.03 KiB, capacity 50 MiB, 7540 hits, 7911 requests, 0.953 recent hit rate, 14400 save period in seconds</span><br><span class="line">Row Cache              : entries 0, size 0 bytes, capacity 0 bytes, 0 hits, 0 requests, NaN recent hit rate, 0 save period in seconds</span><br><span class="line">Counter Cache          : entries 0, size 0 bytes, capacity 25 MiB, 0 hits, 0 requests, NaN recent hit rate, 7200 save period in seconds</span><br><span class="line">Chunk Cache            : entries 28, size 1.75 MiB, capacity 219 MiB, 1237 misses, 26133 requests, 0.953 recent hit rate, NaN microseconds miss latency</span><br><span class="line">Percent Repaired       : 100.0%</span><br><span class="line">Token                  : (invoke with -T/--tokens to see all 256 tokens)</span><br></pre></td></tr></table></figure><h5 id="查看cassandra集群状态-可以看到集群中2台服务器"><a href="#查看cassandra集群状态-可以看到集群中2台服务器" class="headerlink" title="查看cassandra集群状态.可以看到集群中2台服务器"></a>查看cassandra集群状态.可以看到集群中2台服务器</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 bin]$ nodetool status</span><br><span class="line">Datacenter: datacenter1</span><br><span class="line">=======================</span><br><span class="line">Status=Up/Down</span><br><span class="line">|/ State=Normal/Leaving/Joining/Moving</span><br><span class="line">--  Address        Load       Tokens       Owns (effective)  Host ID                               Rack</span><br><span class="line">UN  10.80.229.244  339.93 KiB  256          51.3%             04a75f63-be99-4f3e-93ff-937bbe9656d8  rack1</span><br><span class="line">UN  10.25.87.159   522.87 KiB  256          48.7%             4fe1df37-e69e-4a25-acdc-4b2d73a92225  rack1</span><br></pre></td></tr></table></figure><hr><h4 id="以下是我踩过的坑-在没有删除node2上的数据库文件情况下-直接启动cassnadra"><a href="#以下是我踩过的坑-在没有删除node2上的数据库文件情况下-直接启动cassnadra" class="headerlink" title="以下是我踩过的坑.在没有删除node2上的数据库文件情况下,直接启动cassnadra."></a>以下是我踩过的坑.在没有删除node2上的数据库文件情况下,直接启动cassnadra.</h4><p>启动node2的cassandra后.发现集群无法正常启动.使用cassandra自带的nodetool工具可以查看集群状态.这里只有自己一台服务器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node2 ~]$ nodetool status</span><br><span class="line">Datacenter: datacenter1</span><br><span class="line">=======================</span><br><span class="line">Status=Up/Down</span><br><span class="line">|/ State=Normal/Leaving/Joining/Moving</span><br><span class="line">--  Address        Load       Tokens       Owns (effective)  Host ID                               Rack</span><br><span class="line">UN  10.80.229.244  600.05 KiB  256          100.0%            4fe1df37-e69e-4a25-acdc-4b2d73a92225  rack1</span><br></pre></td></tr></table></figure><p>查看cassandra启动日志,发现日志提示和node1有一样的token:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">less /usr/local/cassandra/logs/system.log</span><br><span class="line"></span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,874 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token -9066137612411979055.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,874 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token -912539082610246005.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,874 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token -9125687604150710607.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,874 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token -9186325188411815558.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,874 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token -934168442605847346.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,874 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token -937629522304513228.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,874 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token -983284835358960159.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,875 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token 1111859401021864246.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,875 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token 1185525604491731552.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,875 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token 1209704333924286496.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,875 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token 1243859262038298713.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,875 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token 1284321765579584761.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,875 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token 1472069791929520463.  Ignoring /10.25.87.159</span><br><span class="line">INFO  [GossipStage:1] 2018-10-24 17:07:26,875 StorageService.java:2386 - Nodes /10.25.87.159 and /10.80.229.244 have the same token 1479257042759500258.  Ignoring /10.25.87.159</span><br></pre></td></tr></table></figure><p>不仅如此,在node1上启动kong,提示cassandra数据库验证失败.以及提示kong需要migrations up(只需要在第一次启动kong时才需要migratios up):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 bin]$ kong restart -c /etc/kong/kong.conf</span><br><span class="line">Error: /usr/local/share/lua/5.1/kong/cmd/start.lua:37: [cassandra error] the current database schema does not match this version of Kong. Please run `kong migrations up` to update/initialize the database schema. Be aware that Kong migrations should only run from a single node, and that nodes running migrations concurrently will conflict with each other and might corrupt your database schema!</span><br></pre></td></tr></table></figure><p>kong migrations失败</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"> work@kong-node1 bin]$ kong migrations up -c /etc/kong/kong.conf</span><br><span class="line">migrating core for keyspace kong</span><br><span class="line">core migrated up to: 2015-01-12-175310_skeleton</span><br><span class="line">Error: [cassandra error] Error during migration 2015-01-12-175310_init_schema: [Invalid] Undefined column name request_host</span><br></pre></td></tr></table></figure><h5 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h5><p>启动node1和node2的cassandra</p><p>1.在node1和node2上drop kong的键空间</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 bin]$ cqlsh 10.25.87.159 -ukong -pkong</span><br><span class="line">Connected to dwd_cassandra at 10.25.87.159:9042.</span><br><span class="line">[cqlsh 5.0.1 | Cassandra 3.11.3 | CQL spec 3.4.4 | Native protocol v4]</span><br><span class="line">Use HELP for help.</span><br><span class="line">kong@cqlsh&gt; drop keyspace kong;</span><br><span class="line">kong@cqlsh&gt; exit</span><br><span class="line"></span><br><span class="line">[work@kong-node2 ~]$ cqlsh 10.80.229.244 -ukong -pkong</span><br><span class="line">Connected to dwd_cassandra at 10.80.229.244:9042.</span><br><span class="line">[cqlsh 5.0.1 | Cassandra 3.11.3 | CQL spec 3.4.4 | Native protocol v4]</span><br><span class="line">Use HELP for help.</span><br><span class="line">kong@cqlsh&gt; drop KEYSPACE kong;</span><br><span class="line">ConfigurationException: Cannot drop non existing keyspace &apos;kong&apos;.</span><br><span class="line">kong@cqlsh&gt; exit</span><br></pre></td></tr></table></figure><p>2.删除kong的键空间目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[work@kong-node1 bin]$ rm -rf  /data/cassandra/kong/</span><br><span class="line">[work@kong-node1 bin]$ ll /data/cassandra/kong/</span><br><span class="line">ls: cannot access /data/cassandra/kong/: No such file or directory</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[work@kong-node2 ~]$ rm -rf /data/cassandra/kong/</span><br><span class="line">[work@kong-node2 ~]$ ll /data/cassandra/kong/</span><br><span class="line">ls: cannot access /data/cassandra/kong/: No such file or directory</span><br></pre></td></tr></table></figure><p>3.在node1上创建kong键空间.创建完毕后,应该会同步到node2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 bin]$ cqlsh 10.25.87.159 -ukong -pkong</span><br><span class="line">Connected to dwd_cassandra at 10.25.87.159:9042.</span><br><span class="line">[cqlsh 5.0.1 | Cassandra 3.11.3 | CQL spec 3.4.4 | Native protocol v4]</span><br><span class="line">Use HELP for help.</span><br><span class="line">kong@cqlsh&gt; CREATE KEYSPACE kong WITH REPLICATION = &#123; &apos;class&apos; : &apos;SimpleStrategy&apos;, &apos;replication_factor&apos; : 1&#125;;</span><br><span class="line">kong@cqlsh&gt; exit</span><br></pre></td></tr></table></figure><p>4.在node1上执行 kong migrations up ,执行完后同样会同步到node2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">work@kong-node1 bin]$ kong migrations up -c /etc/kong/kong.conf</span><br><span class="line">migrating core for keyspace kong</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">66 migrations ran</span><br><span class="line">waiting for Cassandra schema consensus (10000ms timeout)...</span><br><span class="line">Cassandra schema consensus: reached</span><br></pre></td></tr></table></figure><p>5.在node1和node2上启动kong</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 bin]$ kong restart -c /etc/kong/kong.conf</span><br><span class="line"></span><br><span class="line">[work@kong-node2 ~]$ kong start -c /etc/kong/kong.conf</span><br><span class="line">Kong started</span><br></pre></td></tr></table></figure><hr><h3 id="搭建kong-dashboard"><a href="#搭建kong-dashboard" class="headerlink" title="搭建kong-dashboard"></a>搭建kong-dashboard</h3><p>kong-dashboard是管理kong各个组件(serveice,route,plugin,upstream,consumer)的可视化UI管理工具.在增删改查各个组件的配置时非常方便.</p><p>现在kong-dashboard也支持到了最新版的kong和kong的最新组件.</p><p>kong-dashboard的github参考:<a href="https://github.com/PGBI/kong-dashboard" target="_blank" rel="noopener">kong-dashboar</a></p><hr><p>1.确保需要有node.js环境.如果没有npm工具,必须先安装nodejs</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@DWD-BETA kong]$ npm -v</span><br><span class="line">5.6.0</span><br><span class="line">[work@DWD-BETA kong]$ node -v</span><br><span class="line">v8.10.0</span><br></pre></td></tr></table></figure><p>2.root用户执行下列安装命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[root@DWD-BETA ~]# npm install -g kong-dashboard</span><br><span class="line">/usr/local/src/nodejs/bin/kong-dashboard -&gt; /usr/local/src/nodejs/lib/node_modules/kong-dashboard/bin/kong-dashboard.js</span><br><span class="line">+ kong-dashboard@3.5.0</span><br><span class="line">added 184 packages in 28.8s</span><br></pre></td></tr></table></figure><p>3.启动kong-dashboard.启动方式有以下几种</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># Start Kong Dashboard</span><br><span class="line">kong-dashboard start --kong-url http://kong:8001</span><br><span class="line"></span><br><span class="line"># Start Kong Dashboard on a custom port</span><br><span class="line">kong-dashboard start \</span><br><span class="line">  --kong-url http://kong:8001 \</span><br><span class="line">  --port [port]</span><br><span class="line"></span><br><span class="line"># Start Kong Dashboard with basic auth</span><br><span class="line">kong-dashboard start \</span><br><span class="line">  --kong-url http://kong:8001 \</span><br><span class="line">  --basic-auth user1=password1 user2=password2</span><br><span class="line"></span><br><span class="line"># See full list of start options</span><br><span class="line">kong-dashboard start --help</span><br></pre></td></tr></table></figure><p>但是kong-dashboard是前台启动,没有deamnize模式.所以将kong-dashboard加入到supervisor进程管理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[root@DWD-BETA ~]# vim /etc/supervisor/conf.d/kong-dashboard.conf</span><br><span class="line"></span><br><span class="line">[program:kong-dashboard]</span><br><span class="line">command=/usr/local/src/nodejs/bin/kong-dashboard start --kong-url http://localhost:8001</span><br><span class="line">numprocs=1</span><br><span class="line">user=work</span><br><span class="line">stdout_logfile = /data/logs/kong/kong-dashboard.log</span><br><span class="line">redirect_stderr = true</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br></pre></td></tr></table></figure><p>修改权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@DWD-BETA ~]# chown -R work.work /etc/supervisor/conf.d/</span><br></pre></td></tr></table></figure><p>更新supervisor配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@DWD-BETA ~]# supervisorctl update kong-dashboard</span><br><span class="line">kong-dashboard: added process group</span><br></pre></td></tr></table></figure><p>但是由于我这台服务器上8080端口已经被使用,所以启动kong-dashboard报错:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">work@DWD-BETA kong]$ /usr/local/src/nodejs/bin/kong-dashboard start --kong-url http://localhost:8001</span><br><span class="line">Connecting to Kong on http://localhost:8001 ...</span><br><span class="line">Connected to Kong on http://localhost:8001.</span><br><span class="line">Kong version is 0.14.1</span><br><span class="line">Starting Kong Dashboard on port 8080</span><br><span class="line">events.js:183</span><br><span class="line">      throw er; // Unhandled &apos;error&apos; event</span><br><span class="line">      ^</span><br><span class="line"></span><br><span class="line">Error: listen EADDRINUSE :::8080</span><br><span class="line">    at Object._errnoException (util.js:1022:11)</span><br><span class="line">    at _exceptionWithHostPort (util.js:1044:20)</span><br><span class="line">    at Server.setupListenHandle [as _listen2] (net.js:1367:14)</span><br><span class="line">    at listenInCluster (net.js:1408:12)</span><br><span class="line">    at Server.listen (net.js:1492:7)</span><br><span class="line">    at Application.listen (/usr/local/src/nodejs/lib/node_modules/kong-dashboard/node_modules/koa/lib/application.js:65:19)</span><br><span class="line">    at Server.start (/usr/local/src/nodejs/lib/node_modules/kong-dashboard/lib/server.js:32:9)</span><br><span class="line">    at startKongDashboard (/usr/local/src/nodejs/lib/node_modules/kong-dashboard/bin/kong-dashboard.js:189:10)</span><br><span class="line">    at request.get.then.then (/usr/local/src/nodejs/lib/node_modules/kong-dashboard/bin/kong-dashboard.js:178:5)</span><br><span class="line">    at &lt;anonymous&gt;</span><br></pre></td></tr></table></figure><p>8080端口被jenkins占用了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@DWD-BETA kong]$ netstat -tulnp | grep 8080</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">tcp        0      0 0.0.0.0:8080            0.0.0.0:*               LISTEN      17955/java</span><br></pre></td></tr></table></figure><p>更换kong-dashboard端口为8081</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[program:kong-dashboard]</span><br><span class="line">command=/usr/local/src/nodejs/bin/kong-dashboard  start --kong-url http://localhost:8001 --port 8081</span><br><span class="line">numprocs=1</span><br><span class="line">user=work</span><br><span class="line">stdout_logfile = /data/logs/kong/kong-dashboard.log</span><br><span class="line">redirect_stderr = true</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br></pre></td></tr></table></figure><p>更新supervisor后,仍然无法启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[work@DWD-BETA kong]$ supervisorctl update kong-dashboard</span><br><span class="line">kong-dashboard: stopped</span><br><span class="line">kong-dashboard: updated process group</span><br><span class="line">[work@DWD-BETA kong]$ supervisorctl status kong-dashboard</span><br><span class="line">kong-dashboard                   BACKOFF   Exited too quickly (process log may have details)</span><br></pre></td></tr></table></figure><p>手动启动正常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[work@DWD-BETA kong]$ /usr/local/src/nodejs/bin/kong-dashboard  start --kong-url http://localhost:8001 --port 8081</span><br><span class="line">Connecting to Kong on http://localhost:8001 ...</span><br><span class="line">Connected to Kong on http://localhost:8001.</span><br><span class="line">Kong version is 0.14.1</span><br><span class="line">Starting Kong Dashboard on port 8081</span><br><span class="line">Kong Dashboard has started on port 8081</span><br><span class="line">^C</span><br></pre></td></tr></table></figure><p>查看supervisor启动日志文件:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[work@DWD-BETA kong]$ less /data/logs/kong/kong-dashboard.log</span><br><span class="line">/usr/bin/env: node: No such file or directory</span><br><span class="line">/usr/bin/env: node: No such file or directory</span><br><span class="line">/usr/bin/env: node: No such file or directory</span><br><span class="line">/usr/bin/env: node: No such file or directory</span><br></pre></td></tr></table></figure><p>网上查找解决方案.说是要链接以下文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/bin/nodejs /usr/bin/node</span><br></pre></td></tr></table></figure><p>但是这台服务器上nodejs路径不同,所以执行以下命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[work@DWD-BETA kong]$ sudo ln -s /usr/local/src/nodejs /usr/bin/node</span><br></pre></td></tr></table></figure><p>仍然无法启动,提示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/env: node: Permission denied</span><br><span class="line">/usr/bin/env: node: Permission denied</span><br><span class="line">/usr/bin/env: node: Permission denied</span><br><span class="line">/usr/bin/env: node: Permission denied</span><br><span class="line">/usr/bin/env: node: Permission denied</span><br><span class="line">/usr/bin/env: node: Permission denied</span><br></pre></td></tr></table></figure><p>修改kong-dashboard启动用户为root.仍然无法启动.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[program:kong-dashboard]</span><br><span class="line">command=/usr/local/src/nodejs/bin/kong-dashboard  start --kong-url http://127.0.0.1:8001 --port 8081</span><br><span class="line">numprocs=1</span><br><span class="line">user=root</span><br><span class="line">stdout_logfile = /data/logs/kong/kong-dashboard.log</span><br><span class="line">redirect_stderr = true</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br></pre></td></tr></table></figure><hr><p>操作失误在创建软件的时候,删除了nodejs源目录.重新安装了npm和kong-dashboard</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">解压nodejs包到:/usr/local/node/</span><br><span class="line"></span><br><span class="line">#设置环境变量: </span><br><span class="line">[root@DWD-BETA ~]# cat /etc/profile | tail -2</span><br><span class="line">export NODEJS_HOME=/usr/local/node/</span><br><span class="line">export PATH=$PATH:$NODEJS_HOME/bin</span><br><span class="line"></span><br><span class="line">[root@DWD-BETA ~]# node -v</span><br><span class="line">v8.10.0</span><br><span class="line">[root@DWD-BETA ~]# npm -v</span><br><span class="line">5.6.0</span><br></pre></td></tr></table></figure><p>创建链接</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@DWD-BETA ~]# ln -s /usr/local/node/bin/node /usr/bin/node</span><br><span class="line">root@DWD-BETA ~]# ll /usr/bin/node -d</span><br><span class="line">lrwxrwxrwx 1 root root 24 Nov  3 11:25 /usr/bin/node -&gt; /usr/local/node/bin/node</span><br></pre></td></tr></table></figure><p>修改supervisor配置文件中的命令路径</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[program:kong-dashboard]</span><br><span class="line">command=/usr/local/node/bin/kong-dashboard  start --kong-url http://127.0.0.1:8001 --port 8081</span><br><span class="line">numprocs=1</span><br><span class="line">priority=3</span><br><span class="line">user=root</span><br><span class="line">stdout_logfile = /data/logs/kong/kong-dashboard.log</span><br><span class="line">redirect_stderr = true</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br></pre></td></tr></table></figure><p>启动kong-dashboard</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[root@DWD-BETA ~]# supervisorctl update kong-dashboard</span><br><span class="line">kong-dashboard: stopped</span><br><span class="line">kong-dashboard: updated process group</span><br><span class="line"></span><br><span class="line">[root@DWD-BETA ~]# supervisorctl status kong-dashboard</span><br><span class="line">kong-dashboard                   RUNNING   pid 16635, uptime 0:05:02</span><br></pre></td></tr></table></figure><p>启动完成</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@DWD-BETA ~]# netstat -tulnp | grep 8081</span><br><span class="line">tcp6       0      0 :::8081                 :::*                    LISTEN      16635/node</span><br></pre></td></tr></table></figure><hr><h3 id="将cassandra加入到supervisor进程管理"><a href="#将cassandra加入到supervisor进程管理" class="headerlink" title="将cassandra加入到supervisor进程管理"></a>将cassandra加入到supervisor进程管理</h3><p>cassandra加入supervisor进程托管遇到不少问题.踩过以下2个坑:</p><p>1.启动报错,提示需要更高级版本的java.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Cassandra 3.0 and later require Java 8u40 or later.</span><br><span class="line">Cassandra 3.0 and later require Java 8u40 or later.</span><br><span class="line">Cassandra 3.0 and later require Java 8u40 or later.</span><br><span class="line">Cassandra 3.0 and later require Java 8u40 or later.</span><br><span class="line">Cassandra 3.0 and later require Java 8u40 or later.</span><br><span class="line">Cassandra 3.0 and later require Java 8u40 or later.</span><br><span class="line">Cassandra 3.0 and later require Java 8u40 or later.</span><br></pre></td></tr></table></figure><p>我的解决方案:</p><ul><li>在cassandra的supervisor配置文件中加入环境变量:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">environment=JAVA_HOME=&quot;/usr/local/java&quot;  #这样cassandra会识别用户自定义安装的Java.</span><br></pre></td></tr></table></figure><ul><li>配置软链</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo ln -s /usr/local/java/bin/java /usr/bin/java</span><br></pre></td></tr></table></figure><p>2.仍然无法启动,因为命令行是以daemon方式启动.在cassandra的supervisor配置文件中的启动参数加入-f选项.</p><p>最终的cassandra配置文件如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[program:cassandra]</span><br><span class="line">command=/usr/local/cassandra/bin/cassandra -f</span><br><span class="line">directory=/usr/local/cassandra/</span><br><span class="line">environment=JAVA_HOME=&quot;/usr/local/java&quot;</span><br><span class="line">enviroment=PATH=&quot;$JAVA_HOME/bin:$PATH&quot;</span><br><span class="line">priority=0</span><br><span class="line">numprocs=1</span><br><span class="line">user=work</span><br><span class="line">stdout_logfile = /data/logs/cassandra/cassandra_supervisor.log</span><br><span class="line">redirect_stderr = true</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br></pre></td></tr></table></figure><hr><h3 id="将kong加入到supervisor"><a href="#将kong加入到supervisor" class="headerlink" title="将kong加入到supervisor"></a>将kong加入到supervisor</h3><p>1.由于默认kong启动是以daemon方式启动.所以修改/etc/kong/kong.conf配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#将下列行修改为off,且取消注释</span><br><span class="line">nginx_daemon = off</span><br></pre></td></tr></table></figure><p>2.编辑kong的supervisor配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[program:kong]</span><br><span class="line">command=/usr/local/bin/kong start -c /etc/kong/kong.conf</span><br><span class="line">numprocs=1</span><br><span class="line">priority=0</span><br><span class="line">user=work</span><br><span class="line">stdout_logfile = /data/logs/kong/kong_supervisor.log</span><br><span class="line">redirect_stderr = true</span><br><span class="line">autostart=true</span><br><span class="line">autorestart=true</span><br></pre></td></tr></table></figure><blockquote><p>注意由于kong启动的时候会连接后端的cassandra数据库,所以需要先启动cassandra,再启动kong.这就是为什么supervisor里要加入priority参数.优先级越小,启动顺序越优先.停止顺序越靠后.     </p></blockquote><p><strong>但是经过我的验证,发现priority参数没什么鸟用.当我start all,stop all时.永远是cassandra进程首先启动和关闭,无论priority优先级是大还是小.而不是supervisor官网介绍的那样效果</strong></p><p>启动没问题:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node2 ~]$ supervisorctl status</span><br><span class="line">cassandra                        RUNNING   pid 13531, uptime 0:10:09</span><br><span class="line">kong                             RUNNING   pid 14460, uptime 0:00:35</span><br><span class="line">kong-dashboard                   RUNNING   pid 14496, uptime 0:00:17</span><br></pre></td></tr></table></figure><p>但是发现supervisor管理kong进程有很严重的问题.</p><p>因为kong启动后包括2个进程:kong和nginx</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">work@kong-node1 conf.d]$ ps aux | grep kong</span><br><span class="line">work      3198  0.2  0.0 130104  2700 ?        S    17:12   0:00 perl /usr/local/openresty/bin/resty /usr/local/bin/kong start -c /etc/kong/kong.conf</span><br><span class="line">work      3215  6.3  0.1 259600 11800 ?        S    17:12   0:00 nginx: master process /usr/local/openresty/nginx/sbin/nginx -p /data/kong -c nginx.conf</span><br></pre></td></tr></table></figure><p>.这个时候如果用supervisorctl restart kong进程会出现无法启动的情况.这是因为supervisor kill掉了kong进程.但是没有kill Ningx进程.所以重新启动kong的时候,由于nginx进程仍然存在,故无法启动.例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 conf.d]$ ps aux | grep kong</span><br><span class="line">work      2917  0.0  0.1 259600 11820 ?        S    17:05   0:00 nginx: master process /usr/local/openresty/nginx/sbin/nginx -p /data/kong -c nginx.conf</span><br><span class="line">work      3191  0.0  0.0 112704   976 pts/0    S+   17:11   0:00 grep --color=auto kong</span><br><span class="line">[work@kong-node1 conf.d]$ kill 2917</span><br><span class="line">[work@kong-node1 conf.d]$ ps aux | grep kong</span><br><span class="line">work      3193  0.0  0.0 112704   976 pts/0    S+   17:11   0:00 grep --color=auto kong</span><br><span class="line">[work@kong-node1 conf.d]$ supervisorctl start kong</span><br><span class="line">kong: started</span><br><span class="line"></span><br><span class="line">#kong启动后包含2个进程</span><br><span class="line">[work@kong-node1 conf.d]$ ps aux | grep kong</span><br><span class="line">work      3198  0.2  0.0 130104  2700 ?        S    17:12   0:00 perl /usr/local/openresty/bin/resty /usr/local/bin/kong start -c /etc/kong/kong.conf</span><br><span class="line">work      3215  6.3  0.1 259600 11800 ?        S    17:12   0:00 nginx: master process /usr/local/openresty/nginx/sbin/nginx -p /data/kong -c nginx.conf</span><br><span class="line">work      3228  0.0  0.0 112704   976 pts/0    R+   17:12   0:00 grep --color=auto kong</span><br><span class="line"></span><br><span class="line">#supervisor关闭了Kong进程后,无法启动.</span><br><span class="line">[work@kong-node1 conf.d]$ supervisorctl restart kong</span><br><span class="line">kong: stopped</span><br><span class="line">kong: ERROR (spawn error)</span><br><span class="line"></span><br><span class="line">#因为虽然kong进程杀死了.但是nginx进程还在.所以kong的8000端口仍然被占用</span><br><span class="line">[work@kong-node1 conf.d]$ ps aux | grep kong</span><br><span class="line">work      3215  0.1  0.1 259600 11800 ?        S    17:12   0:00 nginx: master process /usr/local/openresty/nginx/sbin/nginx -p /data/kong -c nginx.conf</span><br><span class="line">work      3307  0.0  0.0 112704   976 pts/0    S+   17:15   0:00 grep --color=auto kong</span><br><span class="line"></span><br><span class="line">#查看启动日志,提示kong进程已经启动了.</span><br><span class="line">Error: Kong is already running in /data/kong</span><br><span class="line"></span><br><span class="line">  Run with --v (verbose) or --vv (debug) for more details</span><br></pre></td></tr></table></figure><p><strong>暂时就不用supervisor管理了,采用命令行直接启动方式</strong></p><hr><p><strong>命令行启动kong.只有一个Nginx进程.没有Perl进程.不知道何故</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node2 conf.d]$kong start -c /etc/kong/kong.conf</span><br><span class="line">Kong started</span><br><span class="line">[work@kong-node2 conf.d]$ps aux | grep kong</span><br><span class="line">work     15558  0.0  0.0 259600  6540 ?        Ss   17:29   0:00 nginx: master process /usr/local/openresty/nginx/sbin/nginx -p /data/kong -c nginx.conf</span><br></pre></td></tr></table></figure><hr><h3 id="将kong-Cassandra加入到systemctl管理工具"><a href="#将kong-Cassandra加入到systemctl管理工具" class="headerlink" title="将kong,Cassandra加入到systemctl管理工具"></a>将kong,Cassandra加入到systemctl管理工具</h3><ul><li><strong>cassandra</strong></li></ul><p>systemctl文件如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 ~]$cd /usr/lib/systemd/system</span><br><span class="line">[work@kong-node1 system]$vim cassandra.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Cassandra</span><br><span class="line">After=network.target</span><br><span class="line">Before=kong.target </span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=work</span><br><span class="line">Group=work</span><br><span class="line">ExecStart=/usr/local/cassandra/bin/cassandra -f</span><br><span class="line">ExecStop=kill $(pgrep -f cassandra)</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><blockquote><p>注意.如果java是二进制包,则需要将Bin文件链接到系统环境变量目录下.因为systemctl不会读取profile环境,所以不能识别到java.</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 system]$which java</span><br><span class="line">/usr/bin/java</span><br><span class="line">[work@kong-node1 system]$ll /usr/bin/java</span><br><span class="line">lrwxrwxrwx 1 root root 24 Nov 14 17:46 /usr/bin/java -&gt; /usr/local/java/bin/java</span><br></pre></td></tr></table></figure><p>第二种方法是在systemctl中指定环境变量.指定environment参数(这种方法理论可行,但是没有论证)</p><p>例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Cassandra</span><br><span class="line">After=network.target</span><br><span class="line">Before=kong.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=work</span><br><span class="line">Group=work</span><br><span class="line">environment=JAVA_HOME=/usr/local/java</span><br><span class="line">environment=PATH=$JAVA_HOME/bin:$PATH</span><br><span class="line">ExecStart=/usr/local/cassandra/bin/cassandra -f</span><br><span class="line">ExecStop=kill $(pgrep -f cassandra)</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><hr><ul><li><strong>kong</strong></li></ul><p>在同目录下编辑kong服务配置.</p><blockquote><p>注意,需要在cassandra后端数据库启动后,才能启动kong服务</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node1 system]$vim kong.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description= kong service</span><br><span class="line">After=syslog.target network.target cassandra.target</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=work</span><br><span class="line">Group=work</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/usr/local/bin/kong start -c /etc/kong/kong.conf</span><br><span class="line">ExecReload=/usr/local/bin/kong reload -c /etc/kong/kong.conf</span><br><span class="line">ExecStop=/usr/local/bin/kong stop</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><ul><li><strong>在kong-node2上启动kong-dashbaord</strong></li></ul><blockquote><p>dashbaord服务启动需要在cassandra,kong服务启动之后</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">[work@kong-node2 system]$vim kong-dashboard.service</span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=kong-dashboard</span><br><span class="line">After=network.target cassandra.target kong.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">User=work</span><br><span class="line">Group=work</span><br><span class="line">ExecStart=/usr/local/bin/kong-dashboard start --kong-url http://10.111.30.158:8001</span><br><span class="line">ExecStop=kill $(pgrep -f kong-dashboard)</span><br><span class="line">Restart=always</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">[Install]</span><br><span class="line">WantedBy=multi-user.target</span><br></pre></td></tr></table></figure><ul><li>加入到开启自启动</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable cassandra</span><br><span class="line">systemctl enable kong</span><br><span class="line">systemctl enable kong-dashboard</span><br></pre></td></tr></table></figure><p>经过反复论证,systemctl可以管理以上服务.</p><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;kong-casssandra集群环境部署&quot;&gt;&lt;a href=&quot;#kong-casssandra集群环境部署&quot; class=&quot;headerlink&quot; title=&quot;kong+casssandra集群环境部署&quot;&gt;&lt;/a&gt;kong+casssandra集群环境部署&lt;/h2&gt;&lt;h3 id=&quot;kong简介&quot;&gt;&lt;a href=&quot;#kong简介&quot; class=&quot;headerlink&quot; title=&quot;kong简介&quot;&gt;&lt;/a&gt;kong简介&lt;/h3&gt;&lt;p&gt;Kong是Mashape开源的一款API网关，起初是用来管理 Mashape 公司15000个微服务的，后来在2015年开源,现在已经在很多创业公司、大型企业和政府机构中广泛使用。基于nginx,Lua和Cassandra或PostgreSQL，支持分布式操作，有很强的可移植性和可扩展性。可以在任何一种基础设施上运行,作为应用和API之间的中间层，加上众多功能强大的插件，可以实现认证授权、访问控制等功能。并且提供易于使用的RESTful API来操作和配置系统。&lt;/p&gt;
&lt;p&gt;有关kong的详细介绍请参考官网.&lt;/p&gt;
    
    </summary>
    
      <category term="Linux-分布式&amp;消息队列" scheme="https://jesse.top/categories/Linux-%E5%88%86%E5%B8%83%E5%BC%8F-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
    
      <category term="kong" scheme="https://jesse.top/tags/kong/"/>
    
  </entry>
  
</feed>
