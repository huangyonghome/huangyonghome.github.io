<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />





  <script>
  (function(i,s,o,g,r,a,m){i["DaoVoiceObject"]=r;i[r]=i[r]||function(){(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;a.charset="utf-8";m.parentNode.insertBefore(a,m)})(window,document,"script",('https:' == document.location.protocol ? 'https:' : 'http:') + "//widget.daovoice.io/widget/0f81ff2f.js","daovoice")
  daovoice('init', {
      app_id: "59f7787a"
    });
  daovoice('update');
  </script>















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="docker," />





  <link rel="alternate" href="/atom.xml" title="Jesse's home" type="application/atom+xml" />






<meta name="description" content="Dockerfile 介绍到目前位置我们接触的镜像都是从docker官方hub.docker.com所下载的官方镜像.官方镜像一般分为两类:  OS镜像 应用镜像.(例如nginx.php-fpm,mysql)  但是无论是哪种镜像,官方的标准镜像(或者是通用镜像)都只包含最基础的系统或者应用环境,如果需要使用适合个人或者企业场景的自定义镜像,那么就只能自己制作镜像. 制作镜像的方法:  以容器为">
<meta name="keywords" content="docker">
<meta property="og:type" content="article">
<meta property="og:title" content="docker学习笔记---Dockerfile">
<meta property="og:url" content="https://jesse.top/2020/06/29/docker/docker官网学习—2.dockerfile/index.html">
<meta property="og:site_name" content="Jesse&#39;s home">
<meta property="og:description" content="Dockerfile 介绍到目前位置我们接触的镜像都是从docker官方hub.docker.com所下载的官方镜像.官方镜像一般分为两类:  OS镜像 应用镜像.(例如nginx.php-fpm,mysql)  但是无论是哪种镜像,官方的标准镜像(或者是通用镜像)都只包含最基础的系统或者应用环境,如果需要使用适合个人或者企业场景的自定义镜像,那么就只能自己制作镜像. 制作镜像的方法:  以容器为">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2020-08-26T23:55:20.312Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="docker学习笔记---Dockerfile">
<meta name="twitter:description" content="Dockerfile 介绍到目前位置我们接触的镜像都是从docker官方hub.docker.com所下载的官方镜像.官方镜像一般分为两类:  OS镜像 应用镜像.(例如nginx.php-fpm,mysql)  但是无论是哪种镜像,官方的标准镜像(或者是通用镜像)都只包含最基础的系统或者应用环境,如果需要使用适合个人或者企业场景的自定义镜像,那么就只能自己制作镜像. 制作镜像的方法:  以容器为">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://jesse.top/2020/06/29/docker/docker官网学习—2.dockerfile/"/>





  <title>docker学习笔记---Dockerfile | Jesse's home</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Jesse's home</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://jesse.top/2020/06/29/docker/docker官网学习—2.dockerfile/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Jesse">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Jesse's home">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">docker学习笔记---Dockerfile</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-06-29T11:59:58+08:00">
                2020-06-29
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/docker/" itemprop="url" rel="index">
                    <span itemprop="name">docker</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2020/06/29/docker/docker官网学习—2.dockerfile/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count ds-thread-count" data-thread-key="2020/06/29/docker/docker官网学习—2.dockerfile/" itemprop="commentCount"></span>
                </a>
              </span>
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h3 id="Dockerfile"><a href="#Dockerfile" class="headerlink" title="Dockerfile"></a>Dockerfile</h3><hr>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>到目前位置我们接触的镜像都是从docker官方hub.docker.com所下载的官方镜像.官方镜像一般分为两类:</p>
<ul>
<li>OS镜像</li>
<li>应用镜像.(例如nginx.php-fpm,mysql)</li>
</ul>
<p>但是无论是哪种镜像,官方的标准镜像(或者是通用镜像)都只包含最基础的系统或者应用环境,如果需要使用适合个人或者企业场景的自定义镜像,那么就只能自己制作镜像.</p>
<p><strong>制作镜像的方法:</strong></p>
<ul>
<li>以容器为基础,制作镜像</li>
</ul>
<p>这有点类似于快照,用一个基础镜像运行容器,然后在容器的交互式界面,安装或者配置之定义环境,然后将该容器制作成一个镜像.但是这种方法有很大的缺陷.</p>
<p>例如,如果有多个环境的容器,那么可能容器的应用配置文件不一样,此时可能需要将多个容器制作成多个镜像.例如dev环境容器,beta环境容器,生产环境容器等.而且容器一旦修改以后,可能又需要重新commit制作成镜像,这样一来,镜像的体积将无限大.</p>
<ul>
<li>Dockerfile制作镜像</li>
</ul>
<p>Dockerfile可以用来编译一个docker镜像.Dockerfile是一个包含一系列指令的文本文档,非常类似于一个shell脚本,.docker调用dockerfile中每行的命令,聚集成最终的镜像.使用<code>docker build</code>命令,用户可以依据dockerfile和上下文编译一个镜像.</p>
<hr>
<h3 id="Dockerfile语法格式"><a href="#Dockerfile语法格式" class="headerlink" title="Dockerfile语法格式"></a>Dockerfile语法格式</h3><p>dockerfile的格式非常简单.只有2种:</p>
<ul>
<li><code>#</code>开头的语句表示注释</li>
<li><code>INSTRUCTIONS arguments</code> 指令 参数</li>
</ul>
<p><code>instructions</code>指令大小写非敏感,但是约定俗成的写法是指令全部用大写字母,dockerfile按自上而下的顺序,一次执行每一个指令.</p>
<blockquote>
<p>Dockerfile文件中第一个指令必须是<code>FROM</code>指令,用来表示当前的docker镜像是哪个基础镜像.在dockerfile中,必须要一个基础镜像.(有点类似编程中,所有的类必须要有一个基类)</p>
</blockquote>
<hr>
<h3 id="Dockerfile上下文"><a href="#Dockerfile上下文" class="headerlink" title="Dockerfile上下文"></a>Dockerfile上下文</h3><p>docker build编译镜像时,默认在当前目录下寻找文件名为<code>Dockerfile</code>的文件.如果找不到,则会报错,所以Dockerfile(第一个字母必须大写)的文件名一般是固定的.</p>
<p>docker会将当前目录下的Dockerfile和所有文件打包添加发送到docker daemon服务端.所以一般情况下创建一个空目录编辑Dockerfile文件.然后将需要放到镜像中的文件放进和dockerfile同一目录下,或者子目录下.当然,也可以像Git那样,在当前目录下编辑一个名为<code>.dockeringnore</code>的隐藏文件,列出排除文件或者目录.这样dockerfile在制作镜像时,不会将该文件或者目录提交到docker服务端</p>
<blockquote>
<p>为什么需要一个空目录防止Dockerfile文件呢?</p>
<p>因为docker在编译镜像之前,就会将该目录下的所有文件打包发送到docker daemon服务端中,并且加载到镜像.所以最终产生的镜像体积会非常庞大.(无论你是否使用了目录下的文件或者文件夹).试想一下如果在<code>/</code>目录下打包Dockerfile镜像,会是什么后果</p>
</blockquote>
<p>由于上下文的关系,在Dockerfile中添加文件到docker镜像时.不要使用绝对路径.例如/home/work/a.txt.这是因为docker deamon只能识别到当前上下文环境,无法识别到其他目录.但是可以使用当前上下文的相对路径.</p>
<hr>
<h3 id="Dockerfile构建过程"><a href="#Dockerfile构建过程" class="headerlink" title="Dockerfile构建过程"></a>Dockerfile构建过程</h3><p>使用<code>docker build</code>命令可以将当前目录下的Dockerfile文件编译成一个镜像,docker daemon会隐含式的用Dockerfile中<code>FROM</code>指令指定的镜像启动一个容器,并且从上到下依次在该容器中执行Dockerfile文件中的指令.最终将改容器打包成一个新的镜像.</p>
<p>其本质上和我们启动一个容器,执行命令,然后保存成一个镜像没有多大区别,只不过是docker的<code>build</code>命令帮助我们完成以上一系列动作.所以需要注意的是,我们在Dockerfile中编辑的指令和参数,其作用对象和执行环境并非是宿主机,而是基础镜像..如果基础镜像不支持Dockerfile文件中的指令,那么<code>build</code>执行过程中很可能会报错</p>
<hr>
<h3 id="Dockerfile变量"><a href="#Dockerfile变量" class="headerlink" title="Dockerfile变量"></a>Dockerfile变量</h3><p>Dockerfile支持变量替换,其变量赋值和调用方法和shell脚本中非常类似.</p>
<ul>
<li><p>变量赋值: ENV version 3.0 #设一个名为version的变量,其值为3.0</p>
</li>
<li><p>变量调用: \$version 或者 \${version}</p>
</li>
</ul>
<blockquote>
<p>当然,还支持<code>${variable: -word}</code>和<code>${variable: +word}</code>等更多的变量字符串截取.这里不做说明</p>
</blockquote>
<p>变量可以方便我们构建不同版本的应用.在编译多个版本的同一应用镜像时,我们不需要去修改Dockerfile的指令内容,只需要修改变量名即可</p>
<hr>
<h3 id="dockerfile打包镜像命令"><a href="#dockerfile打包镜像命令" class="headerlink" title="dockerfile打包镜像命令"></a>dockerfile打包镜像命令</h3><p>命令<code>docker build</code>用来编译制作镜像.其支持许多参数,但是常用的格式如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build -t image:tag .</span><br></pre></td></tr></table></figure>
<p>使用<code>-t</code>参数指定新的镜像和标签, <code>.</code>小数点表示当前目录.docker会在当前目录下搜索Dockerfile文件,且将当前目录的所有文件和子目录打包到docker daemon</p>
<hr>
<p>使用dockerfile需要注意一些事项</p>
<p><strong>1.上下文</strong></p>
<p>docker build编译镜像时,会将当前目录下的Dockerfile和所有文件打包添加发送到docker daemon服务端.所以一般情况下创建一个空目录编辑dockerfile文件.然后将需要copy和add的文件放进和dockerfile同一目录下.</p>
<p>dockerfile中的<code>copy</code>以及<code>add</code>命令,添加文件到docker镜像中时.不要使用绝对路径.例如/home/work/a.txt..docker deamon只能识别到当前上下文环境,无法识别到其他目录.但是可以使用当前上下文的相对路径.</p>
<p><strong>2.分层</strong></p>
<p>dockerfile编译镜像时,每条指令都是一个镜像层.除了From指令外,每一行指令都是基于上一行生成的临时镜像运行一个容器.执行一条指令就类似于docker commit命令生成一个新的镜像.所以两条指令之间互不关联.</p>
<a id="more"></a>
<p>例如,下列的dockerfile并不能在/data/目录下创建files文件.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">RUN mkdir /data</span><br><span class="line">RUN cd /data</span><br><span class="line">RUN touch files</span><br></pre></td></tr></table></figure>
<p>下列的dockerfile甚至不会创建/data/file文件,也不会修改/data/目录权限<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">RUN useradd foo</span><br><span class="line">VOLUME /data</span><br><span class="line">RUN touch /data/file</span><br><span class="line">RUN chown -R foo:foo /data</span><br></pre></td></tr></table></figure></p>
<p>想要实现这个需求,可以这样写:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">FROM ubuntu</span><br><span class="line">RUN useradd foo</span><br><span class="line">RUN mkdir /data &amp;&amp; touch /data/file</span><br><span class="line">RUN chown -R foo:foo /data</span><br><span class="line">VOLUME /data</span><br></pre></td></tr></table></figure>
<hr>
<p><strong>3.精简</strong></p>
<p>由于dockerfile在构建镜像时,dockerfile文本中每一行语句会产生每一层镜像.</p>
<p>例如下面这个dockerfile:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">From ubuntu</span><br><span class="line">RUN apt-get update</span><br><span class="line">RUN apt-get -y install vim git wget net-tools</span><br><span class="line">RUN useradd foo</span><br><span class="line">RUN mkdir /data</span><br><span class="line">RUN touch /data/file</span><br><span class="line">RUN chown -R foo:foo /data</span><br></pre></td></tr></table></figure>
<p>在编译时,每一个RUN语句都会构建一层镜像.(实际上所有指令都是这样,不仅仅是RUN)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]$docker build -t test:v1 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/7 : From ubuntu</span><br><span class="line"> ---&gt; 94e814e2efa8</span><br><span class="line">Step 2/7 : RUN apt-get update</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 5520126e7fcc</span><br><span class="line">Step 3/7 : RUN apt-get -y install vim git wget net-tools</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; cb24e170539c</span><br><span class="line">Step 4/7 : RUN useradd foo</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; ca31aeba0309</span><br><span class="line">Step 5/7 : RUN mkdir /data</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; d5c6e0f32f6b</span><br><span class="line">Step 6/7 : RUN touch /data/file</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 9c4b06e9b25d</span><br><span class="line">Step 7/7 : RUN chown -R foo:foo /data</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 75ecea0b0795</span><br><span class="line">Successfully built 75ecea0b0795</span><br><span class="line">Successfully tagged test:v1</span><br></pre></td></tr></table></figure>
<p>这种写法会导致镜像层非常多,镜像文件也会相对较大.所以一般推荐更精简的语法,每一条功能相同的语句,尽量写在一行.上面的dockerfile可以优化成:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">From ubuntu</span><br><span class="line">RUN apt-get update \</span><br><span class="line">    &amp;&amp; apt-get -y install \</span><br><span class="line">       vim \</span><br><span class="line">       git \</span><br><span class="line">       wget \</span><br><span class="line">       net-tools</span><br><span class="line"></span><br><span class="line">RUN useradd foo</span><br><span class="line">RUN mkdir /data &amp;&amp;  touch /data/file &amp;&amp;  chown -R foo:foo /data</span><br></pre></td></tr></table></figure>
<p>这次编译只需构建4层镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost test]$docker build -t test:v1 .</span><br><span class="line">Sending build context to Docker daemon  2.048kB</span><br><span class="line">Step 1/4 : From ubuntu</span><br><span class="line"> ---&gt; 94e814e2efa8</span><br><span class="line">Step 2/4 : RUN apt-get update     &amp;&amp; apt-get -y install        vim        git        wget        net-tools</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 7aa2bc9041e0</span><br><span class="line">Step 3/4 : RUN useradd foo</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; 5a13764414e6</span><br><span class="line">Step 4/4 : RUN mkdir /data &amp;&amp;  touch /data/file &amp;&amp;  chown -R foo:foo /data</span><br><span class="line"> ---&gt; Using cache</span><br><span class="line"> ---&gt; bd61817d7526</span><br><span class="line">Successfully built bd61817d7526</span><br><span class="line">Successfully tagged test:v1</span><br></pre></td></tr></table></figure>
<p>4.使用<code>no-install-recommends</code></p>
<p>如果是使用APT包管理器,则应该在执行apt-get install 命令时加上<code>no-install-recommends`</code>参数.这样ATP就仅安装核心依赖.而不安装其他推荐和建议的包,这会显著减少不必要包的下载数量</p>
<hr>
<h3 id="Dockerfile指令介绍"><a href="#Dockerfile指令介绍" class="headerlink" title="Dockerfile指令介绍"></a>Dockerfile指令介绍</h3><p>介绍完Dockerfile的概念和特点后,接下来了解一下Dockerfile语法中的具体指令的介绍和用法</p>
<p>下面是一个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"># Use an official Python runtime as a parent image</span><br><span class="line">FROM python:2.7-slim</span><br><span class="line"></span><br><span class="line"># Set the working directory to /app</span><br><span class="line">WORKDIR /app</span><br><span class="line"></span><br><span class="line"># Copy the current directory contents into the container at /app</span><br><span class="line">COPY . /app</span><br><span class="line"></span><br><span class="line"># Install any needed packages specified in requirements.txt</span><br><span class="line">RUN pip install --trusted-host pypi.python.org -r requirements.txt</span><br><span class="line"></span><br><span class="line"># Make port 80 available to the world outside this container</span><br><span class="line">EXPOSE 80</span><br><span class="line"></span><br><span class="line"># Define environment variable</span><br><span class="line">ENV NAME World</span><br><span class="line"></span><br><span class="line"># Run app.py when the container launches</span><br><span class="line">CMD [&quot;python&quot;, &quot;app.py&quot;]</span><br></pre></td></tr></table></figure>
<hr>
<ul>
<li>FROM </li>
</ul>
<p>格式: <code>FROM image</code> 或者 <code>FROM image:tag</code></p>
<p>表示从一个基础镜像构建.Dockerfile必须以FROM语句作为第一条非注释语句.默认情况下docker回在当前主机本地查找该镜像,如果镜像不存在,则默认会在docker hub官方拉取镜像文件.或者从指定的registry中寻找,下载镜像</p>
<p>具体格式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">FROM image      #指定镜像名,不加tag就默认是latest镜像</span><br><span class="line">FROM image:tag </span><br><span class="line">FROM &lt;registry&gt;&lt;repository&gt;:tag #指定具体镜像注册中心的镜像,非docker官方hub站点镜像</span><br></pre></td></tr></table></figure>
<ul>
<li>MAINTAINER(deprecated,已废弃)</li>
</ul>
<p>用来表示Dockerfile的制作者的信息.是一个可选指令.一般都会附加到Dockerfile中,表面制作镜像的人员,或者联系方式.例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">MAINTAINER jesse</span><br><span class="line">Maintainer huangyong@doweidu.com</span><br></pre></td></tr></table></figure>
<p>这个命令已经被废弃,取而代之的是LABEL指令.但是MAINTAINER指令依然被新版本的docker兼容</p>
<ul>
<li>LABEL</li>
</ul>
<p>表示为镜像添加元数据.kv格式的指令</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt;</span><br><span class="line">LABEL author=jesse mail=huangyong@doweidu.com</span><br></pre></td></tr></table></figure>
<ul>
<li><p>WORKDIR: 表示工作目录,后续的相对路径也是基于这个目录.容器启动以后,使用<code>exec</code>命令交互式界面接入容器,也是现实这个目录</p>
</li>
<li><p>COPY</p>
</li>
</ul>
<p>格式: <code>copy src dest</code>或者<code>COPY [&quot;src&quot;.....&quot;dest&quot;]</code></p>
<p>复制宿主机上的文件到镜像中.src是当前上下文中的文件或者目录.dest是容器中的目标文件或者目录.</p>
<p>src指定的源可以有多个.此外 src还支持通配符.例如: <code>COPY hom* /mydir/</code> 表示添加所有当前目录下的hom开头的文件到目录/mydir/下</p>
<p><dest>可以是文件或者目录.但是必须是镜像中的绝对路径,或者是WORKDIR的相对路径.若<dest>以反斜杠/结尾,则指向的是目录,否则指向文件.</dest></dest></p>
<p>当 src 有多个源时, dest必须是目录.如果 dest 目录不存在,则会自动被创建</p>
<p>如果目录当中含有空白字符,为了避免歧义,则应该使用第二种格式</p>
<p>如果src是目录,则其内部文件或者子目录会被递归复制,但是src目录本身并不会复制.举个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#shell中命令</span><br><span class="line">cp -r a b/ #表示将a目录复制到b目录下,最终b目录是: b/a/.....</span><br><span class="line"></span><br><span class="line">#dockerfile COPY指令</span><br><span class="line">COPY a b/ #表示将a目录下的所有内容复制到b目录.相当于shell中的cp -r a/* b/ .最终b目录是: b/.....</span><br></pre></td></tr></table></figure>
<ul>
<li>ADD</li>
</ul>
<p>格式: <code>ADD src dest</code></p>
<p> ADD和COPY命令有相同功能,指令用法也基本一样.都支持复制本地文件到镜像里.但ADD能从互联网的URL下载文件到镜像..src还可以是一个本地的压缩归档文件.ADD会自动将tar,gz等压缩包上传到镜像后进行解压.</p>
<p> 但是如果src是一个URL的归档格式文件,则不会自动解压.</p>
<ul>
<li>VOLUME</li>
</ul>
<p><code>VOLUME</code>用于在镜像中创建一个挂载点目录(docker自行管理的挂载卷),以挂载Docker宿主机上的卷或者其他容器的卷.</p>
<p>用法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">VOLUME mountpoint</span><br><span class="line">VOLUME [&quot;mountpoint&quot;]</span><br></pre></td></tr></table></figure>
<p><code>volume</code>会将容器内的目录自行挂载到docker宿主机上,而无需在启动容器时候使用<code>-v</code>参数挂载.</p>
<blockquote>
<p>但是无法使用指定挂载卷,也就是无法指定宿主机的目录挂载,只能使用docker自行管理的挂载卷</p>
</blockquote>
<ul>
<li>RUN</li>
</ul>
<p>RUN命令有两种格式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RUN &lt;command&gt; (shell格式)  </span><br><span class="line">RUN [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec格式)</span><br></pre></td></tr></table></figure>
<p>RUN指令的两种格式表示命令在容器中的两种运行方式.当使用shell格式时,命令通过<code>/bin/sh -c</code>运行.当使用exec格式时.命令直接运行,不调用shell程序.exec格式中的参数会被当成JSON数组被Docker解析.所以必须使用双引号,不能使用单引号. </p>
<p>另外由于exec格式不会在shell中运行.所以无法识别ENV环境变量.例如当执行<code>CMD [&quot;echo&quot;,&quot;$HOME&quot;]</code>时,$HOME不会被变量替换.如果希望运行shell程序.可以写成</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CMD [&quot;sh&quot;,&quot;-c&quot;,&quot;echo&quot;,&quot;$HOME&quot;]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>RUN命令和CMD命令都是表示运行一个命令,但是他们运行的阶段不一样,RUN命令是在build镜像时候运行指令,CMD是在build完成镜像后,启动容器运行的命令</p>
</blockquote>
<ul>
<li>EXPOSE: 镜像需要暴露出来的端口. </li>
</ul>
<blockquote>
<p>要注意的是,这里只是说明镜像需要暴露哪些端口,在镜像构建完毕,启动容器时,仍然需要-p参数来映射端口,否则端口不会自动映射</p>
</blockquote>
<p>用法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">EXPOSE port/protocol port/protocol #protocol可以不指定,默认是TCP协议,可以在一行中暴露多个端口</span><br></pre></td></tr></table></figure>
<blockquote>
<p>EXPOSE无法指定宿主机的IP或者端口,因为镜像运行的宿主机是非固定的,并不知晓宿主机的环境.</p>
</blockquote>
<ul>
<li><p>ENV</p>
<p>格式: <code>ENV &lt;key&gt; &lt;value&gt;</code> 或者 <code>ENV &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt;</code></p>
<p>ENV指令用来声明环境变量,并且可以被(ADD,COPY,WORKDIR等)指令调用</p>
<p>Dockerfile变量赋值和调用方法和shell脚本中非常类似.</p>
<ul>
<li><p>变量赋值: ENV version 3.0 #设一个名为version的变量,其值为3.0</p>
</li>
<li><p>变量调用: \$version 或者 \${version}</p>
</li>
</ul>
<blockquote>
<p>当然,还支持<code>${variable: -word}</code>和<code>${variable: +word}</code>等更多的变量字符串截取.这里不做说明</p>
</blockquote>
<p>变量可以方便我们构建不同版本的应用.在编译多个版本的同一应用镜像时,我们不需要去修改Dockerfile的指令内容,只需要修改变量名即可</p>
<p>EVN像镜像传递环境变量,不仅仅是影响到镜像本身,而且一旦镜像启动为容器时,还会注入到容器内部.在容器中可以继续使用该变量.如果在容器启动时候,覆盖了同名的环境变量,则容器中以覆盖后的环境变量值为准,但是不会更改镜像中已存在的事实结果.</p>
<p>举个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#dockerfile中设置环境变量</span><br><span class="line">ENV NGINX_VERSION 1.17</span><br><span class="line">ADD http://nginx.org/download/nginx-1.17.tar.gz /usr/local/src/</span><br><span class="line"></span><br><span class="line">#生成镜像,启动容器,覆盖同名环境变量</span><br><span class="line">docker run -e NGINX_VERSION 1.16 </span><br><span class="line"></span><br><span class="line">此时再容器中NGINX_VERSION的环境变量值为1.16.但是/usr/local/src/目录下的gz文件仍然是nginx 1.17</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>CMD </li>
</ul>
<p>CMD命令有3种格式:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CMD &lt;command&gt; (shell格式)  </span><br><span class="line">CMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;] (exec格式)  </span><br><span class="line">CMD [&quot;param1&quot;,&quot;param2&quot;] (为ENTRYPOINT命令提供参数)</span><br></pre></td></tr></table></figure>
<p>CMD提供容器启动后执行的命令.或者是为ENTRYPOINT传递一些参数.一个dockerfile文件只允许存在一条CMD指令.如果存在多条CMD指令,以最后一条为准.但是如果用户在 docker run 时指定了命令,则会覆盖CMD中的指令</p>
<ul>
<li>ENTRYPOINT</li>
</ul>
<p>ENTRYPOINT有两种格式.和上文CMD一样分为shell格式和exec格式.</p>
<p>ENTRYPOINT和CMD类似,指定容器启动时执行的命令.和CMD一样一个Dockerfile文件中可以有多个ENTRYPOINT命令.但只有最后一条生效.但是又有一些区别.当使用shell格式时,ENTRYPOINT会忽略任何CMD指令和 <code>docker run</code>启动容器时手动输入的指令.并且会运行在 /bin/sh -c环境中,成为它的子进程.进程在容器中PID不是1,也不能接收UNIX信号.(也就是在执行 <code>docker stop &lt;container&gt;</code>时,进程接收不到SIGTERM指令)</p>
<p>当使用exec格式时, docker run 手动指定的命令,将作为参数覆盖CMD指定的参数传递到ENTRYPOINT.(也就是说 docker run启动容器时指定的不再是具体命令,而是命令的参数).</p>
<hr>
<p>创建上面dockerfile中所需要的app.py和requirements.txt文件,并且将他们和Dockerfile文件放在同一目录下:</p>
<p>requirements.txt:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker_python]$cat requirements.txt</span><br><span class="line">Flask</span><br><span class="line">Redis</span><br></pre></td></tr></table></figure>
<p>app.py:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">root@localhost docker_python]$cat app.py</span><br><span class="line">from flask import Flask</span><br><span class="line">from redis import Redis, RedisError</span><br><span class="line">import os</span><br><span class="line">import socket</span><br><span class="line"></span><br><span class="line"># Connect to Redis</span><br><span class="line">redis = Redis(host=&quot;redis&quot;, db=0, socket_connect_timeout=2, socket_timeout=2)</span><br><span class="line"></span><br><span class="line">app = Flask(__name__)</span><br><span class="line"></span><br><span class="line">@app.route(&quot;/&quot;)</span><br><span class="line">def hello():</span><br><span class="line">    try:</span><br><span class="line">        visits = redis.incr(&quot;counter&quot;)</span><br><span class="line">    except RedisError:</span><br><span class="line">        visits = &quot;&lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;&quot;</span><br><span class="line"></span><br><span class="line">    html = &quot;&lt;h3&gt;Hello &#123;name&#125;!&lt;/h3&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Hostname:&lt;/b&gt; &#123;hostname&#125;&lt;br/&gt;&quot; \</span><br><span class="line">           &quot;&lt;b&gt;Visits:&lt;/b&gt; &#123;visits&#125;&quot;</span><br><span class="line">    return html.format(name=os.getenv(&quot;NAME&quot;, &quot;world&quot;), hostname=socket.gethostname(), visits=visits)</span><br><span class="line"></span><br><span class="line">if __name__ == &quot;__main__&quot;:</span><br><span class="line">    app.run(host=&apos;0.0.0.0&apos;, port=80)</span><br><span class="line">[root@localhost docker_python]$</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="开始构建镜像"><a href="#开始构建镜像" class="headerlink" title="开始构建镜像"></a>开始构建镜像</h4><p>首先确保Dockerfile里所需的文件,以及Dockerfile都在同一目录下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker_python]$ls</span><br><span class="line">app.py  Dockerfile  requirements.txt</span><br></pre></td></tr></table></figure>
<p>运行以下命令来构建一个镜像.使用–tag参数(或者-t),可以为镜像打个标签:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build --tag=friendlyhello .</span><br></pre></td></tr></table></figure>
<p>构建过程略..在构建过程中,注意以下现象:</p>
<p>1.构建镜像层:</p>
<p>部分指令会创建一个新的镜像层,而有些指令则不会.关于如何区分命令是否会新建镜像层,一个基本的原则是:</p>
<p>如果指令的作用是像镜像中添加新的文件或者程序,那么就会新建镜像层.(例如:RUN,COPY,ADD,FROM等)</p>
<p>如果只是告诉docker如何构建或者运行应用程序,增加或者修改容器的元数据,那么不会构建新的镜像层.(例如:WORKDIR,EXPOSE,ENV,ENTERPOINT等)</p>
<p>2.构建步骤:</p>
<p>基本等过程大致为:</p>
<p>运行临时容器—-&gt;在该容器中运行Dockerfile指令—-&gt;将运行结果保存为一个新等镜像层——&gt; 删除临时容器</p>
<p>构建完成后,通过以下命令可以看到构建的镜像</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker_python]$docker images</span><br><span class="line">REPOSITORY                 TAG                 IMAGE ID            CREATED              SIZE</span><br><span class="line">friendlyhello              latest              f091d1bb803c        About a minute ago   131MB</span><br></pre></td></tr></table></figure>
<blockquote>
<p>或者也可以是输入以下命令 docker image ls</p>
</blockquote>
<blockquote>
<p>可能会疑惑,为什么tag标签是latest..镜像的完整标签格式应该是:friendlyhello:lastest.<br>如果需要在构建镜像时指定版本.可以使用: –tag=friendlyhello:v0.0.1</p>
</blockquote>
<hr>
<h4 id="使用构建的镜像启动一个容器"><a href="#使用构建的镜像启动一个容器" class="headerlink" title="使用构建的镜像启动一个容器"></a>使用构建的镜像启动一个容器</h4><p>输入以下命令,利用刚才的镜像启动一个容器:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -p 4000:80 friendlyhello</span><br></pre></td></tr></table></figure>
<p>执行结果:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker_python]$docker run -p 4000:80 friendlyhello</span><br><span class="line"> * Serving Flask app &quot;app&quot; (lazy loading)</span><br><span class="line"> * Environment: production</span><br><span class="line">   WARNING: Do not use the development server in a production environment.</span><br><span class="line">   Use a production WSGI server instead.</span><br><span class="line"> * Debug mode: off</span><br><span class="line"> * Running on http://0.0.0.0:80/ (Press CTRL+C to quit)</span><br></pre></td></tr></table></figure>
<ul>
<li>docker run 表示启动一个容器</li>
<li>-p 宿主机端口:容器端口  表示将宿主机的端口映射给容器.如果是-P 80 表示随机映射一个宿主机的端口给容器</li>
</ul>
<p>此时可以在其他电脑上访问这个容器的80端口,下面是在我的PC上访问宿主机的4000端口,也就是刚才启动的容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> ✘ huangyong@huangyong-Macbook-Pro  ~  curl http://10.0.0.50:4000</span><br><span class="line">&lt;h3&gt;Hello World!&lt;/h3&gt;&lt;b&gt;Hostname:&lt;/b&gt; f9b1b804404f&lt;br/&gt;&lt;b&gt;Visits:&lt;/b&gt; &lt;i&gt;cannot connect to Redis, counter disabled&lt;/i&gt;%</span><br></pre></td></tr></table></figure>
<p>容器默认是在前台执行,加上-d参数可以时容器运行在后台:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -d -p 4000:80 friendlyhello</span><br></pre></td></tr></table></figure>
<p>docker ps命令可以显示正在运行中的容器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost docker_python]$docker ps</span><br><span class="line">CONTAINER ID        IMAGE                      COMMAND             CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">fcf7d29ac627        friendlyhello              &quot;python app.py&quot;     5 seconds ago       Up 1 second         0.0.0.0:4000-&gt;80/tcp     stoic_colden</span><br></pre></td></tr></table></figure>
<blockquote>
<p>docker container ls命令也有同样的效果</p>
</blockquote>
<hr>
<p>这一节(包括第3小节)涉及到的基础命令如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">docker build -t friendlyhello .  # Create image using this directory&apos;s Dockerfile</span><br><span class="line">docker run -p 4000:80 friendlyhello  # Run &quot;friendlyname&quot; mapping port 4000 to 80</span><br><span class="line">docker run -d -p 4000:80 friendlyhello         # Same thing, but in detached mode</span><br><span class="line">docker container ls                                # List all running containers</span><br><span class="line">docker container ls -a             # List all containers, even those not running</span><br><span class="line">docker container stop &lt;hash&gt;           # Gracefully stop the specified container</span><br><span class="line">docker container kill &lt;hash&gt;         # Force shutdown of the specified container</span><br><span class="line">docker container rm &lt;hash&gt;        # Remove specified container from this machine</span><br><span class="line">docker container rm $(docker container ls -a -q)         # Remove all containers</span><br><span class="line">docker image ls -a                             # List all images on this machine</span><br><span class="line">docker image rm &lt;image id&gt;            # Remove specified image from this machine</span><br><span class="line">docker image rm $(docker image ls -a -q)   # Remove all images from this machine</span><br><span class="line">docker login             # Log in this CLI session using your Docker credentials</span><br><span class="line">docker tag &lt;image&gt; username/repository:tag  # Tag &lt;image&gt; for upload to registry</span><br><span class="line">docker push username/repository:tag            # Upload tagged image to registry</span><br><span class="line">docker run username/repository:tag                   # Run image from a registry</span><br></pre></td></tr></table></figure>
      
    </div>
    
    
    
   
    <div>
      
        
<div class="my_post_copyright">
  <script src="//cdn.bootcss.com/clipboard.js/1.5.10/clipboard.min.js"></script>

  <!-- JS库 sweetalert 可修改路径 -->
  <script src="https://cdn.bootcss.com/jquery/2.0.0/jquery.min.js"></script>
  <script src="https://unpkg.com/sweetalert/dist/sweetalert.min.js"></script>
  <p><span>本文标题:</span><a href="/2020/06/29/docker/docker官网学习—2.dockerfile/">docker学习笔记---Dockerfile</a></p>
  <p><span>文章作者:</span><a href="/" title="访问 Jesse 的个人博客">Jesse</a></p>
  <p><span>发布时间:</span>2020年06月29日 - 11:06</p>
  <p><span>最后更新:</span>2020年08月27日 - 07:08</p>
  <p><span>原始链接:</span><a href="/2020/06/29/docker/docker官网学习—2.dockerfile/" title="docker学习笔记---Dockerfile">https://jesse.top/2020/06/29/docker/docker官网学习—2.dockerfile/</a>
    <span class="copy-path"  title="点击复制文章链接"><i class="fa fa-clipboard" data-clipboard-text="https://jesse.top/2020/06/29/docker/docker官网学习—2.dockerfile/"  aria-label="复制成功！"></i></span>
  </p>
  <p><span>许可协议:</span><i class="fa fa-creative-commons"></i> <a rel="license" href="https://creativecommons.org/licenses/by-nc-nd/4.0/" target="_blank" title="Attribution-NonCommercial-NoDerivatives 4.0 International (CC BY-NC-ND 4.0)">禁止商业用途</a> 转载请保留原文链接及作者。</p>  
</div>
<script> 
    var clipboard = new Clipboard('.fa-clipboard');
      $(".fa-clipboard").click(function(){
      clipboard.on('success', function(){
        swal({   
          title: "",   
          text: '复制成功',
          icon: "success", 
          showConfirmButton: true
          });
        });
    });  
</script>

      
    </div>

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/wechatpay.jpg" alt="Jesse 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/alipay.jpg" alt="Jesse 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/docker/" rel="tag"># docker</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/06/29/docker/docker笔记—存储驱动篇/" rel="next" title="docker学习笔记---Docker存储驱动篇">
                <i class="fa fa-chevron-left"></i> docker学习笔记---Docker存储驱动篇
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/06/29/docker/docker官网学习-7.docker网络之host,Container,None网络/" rel="prev" title="docker学习笔记---docker网络之host,Container,None网络">
                docker学习笔记---docker网络之host,Container,None网络 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      <div class="ds-thread" data-thread-key="2020/06/29/docker/docker官网学习—2.dockerfile/"
           data-title="docker学习笔记---Dockerfile" data-url="https://jesse.top/2020/06/29/docker/docker官网学习—2.dockerfile/">
      </div>
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.png"
                alt="Jesse" />
            
              <p class="site-author-name" itemprop="name">Jesse</p>
              <p class="site-description motion-element" itemprop="description">求知若饥,虚心若愚.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">209</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">44</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">41</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-3"><a class="nav-link" href="#Dockerfile"><span class="nav-number">1.</span> <span class="nav-text">Dockerfile</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#介绍"><span class="nav-number">2.</span> <span class="nav-text">介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dockerfile语法格式"><span class="nav-number">3.</span> <span class="nav-text">Dockerfile语法格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dockerfile上下文"><span class="nav-number">4.</span> <span class="nav-text">Dockerfile上下文</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dockerfile构建过程"><span class="nav-number">5.</span> <span class="nav-text">Dockerfile构建过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dockerfile变量"><span class="nav-number">6.</span> <span class="nav-text">Dockerfile变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#dockerfile打包镜像命令"><span class="nav-number">7.</span> <span class="nav-text">dockerfile打包镜像命令</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Dockerfile指令介绍"><span class="nav-number">8.</span> <span class="nav-text">Dockerfile指令介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#开始构建镜像"><span class="nav-number">8.1.</span> <span class="nav-text">开始构建镜像</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用构建的镜像启动一个容器"><span class="nav-number">8.2.</span> <span class="nav-text">使用构建的镜像启动一个容器</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; Tue Jun 12 2018 08:00:00 GMT+0800 (GMT+08:00) &mdash; <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Jesse</span>

  
</div>

<!--

  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>

-->



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  

  
    
  

  <script type="text/javascript">
    var duoshuoQuery = {short_name:"comments"};
    (function() {
      var ds = document.createElement('script');
      ds.type = 'text/javascript';ds.async = true;
      ds.id = 'duoshuo-script';
      ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
      ds.charset = 'UTF-8';
      (document.getElementsByTagName('head')[0]
      || document.getElementsByTagName('body')[0]).appendChild(ds);
    })();
  </script>

  
    
    
    <script src="/lib/ua-parser-js/dist/ua-parser.min.js?v=0.7.9"></script>
    <script src="/js/src/hook-duoshuo.js"></script>
  
















  <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
  <script src="//unpkg.com/valine/dist/Valine.min.js"></script>
  
  <script type="text/javascript">
    var GUEST = ['nick','mail','link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item=>{
      return GUEST.indexOf(item)>-1;
    });
    new Valine({
        el: '#comments' ,
        verify: false,
        notify: false,
        appId: '3CtYiIp3Dijlw0XHyLxqMUM0-gzGzoHsz',
        appKey: '6dleF8bCPBg8gTr0pBp1IgVe',
        placeholder: '欢迎留言交流',
        avatar:'mm',
        guest_info:guest,
        pageSize:'10' || 10,
    });
  </script>



  





  

  

  

  
  

  

  

  

</body>
</html>
